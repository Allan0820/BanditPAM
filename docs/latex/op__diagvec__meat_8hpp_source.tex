\hypertarget{op__diagvec__meat_8hpp_source}{}\doxysection{op\+\_\+diagvec\+\_\+meat.\+hpp}
\label{op__diagvec__meat_8hpp_source}\index{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/op\_diagvec\_meat.hpp@{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/op\_diagvec\_meat.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008-\/2016 Conrad Sanderson (http://conradsanderson.id.au)}}
\DoxyCodeLine{2 \textcolor{comment}{// Copyright 2008-\/2016 National ICT Australia (NICTA)}}
\DoxyCodeLine{3 \textcolor{comment}{// }}
\DoxyCodeLine{4 \textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{5 \textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{6 \textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{7 \textcolor{comment}{// http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{8 \textcolor{comment}{// }}
\DoxyCodeLine{9 \textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{10 \textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{11 \textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{12 \textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{13 \textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{14 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{19 }
\DoxyCodeLine{20 }
\DoxyCodeLine{21 }
\DoxyCodeLine{22 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{23 \textcolor{keyword}{inline}}
\DoxyCodeLine{24 \textcolor{keywordtype}{void}}
\DoxyCodeLine{25 op\_diagvec::apply(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T1, op\_diagvec>}}\& X)}
\DoxyCodeLine{26   \{}
\DoxyCodeLine{27   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{28   }
\DoxyCodeLine{29   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{30   }
\DoxyCodeLine{31   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} P(X.m);}
\DoxyCodeLine{32   }
\DoxyCodeLine{33   \textcolor{keywordflow}{if}(P.is\_alias(out) == \textcolor{keyword}{false})}
\DoxyCodeLine{34     \{}
\DoxyCodeLine{35     op\_diagvec::apply\_proxy(out, P);}
\DoxyCodeLine{36     \}}
\DoxyCodeLine{37   \textcolor{keywordflow}{else}}
\DoxyCodeLine{38     \{}
\DoxyCodeLine{39     \mbox{\hyperlink{classMat}{Mat<eT>}} tmp;}
\DoxyCodeLine{40     }
\DoxyCodeLine{41     op\_diagvec::apply\_proxy(tmp, P);}
\DoxyCodeLine{42     }
\DoxyCodeLine{43     out.\mbox{\hyperlink{group__Mat_gaff06a75771f96605f7cc4f8c6b3fceb7}{steal\_mem}}(tmp);}
\DoxyCodeLine{44     \}}
\DoxyCodeLine{45   \}}
\DoxyCodeLine{46 }
\DoxyCodeLine{47 }
\DoxyCodeLine{48 }
\DoxyCodeLine{49 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{50 \textcolor{keyword}{inline}}
\DoxyCodeLine{51 \textcolor{keywordtype}{void}}
\DoxyCodeLine{52 op\_diagvec::apply\_proxy(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}}\& P)}
\DoxyCodeLine{53   \{}
\DoxyCodeLine{54   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{55   }
\DoxyCodeLine{56   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{57   }
\DoxyCodeLine{58   \textcolor{keyword}{const} uword n\_rows = P.get\_n\_rows();}
\DoxyCodeLine{59   \textcolor{keyword}{const} uword n\_cols = P.get\_n\_cols();}
\DoxyCodeLine{60   }
\DoxyCodeLine{61   \textcolor{keyword}{const} uword \mbox{\hyperlink{group__python__builtins_gaeff368081ac50b8fe2cc0230d96e3acb}{len}} = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(n\_rows, n\_cols);}
\DoxyCodeLine{62   }
\DoxyCodeLine{63   out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(\mbox{\hyperlink{group__python__builtins_gaeff368081ac50b8fe2cc0230d96e3acb}{len}}, 1);}
\DoxyCodeLine{64   }
\DoxyCodeLine{65   eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{66   }
\DoxyCodeLine{67   uword i,j;}
\DoxyCodeLine{68   \textcolor{keywordflow}{for}(i=0, j=1; j < \mbox{\hyperlink{group__python__builtins_gaeff368081ac50b8fe2cc0230d96e3acb}{len}}; i+=2, j+=2)}
\DoxyCodeLine{69     \{}
\DoxyCodeLine{70     \textcolor{keyword}{const} eT tmp\_i = P.at(i, i);}
\DoxyCodeLine{71     \textcolor{keyword}{const} eT tmp\_j = P.at(j, j);}
\DoxyCodeLine{72     }
\DoxyCodeLine{73     out\_mem[i] = tmp\_i;}
\DoxyCodeLine{74     out\_mem[j] = tmp\_j;}
\DoxyCodeLine{75     \}}
\DoxyCodeLine{76   }
\DoxyCodeLine{77   \textcolor{keywordflow}{if}(i < \mbox{\hyperlink{group__python__builtins_gaeff368081ac50b8fe2cc0230d96e3acb}{len}})}
\DoxyCodeLine{78     \{}
\DoxyCodeLine{79     out\_mem[i] = P.at(i, i);}
\DoxyCodeLine{80     \}}
\DoxyCodeLine{81   \}}
\DoxyCodeLine{82 }
\DoxyCodeLine{83 }
\DoxyCodeLine{84 }
\DoxyCodeLine{85 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{86 \textcolor{keyword}{inline}}
\DoxyCodeLine{87 \textcolor{keywordtype}{void}}
\DoxyCodeLine{88 op\_diagvec::apply(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& actual\_out, \textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op}}< \mbox{\hyperlink{classGlue}{Glue<T1,T2,glue\_times>}}, \mbox{\hyperlink{classop__diagvec}{op\_diagvec}}>\& X, \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<typename T1::elem\_type>::result* junk)}
\DoxyCodeLine{89   \{}
\DoxyCodeLine{90   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{91   arma\_ignore(junk);}
\DoxyCodeLine{92   }
\DoxyCodeLine{93   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{94   }
\DoxyCodeLine{95   \textcolor{keyword}{const} \mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T1>}} UA(X.m.A);}
\DoxyCodeLine{96   \textcolor{keyword}{const} \mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T2>}} UB(X.m.B);}
\DoxyCodeLine{97   }
\DoxyCodeLine{98   \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T1>::stored\_type}}\& \mbox{\hyperlink{structA}{A}} = UA.M;}
\DoxyCodeLine{99   \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T2>::stored\_type}}\& \mbox{\hyperlink{structB}{B}} = UB.M;}
\DoxyCodeLine{100   }
\DoxyCodeLine{101   arma\_debug\_assert\_trans\_mul\_size< partial\_unwrap<T1>::do\_trans, \mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T2>::do\_trans}} >(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structB}{B}}.n\_rows, \mbox{\hyperlink{structB}{B}}.n\_cols, \textcolor{stringliteral}{"{}matrix multiplication"{}});}
\DoxyCodeLine{102   }
\DoxyCodeLine{103   \textcolor{keywordflow}{if}( (\mbox{\hyperlink{structA}{A}}.n\_elem == 0) || (\mbox{\hyperlink{structB}{B}}.n\_elem == 0) )  \{ actual\_out.reset(); \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{104   }
\DoxyCodeLine{105   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_alpha = \mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T1>::do\_times}} || \mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T2>::do\_times}};}
\DoxyCodeLine{106   \textcolor{keyword}{const} eT       alpha = use\_alpha ? (UA.get\_val() * UB.get\_val()) : eT(0);}
\DoxyCodeLine{107   }
\DoxyCodeLine{108   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} is\_alias  = (UA.is\_alias(actual\_out) || UB.is\_alias(actual\_out));}
\DoxyCodeLine{109   }
\DoxyCodeLine{110   \mbox{\hyperlink{classMat}{Mat<eT>}}  tmp;}
\DoxyCodeLine{111   \mbox{\hyperlink{classMat}{Mat<eT>}}\& out = (is\_alias) ? tmp : actual\_out;}
\DoxyCodeLine{112   }
\DoxyCodeLine{113   \textcolor{keyword}{const} uword A\_n\_rows = \mbox{\hyperlink{structA}{A}}.n\_rows;}
\DoxyCodeLine{114   \textcolor{keyword}{const} uword A\_n\_cols = \mbox{\hyperlink{structA}{A}}.n\_cols;}
\DoxyCodeLine{115 }
\DoxyCodeLine{116   \textcolor{keyword}{const} uword B\_n\_rows = \mbox{\hyperlink{structB}{B}}.n\_rows;}
\DoxyCodeLine{117   \textcolor{keyword}{const} uword B\_n\_cols = \mbox{\hyperlink{structB}{B}}.n\_cols;}
\DoxyCodeLine{118   }
\DoxyCodeLine{119   \textcolor{keywordflow}{if}( (\mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T1>::do\_trans}} == \textcolor{keyword}{false}) \&\& (\mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T2>::do\_trans}} == \textcolor{keyword}{false}) )}
\DoxyCodeLine{120     \{}
\DoxyCodeLine{121     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}trans\_A = false; trans\_B = false;"{}});}
\DoxyCodeLine{122     }
\DoxyCodeLine{123     \textcolor{keyword}{const} uword N = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(A\_n\_rows, B\_n\_cols);}
\DoxyCodeLine{124     }
\DoxyCodeLine{125     out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(N,1);}
\DoxyCodeLine{126     }
\DoxyCodeLine{127     eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{128     }
\DoxyCodeLine{129     \textcolor{keywordflow}{for}(uword k=0; k < N; ++k)}
\DoxyCodeLine{130       \{}
\DoxyCodeLine{131       eT acc1 = eT(0);}
\DoxyCodeLine{132       eT acc2 = eT(0);}
\DoxyCodeLine{133       }
\DoxyCodeLine{134       \textcolor{keyword}{const} eT* B\_colptr = \mbox{\hyperlink{structB}{B}}.colptr(k);}
\DoxyCodeLine{135       }
\DoxyCodeLine{136       \textcolor{comment}{// condition: A\_n\_cols = B\_n\_rows}}
\DoxyCodeLine{137       }
\DoxyCodeLine{138       uword j;}
\DoxyCodeLine{139       }
\DoxyCodeLine{140       \textcolor{keywordflow}{for}(j=1; j < A\_n\_cols; j+=2)}
\DoxyCodeLine{141         \{}
\DoxyCodeLine{142         \textcolor{keyword}{const} uword i = (j-\/1);}
\DoxyCodeLine{143         }
\DoxyCodeLine{144         \textcolor{keyword}{const} eT tmp\_i = B\_colptr[i];}
\DoxyCodeLine{145         \textcolor{keyword}{const} eT tmp\_j = B\_colptr[j];}
\DoxyCodeLine{146         }
\DoxyCodeLine{147         acc1 += \mbox{\hyperlink{structA}{A}}.at(k, i) * tmp\_i;}
\DoxyCodeLine{148         acc2 += \mbox{\hyperlink{structA}{A}}.at(k, j) * tmp\_j;}
\DoxyCodeLine{149         \}}
\DoxyCodeLine{150       }
\DoxyCodeLine{151       \textcolor{keyword}{const} uword i = (j-\/1);}
\DoxyCodeLine{152       }
\DoxyCodeLine{153       \textcolor{keywordflow}{if}(i < A\_n\_cols)}
\DoxyCodeLine{154         \{}
\DoxyCodeLine{155         acc1 += \mbox{\hyperlink{structA}{A}}.at(k, i) * B\_colptr[i];}
\DoxyCodeLine{156         \}}
\DoxyCodeLine{157       }
\DoxyCodeLine{158       \textcolor{keyword}{const} eT acc = acc1 + acc2;}
\DoxyCodeLine{159       }
\DoxyCodeLine{160       out\_mem[k] = (use\_alpha) ? eT(alpha * acc) : eT(acc);}
\DoxyCodeLine{161       \}}
\DoxyCodeLine{162     \}}
\DoxyCodeLine{163   \textcolor{keywordflow}{else}}
\DoxyCodeLine{164   \textcolor{keywordflow}{if}( (\mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T1>::do\_trans}} == \textcolor{keyword}{true} ) \&\& (\mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T2>::do\_trans}} == \textcolor{keyword}{false}) )}
\DoxyCodeLine{165     \{}
\DoxyCodeLine{166     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}trans\_A = true; trans\_B = false;"{}});}
\DoxyCodeLine{167     }
\DoxyCodeLine{168     \textcolor{keyword}{const} uword N = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(A\_n\_cols, B\_n\_cols);}
\DoxyCodeLine{169     }
\DoxyCodeLine{170     out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(N,1);}
\DoxyCodeLine{171     }
\DoxyCodeLine{172     eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{173     }
\DoxyCodeLine{174     \textcolor{keywordflow}{for}(uword k=0; k < N; ++k)}
\DoxyCodeLine{175       \{}
\DoxyCodeLine{176       \textcolor{keyword}{const} eT* A\_colptr = \mbox{\hyperlink{structA}{A}}.colptr(k);}
\DoxyCodeLine{177       \textcolor{keyword}{const} eT* B\_colptr = \mbox{\hyperlink{structB}{B}}.colptr(k);}
\DoxyCodeLine{178       }
\DoxyCodeLine{179       \textcolor{comment}{// condition: A\_n\_rows = B\_n\_rows}}
\DoxyCodeLine{180       }
\DoxyCodeLine{181       \textcolor{keyword}{const} eT acc = \mbox{\hyperlink{group__op__dot_gafcc9d4848f5791b21d9a4c755baa6440}{op\_dot::direct\_dot}}(A\_n\_rows, A\_colptr, B\_colptr);}
\DoxyCodeLine{182       }
\DoxyCodeLine{183       out\_mem[k] = (use\_alpha) ? eT(alpha * acc) : eT(acc);}
\DoxyCodeLine{184       \}}
\DoxyCodeLine{185     \}}
\DoxyCodeLine{186   \textcolor{keywordflow}{else}}
\DoxyCodeLine{187   \textcolor{keywordflow}{if}( (\mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T1>::do\_trans}} == \textcolor{keyword}{false}) \&\& (\mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T2>::do\_trans}} == \textcolor{keyword}{true} ) )}
\DoxyCodeLine{188     \{}
\DoxyCodeLine{189     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}trans\_A = false; trans\_B = true;"{}});}
\DoxyCodeLine{190     }
\DoxyCodeLine{191     \textcolor{keyword}{const} uword N = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(A\_n\_rows, B\_n\_rows);}
\DoxyCodeLine{192     }
\DoxyCodeLine{193     out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(N,1);}
\DoxyCodeLine{194     }
\DoxyCodeLine{195     eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{196     }
\DoxyCodeLine{197     \textcolor{keywordflow}{for}(uword k=0; k < N; ++k)}
\DoxyCodeLine{198       \{}
\DoxyCodeLine{199       eT acc = eT(0);}
\DoxyCodeLine{200       }
\DoxyCodeLine{201       \textcolor{comment}{// condition: A\_n\_cols = B\_n\_cols}}
\DoxyCodeLine{202       }
\DoxyCodeLine{203       \textcolor{keywordflow}{for}(uword i=0; i < A\_n\_cols; ++i)}
\DoxyCodeLine{204         \{}
\DoxyCodeLine{205         acc += \mbox{\hyperlink{structA}{A}}.at(k,i) * \mbox{\hyperlink{structB}{B}}.at(k,i);}
\DoxyCodeLine{206         \}}
\DoxyCodeLine{207       }
\DoxyCodeLine{208       out\_mem[k] = (use\_alpha) ? eT(alpha * acc) : eT(acc);}
\DoxyCodeLine{209       \}}
\DoxyCodeLine{210     \}}
\DoxyCodeLine{211   \textcolor{keywordflow}{else}}
\DoxyCodeLine{212   \textcolor{keywordflow}{if}( (\mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T1>::do\_trans}} == \textcolor{keyword}{true} ) \&\& (\mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T2>::do\_trans}} == \textcolor{keyword}{true} ) )}
\DoxyCodeLine{213     \{}
\DoxyCodeLine{214     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}trans\_A = true; trans\_B = true;"{}});}
\DoxyCodeLine{215     }
\DoxyCodeLine{216     \textcolor{keyword}{const} uword N = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(A\_n\_cols, B\_n\_rows);}
\DoxyCodeLine{217     }
\DoxyCodeLine{218     out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(N,1);}
\DoxyCodeLine{219     }
\DoxyCodeLine{220     eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{221     }
\DoxyCodeLine{222     \textcolor{keywordflow}{for}(uword k=0; k < N; ++k)}
\DoxyCodeLine{223       \{}
\DoxyCodeLine{224       eT acc = eT(0);}
\DoxyCodeLine{225       }
\DoxyCodeLine{226       \textcolor{keyword}{const} eT* A\_colptr = \mbox{\hyperlink{structA}{A}}.colptr(k);}
\DoxyCodeLine{227       }
\DoxyCodeLine{228       \textcolor{comment}{// condition: A\_n\_rows = B\_n\_cols}}
\DoxyCodeLine{229       }
\DoxyCodeLine{230       \textcolor{keywordflow}{for}(uword i=0; i < A\_n\_rows; ++i)}
\DoxyCodeLine{231         \{}
\DoxyCodeLine{232         acc += A\_colptr[i] * \mbox{\hyperlink{structB}{B}}.at(k,i);}
\DoxyCodeLine{233         \}}
\DoxyCodeLine{234       }
\DoxyCodeLine{235       out\_mem[k] = (use\_alpha) ? eT(alpha * acc) : eT(acc);}
\DoxyCodeLine{236       \}}
\DoxyCodeLine{237     \}}
\DoxyCodeLine{238   }
\DoxyCodeLine{239   \textcolor{keywordflow}{if}(is\_alias)  \{ actual\_out.\mbox{\hyperlink{group__Mat_gaff06a75771f96605f7cc4f8c6b3fceb7}{steal\_mem}}(tmp); \}}
\DoxyCodeLine{240   \}}
\DoxyCodeLine{241 }
\DoxyCodeLine{242 }
\DoxyCodeLine{243 }
\DoxyCodeLine{244 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{245 \textcolor{keyword}{inline}}
\DoxyCodeLine{246 \textcolor{keywordtype}{void}}
\DoxyCodeLine{247 op\_diagvec::apply(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& actual\_out, \textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op}}< \mbox{\hyperlink{classGlue}{Glue<T1,T2,glue\_times>}}, \mbox{\hyperlink{classop__diagvec}{op\_diagvec}}>\& X, \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<typename T1::elem\_type>::result}}* junk)}
\DoxyCodeLine{248   \{}
\DoxyCodeLine{249   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{250   arma\_ignore(junk);}
\DoxyCodeLine{251   }
\DoxyCodeLine{252   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type   T;}
\DoxyCodeLine{253   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{254   }
\DoxyCodeLine{255   \textcolor{keyword}{const} \mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T1>}} UA(X.m.A);}
\DoxyCodeLine{256   \textcolor{keyword}{const} \mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T2>}} UB(X.m.B);}
\DoxyCodeLine{257   }
\DoxyCodeLine{258   \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T1>::stored\_type}}\& \mbox{\hyperlink{structA}{A}} = UA.M;}
\DoxyCodeLine{259   \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T2>::stored\_type}}\& \mbox{\hyperlink{structB}{B}} = UB.M;}
\DoxyCodeLine{260   }
\DoxyCodeLine{261   arma\_debug\_assert\_trans\_mul\_size< partial\_unwrap<T1>::do\_trans, \mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T2>::do\_trans}} >(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structB}{B}}.n\_rows, \mbox{\hyperlink{structB}{B}}.n\_cols, \textcolor{stringliteral}{"{}matrix multiplication"{}});}
\DoxyCodeLine{262   }
\DoxyCodeLine{263   \textcolor{keywordflow}{if}( (\mbox{\hyperlink{structA}{A}}.n\_elem == 0) || (\mbox{\hyperlink{structB}{B}}.n\_elem == 0) )  \{ actual\_out.reset(); \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{264   }
\DoxyCodeLine{265   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_alpha = \mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T1>::do\_times}} || \mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T2>::do\_times}};}
\DoxyCodeLine{266   \textcolor{keyword}{const} eT       alpha = use\_alpha ? (UA.get\_val() * UB.get\_val()) : eT(0);}
\DoxyCodeLine{267   }
\DoxyCodeLine{268   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} is\_alias  = (UA.is\_alias(actual\_out) || UB.is\_alias(actual\_out));}
\DoxyCodeLine{269   }
\DoxyCodeLine{270   \mbox{\hyperlink{classMat}{Mat<eT>}}  tmp;}
\DoxyCodeLine{271   \mbox{\hyperlink{classMat}{Mat<eT>}}\& out = (is\_alias) ? tmp : actual\_out;}
\DoxyCodeLine{272   }
\DoxyCodeLine{273   \textcolor{keyword}{const} uword A\_n\_rows = \mbox{\hyperlink{structA}{A}}.n\_rows;}
\DoxyCodeLine{274   \textcolor{keyword}{const} uword A\_n\_cols = \mbox{\hyperlink{structA}{A}}.n\_cols;}
\DoxyCodeLine{275   }
\DoxyCodeLine{276   \textcolor{keyword}{const} uword B\_n\_rows = \mbox{\hyperlink{structB}{B}}.n\_rows;}
\DoxyCodeLine{277   \textcolor{keyword}{const} uword B\_n\_cols = \mbox{\hyperlink{structB}{B}}.n\_cols;}
\DoxyCodeLine{278   }
\DoxyCodeLine{279   \textcolor{keywordflow}{if}( (\mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T1>::do\_trans}} == \textcolor{keyword}{false}) \&\& (\mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T2>::do\_trans}} == \textcolor{keyword}{false}) )}
\DoxyCodeLine{280     \{}
\DoxyCodeLine{281     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}trans\_A = false; trans\_B = false;"{}});}
\DoxyCodeLine{282     }
\DoxyCodeLine{283     \textcolor{keyword}{const} uword N = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(A\_n\_rows, B\_n\_cols);}
\DoxyCodeLine{284     }
\DoxyCodeLine{285     out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(N,1);}
\DoxyCodeLine{286     }
\DoxyCodeLine{287     eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{288     }
\DoxyCodeLine{289     \textcolor{keywordflow}{for}(uword k=0; k < N; ++k)}
\DoxyCodeLine{290       \{}
\DoxyCodeLine{291       T acc\_real = T(0);}
\DoxyCodeLine{292       T acc\_imag = T(0);}
\DoxyCodeLine{293       }
\DoxyCodeLine{294       \textcolor{keyword}{const} eT* B\_colptr = \mbox{\hyperlink{structB}{B}}.colptr(k);}
\DoxyCodeLine{295       }
\DoxyCodeLine{296       \textcolor{comment}{// condition: A\_n\_cols = B\_n\_rows}}
\DoxyCodeLine{297       }
\DoxyCodeLine{298       \textcolor{keywordflow}{for}(uword i=0; i < A\_n\_cols; ++i)}
\DoxyCodeLine{299         \{}
\DoxyCodeLine{300         \textcolor{comment}{// acc += A.at(k, i) * B\_colptr[i];}}
\DoxyCodeLine{301         }
\DoxyCodeLine{302         \textcolor{keyword}{const} std::complex<T>\& xx = \mbox{\hyperlink{structA}{A}}.at(k, i);}
\DoxyCodeLine{303         \textcolor{keyword}{const} std::complex<T>\& yy = B\_colptr[i];}
\DoxyCodeLine{304         }
\DoxyCodeLine{305         \textcolor{keyword}{const} T a = xx.real();}
\DoxyCodeLine{306         \textcolor{keyword}{const} T b = xx.imag();}
\DoxyCodeLine{307         }
\DoxyCodeLine{308         \textcolor{keyword}{const} T c = yy.real();}
\DoxyCodeLine{309         \textcolor{keyword}{const} T d = yy.imag();}
\DoxyCodeLine{310         }
\DoxyCodeLine{311         acc\_real += (a*c) -\/ (b*d);}
\DoxyCodeLine{312         acc\_imag += (a*d) + (b*c);}
\DoxyCodeLine{313         \}}
\DoxyCodeLine{314       }
\DoxyCodeLine{315       \textcolor{keyword}{const} eT acc = std::complex<T>(acc\_real, acc\_imag);}
\DoxyCodeLine{316       }
\DoxyCodeLine{317       out\_mem[k] = (use\_alpha) ? eT(alpha * acc) : eT(acc);}
\DoxyCodeLine{318       \}}
\DoxyCodeLine{319     \}}
\DoxyCodeLine{320   \textcolor{keywordflow}{else}}
\DoxyCodeLine{321   \textcolor{keywordflow}{if}( (\mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T1>::do\_trans}} == \textcolor{keyword}{true}) \&\& (\mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T2>::do\_trans}} == \textcolor{keyword}{false}) )}
\DoxyCodeLine{322     \{}
\DoxyCodeLine{323     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}trans\_A = true; trans\_B = false;"{}});}
\DoxyCodeLine{324     }
\DoxyCodeLine{325     \textcolor{keyword}{const} uword N = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(A\_n\_cols, B\_n\_cols);}
\DoxyCodeLine{326     }
\DoxyCodeLine{327     out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(N,1);}
\DoxyCodeLine{328     }
\DoxyCodeLine{329     eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{330     }
\DoxyCodeLine{331     \textcolor{keywordflow}{for}(uword k=0; k < N; ++k)}
\DoxyCodeLine{332       \{}
\DoxyCodeLine{333       T acc\_real = T(0);}
\DoxyCodeLine{334       T acc\_imag = T(0);}
\DoxyCodeLine{335       }
\DoxyCodeLine{336       \textcolor{keyword}{const} eT* A\_colptr = \mbox{\hyperlink{structA}{A}}.colptr(k);}
\DoxyCodeLine{337       \textcolor{keyword}{const} eT* B\_colptr = \mbox{\hyperlink{structB}{B}}.colptr(k);}
\DoxyCodeLine{338       }
\DoxyCodeLine{339       \textcolor{comment}{// condition: A\_n\_rows = B\_n\_rows}}
\DoxyCodeLine{340       }
\DoxyCodeLine{341       \textcolor{keywordflow}{for}(uword i=0; i < A\_n\_rows; ++i)}
\DoxyCodeLine{342         \{}
\DoxyCodeLine{343         \textcolor{comment}{// acc += std::conj(A\_colptr[i]) * B\_colptr[i];}}
\DoxyCodeLine{344         }
\DoxyCodeLine{345         \textcolor{keyword}{const} std::complex<T>\& xx = A\_colptr[i];}
\DoxyCodeLine{346         \textcolor{keyword}{const} std::complex<T>\& yy = B\_colptr[i];}
\DoxyCodeLine{347         }
\DoxyCodeLine{348         \textcolor{keyword}{const} T a = xx.real();}
\DoxyCodeLine{349         \textcolor{keyword}{const} T b = xx.imag();}
\DoxyCodeLine{350         }
\DoxyCodeLine{351         \textcolor{keyword}{const} T c = yy.real();}
\DoxyCodeLine{352         \textcolor{keyword}{const} T d = yy.imag();}
\DoxyCodeLine{353         }
\DoxyCodeLine{354         \textcolor{comment}{// take into account the complex conjugate of xx}}
\DoxyCodeLine{355         }
\DoxyCodeLine{356         acc\_real += (a*c) + (b*d);}
\DoxyCodeLine{357         acc\_imag += (a*d) -\/ (b*c);}
\DoxyCodeLine{358         \}}
\DoxyCodeLine{359       }
\DoxyCodeLine{360       \textcolor{keyword}{const} eT acc = std::complex<T>(acc\_real, acc\_imag);}
\DoxyCodeLine{361       }
\DoxyCodeLine{362       out\_mem[k] = (use\_alpha) ? eT(alpha * acc) : eT(acc);}
\DoxyCodeLine{363       \}}
\DoxyCodeLine{364     \}}
\DoxyCodeLine{365   \textcolor{keywordflow}{else}}
\DoxyCodeLine{366   \textcolor{keywordflow}{if}( (\mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T1>::do\_trans}} == \textcolor{keyword}{false}) \&\& (\mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T2>::do\_trans}} == \textcolor{keyword}{true}) )}
\DoxyCodeLine{367     \{}
\DoxyCodeLine{368     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}trans\_A = false; trans\_B = true;"{}});}
\DoxyCodeLine{369     }
\DoxyCodeLine{370     \textcolor{keyword}{const} uword N = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(A\_n\_rows, B\_n\_rows);}
\DoxyCodeLine{371     }
\DoxyCodeLine{372     out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(N,1);}
\DoxyCodeLine{373     }
\DoxyCodeLine{374     eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{375     }
\DoxyCodeLine{376     \textcolor{keywordflow}{for}(uword k=0; k < N; ++k)}
\DoxyCodeLine{377       \{}
\DoxyCodeLine{378       T acc\_real = T(0);}
\DoxyCodeLine{379       T acc\_imag = T(0);}
\DoxyCodeLine{380       }
\DoxyCodeLine{381       \textcolor{comment}{// condition: A\_n\_cols = B\_n\_cols}}
\DoxyCodeLine{382       }
\DoxyCodeLine{383       \textcolor{keywordflow}{for}(uword i=0; i < A\_n\_cols; ++i)}
\DoxyCodeLine{384         \{}
\DoxyCodeLine{385         \textcolor{comment}{// acc += A.at(k,i) * std::conj(B.at(k,i));}}
\DoxyCodeLine{386         }
\DoxyCodeLine{387         \textcolor{keyword}{const} std::complex<T>\& xx = \mbox{\hyperlink{structA}{A}}.at(k, i);}
\DoxyCodeLine{388         \textcolor{keyword}{const} std::complex<T>\& yy = \mbox{\hyperlink{structB}{B}}.at(k, i);}
\DoxyCodeLine{389         }
\DoxyCodeLine{390         \textcolor{keyword}{const} T a = xx.real();}
\DoxyCodeLine{391         \textcolor{keyword}{const} T b = xx.imag();}
\DoxyCodeLine{392         }
\DoxyCodeLine{393         \textcolor{keyword}{const} T c =  yy.real();}
\DoxyCodeLine{394         \textcolor{keyword}{const} T d = -\/yy.imag();  \textcolor{comment}{// take the conjugate}}
\DoxyCodeLine{395         }
\DoxyCodeLine{396         acc\_real += (a*c) -\/ (b*d);}
\DoxyCodeLine{397         acc\_imag += (a*d) + (b*c);}
\DoxyCodeLine{398         \}}
\DoxyCodeLine{399       }
\DoxyCodeLine{400       \textcolor{keyword}{const} eT acc = std::complex<T>(acc\_real, acc\_imag);}
\DoxyCodeLine{401       }
\DoxyCodeLine{402       out\_mem[k] = (use\_alpha) ? eT(alpha * acc) : eT(acc);}
\DoxyCodeLine{403       \}}
\DoxyCodeLine{404     \}}
\DoxyCodeLine{405   \textcolor{keywordflow}{else}}
\DoxyCodeLine{406   \textcolor{keywordflow}{if}( (\mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T1>::do\_trans}} == \textcolor{keyword}{true}) \&\& (\mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T2>::do\_trans}} == \textcolor{keyword}{true}) )}
\DoxyCodeLine{407     \{}
\DoxyCodeLine{408     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}trans\_A = true; trans\_B = true;"{}});}
\DoxyCodeLine{409     }
\DoxyCodeLine{410     \textcolor{keyword}{const} uword N = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(A\_n\_cols, B\_n\_rows);}
\DoxyCodeLine{411     }
\DoxyCodeLine{412     out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(N,1);}
\DoxyCodeLine{413     }
\DoxyCodeLine{414     eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{415     }
\DoxyCodeLine{416     \textcolor{keywordflow}{for}(uword k=0; k < N; ++k)}
\DoxyCodeLine{417       \{}
\DoxyCodeLine{418       T acc\_real = T(0);}
\DoxyCodeLine{419       T acc\_imag = T(0);}
\DoxyCodeLine{420       }
\DoxyCodeLine{421       \textcolor{keyword}{const} eT* A\_colptr = \mbox{\hyperlink{structA}{A}}.colptr(k);}
\DoxyCodeLine{422       }
\DoxyCodeLine{423       \textcolor{comment}{// condition: A\_n\_rows = B\_n\_cols}}
\DoxyCodeLine{424       }
\DoxyCodeLine{425       \textcolor{keywordflow}{for}(uword i=0; i < A\_n\_rows; ++i)}
\DoxyCodeLine{426         \{}
\DoxyCodeLine{427         \textcolor{comment}{// acc += std::conj(A\_colptr[i]) * std::conj(B.at(k,i));}}
\DoxyCodeLine{428         }
\DoxyCodeLine{429         \textcolor{keyword}{const} std::complex<T>\& xx = A\_colptr[i];}
\DoxyCodeLine{430         \textcolor{keyword}{const} std::complex<T>\& yy = \mbox{\hyperlink{structB}{B}}.at(k, i);}
\DoxyCodeLine{431         }
\DoxyCodeLine{432         \textcolor{keyword}{const} T a =  xx.real();}
\DoxyCodeLine{433         \textcolor{keyword}{const} T b = -\/xx.imag();  \textcolor{comment}{// take the conjugate}}
\DoxyCodeLine{434         }
\DoxyCodeLine{435         \textcolor{keyword}{const} T c =  yy.real();}
\DoxyCodeLine{436         \textcolor{keyword}{const} T d = -\/yy.imag();  \textcolor{comment}{// take the conjugate}}
\DoxyCodeLine{437         }
\DoxyCodeLine{438         acc\_real += (a*c) -\/ (b*d);}
\DoxyCodeLine{439         acc\_imag += (a*d) + (b*c);}
\DoxyCodeLine{440         \}}
\DoxyCodeLine{441       }
\DoxyCodeLine{442       \textcolor{keyword}{const} eT acc = std::complex<T>(acc\_real, acc\_imag);}
\DoxyCodeLine{443       }
\DoxyCodeLine{444       out\_mem[k] = (use\_alpha) ? eT(alpha * acc) : eT(acc);}
\DoxyCodeLine{445       \}}
\DoxyCodeLine{446     \}}
\DoxyCodeLine{447   }
\DoxyCodeLine{448   \textcolor{keywordflow}{if}(is\_alias)  \{ actual\_out.\mbox{\hyperlink{group__Mat_gaff06a75771f96605f7cc4f8c6b3fceb7}{steal\_mem}}(tmp); \}}
\DoxyCodeLine{449   \}}
\DoxyCodeLine{450 }
\DoxyCodeLine{451 }
\DoxyCodeLine{452 }
\DoxyCodeLine{453 \textcolor{comment}{//}}
\DoxyCodeLine{454 \textcolor{comment}{//}}
\DoxyCodeLine{455 \textcolor{comment}{//}}
\DoxyCodeLine{456 }
\DoxyCodeLine{457 }
\DoxyCodeLine{458 }
\DoxyCodeLine{459 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{460 \textcolor{keyword}{inline}}
\DoxyCodeLine{461 \textcolor{keywordtype}{void}}
\DoxyCodeLine{462 op\_diagvec2::apply(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T1, op\_diagvec2>}}\& X)}
\DoxyCodeLine{463   \{}
\DoxyCodeLine{464   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{465   }
\DoxyCodeLine{466   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{467   }
\DoxyCodeLine{468   \textcolor{keyword}{const} uword a = X.aux\_uword\_a;}
\DoxyCodeLine{469   \textcolor{keyword}{const} uword b = X.aux\_uword\_b;}
\DoxyCodeLine{470   }
\DoxyCodeLine{471   \textcolor{keyword}{const} uword row\_offset = (b >  0) ? a : 0;}
\DoxyCodeLine{472   \textcolor{keyword}{const} uword col\_offset = (b == 0) ? a : 0;}
\DoxyCodeLine{473   }
\DoxyCodeLine{474   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} P(X.m);}
\DoxyCodeLine{475   }
\DoxyCodeLine{476   \textcolor{keywordflow}{if}(P.is\_alias(out) == \textcolor{keyword}{false})}
\DoxyCodeLine{477     \{}
\DoxyCodeLine{478     op\_diagvec2::apply\_proxy(out, P, row\_offset, col\_offset);}
\DoxyCodeLine{479     \}}
\DoxyCodeLine{480   \textcolor{keywordflow}{else}}
\DoxyCodeLine{481     \{}
\DoxyCodeLine{482     \mbox{\hyperlink{classMat}{Mat<eT>}} tmp;}
\DoxyCodeLine{483     }
\DoxyCodeLine{484     op\_diagvec2::apply\_proxy(tmp, P, row\_offset, col\_offset);}
\DoxyCodeLine{485     }
\DoxyCodeLine{486     out.\mbox{\hyperlink{group__Mat_gaff06a75771f96605f7cc4f8c6b3fceb7}{steal\_mem}}(tmp);}
\DoxyCodeLine{487     \}}
\DoxyCodeLine{488   \}}
\DoxyCodeLine{489 }
\DoxyCodeLine{490 }
\DoxyCodeLine{491 }
\DoxyCodeLine{492 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{493 \textcolor{keyword}{inline}}
\DoxyCodeLine{494 \textcolor{keywordtype}{void}}
\DoxyCodeLine{495 op\_diagvec2::apply\_proxy(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}}\& P, \textcolor{keyword}{const} uword row\_offset, \textcolor{keyword}{const} uword col\_offset)}
\DoxyCodeLine{496   \{}
\DoxyCodeLine{497   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{498   }
\DoxyCodeLine{499   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{500   }
\DoxyCodeLine{501   \textcolor{keyword}{const} uword n\_rows = P.get\_n\_rows();}
\DoxyCodeLine{502   \textcolor{keyword}{const} uword n\_cols = P.get\_n\_cols();}
\DoxyCodeLine{503   }
\DoxyCodeLine{504   arma\_debug\_check\_bounds}
\DoxyCodeLine{505     (}
\DoxyCodeLine{506     ((row\_offset > 0) \&\& (row\_offset >= n\_rows)) || ((col\_offset > 0) \&\& (col\_offset >= n\_cols)),}
\DoxyCodeLine{507     \textcolor{stringliteral}{"{}diagvec(): requested diagonal is out of bounds"{}}}
\DoxyCodeLine{508     );}
\DoxyCodeLine{509   }
\DoxyCodeLine{510   \textcolor{keyword}{const} uword \mbox{\hyperlink{group__python__builtins_gaeff368081ac50b8fe2cc0230d96e3acb}{len}} = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(n\_rows -\/ row\_offset, n\_cols -\/ col\_offset);}
\DoxyCodeLine{511   }
\DoxyCodeLine{512   out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(\mbox{\hyperlink{group__python__builtins_gaeff368081ac50b8fe2cc0230d96e3acb}{len}}, 1);}
\DoxyCodeLine{513   }
\DoxyCodeLine{514   eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{515   }
\DoxyCodeLine{516   uword i,j;}
\DoxyCodeLine{517   \textcolor{keywordflow}{for}(i=0, j=1; j < \mbox{\hyperlink{group__python__builtins_gaeff368081ac50b8fe2cc0230d96e3acb}{len}}; i+=2, j+=2)}
\DoxyCodeLine{518     \{}
\DoxyCodeLine{519     \textcolor{keyword}{const} eT tmp\_i = P.at( i + row\_offset, i + col\_offset );}
\DoxyCodeLine{520     \textcolor{keyword}{const} eT tmp\_j = P.at( j + row\_offset, j + col\_offset );}
\DoxyCodeLine{521     }
\DoxyCodeLine{522     out\_mem[i] = tmp\_i;}
\DoxyCodeLine{523     out\_mem[j] = tmp\_j;}
\DoxyCodeLine{524     \}}
\DoxyCodeLine{525   }
\DoxyCodeLine{526   \textcolor{keywordflow}{if}(i < \mbox{\hyperlink{group__python__builtins_gaeff368081ac50b8fe2cc0230d96e3acb}{len}})}
\DoxyCodeLine{527     \{}
\DoxyCodeLine{528     out\_mem[i] = P.at( i + row\_offset, i + col\_offset );}
\DoxyCodeLine{529     \}}
\DoxyCodeLine{530   \}}
\DoxyCodeLine{531 }
\DoxyCodeLine{532 }
\DoxyCodeLine{533 }

\end{DoxyCode}
