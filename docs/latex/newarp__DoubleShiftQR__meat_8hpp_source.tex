\hypertarget{newarp__DoubleShiftQR__meat_8hpp_source}{}\doxysection{newarp\+\_\+\+Double\+Shift\+QR\+\_\+meat.\+hpp}
\label{newarp__DoubleShiftQR__meat_8hpp_source}\index{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/newarp\_DoubleShiftQR\_meat.hpp@{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/newarp\_DoubleShiftQR\_meat.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008-\/2016 Conrad Sanderson (http://conradsanderson.id.au)}}
\DoxyCodeLine{2 \textcolor{comment}{// Copyright 2008-\/2016 National ICT Australia (NICTA)}}
\DoxyCodeLine{3 \textcolor{comment}{// }}
\DoxyCodeLine{4 \textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{5 \textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{6 \textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{7 \textcolor{comment}{// http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{8 \textcolor{comment}{// }}
\DoxyCodeLine{9 \textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{10 \textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{11 \textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{12 \textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{13 \textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{14 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{17 \textcolor{keyword}{namespace }newarp}
\DoxyCodeLine{18 \{}
\DoxyCodeLine{19 }
\DoxyCodeLine{20 }
\DoxyCodeLine{21 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{22 \textcolor{keyword}{inline}}
\DoxyCodeLine{23 \textcolor{keywordtype}{void}}
\DoxyCodeLine{24 DoubleShiftQR<eT>::compute\_reflector(\textcolor{keyword}{const} eT\& x1, \textcolor{keyword}{const} eT\& x2, \textcolor{keyword}{const} eT\& x3, uword ind)}
\DoxyCodeLine{25   \{}
\DoxyCodeLine{26   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{27   }
\DoxyCodeLine{28   \textcolor{comment}{// In general case the reflector affects 3 rows}}
\DoxyCodeLine{29   ref\_nr(ind) = 3;}
\DoxyCodeLine{30   eT x2x3 = eT(0);}
\DoxyCodeLine{31   \textcolor{comment}{// If x3 is zero, decrease nr by 1}}
\DoxyCodeLine{32   \textcolor{keywordflow}{if}(std::abs(x3) < prec)}
\DoxyCodeLine{33     \{}
\DoxyCodeLine{34     \textcolor{comment}{// If x2 is also zero, nr will be 1, and we can exit this function}}
\DoxyCodeLine{35     \textcolor{keywordflow}{if}(std::abs(x2) < prec)}
\DoxyCodeLine{36       \{}
\DoxyCodeLine{37       ref\_nr(ind) = 1;}
\DoxyCodeLine{38       \textcolor{keywordflow}{return};}
\DoxyCodeLine{39       \}}
\DoxyCodeLine{40     \textcolor{keywordflow}{else}}
\DoxyCodeLine{41       \{}
\DoxyCodeLine{42       ref\_nr(ind) = 2;}
\DoxyCodeLine{43       \}}
\DoxyCodeLine{44     x2x3 = std::abs(x2);}
\DoxyCodeLine{45     \}}
\DoxyCodeLine{46   \textcolor{keywordflow}{else}}
\DoxyCodeLine{47     \{}
\DoxyCodeLine{48     x2x3 = arma\_hypot(x2, x3);}
\DoxyCodeLine{49     \}}
\DoxyCodeLine{50 }
\DoxyCodeLine{51   \textcolor{comment}{// x1' = x1 -\/ rho * ||x||}}
\DoxyCodeLine{52   \textcolor{comment}{// rho = -\/sign(x1), if x1 == 0, we choose rho = 1}}
\DoxyCodeLine{53   eT x1\_new = x1 -\/ ((x1 <= 0) -\/ (x1 > 0)) * arma\_hypot(x1, x2x3);}
\DoxyCodeLine{54   eT x\_norm = arma\_hypot(x1\_new, x2x3);}
\DoxyCodeLine{55   \textcolor{comment}{// Double check the norm of new x}}
\DoxyCodeLine{56   \textcolor{keywordflow}{if}(x\_norm < prec)}
\DoxyCodeLine{57     \{}
\DoxyCodeLine{58     ref\_nr(ind) = 1;}
\DoxyCodeLine{59     \textcolor{keywordflow}{return};}
\DoxyCodeLine{60     \}}
\DoxyCodeLine{61   ref\_u(0, ind) = x1\_new / x\_norm;}
\DoxyCodeLine{62   ref\_u(1, ind) = x2 / x\_norm;}
\DoxyCodeLine{63   ref\_u(2, ind) = x3 / x\_norm;}
\DoxyCodeLine{64   \}}
\DoxyCodeLine{65 }
\DoxyCodeLine{66 }
\DoxyCodeLine{67 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{68 arma\_inline}
\DoxyCodeLine{69 \textcolor{keywordtype}{void}}
\DoxyCodeLine{70 DoubleShiftQR<eT>::compute\_reflector(\textcolor{keyword}{const} eT* x, uword ind)}
\DoxyCodeLine{71   \{}
\DoxyCodeLine{72   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{73   }
\DoxyCodeLine{74   compute\_reflector(x[0], x[1], x[2], ind);}
\DoxyCodeLine{75   \}}
\DoxyCodeLine{76 }
\DoxyCodeLine{77 }
\DoxyCodeLine{78 }
\DoxyCodeLine{79 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{80 \textcolor{keyword}{inline}}
\DoxyCodeLine{81 \textcolor{keywordtype}{void}}
\DoxyCodeLine{82 DoubleShiftQR<eT>::update\_block(uword il, uword iu)}
\DoxyCodeLine{83   \{}
\DoxyCodeLine{84   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{85   }
\DoxyCodeLine{86   \textcolor{comment}{// Block size}}
\DoxyCodeLine{87   uword bsize = iu -\/ il + 1;}
\DoxyCodeLine{88 }
\DoxyCodeLine{89   \textcolor{comment}{// If block size == 1, there is no need to apply reflectors}}
\DoxyCodeLine{90   \textcolor{keywordflow}{if}(bsize == 1)}
\DoxyCodeLine{91     \{}
\DoxyCodeLine{92     ref\_nr(il) = 1;}
\DoxyCodeLine{93     \textcolor{keywordflow}{return};}
\DoxyCodeLine{94     \}}
\DoxyCodeLine{95 }
\DoxyCodeLine{96   \textcolor{comment}{// For block size == 2, do a Givens rotation on M = X * X -\/ s * X + t * I}}
\DoxyCodeLine{97   \textcolor{keywordflow}{if}(bsize == 2)}
\DoxyCodeLine{98     \{}
\DoxyCodeLine{99     \textcolor{comment}{// m00 = x00 * (x00 -\/ s) + x01 * x10 + t}}
\DoxyCodeLine{100     eT m00 = mat\_H(il, il) * (mat\_H(il, il) -\/ shift\_s) +}
\DoxyCodeLine{101              mat\_H(il, il + 1) * mat\_H(il + 1, il) +}
\DoxyCodeLine{102              shift\_t;}
\DoxyCodeLine{103     \textcolor{comment}{// m10 = x10 * (x00 + x11 -\/ s)}}
\DoxyCodeLine{104     eT m10 = mat\_H(il + 1, il) * (mat\_H(il, il) + mat\_H(il + 1, il + 1) -\/ shift\_s);}
\DoxyCodeLine{105     \textcolor{comment}{// This causes nr=2}}
\DoxyCodeLine{106     compute\_reflector(m00, m10, 0, il);}
\DoxyCodeLine{107     \textcolor{comment}{// Apply the reflector to X}}
\DoxyCodeLine{108     apply\_PX(mat\_H, il, il, 2, n -\/ il, il);}
\DoxyCodeLine{109     apply\_XP(mat\_H, 0, il, il + 2, 2, il);}
\DoxyCodeLine{110 }
\DoxyCodeLine{111     ref\_nr(il + 1) = 1;}
\DoxyCodeLine{112     \textcolor{keywordflow}{return};}
\DoxyCodeLine{113     \}}
\DoxyCodeLine{114 }
\DoxyCodeLine{115   \textcolor{comment}{// For block size >=3, use the regular strategy}}
\DoxyCodeLine{116   eT m00 = mat\_H(il, il) * (mat\_H(il, il) -\/ shift\_s) +}
\DoxyCodeLine{117            mat\_H(il, il + 1) * mat\_H(il + 1, il) +}
\DoxyCodeLine{118            shift\_t;}
\DoxyCodeLine{119   eT m10 = mat\_H(il + 1, il) * (mat\_H(il, il) + mat\_H(il + 1, il + 1) -\/ shift\_s);}
\DoxyCodeLine{120   \textcolor{comment}{// m20 = x21 * x10}}
\DoxyCodeLine{121   eT m20 = mat\_H(il + 2, il + 1) * mat\_H(il + 1, il);}
\DoxyCodeLine{122   compute\_reflector(m00, m10, m20, il);}
\DoxyCodeLine{123 }
\DoxyCodeLine{124   \textcolor{comment}{// Apply the first reflector}}
\DoxyCodeLine{125   apply\_PX(mat\_H, il, il, 3, n -\/ il, il);}
\DoxyCodeLine{126   apply\_XP(mat\_H, 0, il, il + (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(bsize, uword(4)), 3, il);}
\DoxyCodeLine{127 }
\DoxyCodeLine{128   \textcolor{comment}{// Calculate the following reflectors}}
\DoxyCodeLine{129   \textcolor{comment}{// If entering this loop, block size is at least 4.}}
\DoxyCodeLine{130   \textcolor{keywordflow}{for}(uword i = 1; i < bsize -\/ 2; i++)}
\DoxyCodeLine{131     \{}
\DoxyCodeLine{132     compute\_reflector(mat\_H.colptr(il + i -\/ 1) + il + i, il + i);}
\DoxyCodeLine{133     \textcolor{comment}{// Apply the reflector to X}}
\DoxyCodeLine{134     apply\_PX(mat\_H, il + i, il + i -\/ 1, 3, n + 1 -\/ il -\/ i, il + i);}
\DoxyCodeLine{135     apply\_XP(mat\_H, 0, il + i, il + (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(bsize, uword(i + 4)), 3, il + i);}
\DoxyCodeLine{136     \}}
\DoxyCodeLine{137 }
\DoxyCodeLine{138   \textcolor{comment}{// The last reflector}}
\DoxyCodeLine{139   \textcolor{comment}{// This causes nr=2}}
\DoxyCodeLine{140   compute\_reflector(mat\_H(iu -\/ 1, iu -\/ 2), mat\_H(iu, iu -\/ 2), 0, iu -\/ 1);}
\DoxyCodeLine{141   \textcolor{comment}{// Apply the reflector to X}}
\DoxyCodeLine{142   apply\_PX(mat\_H, iu -\/ 1, iu -\/ 2, 2, n + 2 -\/ iu, iu -\/ 1);}
\DoxyCodeLine{143   apply\_XP(mat\_H, 0, iu -\/ 1, il + bsize, 2, iu -\/ 1);}
\DoxyCodeLine{144 }
\DoxyCodeLine{145   ref\_nr(iu) = 1;}
\DoxyCodeLine{146   \}}
\DoxyCodeLine{147 }
\DoxyCodeLine{148 }
\DoxyCodeLine{149 }
\DoxyCodeLine{150 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{151 \textcolor{keyword}{inline}}
\DoxyCodeLine{152 \textcolor{keywordtype}{void}}
\DoxyCodeLine{153 DoubleShiftQR<eT>::apply\_PX(\mbox{\hyperlink{classMat}{Mat<eT>}}\& X, uword oi, uword oj, uword nrow, uword ncol, uword u\_ind)}
\DoxyCodeLine{154   \{}
\DoxyCodeLine{155   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{156   }
\DoxyCodeLine{157   \textcolor{keywordflow}{if}(ref\_nr(u\_ind) == 1) \{ \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{158 }
\DoxyCodeLine{159   \textcolor{comment}{// Householder reflectors at index u\_ind}}
\DoxyCodeLine{160   \mbox{\hyperlink{classCol}{Col<eT>}} u(ref\_u.colptr(u\_ind), 3, \textcolor{keyword}{false});}
\DoxyCodeLine{161 }
\DoxyCodeLine{162   \textcolor{keyword}{const} uword stride = X.n\_rows;}
\DoxyCodeLine{163   \textcolor{keyword}{const} eT u0\_2 = 2 * u(0);}
\DoxyCodeLine{164   \textcolor{keyword}{const} eT u1\_2 = 2 * u(1);}
\DoxyCodeLine{165 }
\DoxyCodeLine{166   eT* xptr = \&X(oi, oj);}
\DoxyCodeLine{167   \textcolor{keywordflow}{if}(ref\_nr(u\_ind) == 2 || nrow == 2)}
\DoxyCodeLine{168     \{}
\DoxyCodeLine{169     \textcolor{keywordflow}{for}(uword i = 0; i < ncol; i++, xptr += stride)}
\DoxyCodeLine{170       \{}
\DoxyCodeLine{171       eT tmp = u0\_2 * xptr[0] + u1\_2 * xptr[1];}
\DoxyCodeLine{172       xptr[0] -\/= tmp * u(0);}
\DoxyCodeLine{173       xptr[1] -\/= tmp * u(1);}
\DoxyCodeLine{174       \}}
\DoxyCodeLine{175     \}}
\DoxyCodeLine{176   \textcolor{keywordflow}{else}}
\DoxyCodeLine{177     \{}
\DoxyCodeLine{178     \textcolor{keyword}{const} eT u2\_2 = 2 * u(2);}
\DoxyCodeLine{179     \textcolor{keywordflow}{for}(uword i = 0; i < ncol; i++, xptr += stride)}
\DoxyCodeLine{180       \{}
\DoxyCodeLine{181       eT tmp = u0\_2 * xptr[0] + u1\_2 * xptr[1] + u2\_2 * xptr[2];}
\DoxyCodeLine{182       xptr[0] -\/= tmp * u(0);}
\DoxyCodeLine{183       xptr[1] -\/= tmp * u(1);}
\DoxyCodeLine{184       xptr[2] -\/= tmp * u(2);}
\DoxyCodeLine{185       \}}
\DoxyCodeLine{186     \}}
\DoxyCodeLine{187   \}}
\DoxyCodeLine{188 }
\DoxyCodeLine{189 }
\DoxyCodeLine{190 }
\DoxyCodeLine{191 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{192 \textcolor{keyword}{inline}}
\DoxyCodeLine{193 \textcolor{keywordtype}{void}}
\DoxyCodeLine{194 DoubleShiftQR<eT>::apply\_PX(eT* x, uword u\_ind)}
\DoxyCodeLine{195   \{}
\DoxyCodeLine{196   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{197   }
\DoxyCodeLine{198   \textcolor{keywordflow}{if}(ref\_nr(u\_ind) == 1) \{ \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{199 }
\DoxyCodeLine{200   eT u0 = ref\_u(0, u\_ind),}
\DoxyCodeLine{201      u1 = ref\_u(1, u\_ind),}
\DoxyCodeLine{202      u2 = ref\_u(2, u\_ind);}
\DoxyCodeLine{203 }
\DoxyCodeLine{204   \textcolor{comment}{// When the reflector only contains two elements, u2 has been set to zero}}
\DoxyCodeLine{205   \textcolor{keywordtype}{bool} nr\_is\_2 = (ref\_nr(u\_ind) == 2);}
\DoxyCodeLine{206   eT dot2 = x[0] * u0 + x[1] * u1 + (nr\_is\_2 ? 0 : (x[2] * u2));}
\DoxyCodeLine{207   dot2 *= 2;}
\DoxyCodeLine{208   x[0] -\/= dot2 * u0;}
\DoxyCodeLine{209   x[1] -\/= dot2 * u1;}
\DoxyCodeLine{210   \textcolor{keywordflow}{if}(!nr\_is\_2) \{ x[2] -\/= dot2 * u2; \}}
\DoxyCodeLine{211   \}}
\DoxyCodeLine{212 }
\DoxyCodeLine{213 }
\DoxyCodeLine{214 }
\DoxyCodeLine{215 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{216 \textcolor{keyword}{inline}}
\DoxyCodeLine{217 \textcolor{keywordtype}{void}}
\DoxyCodeLine{218 DoubleShiftQR<eT>::apply\_XP(\mbox{\hyperlink{classMat}{Mat<eT>}}\& X, uword oi, uword oj, uword nrow, uword ncol, uword u\_ind)}
\DoxyCodeLine{219   \{}
\DoxyCodeLine{220   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{221   }
\DoxyCodeLine{222   \textcolor{keywordflow}{if}(ref\_nr(u\_ind) == 1) \{ \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{223 }
\DoxyCodeLine{224   \textcolor{comment}{// Householder reflectors at index u\_ind}}
\DoxyCodeLine{225   \mbox{\hyperlink{classCol}{Col<eT>}} u(ref\_u.colptr(u\_ind), 3, \textcolor{keyword}{false});}
\DoxyCodeLine{226   uword stride = X.n\_rows;}
\DoxyCodeLine{227   \textcolor{keyword}{const} eT u0\_2 = 2 * u(0);}
\DoxyCodeLine{228   \textcolor{keyword}{const} eT u1\_2 = 2 * u(1);}
\DoxyCodeLine{229   eT* X0 = \&X(oi, oj);}
\DoxyCodeLine{230   eT* X1 = X0 + stride;  \textcolor{comment}{// X0 => X(oi, oj), X1 => X(oi, oj + 1)}}
\DoxyCodeLine{231 }
\DoxyCodeLine{232   \textcolor{keywordflow}{if}(ref\_nr(u\_ind) == 2 || ncol == 2)}
\DoxyCodeLine{233     \{}
\DoxyCodeLine{234     \textcolor{comment}{// tmp = 2 * u0 * X0 + 2 * u1 * X1}}
\DoxyCodeLine{235     \textcolor{comment}{// X0 => X0 -\/ u0 * tmp}}
\DoxyCodeLine{236     \textcolor{comment}{// X1 => X1 -\/ u1 * tmp}}
\DoxyCodeLine{237     \textcolor{keywordflow}{for}(uword i = 0; i < nrow; i++)}
\DoxyCodeLine{238       \{}
\DoxyCodeLine{239       eT tmp = u0\_2 * X0[i] + u1\_2 * X1[i];}
\DoxyCodeLine{240       X0[i] -\/= tmp * u(0);}
\DoxyCodeLine{241       X1[i] -\/= tmp * u(1);}
\DoxyCodeLine{242       \}}
\DoxyCodeLine{243     \}}
\DoxyCodeLine{244   \textcolor{keywordflow}{else}}
\DoxyCodeLine{245     \{}
\DoxyCodeLine{246     eT* X2 = X1 + stride;  \textcolor{comment}{// X2 => X(oi, oj + 2)}}
\DoxyCodeLine{247     \textcolor{keyword}{const} eT u2\_2 = 2 * u(2);}
\DoxyCodeLine{248     \textcolor{keywordflow}{for}(uword i = 0; i < nrow; i++)}
\DoxyCodeLine{249       \{}
\DoxyCodeLine{250       eT tmp = u0\_2 * X0[i] + u1\_2 * X1[i] + u2\_2 * X2[i];}
\DoxyCodeLine{251       X0[i] -\/= tmp * u(0);}
\DoxyCodeLine{252       X1[i] -\/= tmp * u(1);}
\DoxyCodeLine{253       X2[i] -\/= tmp * u(2);}
\DoxyCodeLine{254       \}}
\DoxyCodeLine{255     \}}
\DoxyCodeLine{256   \}}
\DoxyCodeLine{257 }
\DoxyCodeLine{258 }
\DoxyCodeLine{259 }
\DoxyCodeLine{260 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{261 \textcolor{keyword}{inline}}
\DoxyCodeLine{262 DoubleShiftQR<eT>::DoubleShiftQR(uword size)}
\DoxyCodeLine{263   : n(size)}
\DoxyCodeLine{264   , prec(std::numeric\_limits<eT>::epsilon())}
\DoxyCodeLine{265   , eps\_rel(prec)}
\DoxyCodeLine{266   , eps\_abs(prec)}
\DoxyCodeLine{267   , computed(false)}
\DoxyCodeLine{268   \{}
\DoxyCodeLine{269   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{270   \}}
\DoxyCodeLine{271 }
\DoxyCodeLine{272 }
\DoxyCodeLine{273 }
\DoxyCodeLine{274 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{275 \textcolor{keyword}{inline}}
\DoxyCodeLine{276 DoubleShiftQR<eT>::DoubleShiftQR(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& mat\_obj, eT s, eT t)}
\DoxyCodeLine{277   : n(mat\_obj.n\_rows)}
\DoxyCodeLine{278   , mat\_H(n, n)}
\DoxyCodeLine{279   , shift\_s(s)}
\DoxyCodeLine{280   , shift\_t(t)}
\DoxyCodeLine{281   , ref\_u(3, n)}
\DoxyCodeLine{282   , ref\_nr(n)}
\DoxyCodeLine{283   , prec(std::numeric\_limits<eT>::epsilon())}
\DoxyCodeLine{284   , eps\_rel(prec)}
\DoxyCodeLine{285   , eps\_abs(prec)}
\DoxyCodeLine{286   , computed(false)}
\DoxyCodeLine{287   \{}
\DoxyCodeLine{288   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{289   }
\DoxyCodeLine{290   compute(mat\_obj, s, t);}
\DoxyCodeLine{291   \}}
\DoxyCodeLine{292 }
\DoxyCodeLine{293 }
\DoxyCodeLine{294 }
\DoxyCodeLine{295 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{296 \textcolor{keywordtype}{void}}
\DoxyCodeLine{297 DoubleShiftQR<eT>::compute(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& mat\_obj, eT s, eT t)}
\DoxyCodeLine{298   \{}
\DoxyCodeLine{299   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{300   }
\DoxyCodeLine{301   arma\_debug\_check( (mat\_obj.\mbox{\hyperlink{group__Mat_ga1f860b22491beb19251642270d04d8f1}{is\_square}}() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}newarp::DoubleShiftQR::compute(): matrix must be square"{}} );}
\DoxyCodeLine{302 }
\DoxyCodeLine{303   n = mat\_obj.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}};}
\DoxyCodeLine{304   mat\_H.set\_size(n, n);}
\DoxyCodeLine{305   shift\_s = s;}
\DoxyCodeLine{306   shift\_t = t;}
\DoxyCodeLine{307   ref\_u.set\_size(3, n);}
\DoxyCodeLine{308   ref\_nr.set\_size(n);}
\DoxyCodeLine{309 }
\DoxyCodeLine{310   \textcolor{comment}{// Make a copy of mat\_obj}}
\DoxyCodeLine{311   mat\_H = mat\_obj;}
\DoxyCodeLine{312 }
\DoxyCodeLine{313   \textcolor{comment}{// Obtain the indices of zero elements in the subdiagonal,}}
\DoxyCodeLine{314   \textcolor{comment}{// so that H can be divided into several blocks}}
\DoxyCodeLine{315   std::vector<uword> zero\_ind;}
\DoxyCodeLine{316   zero\_ind.reserve(n -\/ 1);}
\DoxyCodeLine{317   zero\_ind.push\_back(0);}
\DoxyCodeLine{318   eT* Hii = mat\_H.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{319   \textcolor{keywordflow}{for}(uword i = 0; i < n -\/ 2; i++, Hii += (n + 1))}
\DoxyCodeLine{320     \{}
\DoxyCodeLine{321     \textcolor{comment}{// Hii[1] => mat\_H(i + 1, i)}}
\DoxyCodeLine{322     \textcolor{keyword}{const} eT h = std::abs(Hii[1]);}
\DoxyCodeLine{323     \textcolor{keywordflow}{if}(h <= eps\_abs || h <= eps\_rel * (std::abs(Hii[0]) + std::abs(Hii[n + 1])))}
\DoxyCodeLine{324       \{}
\DoxyCodeLine{325       Hii[1] = 0;}
\DoxyCodeLine{326       zero\_ind.push\_back(i + 1);}
\DoxyCodeLine{327       \}}
\DoxyCodeLine{328     \textcolor{comment}{// Make sure mat\_H is upper Hessenberg}}
\DoxyCodeLine{329     \textcolor{comment}{// Zero the elements below mat\_H(i + 1, i)}}
\DoxyCodeLine{330     std::fill(Hii + 2, Hii + n -\/ i, eT(0));}
\DoxyCodeLine{331     \}}
\DoxyCodeLine{332   zero\_ind.push\_back(n);}
\DoxyCodeLine{333 }
\DoxyCodeLine{334   \textcolor{keywordflow}{for}(std::vector<uword>::size\_type i = 0; i < zero\_ind.size() -\/ 1; i++)}
\DoxyCodeLine{335     \{}
\DoxyCodeLine{336     uword start = zero\_ind[i];}
\DoxyCodeLine{337     uword end = zero\_ind[i + 1] -\/ 1;}
\DoxyCodeLine{338     \textcolor{comment}{// Compute refelctors from each block X}}
\DoxyCodeLine{339     update\_block(start, end);}
\DoxyCodeLine{340     \}}
\DoxyCodeLine{341 }
\DoxyCodeLine{342   computed = \textcolor{keyword}{true};}
\DoxyCodeLine{343   \}}
\DoxyCodeLine{344 }
\DoxyCodeLine{345 }
\DoxyCodeLine{346 }
\DoxyCodeLine{347 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{348 \mbox{\hyperlink{classMat}{Mat<eT>}}}
\DoxyCodeLine{349 DoubleShiftQR<eT>::matrix\_QtHQ()}
\DoxyCodeLine{350   \{}
\DoxyCodeLine{351   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{352   }
\DoxyCodeLine{353   arma\_debug\_check( (computed == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}newarp::DoubleShiftQR::matrix\_QtHQ(): need to call compute() first"{}} );}
\DoxyCodeLine{354 }
\DoxyCodeLine{355   \textcolor{keywordflow}{return} mat\_H;}
\DoxyCodeLine{356   \}}
\DoxyCodeLine{357 }
\DoxyCodeLine{358 }
\DoxyCodeLine{359 }
\DoxyCodeLine{360 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{361 \textcolor{keyword}{inline}}
\DoxyCodeLine{362 \textcolor{keywordtype}{void}}
\DoxyCodeLine{363 DoubleShiftQR<eT>::apply\_QtY(\mbox{\hyperlink{classCol}{Col<eT>}}\& y)}
\DoxyCodeLine{364   \{}
\DoxyCodeLine{365   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{366   }
\DoxyCodeLine{367   arma\_debug\_check( (computed == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}newarp::DoubleShiftQR::apply\_QtY(): need to call compute() first"{}} );}
\DoxyCodeLine{368 }
\DoxyCodeLine{369   eT* y\_ptr = y.memptr();}
\DoxyCodeLine{370   \textcolor{keywordflow}{for}(uword i = 0; i < n -\/ 1; i++, y\_ptr++)}
\DoxyCodeLine{371     \{}
\DoxyCodeLine{372     apply\_PX(y\_ptr, i);}
\DoxyCodeLine{373     \}}
\DoxyCodeLine{374   \}}
\DoxyCodeLine{375 }
\DoxyCodeLine{376 }
\DoxyCodeLine{377 }
\DoxyCodeLine{378 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{379 \textcolor{keyword}{inline}}
\DoxyCodeLine{380 \textcolor{keywordtype}{void}}
\DoxyCodeLine{381 DoubleShiftQR<eT>::apply\_YQ(\mbox{\hyperlink{classMat}{Mat<eT>}}\& Y)}
\DoxyCodeLine{382   \{}
\DoxyCodeLine{383   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{384   }
\DoxyCodeLine{385   arma\_debug\_check( (computed == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}newarp::DoubleShiftQR::apply\_YQ(): need to call compute() first"{}} );}
\DoxyCodeLine{386 }
\DoxyCodeLine{387   uword nrow = Y.n\_rows;}
\DoxyCodeLine{388   \textcolor{keywordflow}{for}(uword i = 0; i < n -\/ 2; i++)}
\DoxyCodeLine{389     \{}
\DoxyCodeLine{390     apply\_XP(Y, 0, i, nrow, 3, i);}
\DoxyCodeLine{391     \}}
\DoxyCodeLine{392   }
\DoxyCodeLine{393   apply\_XP(Y, 0, n -\/ 2, nrow, 2, n -\/ 2);}
\DoxyCodeLine{394   \}}
\DoxyCodeLine{395 }
\DoxyCodeLine{396 }
\DoxyCodeLine{397 \}  \textcolor{comment}{// namespace newarp}}

\end{DoxyCode}
