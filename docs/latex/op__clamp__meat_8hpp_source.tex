\hypertarget{op__clamp__meat_8hpp_source}{}\doxysection{op\+\_\+clamp\+\_\+meat.\+hpp}
\label{op__clamp__meat_8hpp_source}\index{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/op\_clamp\_meat.hpp@{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/op\_clamp\_meat.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008-\/2016 Conrad Sanderson (http://conradsanderson.id.au)}}
\DoxyCodeLine{2 \textcolor{comment}{// Copyright 2008-\/2016 National ICT Australia (NICTA)}}
\DoxyCodeLine{3 \textcolor{comment}{// }}
\DoxyCodeLine{4 \textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{5 \textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{6 \textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{7 \textcolor{comment}{// http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{8 \textcolor{comment}{// }}
\DoxyCodeLine{9 \textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{10 \textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{11 \textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{12 \textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{13 \textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{14 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{17 }
\DoxyCodeLine{20 }
\DoxyCodeLine{21 }
\DoxyCodeLine{22 }
\DoxyCodeLine{23 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{24 \textcolor{keyword}{inline}}
\DoxyCodeLine{25 \textcolor{keywordtype}{void}}
\DoxyCodeLine{26 op\_clamp::apply(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classmtOp}{mtOp<typename T1::elem\_type, T1, op\_clamp>}}\& in)}
\DoxyCodeLine{27   \{}
\DoxyCodeLine{28   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{29   }
\DoxyCodeLine{30   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{31   }
\DoxyCodeLine{32   \textcolor{keyword}{const} eT min\_val = in.\mbox{\hyperlink{classmtOp_aa4033d0fc3f9eab453fb0565977d9fc8}{aux}};}
\DoxyCodeLine{33   \textcolor{keyword}{const} eT max\_val = in.\mbox{\hyperlink{classmtOp_ae4971a90218630622fa8e07c4f7df6b9}{aux\_out\_eT}};}
\DoxyCodeLine{34   }
\DoxyCodeLine{35   arma\_debug\_check( (min\_val > max\_val), \textcolor{stringliteral}{"{}clamp(): min\_val must be less than max\_val"{}} );}
\DoxyCodeLine{36   }
\DoxyCodeLine{37   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__Mat}{is\_Mat<T1>::value}})}
\DoxyCodeLine{38     \{}
\DoxyCodeLine{39     \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap}{unwrap<T1>}} U(in.\mbox{\hyperlink{classmtOp_a36bff6e38e68a900a5d4f1443d7f6dc2}{m}});}
\DoxyCodeLine{40     }
\DoxyCodeLine{41     op\_clamp::apply\_direct(out, U.M, min\_val, max\_val);}
\DoxyCodeLine{42     \}}
\DoxyCodeLine{43   \textcolor{keywordflow}{else}}
\DoxyCodeLine{44     \{}
\DoxyCodeLine{45     \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} P(in.\mbox{\hyperlink{classmtOp_a36bff6e38e68a900a5d4f1443d7f6dc2}{m}});}
\DoxyCodeLine{46     }
\DoxyCodeLine{47     \textcolor{keywordflow}{if}(P.is\_alias(out))}
\DoxyCodeLine{48       \{}
\DoxyCodeLine{49       \mbox{\hyperlink{classMat}{Mat<eT>}} tmp;}
\DoxyCodeLine{50       }
\DoxyCodeLine{51       op\_clamp::apply\_proxy\_noalias(tmp, P, min\_val, max\_val);}
\DoxyCodeLine{52       }
\DoxyCodeLine{53       out.\mbox{\hyperlink{group__Mat_gaff06a75771f96605f7cc4f8c6b3fceb7}{steal\_mem}}(tmp);}
\DoxyCodeLine{54       \}}
\DoxyCodeLine{55     \textcolor{keywordflow}{else}}
\DoxyCodeLine{56       \{}
\DoxyCodeLine{57       op\_clamp::apply\_proxy\_noalias(out, P, min\_val, max\_val);}
\DoxyCodeLine{58       \}}
\DoxyCodeLine{59     \}}
\DoxyCodeLine{60   \}}
\DoxyCodeLine{61 }
\DoxyCodeLine{62 }
\DoxyCodeLine{63 }
\DoxyCodeLine{64 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{65 \textcolor{keyword}{inline}}
\DoxyCodeLine{66 \textcolor{keywordtype}{void}}
\DoxyCodeLine{67 op\_clamp::apply\_direct(\mbox{\hyperlink{classMat}{Mat<eT>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X, \textcolor{keyword}{const} eT min\_val, \textcolor{keyword}{const} eT max\_val)}
\DoxyCodeLine{68   \{}
\DoxyCodeLine{69   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{70   }
\DoxyCodeLine{71   \textcolor{keywordflow}{if}(\&out != \&X)}
\DoxyCodeLine{72     \{}
\DoxyCodeLine{73     out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(X.n\_rows, X.n\_cols);}
\DoxyCodeLine{74     }
\DoxyCodeLine{75     \textcolor{keyword}{const} uword N = out.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}};}
\DoxyCodeLine{76     }
\DoxyCodeLine{77     \textcolor{keyword}{const} eT*   X\_mem =   X.memptr();}
\DoxyCodeLine{78           eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{79     }
\DoxyCodeLine{80     \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)}
\DoxyCodeLine{81       \{}
\DoxyCodeLine{82       \textcolor{keyword}{const} eT val = X\_mem[i];}
\DoxyCodeLine{83       }
\DoxyCodeLine{84       out\_mem[i] = (val < min\_val) ? min\_val : ((val > max\_val) ? max\_val : val);}
\DoxyCodeLine{85       \}}
\DoxyCodeLine{86     \}}
\DoxyCodeLine{87   \textcolor{keywordflow}{else}}
\DoxyCodeLine{88     \{}
\DoxyCodeLine{89     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}op\_clamp::apply\_direct(): inplace operation"{}});}
\DoxyCodeLine{90     }
\DoxyCodeLine{91     arrayops::clamp(out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), out.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}}, min\_val, max\_val);}
\DoxyCodeLine{92     \}}
\DoxyCodeLine{93   \}}
\DoxyCodeLine{94 }
\DoxyCodeLine{95 }
\DoxyCodeLine{96 }
\DoxyCodeLine{97 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{98 \textcolor{keyword}{inline}}
\DoxyCodeLine{99 \textcolor{keywordtype}{void}}
\DoxyCodeLine{100 op\_clamp::apply\_proxy\_noalias(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}}\& P, \textcolor{keyword}{const} \textcolor{keyword}{typename} T1::elem\_type min\_val, \textcolor{keyword}{const} \textcolor{keyword}{typename} T1::elem\_type max\_val)}
\DoxyCodeLine{101   \{}
\DoxyCodeLine{102   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{103   }
\DoxyCodeLine{104   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{105   }
\DoxyCodeLine{106   \textcolor{keyword}{const} uword n\_rows = P.get\_n\_rows();}
\DoxyCodeLine{107   \textcolor{keyword}{const} uword n\_cols = P.get\_n\_cols();}
\DoxyCodeLine{108   }
\DoxyCodeLine{109   out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(n\_rows, n\_cols);}
\DoxyCodeLine{110   }
\DoxyCodeLine{111   eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{112   }
\DoxyCodeLine{113   \textcolor{keywordflow}{if}(\mbox{\hyperlink{classProxy}{Proxy<T1>::use\_at}} == \textcolor{keyword}{false})}
\DoxyCodeLine{114     \{}
\DoxyCodeLine{115     \textcolor{keyword}{const} uword N = P.get\_n\_elem();}
\DoxyCodeLine{116     }
\DoxyCodeLine{117     \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::ea\_type}} \mbox{\hyperlink{structA}{A}} = P.get\_ea();}
\DoxyCodeLine{118     }
\DoxyCodeLine{119     \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)}
\DoxyCodeLine{120       \{}
\DoxyCodeLine{121       \textcolor{keyword}{const} eT val = \mbox{\hyperlink{structA}{A}}[i];}
\DoxyCodeLine{122       }
\DoxyCodeLine{123       out\_mem[i] = (val < min\_val) ? min\_val : ((val > max\_val) ? max\_val : val);}
\DoxyCodeLine{124       \}}
\DoxyCodeLine{125     \}}
\DoxyCodeLine{126   \textcolor{keywordflow}{else}}
\DoxyCodeLine{127     \{}
\DoxyCodeLine{128     \textcolor{keywordflow}{for}(uword col=0; col < n\_cols; ++col)}
\DoxyCodeLine{129     \textcolor{keywordflow}{for}(uword row=0; row < n\_rows; ++row)}
\DoxyCodeLine{130       \{}
\DoxyCodeLine{131       \textcolor{keyword}{const} eT val = P.at(row,col);}
\DoxyCodeLine{132       }
\DoxyCodeLine{133       (*out\_mem) = (val < min\_val) ? min\_val : ((val > max\_val) ? max\_val : val);}
\DoxyCodeLine{134       }
\DoxyCodeLine{135       out\_mem++;}
\DoxyCodeLine{136       \}}
\DoxyCodeLine{137     \}}
\DoxyCodeLine{138   \}}
\DoxyCodeLine{139 }
\DoxyCodeLine{140 }
\DoxyCodeLine{141 }
\DoxyCodeLine{142 \textcolor{comment}{//}}
\DoxyCodeLine{143 }
\DoxyCodeLine{144 }
\DoxyCodeLine{145 }
\DoxyCodeLine{146 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{147 \textcolor{keyword}{inline}}
\DoxyCodeLine{148 \textcolor{keywordtype}{void}}
\DoxyCodeLine{149 op\_clamp::apply(\mbox{\hyperlink{classCube}{Cube<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classmtOpCube}{mtOpCube<typename T1::elem\_type, T1, op\_clamp>}}\& in)}
\DoxyCodeLine{150   \{}
\DoxyCodeLine{151   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{152   }
\DoxyCodeLine{153   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{154   }
\DoxyCodeLine{155   \textcolor{keyword}{const} eT min\_val = in.\mbox{\hyperlink{classmtOpCube_ac3099786a3343847511b53c97b61024f}{aux}};}
\DoxyCodeLine{156   \textcolor{keyword}{const} eT max\_val = in.\mbox{\hyperlink{classmtOpCube_a94c46a125bf397e4856e628ee96abdac}{aux\_out\_eT}};}
\DoxyCodeLine{157   }
\DoxyCodeLine{158   arma\_debug\_check( (min\_val > max\_val), \textcolor{stringliteral}{"{}clamp(): min\_val must be less than max\_val"{}} );}
\DoxyCodeLine{159   }
\DoxyCodeLine{160   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__Cube}{is\_Cube<T1>::value}})}
\DoxyCodeLine{161     \{}
\DoxyCodeLine{162     \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap__cube}{unwrap\_cube<T1>}} U(in.\mbox{\hyperlink{classmtOpCube_a138bd6382aa304713adf55d2357b220d}{m}});}
\DoxyCodeLine{163     }
\DoxyCodeLine{164     op\_clamp::apply\_direct(out, U.M, min\_val, max\_val);}
\DoxyCodeLine{165     \}}
\DoxyCodeLine{166   \textcolor{keywordflow}{else}}
\DoxyCodeLine{167     \{}
\DoxyCodeLine{168     \textcolor{keyword}{const} \mbox{\hyperlink{classProxyCube}{ProxyCube<T1>}} P(in.\mbox{\hyperlink{classmtOpCube_a138bd6382aa304713adf55d2357b220d}{m}});}
\DoxyCodeLine{169     }
\DoxyCodeLine{170     \textcolor{keywordflow}{if}(P.is\_alias(out))}
\DoxyCodeLine{171       \{}
\DoxyCodeLine{172       \mbox{\hyperlink{classCube}{Cube<eT>}} tmp;}
\DoxyCodeLine{173       }
\DoxyCodeLine{174       op\_clamp::apply\_proxy\_noalias(tmp, P, min\_val, max\_val);}
\DoxyCodeLine{175       }
\DoxyCodeLine{176       out.\mbox{\hyperlink{group__Cube_ga70006d5a49f67d35d4ae10cb6c5a681f}{steal\_mem}}(tmp);}
\DoxyCodeLine{177       \}}
\DoxyCodeLine{178     \textcolor{keywordflow}{else}}
\DoxyCodeLine{179       \{}
\DoxyCodeLine{180       op\_clamp::apply\_proxy\_noalias(out, P, min\_val, max\_val);}
\DoxyCodeLine{181       \}}
\DoxyCodeLine{182     \}}
\DoxyCodeLine{183   \}}
\DoxyCodeLine{184 }
\DoxyCodeLine{185 }
\DoxyCodeLine{186 }
\DoxyCodeLine{187 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{188 \textcolor{keyword}{inline}}
\DoxyCodeLine{189 \textcolor{keywordtype}{void}}
\DoxyCodeLine{190 op\_clamp::apply\_direct(\mbox{\hyperlink{classCube}{Cube<eT>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classCube}{Cube<eT>}}\& X, \textcolor{keyword}{const} eT min\_val, \textcolor{keyword}{const} eT max\_val)}
\DoxyCodeLine{191   \{}
\DoxyCodeLine{192   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{193   }
\DoxyCodeLine{194   \textcolor{keywordflow}{if}(\&out != \&X)}
\DoxyCodeLine{195     \{}
\DoxyCodeLine{196     out.\mbox{\hyperlink{group__Cube_ga0d461586030945472fe66f7364882771}{set\_size}}(X.n\_rows, X.n\_cols, X.n\_slices);}
\DoxyCodeLine{197     }
\DoxyCodeLine{198     \textcolor{keyword}{const} uword N = out.\mbox{\hyperlink{classCube_a4903e94049fa6d9f0d62dbcbf376da96}{n\_elem}};}
\DoxyCodeLine{199     }
\DoxyCodeLine{200     \textcolor{keyword}{const} eT*   X\_mem =   X.memptr();}
\DoxyCodeLine{201           eT* out\_mem = out.\mbox{\hyperlink{group__Cube_ga5b00237224a8e3bfb05728de7c962f85}{memptr}}();}
\DoxyCodeLine{202     }
\DoxyCodeLine{203     \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)}
\DoxyCodeLine{204       \{}
\DoxyCodeLine{205       \textcolor{keyword}{const} eT val = X\_mem[i];}
\DoxyCodeLine{206       }
\DoxyCodeLine{207       out\_mem[i] = (val < min\_val) ? min\_val : ((val > max\_val) ? max\_val : val);}
\DoxyCodeLine{208       \}}
\DoxyCodeLine{209     \}}
\DoxyCodeLine{210   \textcolor{keywordflow}{else}}
\DoxyCodeLine{211     \{}
\DoxyCodeLine{212     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}op\_clamp::apply\_direct(): inplace operation"{}});}
\DoxyCodeLine{213     }
\DoxyCodeLine{214     arrayops::clamp(out.\mbox{\hyperlink{group__Cube_ga5b00237224a8e3bfb05728de7c962f85}{memptr}}(), out.\mbox{\hyperlink{classCube_a4903e94049fa6d9f0d62dbcbf376da96}{n\_elem}}, min\_val, max\_val);}
\DoxyCodeLine{215     \}}
\DoxyCodeLine{216   \}}
\DoxyCodeLine{217 }
\DoxyCodeLine{218 }
\DoxyCodeLine{219 }
\DoxyCodeLine{220 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{221 \textcolor{keyword}{inline}}
\DoxyCodeLine{222 \textcolor{keywordtype}{void}}
\DoxyCodeLine{223 op\_clamp::apply\_proxy\_noalias(\mbox{\hyperlink{classCube}{Cube<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classProxyCube}{ProxyCube<T1>}}\& P, \textcolor{keyword}{const} \textcolor{keyword}{typename} T1::elem\_type min\_val, \textcolor{keyword}{const} \textcolor{keyword}{typename} T1::elem\_type max\_val)}
\DoxyCodeLine{224   \{}
\DoxyCodeLine{225   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{226   }
\DoxyCodeLine{227   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{228   }
\DoxyCodeLine{229   \textcolor{keyword}{const} uword n\_rows   = P.get\_n\_rows();}
\DoxyCodeLine{230   \textcolor{keyword}{const} uword n\_cols   = P.get\_n\_cols();}
\DoxyCodeLine{231   \textcolor{keyword}{const} uword n\_slices = P.get\_n\_slices();}
\DoxyCodeLine{232   }
\DoxyCodeLine{233   out.\mbox{\hyperlink{group__Cube_ga0d461586030945472fe66f7364882771}{set\_size}}(n\_rows, n\_cols, n\_slices);}
\DoxyCodeLine{234   }
\DoxyCodeLine{235   eT* out\_mem = out.\mbox{\hyperlink{group__Cube_ga5b00237224a8e3bfb05728de7c962f85}{memptr}}();}
\DoxyCodeLine{236   }
\DoxyCodeLine{237   \textcolor{keywordflow}{if}(\mbox{\hyperlink{classProxyCube}{ProxyCube<T1>::use\_at}} == \textcolor{keyword}{false})}
\DoxyCodeLine{238     \{}
\DoxyCodeLine{239     \textcolor{keyword}{const} uword N = P.get\_n\_elem();}
\DoxyCodeLine{240     }
\DoxyCodeLine{241     \textcolor{keyword}{typename} \mbox{\hyperlink{classProxyCube}{ProxyCube<T1>::ea\_type}} \mbox{\hyperlink{structA}{A}} = P.get\_ea();}
\DoxyCodeLine{242     }
\DoxyCodeLine{243     \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)}
\DoxyCodeLine{244       \{}
\DoxyCodeLine{245       \textcolor{keyword}{const} eT val = \mbox{\hyperlink{structA}{A}}[i];}
\DoxyCodeLine{246       }
\DoxyCodeLine{247       out\_mem[i] = (val < min\_val) ? min\_val : ((val > max\_val) ? max\_val : val);}
\DoxyCodeLine{248       \}}
\DoxyCodeLine{249     \}}
\DoxyCodeLine{250   \textcolor{keywordflow}{else}}
\DoxyCodeLine{251     \{}
\DoxyCodeLine{252     \textcolor{keywordflow}{for}(uword s=0; s < n\_slices; ++s)}
\DoxyCodeLine{253     \textcolor{keywordflow}{for}(uword c=0; c < n\_cols;   ++c)}
\DoxyCodeLine{254     \textcolor{keywordflow}{for}(uword r=0; r < n\_rows;   ++r)}
\DoxyCodeLine{255       \{}
\DoxyCodeLine{256       \textcolor{keyword}{const} eT val = P.at(r,c,s);}
\DoxyCodeLine{257       }
\DoxyCodeLine{258       (*out\_mem) = (val < min\_val) ? min\_val : ((val > max\_val) ? max\_val : val);}
\DoxyCodeLine{259       }
\DoxyCodeLine{260       out\_mem++;}
\DoxyCodeLine{261       \}}
\DoxyCodeLine{262     \}}
\DoxyCodeLine{263   \}}
\DoxyCodeLine{264 }
\DoxyCodeLine{265 }
\DoxyCodeLine{266 }
\DoxyCodeLine{267 \textcolor{comment}{//}}
\DoxyCodeLine{268 }
\DoxyCodeLine{269 }
\DoxyCodeLine{270 }
\DoxyCodeLine{271 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{272 \textcolor{keyword}{inline}}
\DoxyCodeLine{273 \textcolor{keywordtype}{void}}
\DoxyCodeLine{274 op\_clamp\_cx::apply(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classmtOp}{mtOp<typename T1::elem\_type, T1, op\_clamp\_cx>}}\& in)}
\DoxyCodeLine{275   \{}
\DoxyCodeLine{276   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{277   }
\DoxyCodeLine{278   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{279   }
\DoxyCodeLine{280   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__Mat}{is\_Mat<T1>::value}})}
\DoxyCodeLine{281     \{}
\DoxyCodeLine{282     \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap}{unwrap<T1>}} U(in.\mbox{\hyperlink{classmtOp_a36bff6e38e68a900a5d4f1443d7f6dc2}{m}});}
\DoxyCodeLine{283     }
\DoxyCodeLine{284     op\_clamp\_cx::apply\_direct(out, U.M, in.\mbox{\hyperlink{classmtOp_aa4033d0fc3f9eab453fb0565977d9fc8}{aux}}, in.\mbox{\hyperlink{classmtOp_ae4971a90218630622fa8e07c4f7df6b9}{aux\_out\_eT}});}
\DoxyCodeLine{285     \}}
\DoxyCodeLine{286   \textcolor{keywordflow}{else}}
\DoxyCodeLine{287     \{}
\DoxyCodeLine{288     \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} P(in.\mbox{\hyperlink{classmtOp_a36bff6e38e68a900a5d4f1443d7f6dc2}{m}});}
\DoxyCodeLine{289     }
\DoxyCodeLine{290     \textcolor{keywordflow}{if}(P.is\_alias(out))}
\DoxyCodeLine{291       \{}
\DoxyCodeLine{292       \mbox{\hyperlink{classMat}{Mat<eT>}} tmp;}
\DoxyCodeLine{293       }
\DoxyCodeLine{294       op\_clamp\_cx::apply\_proxy\_noalias(tmp, P, in.\mbox{\hyperlink{classmtOp_aa4033d0fc3f9eab453fb0565977d9fc8}{aux}}, in.\mbox{\hyperlink{classmtOp_ae4971a90218630622fa8e07c4f7df6b9}{aux\_out\_eT}});}
\DoxyCodeLine{295       }
\DoxyCodeLine{296       out.\mbox{\hyperlink{group__Mat_gaff06a75771f96605f7cc4f8c6b3fceb7}{steal\_mem}}(tmp);}
\DoxyCodeLine{297       \}}
\DoxyCodeLine{298     \textcolor{keywordflow}{else}}
\DoxyCodeLine{299       \{}
\DoxyCodeLine{300       op\_clamp\_cx::apply\_proxy\_noalias(out, P, in.\mbox{\hyperlink{classmtOp_aa4033d0fc3f9eab453fb0565977d9fc8}{aux}}, in.\mbox{\hyperlink{classmtOp_ae4971a90218630622fa8e07c4f7df6b9}{aux\_out\_eT}});}
\DoxyCodeLine{301       \}}
\DoxyCodeLine{302     \}}
\DoxyCodeLine{303   \}}
\DoxyCodeLine{304 }
\DoxyCodeLine{305 }
\DoxyCodeLine{306 }
\DoxyCodeLine{307 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{308 \textcolor{keyword}{inline}}
\DoxyCodeLine{309 \textcolor{keywordtype}{void}}
\DoxyCodeLine{310 op\_clamp\_cx::apply\_direct(\mbox{\hyperlink{classMat}{Mat<eT>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X, \textcolor{keyword}{const} eT min\_val, \textcolor{keyword}{const} eT max\_val)}
\DoxyCodeLine{311   \{}
\DoxyCodeLine{312   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{313   }
\DoxyCodeLine{314   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} get\_pod\_type<eT>::result T;}
\DoxyCodeLine{315   }
\DoxyCodeLine{316   \textcolor{keyword}{const} T min\_val\_real = std::real(min\_val);}
\DoxyCodeLine{317   \textcolor{keyword}{const} T min\_val\_imag = std::imag(min\_val);}
\DoxyCodeLine{318   }
\DoxyCodeLine{319   \textcolor{keyword}{const} T max\_val\_real = std::real(max\_val);}
\DoxyCodeLine{320   \textcolor{keyword}{const} T max\_val\_imag = std::imag(max\_val);}
\DoxyCodeLine{321   }
\DoxyCodeLine{322   arma\_debug\_check( (min\_val\_real > max\_val\_real), \textcolor{stringliteral}{"{}clamp(): real(min\_val) must be less than real(max\_val)"{}} );}
\DoxyCodeLine{323   arma\_debug\_check( (min\_val\_imag > max\_val\_imag), \textcolor{stringliteral}{"{}clamp(): imag(min\_val) must be less than imag(max\_val)"{}} );}
\DoxyCodeLine{324   }
\DoxyCodeLine{325   \textcolor{keywordflow}{if}(\&out != \&X)}
\DoxyCodeLine{326     \{}
\DoxyCodeLine{327     out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(X.n\_rows, X.n\_cols);}
\DoxyCodeLine{328     }
\DoxyCodeLine{329     \textcolor{keyword}{const} uword N = out.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}};}
\DoxyCodeLine{330     }
\DoxyCodeLine{331     \textcolor{keyword}{const} eT*   X\_mem =   X.memptr();}
\DoxyCodeLine{332           eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{333     }
\DoxyCodeLine{334     \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)}
\DoxyCodeLine{335       \{}
\DoxyCodeLine{336       \textcolor{keyword}{const} eT\& X\_val = X\_mem[i];}
\DoxyCodeLine{337       }
\DoxyCodeLine{338       T val\_real = std::real(X\_val);}
\DoxyCodeLine{339       T val\_imag = std::imag(X\_val);}
\DoxyCodeLine{340       }
\DoxyCodeLine{341       val\_real = (val\_real < min\_val\_real) ? min\_val\_real : ((val\_real > max\_val\_real) ? max\_val\_real : val\_real);}
\DoxyCodeLine{342       val\_imag = (val\_imag < min\_val\_imag) ? min\_val\_imag : ((val\_imag > max\_val\_imag) ? max\_val\_imag : val\_imag);}
\DoxyCodeLine{343       }
\DoxyCodeLine{344       out\_mem[i] = std::complex<T>(val\_real,val\_imag);}
\DoxyCodeLine{345       \}}
\DoxyCodeLine{346     \}}
\DoxyCodeLine{347   \textcolor{keywordflow}{else}}
\DoxyCodeLine{348     \{}
\DoxyCodeLine{349     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}op\_clamp\_cx::apply\_direct(): inplace operation"{}});}
\DoxyCodeLine{350     }
\DoxyCodeLine{351     arrayops::clamp(out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), out.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}}, min\_val, max\_val);}
\DoxyCodeLine{352     \}}
\DoxyCodeLine{353   \}}
\DoxyCodeLine{354 }
\DoxyCodeLine{355 }
\DoxyCodeLine{356 }
\DoxyCodeLine{357 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{358 \textcolor{keyword}{inline}}
\DoxyCodeLine{359 \textcolor{keywordtype}{void}}
\DoxyCodeLine{360 op\_clamp\_cx::apply\_proxy\_noalias(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}}\& P, \textcolor{keyword}{const} \textcolor{keyword}{typename} T1::elem\_type min\_val, \textcolor{keyword}{const} \textcolor{keyword}{typename} T1::elem\_type max\_val)}
\DoxyCodeLine{361   \{}
\DoxyCodeLine{362   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{363   }
\DoxyCodeLine{364   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{365   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type   T;}
\DoxyCodeLine{366   }
\DoxyCodeLine{367   \textcolor{keyword}{const} T min\_val\_real = std::real(min\_val);}
\DoxyCodeLine{368   \textcolor{keyword}{const} T min\_val\_imag = std::imag(min\_val);}
\DoxyCodeLine{369   }
\DoxyCodeLine{370   \textcolor{keyword}{const} T max\_val\_real = std::real(max\_val);}
\DoxyCodeLine{371   \textcolor{keyword}{const} T max\_val\_imag = std::imag(max\_val);}
\DoxyCodeLine{372   }
\DoxyCodeLine{373   arma\_debug\_check( (min\_val\_real > max\_val\_real), \textcolor{stringliteral}{"{}clamp(): real(min\_val) must be less than real(max\_val)"{}} );}
\DoxyCodeLine{374   arma\_debug\_check( (min\_val\_imag > max\_val\_imag), \textcolor{stringliteral}{"{}clamp(): imag(min\_val) must be less than imag(max\_val)"{}} );}
\DoxyCodeLine{375   }
\DoxyCodeLine{376   \textcolor{keyword}{const} uword n\_rows = P.get\_n\_rows();}
\DoxyCodeLine{377   \textcolor{keyword}{const} uword n\_cols = P.get\_n\_cols();}
\DoxyCodeLine{378   }
\DoxyCodeLine{379   out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(n\_rows, n\_cols);}
\DoxyCodeLine{380   }
\DoxyCodeLine{381   eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{382   }
\DoxyCodeLine{383   \textcolor{keywordflow}{if}(\mbox{\hyperlink{classProxy}{Proxy<T1>::use\_at}} == \textcolor{keyword}{false})}
\DoxyCodeLine{384     \{}
\DoxyCodeLine{385     \textcolor{keyword}{const} uword N = P.get\_n\_elem();}
\DoxyCodeLine{386     }
\DoxyCodeLine{387     \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::ea\_type}} \mbox{\hyperlink{structA}{A}} = P.get\_ea();}
\DoxyCodeLine{388     }
\DoxyCodeLine{389     \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)}
\DoxyCodeLine{390       \{}
\DoxyCodeLine{391       T val\_real = std::real(\mbox{\hyperlink{structA}{A}}[i]);}
\DoxyCodeLine{392       T val\_imag = std::imag(\mbox{\hyperlink{structA}{A}}[i]);}
\DoxyCodeLine{393       }
\DoxyCodeLine{394       val\_real = (val\_real < min\_val\_real) ? min\_val\_real : ((val\_real > max\_val\_real) ? max\_val\_real : val\_real);}
\DoxyCodeLine{395       val\_imag = (val\_imag < min\_val\_imag) ? min\_val\_imag : ((val\_imag > max\_val\_imag) ? max\_val\_imag : val\_imag);}
\DoxyCodeLine{396       }
\DoxyCodeLine{397       out\_mem[i] = std::complex<T>(val\_real,val\_imag);}
\DoxyCodeLine{398       \}}
\DoxyCodeLine{399     \}}
\DoxyCodeLine{400   \textcolor{keywordflow}{else}}
\DoxyCodeLine{401     \{}
\DoxyCodeLine{402     \textcolor{keywordflow}{for}(uword col=0; col < n\_cols; ++col)}
\DoxyCodeLine{403     \textcolor{keywordflow}{for}(uword row=0; row < n\_rows; ++row)}
\DoxyCodeLine{404       \{}
\DoxyCodeLine{405       \textcolor{keyword}{const} eT val = P.at(row,col);}
\DoxyCodeLine{406       }
\DoxyCodeLine{407       T val\_real = std::real(val);}
\DoxyCodeLine{408       T val\_imag = std::imag(val);}
\DoxyCodeLine{409       }
\DoxyCodeLine{410       val\_real = (val\_real < min\_val\_real) ? min\_val\_real : ((val\_real > max\_val\_real) ? max\_val\_real : val\_real);}
\DoxyCodeLine{411       val\_imag = (val\_imag < min\_val\_imag) ? min\_val\_imag : ((val\_imag > max\_val\_imag) ? max\_val\_imag : val\_imag);}
\DoxyCodeLine{412       }
\DoxyCodeLine{413       (*out\_mem) = std::complex<T>(val\_real,val\_imag);  out\_mem++;}
\DoxyCodeLine{414       \}}
\DoxyCodeLine{415     \}}
\DoxyCodeLine{416   \}}
\DoxyCodeLine{417 }
\DoxyCodeLine{418 }
\DoxyCodeLine{419 }
\DoxyCodeLine{420 \textcolor{comment}{//}}
\DoxyCodeLine{421 }
\DoxyCodeLine{422 }
\DoxyCodeLine{423 }
\DoxyCodeLine{424 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{425 \textcolor{keyword}{inline}}
\DoxyCodeLine{426 \textcolor{keywordtype}{void}}
\DoxyCodeLine{427 op\_clamp\_cx::apply(\mbox{\hyperlink{classCube}{Cube<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classmtOpCube}{mtOpCube<typename T1::elem\_type, T1, op\_clamp\_cx>}}\& in)}
\DoxyCodeLine{428   \{}
\DoxyCodeLine{429   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{430   }
\DoxyCodeLine{431   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{432   }
\DoxyCodeLine{433   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__Cube}{is\_Cube<T1>::value}})}
\DoxyCodeLine{434     \{}
\DoxyCodeLine{435     \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap__cube}{unwrap\_cube<T1>}} U(in.\mbox{\hyperlink{classmtOpCube_a138bd6382aa304713adf55d2357b220d}{m}});}
\DoxyCodeLine{436     }
\DoxyCodeLine{437     op\_clamp\_cx::apply\_direct(out, U.M, in.\mbox{\hyperlink{classmtOpCube_ac3099786a3343847511b53c97b61024f}{aux}}, in.\mbox{\hyperlink{classmtOpCube_a94c46a125bf397e4856e628ee96abdac}{aux\_out\_eT}});}
\DoxyCodeLine{438     \}}
\DoxyCodeLine{439   \textcolor{keywordflow}{else}}
\DoxyCodeLine{440     \{}
\DoxyCodeLine{441     \textcolor{keyword}{const} \mbox{\hyperlink{classProxyCube}{ProxyCube<T1>}} P(in.\mbox{\hyperlink{classmtOpCube_a138bd6382aa304713adf55d2357b220d}{m}});}
\DoxyCodeLine{442     }
\DoxyCodeLine{443     \textcolor{keywordflow}{if}(P.is\_alias(out))}
\DoxyCodeLine{444       \{}
\DoxyCodeLine{445       \mbox{\hyperlink{classCube}{Cube<eT>}} tmp;}
\DoxyCodeLine{446       }
\DoxyCodeLine{447       op\_clamp\_cx::apply\_proxy\_noalias(tmp, P, in.\mbox{\hyperlink{classmtOpCube_ac3099786a3343847511b53c97b61024f}{aux}}, in.\mbox{\hyperlink{classmtOpCube_a94c46a125bf397e4856e628ee96abdac}{aux\_out\_eT}});}
\DoxyCodeLine{448       }
\DoxyCodeLine{449       out.\mbox{\hyperlink{group__Cube_ga70006d5a49f67d35d4ae10cb6c5a681f}{steal\_mem}}(tmp);}
\DoxyCodeLine{450       \}}
\DoxyCodeLine{451     \textcolor{keywordflow}{else}}
\DoxyCodeLine{452       \{}
\DoxyCodeLine{453       op\_clamp\_cx::apply\_proxy\_noalias(out, P, in.\mbox{\hyperlink{classmtOpCube_ac3099786a3343847511b53c97b61024f}{aux}}, in.\mbox{\hyperlink{classmtOpCube_a94c46a125bf397e4856e628ee96abdac}{aux\_out\_eT}});}
\DoxyCodeLine{454       \}}
\DoxyCodeLine{455     \}}
\DoxyCodeLine{456   \}}
\DoxyCodeLine{457 }
\DoxyCodeLine{458 }
\DoxyCodeLine{459 }
\DoxyCodeLine{460 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{461 \textcolor{keyword}{inline}}
\DoxyCodeLine{462 \textcolor{keywordtype}{void}}
\DoxyCodeLine{463 op\_clamp\_cx::apply\_direct(\mbox{\hyperlink{classCube}{Cube<eT>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classCube}{Cube<eT>}}\& X, \textcolor{keyword}{const} eT min\_val, \textcolor{keyword}{const} eT max\_val)}
\DoxyCodeLine{464   \{}
\DoxyCodeLine{465   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{466   }
\DoxyCodeLine{467   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} get\_pod\_type<eT>::result T;}
\DoxyCodeLine{468   }
\DoxyCodeLine{469   \textcolor{keyword}{const} T min\_val\_real = std::real(min\_val);}
\DoxyCodeLine{470   \textcolor{keyword}{const} T min\_val\_imag = std::imag(min\_val);}
\DoxyCodeLine{471   }
\DoxyCodeLine{472   \textcolor{keyword}{const} T max\_val\_real = std::real(max\_val);}
\DoxyCodeLine{473   \textcolor{keyword}{const} T max\_val\_imag = std::imag(max\_val);}
\DoxyCodeLine{474   }
\DoxyCodeLine{475   arma\_debug\_check( (min\_val\_real > max\_val\_real), \textcolor{stringliteral}{"{}clamp(): real(min\_val) must be less than real(max\_val)"{}} );}
\DoxyCodeLine{476   arma\_debug\_check( (min\_val\_imag > max\_val\_imag), \textcolor{stringliteral}{"{}clamp(): imag(min\_val) must be less than imag(max\_val)"{}} );}
\DoxyCodeLine{477   }
\DoxyCodeLine{478   \textcolor{keywordflow}{if}(\&out != \&X)}
\DoxyCodeLine{479     \{}
\DoxyCodeLine{480     out.\mbox{\hyperlink{group__Cube_ga0d461586030945472fe66f7364882771}{set\_size}}(X.n\_rows, X.n\_cols, X.n\_slices);}
\DoxyCodeLine{481     }
\DoxyCodeLine{482     \textcolor{keyword}{const} uword N = out.\mbox{\hyperlink{classCube_a4903e94049fa6d9f0d62dbcbf376da96}{n\_elem}};}
\DoxyCodeLine{483     }
\DoxyCodeLine{484     \textcolor{keyword}{const} eT*   X\_mem =   X.memptr();}
\DoxyCodeLine{485           eT* out\_mem = out.\mbox{\hyperlink{group__Cube_ga5b00237224a8e3bfb05728de7c962f85}{memptr}}();}
\DoxyCodeLine{486     }
\DoxyCodeLine{487     \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)}
\DoxyCodeLine{488       \{}
\DoxyCodeLine{489       \textcolor{keyword}{const} eT\& X\_val = X\_mem[i];}
\DoxyCodeLine{490       }
\DoxyCodeLine{491       T val\_real = std::real(X\_val);}
\DoxyCodeLine{492       T val\_imag = std::imag(X\_val);}
\DoxyCodeLine{493       }
\DoxyCodeLine{494       val\_real = (val\_real < min\_val\_real) ? min\_val\_real : ((val\_real > max\_val\_real) ? max\_val\_real : val\_real);}
\DoxyCodeLine{495       val\_imag = (val\_imag < min\_val\_imag) ? min\_val\_imag : ((val\_imag > max\_val\_imag) ? max\_val\_imag : val\_imag);}
\DoxyCodeLine{496       }
\DoxyCodeLine{497       out\_mem[i] = std::complex<T>(val\_real,val\_imag);}
\DoxyCodeLine{498       \}}
\DoxyCodeLine{499     \}}
\DoxyCodeLine{500   \textcolor{keywordflow}{else}}
\DoxyCodeLine{501     \{}
\DoxyCodeLine{502     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}op\_clamp\_cx::apply\_direct(): inplace operation"{}});}
\DoxyCodeLine{503     }
\DoxyCodeLine{504     arrayops::clamp(out.\mbox{\hyperlink{group__Cube_ga5b00237224a8e3bfb05728de7c962f85}{memptr}}(), out.\mbox{\hyperlink{classCube_a4903e94049fa6d9f0d62dbcbf376da96}{n\_elem}}, min\_val, max\_val);}
\DoxyCodeLine{505     \}}
\DoxyCodeLine{506   \}}
\DoxyCodeLine{507 }
\DoxyCodeLine{508 }
\DoxyCodeLine{509 }
\DoxyCodeLine{510 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{511 \textcolor{keyword}{inline}}
\DoxyCodeLine{512 \textcolor{keywordtype}{void}}
\DoxyCodeLine{513 op\_clamp\_cx::apply\_proxy\_noalias(\mbox{\hyperlink{classCube}{Cube<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classProxyCube}{ProxyCube<T1>}}\& P, \textcolor{keyword}{const} \textcolor{keyword}{typename} T1::elem\_type min\_val, \textcolor{keyword}{const} \textcolor{keyword}{typename} T1::elem\_type max\_val)}
\DoxyCodeLine{514   \{}
\DoxyCodeLine{515   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{516   }
\DoxyCodeLine{517   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{518   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type   T;}
\DoxyCodeLine{519   }
\DoxyCodeLine{520   \textcolor{keyword}{const} T min\_val\_real = std::real(min\_val);}
\DoxyCodeLine{521   \textcolor{keyword}{const} T min\_val\_imag = std::imag(min\_val);}
\DoxyCodeLine{522   }
\DoxyCodeLine{523   \textcolor{keyword}{const} T max\_val\_real = std::real(max\_val);}
\DoxyCodeLine{524   \textcolor{keyword}{const} T max\_val\_imag = std::imag(max\_val);}
\DoxyCodeLine{525   }
\DoxyCodeLine{526   arma\_debug\_check( (min\_val\_real > max\_val\_real), \textcolor{stringliteral}{"{}clamp(): real(min\_val) must be less than real(max\_val)"{}} );}
\DoxyCodeLine{527   arma\_debug\_check( (min\_val\_imag > max\_val\_imag), \textcolor{stringliteral}{"{}clamp(): imag(min\_val) must be less than imag(max\_val)"{}} );}
\DoxyCodeLine{528   }
\DoxyCodeLine{529   \textcolor{keyword}{const} uword n\_rows   = P.get\_n\_rows();}
\DoxyCodeLine{530   \textcolor{keyword}{const} uword n\_cols   = P.get\_n\_cols();}
\DoxyCodeLine{531   \textcolor{keyword}{const} uword n\_slices = P.get\_n\_slices();}
\DoxyCodeLine{532   }
\DoxyCodeLine{533   out.\mbox{\hyperlink{group__Cube_ga0d461586030945472fe66f7364882771}{set\_size}}(n\_rows, n\_cols, n\_slices);}
\DoxyCodeLine{534   }
\DoxyCodeLine{535   eT* out\_mem = out.\mbox{\hyperlink{group__Cube_ga5b00237224a8e3bfb05728de7c962f85}{memptr}}();}
\DoxyCodeLine{536   }
\DoxyCodeLine{537   \textcolor{keywordflow}{if}(\mbox{\hyperlink{classProxyCube}{ProxyCube<T1>::use\_at}} == \textcolor{keyword}{false})}
\DoxyCodeLine{538     \{}
\DoxyCodeLine{539     \textcolor{keyword}{const} uword N = P.get\_n\_elem();}
\DoxyCodeLine{540     }
\DoxyCodeLine{541     \textcolor{keyword}{typename} \mbox{\hyperlink{classProxyCube}{ProxyCube<T1>::ea\_type}} \mbox{\hyperlink{structA}{A}} = P.get\_ea();}
\DoxyCodeLine{542     }
\DoxyCodeLine{543     \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)}
\DoxyCodeLine{544       \{}
\DoxyCodeLine{545       T val\_real = std::real(\mbox{\hyperlink{structA}{A}}[i]);}
\DoxyCodeLine{546       T val\_imag = std::imag(\mbox{\hyperlink{structA}{A}}[i]);}
\DoxyCodeLine{547       }
\DoxyCodeLine{548       val\_real = (val\_real < min\_val\_real) ? min\_val\_real : ((val\_real > max\_val\_real) ? max\_val\_real : val\_real);}
\DoxyCodeLine{549       val\_imag = (val\_imag < min\_val\_imag) ? min\_val\_imag : ((val\_imag > max\_val\_imag) ? max\_val\_imag : val\_imag);}
\DoxyCodeLine{550       }
\DoxyCodeLine{551       out\_mem[i] = std::complex<T>(val\_real,val\_imag);}
\DoxyCodeLine{552       \}}
\DoxyCodeLine{553     \}}
\DoxyCodeLine{554   \textcolor{keywordflow}{else}}
\DoxyCodeLine{555     \{}
\DoxyCodeLine{556     \textcolor{keywordflow}{for}(uword s=0; s < n\_slices; ++s)}
\DoxyCodeLine{557     \textcolor{keywordflow}{for}(uword c=0; c < n\_cols;   ++c)}
\DoxyCodeLine{558     \textcolor{keywordflow}{for}(uword r=0; r < n\_rows;   ++r)}
\DoxyCodeLine{559       \{}
\DoxyCodeLine{560       \textcolor{keyword}{const} eT val = P.at(r,c,s);}
\DoxyCodeLine{561       }
\DoxyCodeLine{562       T val\_real = std::real(val);}
\DoxyCodeLine{563       T val\_imag = std::imag(val);}
\DoxyCodeLine{564       }
\DoxyCodeLine{565       val\_real = (val\_real < min\_val\_real) ? min\_val\_real : ((val\_real > max\_val\_real) ? max\_val\_real : val\_real);}
\DoxyCodeLine{566       val\_imag = (val\_imag < min\_val\_imag) ? min\_val\_imag : ((val\_imag > max\_val\_imag) ? max\_val\_imag : val\_imag);}
\DoxyCodeLine{567       }
\DoxyCodeLine{568       (*out\_mem) = std::complex<T>(val\_real,val\_imag);  out\_mem++;}
\DoxyCodeLine{569       \}}
\DoxyCodeLine{570     \}}
\DoxyCodeLine{571   \}}
\DoxyCodeLine{572 }
\DoxyCodeLine{573 }
\DoxyCodeLine{574 }

\end{DoxyCode}
