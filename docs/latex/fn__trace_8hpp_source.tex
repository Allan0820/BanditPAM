\hypertarget{fn__trace_8hpp_source}{}\doxysection{fn\+\_\+trace.\+hpp}
\label{fn__trace_8hpp_source}\index{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/fn\_trace.hpp@{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/fn\_trace.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008-\/2016 Conrad Sanderson (http://conradsanderson.id.au)}}
\DoxyCodeLine{2 \textcolor{comment}{// Copyright 2008-\/2016 National ICT Australia (NICTA)}}
\DoxyCodeLine{3 \textcolor{comment}{// }}
\DoxyCodeLine{4 \textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{5 \textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{6 \textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{7 \textcolor{comment}{// http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{8 \textcolor{comment}{// }}
\DoxyCodeLine{9 \textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{10 \textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{11 \textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{12 \textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{13 \textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{14 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{19 }
\DoxyCodeLine{20 }
\DoxyCodeLine{21 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{22 arma\_warn\_unused}
\DoxyCodeLine{23 \textcolor{keyword}{inline}}
\DoxyCodeLine{24 \textcolor{keyword}{typename} T1::elem\_type}
\DoxyCodeLine{25 \mbox{\hyperlink{group__fn__trace_ga2604bb0f64c12abb8a3577f1bde42b35}{trace}}(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::elem\_type, T1>}}\& X)}
\DoxyCodeLine{26   \{}
\DoxyCodeLine{27   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{28   }
\DoxyCodeLine{29   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{30   }
\DoxyCodeLine{31   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} P(X.get\_ref());}
\DoxyCodeLine{32   }
\DoxyCodeLine{33   \textcolor{keyword}{const} uword N = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(P.get\_n\_rows(), P.get\_n\_cols());}
\DoxyCodeLine{34   }
\DoxyCodeLine{35   eT val1 = eT(0);}
\DoxyCodeLine{36   eT val2 = eT(0);}
\DoxyCodeLine{37   }
\DoxyCodeLine{38   uword i,j;}
\DoxyCodeLine{39   \textcolor{keywordflow}{for}(i=0, j=1; j<N; i+=2, j+=2)}
\DoxyCodeLine{40     \{}
\DoxyCodeLine{41     val1 += P.at(i,i);}
\DoxyCodeLine{42     val2 += P.at(j,j);}
\DoxyCodeLine{43     \}}
\DoxyCodeLine{44   }
\DoxyCodeLine{45   \textcolor{keywordflow}{if}(i < N)}
\DoxyCodeLine{46     \{}
\DoxyCodeLine{47     val1 += P.at(i,i);}
\DoxyCodeLine{48     \}}
\DoxyCodeLine{49   }
\DoxyCodeLine{50   \textcolor{keywordflow}{return} val1 + val2;}
\DoxyCodeLine{51   \}}
\DoxyCodeLine{52 }
\DoxyCodeLine{53 }
\DoxyCodeLine{54 }
\DoxyCodeLine{55 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{56 arma\_warn\_unused}
\DoxyCodeLine{57 \textcolor{keyword}{inline}}
\DoxyCodeLine{58 \textcolor{keyword}{typename} T1::elem\_type}
\DoxyCodeLine{59 \mbox{\hyperlink{group__fn__trace_ga2604bb0f64c12abb8a3577f1bde42b35}{trace}}(\textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T1, op\_diagmat>}}\& X)}
\DoxyCodeLine{60   \{}
\DoxyCodeLine{61   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{62   }
\DoxyCodeLine{63   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{64   }
\DoxyCodeLine{65   \textcolor{keyword}{const} \mbox{\hyperlink{classdiagmat__proxy}{diagmat\_proxy<T1>}} \mbox{\hyperlink{structA}{A}}(X.m);}
\DoxyCodeLine{66   }
\DoxyCodeLine{67   \textcolor{keyword}{const} uword N = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{68   }
\DoxyCodeLine{69   eT val = eT(0);}
\DoxyCodeLine{70   }
\DoxyCodeLine{71   \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)}
\DoxyCodeLine{72     \{}
\DoxyCodeLine{73     val += \mbox{\hyperlink{structA}{A}}[i];}
\DoxyCodeLine{74     \}}
\DoxyCodeLine{75   }
\DoxyCodeLine{76   \textcolor{keywordflow}{return} val;}
\DoxyCodeLine{77   \}}
\DoxyCodeLine{78 }
\DoxyCodeLine{79 }
\DoxyCodeLine{80 }
\DoxyCodeLine{82 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{83 arma\_warn\_unused}
\DoxyCodeLine{84 \textcolor{keyword}{inline}}
\DoxyCodeLine{85 \textcolor{keyword}{typename} \mbox{\hyperlink{structenable__if2}{enable\_if2< is\_cx<typename T1::elem\_type>::no}}, \textcolor{keyword}{typename} T1::elem\_type>::result}
\DoxyCodeLine{86 \mbox{\hyperlink{group__fn__trace_ga2604bb0f64c12abb8a3577f1bde42b35}{trace}}(\textcolor{keyword}{const} \mbox{\hyperlink{classGlue}{Glue<T1, T2, glue\_times>}}\& X)}
\DoxyCodeLine{87   \{}
\DoxyCodeLine{88   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{89   }
\DoxyCodeLine{90   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{91   }
\DoxyCodeLine{92   \textcolor{keyword}{const} \mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T1>}} tmp1(X.A);}
\DoxyCodeLine{93   \textcolor{keyword}{const} \mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T2>}} tmp2(X.B);}
\DoxyCodeLine{94   }
\DoxyCodeLine{95   \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T1>::stored\_type}}\& \mbox{\hyperlink{structA}{A}} = tmp1.M;}
\DoxyCodeLine{96   \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T2>::stored\_type}}\& \mbox{\hyperlink{structB}{B}} = tmp2.M;}
\DoxyCodeLine{97   }
\DoxyCodeLine{98   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_alpha = \mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T1>::do\_times}} || \mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T2>::do\_times}};}
\DoxyCodeLine{99   \textcolor{keyword}{const} eT       alpha = use\_alpha ? (tmp1.get\_val() * tmp2.get\_val()) : eT(0);}
\DoxyCodeLine{100   }
\DoxyCodeLine{101   arma\_debug\_assert\_trans\_mul\_size< partial\_unwrap<T1>::do\_trans, \mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T2>::do\_trans}} >(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structB}{B}}.n\_rows, \mbox{\hyperlink{structB}{B}}.n\_cols, \textcolor{stringliteral}{"{}matrix multiplication"{}});}
\DoxyCodeLine{102   }
\DoxyCodeLine{103   \textcolor{keywordflow}{if}( (\mbox{\hyperlink{structA}{A}}.n\_elem == 0) || (\mbox{\hyperlink{structB}{B}}.n\_elem == 0) )}
\DoxyCodeLine{104     \{}
\DoxyCodeLine{105     \textcolor{keywordflow}{return} eT(0);}
\DoxyCodeLine{106     \}}
\DoxyCodeLine{107   }
\DoxyCodeLine{108   \textcolor{keyword}{const} uword A\_n\_rows = \mbox{\hyperlink{structA}{A}}.n\_rows;}
\DoxyCodeLine{109   \textcolor{keyword}{const} uword A\_n\_cols = \mbox{\hyperlink{structA}{A}}.n\_cols;}
\DoxyCodeLine{110 }
\DoxyCodeLine{111   \textcolor{keyword}{const} uword B\_n\_rows = \mbox{\hyperlink{structB}{B}}.n\_rows;}
\DoxyCodeLine{112   \textcolor{keyword}{const} uword B\_n\_cols = \mbox{\hyperlink{structB}{B}}.n\_cols;}
\DoxyCodeLine{113   }
\DoxyCodeLine{114   eT acc = eT(0);}
\DoxyCodeLine{115   }
\DoxyCodeLine{116   \textcolor{keywordflow}{if}( (\mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T1>::do\_trans}} == \textcolor{keyword}{false}) \&\& (\mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T2>::do\_trans}} == \textcolor{keyword}{false}) )}
\DoxyCodeLine{117     \{}
\DoxyCodeLine{118     \textcolor{keyword}{const} uword N = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(A\_n\_rows, B\_n\_cols);}
\DoxyCodeLine{119     }
\DoxyCodeLine{120     eT acc1 = eT(0);}
\DoxyCodeLine{121     eT acc2 = eT(0);}
\DoxyCodeLine{122     }
\DoxyCodeLine{123     \textcolor{keywordflow}{for}(uword k=0; k < N; ++k)}
\DoxyCodeLine{124       \{}
\DoxyCodeLine{125       \textcolor{keyword}{const} eT* B\_colptr = \mbox{\hyperlink{structB}{B}}.colptr(k);}
\DoxyCodeLine{126       }
\DoxyCodeLine{127       \textcolor{comment}{// condition: A\_n\_cols = B\_n\_rows}}
\DoxyCodeLine{128       }
\DoxyCodeLine{129       uword j;}
\DoxyCodeLine{130       }
\DoxyCodeLine{131       \textcolor{keywordflow}{for}(j=1; j < A\_n\_cols; j+=2)}
\DoxyCodeLine{132         \{}
\DoxyCodeLine{133         \textcolor{keyword}{const} uword i = (j-\/1);}
\DoxyCodeLine{134         }
\DoxyCodeLine{135         \textcolor{keyword}{const} eT tmp\_i = B\_colptr[i];}
\DoxyCodeLine{136         \textcolor{keyword}{const} eT tmp\_j = B\_colptr[j];}
\DoxyCodeLine{137         }
\DoxyCodeLine{138         acc1 += \mbox{\hyperlink{structA}{A}}.at(k, i) * tmp\_i;}
\DoxyCodeLine{139         acc2 += \mbox{\hyperlink{structA}{A}}.at(k, j) * tmp\_j;}
\DoxyCodeLine{140         \}}
\DoxyCodeLine{141       }
\DoxyCodeLine{142       \textcolor{keyword}{const} uword i = (j-\/1);}
\DoxyCodeLine{143       }
\DoxyCodeLine{144       \textcolor{keywordflow}{if}(i < A\_n\_cols)}
\DoxyCodeLine{145         \{}
\DoxyCodeLine{146         acc1 += \mbox{\hyperlink{structA}{A}}.at(k, i) * B\_colptr[i];}
\DoxyCodeLine{147         \}}
\DoxyCodeLine{148       \}}
\DoxyCodeLine{149       }
\DoxyCodeLine{150     acc = (acc1 + acc2);}
\DoxyCodeLine{151     \}}
\DoxyCodeLine{152   \textcolor{keywordflow}{else}}
\DoxyCodeLine{153   \textcolor{keywordflow}{if}( (\mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T1>::do\_trans}} == \textcolor{keyword}{true} ) \&\& (\mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T2>::do\_trans}} == \textcolor{keyword}{false}) )}
\DoxyCodeLine{154     \{}
\DoxyCodeLine{155     \textcolor{keyword}{const} uword N = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(A\_n\_cols, B\_n\_cols);}
\DoxyCodeLine{156     }
\DoxyCodeLine{157     \textcolor{keywordflow}{for}(uword k=0; k < N; ++k)}
\DoxyCodeLine{158       \{}
\DoxyCodeLine{159       \textcolor{keyword}{const} eT* A\_colptr = \mbox{\hyperlink{structA}{A}}.colptr(k);}
\DoxyCodeLine{160       \textcolor{keyword}{const} eT* B\_colptr = \mbox{\hyperlink{structB}{B}}.colptr(k);}
\DoxyCodeLine{161       }
\DoxyCodeLine{162       \textcolor{comment}{// condition: A\_n\_rows = B\_n\_rows}}
\DoxyCodeLine{163       acc += \mbox{\hyperlink{group__op__dot_gafcc9d4848f5791b21d9a4c755baa6440}{op\_dot::direct\_dot}}(A\_n\_rows, A\_colptr, B\_colptr);}
\DoxyCodeLine{164       \}}
\DoxyCodeLine{165     \}}
\DoxyCodeLine{166   \textcolor{keywordflow}{else}}
\DoxyCodeLine{167   \textcolor{keywordflow}{if}( (\mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T1>::do\_trans}} == \textcolor{keyword}{false}) \&\& (\mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T2>::do\_trans}} == \textcolor{keyword}{true} ) )}
\DoxyCodeLine{168     \{}
\DoxyCodeLine{169     \textcolor{keyword}{const} uword N = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(A\_n\_rows, B\_n\_rows);}
\DoxyCodeLine{170     }
\DoxyCodeLine{171     \textcolor{keywordflow}{for}(uword k=0; k < N; ++k)}
\DoxyCodeLine{172       \{}
\DoxyCodeLine{173       \textcolor{comment}{// condition: A\_n\_cols = B\_n\_cols}}
\DoxyCodeLine{174       \textcolor{keywordflow}{for}(uword i=0; i < A\_n\_cols; ++i)}
\DoxyCodeLine{175         \{}
\DoxyCodeLine{176         acc += \mbox{\hyperlink{structA}{A}}.at(k,i) * \mbox{\hyperlink{structB}{B}}.at(k,i);}
\DoxyCodeLine{177         \}}
\DoxyCodeLine{178       \}}
\DoxyCodeLine{179     \}}
\DoxyCodeLine{180   \textcolor{keywordflow}{else}}
\DoxyCodeLine{181   \textcolor{keywordflow}{if}( (\mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T1>::do\_trans}} == \textcolor{keyword}{true} ) \&\& (\mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T2>::do\_trans}} == true ) )}
\DoxyCodeLine{182     \{}
\DoxyCodeLine{183     \textcolor{keyword}{const} uword N = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(A\_n\_cols, B\_n\_rows);}
\DoxyCodeLine{184     }
\DoxyCodeLine{185     \textcolor{keywordflow}{for}(uword k=0; k < N; ++k)}
\DoxyCodeLine{186       \{}
\DoxyCodeLine{187       \textcolor{keyword}{const} eT* A\_colptr = \mbox{\hyperlink{structA}{A}}.colptr(k);}
\DoxyCodeLine{188       }
\DoxyCodeLine{189       \textcolor{comment}{// condition: A\_n\_rows = B\_n\_cols}}
\DoxyCodeLine{190       \textcolor{keywordflow}{for}(uword i=0; i < A\_n\_rows; ++i)}
\DoxyCodeLine{191         \{}
\DoxyCodeLine{192         acc += A\_colptr[i] * \mbox{\hyperlink{structB}{B}}.at(k,i);}
\DoxyCodeLine{193         \}}
\DoxyCodeLine{194       \}}
\DoxyCodeLine{195     \}}
\DoxyCodeLine{196   }
\DoxyCodeLine{197   \textcolor{keywordflow}{return} (use\_alpha) ? (alpha * acc) : acc;}
\DoxyCodeLine{198   \}}
\DoxyCodeLine{199 }
\DoxyCodeLine{200 }
\DoxyCodeLine{201 }
\DoxyCodeLine{203 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{204 arma\_warn\_unused}
\DoxyCodeLine{205 \textcolor{keyword}{inline}}
\DoxyCodeLine{206 \textcolor{keyword}{typename} \mbox{\hyperlink{structenable__if2}{enable\_if2< is\_cx<typename T1::elem\_type>::yes}}, \textcolor{keyword}{typename} T1::elem\_type>::result}
\DoxyCodeLine{207 \mbox{\hyperlink{group__fn__trace_ga2604bb0f64c12abb8a3577f1bde42b35}{trace}}(\textcolor{keyword}{const} \mbox{\hyperlink{classGlue}{Glue<T1, T2, glue\_times>}}\& X)}
\DoxyCodeLine{208   \{}
\DoxyCodeLine{209   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{210   }
\DoxyCodeLine{211   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type   T;}
\DoxyCodeLine{212   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{213   }
\DoxyCodeLine{214   \textcolor{keyword}{const} \mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T1>}} tmp1(X.A);}
\DoxyCodeLine{215   \textcolor{keyword}{const} \mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T2>}} tmp2(X.B);}
\DoxyCodeLine{216   }
\DoxyCodeLine{217   \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T1>::stored\_type}}\& \mbox{\hyperlink{structA}{A}} = tmp1.M;}
\DoxyCodeLine{218   \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T2>::stored\_type}}\& \mbox{\hyperlink{structB}{B}} = tmp2.M;}
\DoxyCodeLine{219   }
\DoxyCodeLine{220   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_alpha = \mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T1>::do\_times}} || \mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T2>::do\_times}};}
\DoxyCodeLine{221   \textcolor{keyword}{const} eT       alpha = use\_alpha ? (tmp1.get\_val() * tmp2.get\_val()) : eT(0);}
\DoxyCodeLine{222   }
\DoxyCodeLine{223   arma\_debug\_assert\_trans\_mul\_size< partial\_unwrap<T1>::do\_trans, \mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T2>::do\_trans}} >(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structB}{B}}.n\_rows, \mbox{\hyperlink{structB}{B}}.n\_cols, \textcolor{stringliteral}{"{}matrix multiplication"{}});}
\DoxyCodeLine{224   }
\DoxyCodeLine{225   \textcolor{keywordflow}{if}( (\mbox{\hyperlink{structA}{A}}.n\_elem == 0) || (\mbox{\hyperlink{structB}{B}}.n\_elem == 0) )}
\DoxyCodeLine{226     \{}
\DoxyCodeLine{227     \textcolor{keywordflow}{return} eT(0);}
\DoxyCodeLine{228     \}}
\DoxyCodeLine{229   }
\DoxyCodeLine{230   \textcolor{keyword}{const} uword A\_n\_rows = \mbox{\hyperlink{structA}{A}}.n\_rows;}
\DoxyCodeLine{231   \textcolor{keyword}{const} uword A\_n\_cols = \mbox{\hyperlink{structA}{A}}.n\_cols;}
\DoxyCodeLine{232   }
\DoxyCodeLine{233   \textcolor{keyword}{const} uword B\_n\_rows = \mbox{\hyperlink{structB}{B}}.n\_rows;}
\DoxyCodeLine{234   \textcolor{keyword}{const} uword B\_n\_cols = \mbox{\hyperlink{structB}{B}}.n\_cols;}
\DoxyCodeLine{235   }
\DoxyCodeLine{236   eT acc = eT(0);}
\DoxyCodeLine{237   }
\DoxyCodeLine{238   \textcolor{keywordflow}{if}( (\mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T1>::do\_trans}} == \textcolor{keyword}{false}) \&\& (\mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T2>::do\_trans}} == \textcolor{keyword}{false}) )}
\DoxyCodeLine{239     \{}
\DoxyCodeLine{240     \textcolor{keyword}{const} uword N = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(A\_n\_rows, B\_n\_cols);}
\DoxyCodeLine{241     }
\DoxyCodeLine{242     T acc\_real = T(0);}
\DoxyCodeLine{243     T acc\_imag = T(0);}
\DoxyCodeLine{244     }
\DoxyCodeLine{245     \textcolor{keywordflow}{for}(uword k=0; k < N; ++k)}
\DoxyCodeLine{246       \{}
\DoxyCodeLine{247       \textcolor{keyword}{const} eT* B\_colptr = \mbox{\hyperlink{structB}{B}}.colptr(k);}
\DoxyCodeLine{248       }
\DoxyCodeLine{249       \textcolor{comment}{// condition: A\_n\_cols = B\_n\_rows}}
\DoxyCodeLine{250       }
\DoxyCodeLine{251       \textcolor{keywordflow}{for}(uword i=0; i < A\_n\_cols; ++i)}
\DoxyCodeLine{252         \{}
\DoxyCodeLine{253         \textcolor{comment}{// acc += A.at(k, i) * B\_colptr[i];}}
\DoxyCodeLine{254         }
\DoxyCodeLine{255         \textcolor{keyword}{const} std::complex<T>\& xx = \mbox{\hyperlink{structA}{A}}.at(k, i);}
\DoxyCodeLine{256         \textcolor{keyword}{const} std::complex<T>\& yy = B\_colptr[i];}
\DoxyCodeLine{257         }
\DoxyCodeLine{258         \textcolor{keyword}{const} T a = xx.real();}
\DoxyCodeLine{259         \textcolor{keyword}{const} T b = xx.imag();}
\DoxyCodeLine{260         }
\DoxyCodeLine{261         \textcolor{keyword}{const} T c = yy.real();}
\DoxyCodeLine{262         \textcolor{keyword}{const} T d = yy.imag();}
\DoxyCodeLine{263         }
\DoxyCodeLine{264         acc\_real += (a*c) -\/ (b*d);}
\DoxyCodeLine{265         acc\_imag += (a*d) + (b*c);}
\DoxyCodeLine{266         \}}
\DoxyCodeLine{267       \}}
\DoxyCodeLine{268     }
\DoxyCodeLine{269     acc = std::complex<T>(acc\_real, acc\_imag);}
\DoxyCodeLine{270     \}}
\DoxyCodeLine{271   \textcolor{keywordflow}{else}}
\DoxyCodeLine{272   \textcolor{keywordflow}{if}( (\mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T1>::do\_trans}} == \textcolor{keyword}{true}) \&\& (\mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T2>::do\_trans}} == \textcolor{keyword}{false}) )}
\DoxyCodeLine{273     \{}
\DoxyCodeLine{274     \textcolor{keyword}{const} uword N = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(A\_n\_cols, B\_n\_cols);}
\DoxyCodeLine{275     }
\DoxyCodeLine{276     T acc\_real = T(0);}
\DoxyCodeLine{277     T acc\_imag = T(0);}
\DoxyCodeLine{278     }
\DoxyCodeLine{279     \textcolor{keywordflow}{for}(uword k=0; k < N; ++k)}
\DoxyCodeLine{280       \{}
\DoxyCodeLine{281       \textcolor{keyword}{const} eT* A\_colptr = \mbox{\hyperlink{structA}{A}}.colptr(k);}
\DoxyCodeLine{282       \textcolor{keyword}{const} eT* B\_colptr = \mbox{\hyperlink{structB}{B}}.colptr(k);}
\DoxyCodeLine{283       }
\DoxyCodeLine{284       \textcolor{comment}{// condition: A\_n\_rows = B\_n\_rows}}
\DoxyCodeLine{285       }
\DoxyCodeLine{286       \textcolor{keywordflow}{for}(uword i=0; i < A\_n\_rows; ++i)}
\DoxyCodeLine{287         \{}
\DoxyCodeLine{288         \textcolor{comment}{// acc += std::conj(A\_colptr[i]) * B\_colptr[i];}}
\DoxyCodeLine{289         }
\DoxyCodeLine{290         \textcolor{keyword}{const} std::complex<T>\& xx = A\_colptr[i];}
\DoxyCodeLine{291         \textcolor{keyword}{const} std::complex<T>\& yy = B\_colptr[i];}
\DoxyCodeLine{292         }
\DoxyCodeLine{293         \textcolor{keyword}{const} T a = xx.real();}
\DoxyCodeLine{294         \textcolor{keyword}{const} T b = xx.imag();}
\DoxyCodeLine{295         }
\DoxyCodeLine{296         \textcolor{keyword}{const} T c = yy.real();}
\DoxyCodeLine{297         \textcolor{keyword}{const} T d = yy.imag();}
\DoxyCodeLine{298         }
\DoxyCodeLine{299         \textcolor{comment}{// take into account the complex conjugate of xx}}
\DoxyCodeLine{300         }
\DoxyCodeLine{301         acc\_real += (a*c) + (b*d);}
\DoxyCodeLine{302         acc\_imag += (a*d) -\/ (b*c);}
\DoxyCodeLine{303         \}}
\DoxyCodeLine{304       \}}
\DoxyCodeLine{305     }
\DoxyCodeLine{306     acc = std::complex<T>(acc\_real, acc\_imag);}
\DoxyCodeLine{307     \}}
\DoxyCodeLine{308   \textcolor{keywordflow}{else}}
\DoxyCodeLine{309   \textcolor{keywordflow}{if}( (\mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T1>::do\_trans}} == \textcolor{keyword}{false}) \&\& (\mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T2>::do\_trans}} == \textcolor{keyword}{true}) )}
\DoxyCodeLine{310     \{}
\DoxyCodeLine{311     \textcolor{keyword}{const} uword N = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(A\_n\_rows, B\_n\_rows);}
\DoxyCodeLine{312     }
\DoxyCodeLine{313     T acc\_real = T(0);}
\DoxyCodeLine{314     T acc\_imag = T(0);}
\DoxyCodeLine{315     }
\DoxyCodeLine{316     \textcolor{keywordflow}{for}(uword k=0; k < N; ++k)}
\DoxyCodeLine{317       \{}
\DoxyCodeLine{318       \textcolor{comment}{// condition: A\_n\_cols = B\_n\_cols}}
\DoxyCodeLine{319       \textcolor{keywordflow}{for}(uword i=0; i < A\_n\_cols; ++i)}
\DoxyCodeLine{320         \{}
\DoxyCodeLine{321         \textcolor{comment}{// acc += A.at(k,i) * std::conj(B.at(k,i));}}
\DoxyCodeLine{322         }
\DoxyCodeLine{323         \textcolor{keyword}{const} std::complex<T>\& xx = \mbox{\hyperlink{structA}{A}}.at(k, i);}
\DoxyCodeLine{324         \textcolor{keyword}{const} std::complex<T>\& yy = \mbox{\hyperlink{structB}{B}}.at(k, i);}
\DoxyCodeLine{325         }
\DoxyCodeLine{326         \textcolor{keyword}{const} T a = xx.real();}
\DoxyCodeLine{327         \textcolor{keyword}{const} T b = xx.imag();}
\DoxyCodeLine{328         }
\DoxyCodeLine{329         \textcolor{keyword}{const} T c =  yy.real();}
\DoxyCodeLine{330         \textcolor{keyword}{const} T d = -\/yy.imag();  \textcolor{comment}{// take the conjugate}}
\DoxyCodeLine{331         }
\DoxyCodeLine{332         acc\_real += (a*c) -\/ (b*d);}
\DoxyCodeLine{333         acc\_imag += (a*d) + (b*c);}
\DoxyCodeLine{334         \}}
\DoxyCodeLine{335       \}}
\DoxyCodeLine{336     }
\DoxyCodeLine{337     acc = std::complex<T>(acc\_real, acc\_imag);}
\DoxyCodeLine{338     \}}
\DoxyCodeLine{339   \textcolor{keywordflow}{else}}
\DoxyCodeLine{340   \textcolor{keywordflow}{if}( (\mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T1>::do\_trans}} == \textcolor{keyword}{true}) \&\& (\mbox{\hyperlink{structpartial__unwrap}{partial\_unwrap<T2>::do\_trans}} == \textcolor{keyword}{true}) )}
\DoxyCodeLine{341     \{}
\DoxyCodeLine{342     \textcolor{keyword}{const} uword N = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(A\_n\_cols, B\_n\_rows);}
\DoxyCodeLine{343     }
\DoxyCodeLine{344     T acc\_real = T(0);}
\DoxyCodeLine{345     T acc\_imag = T(0);}
\DoxyCodeLine{346     }
\DoxyCodeLine{347     \textcolor{keywordflow}{for}(uword k=0; k < N; ++k)}
\DoxyCodeLine{348       \{}
\DoxyCodeLine{349       \textcolor{keyword}{const} eT* A\_colptr = \mbox{\hyperlink{structA}{A}}.colptr(k);}
\DoxyCodeLine{350       }
\DoxyCodeLine{351       \textcolor{comment}{// condition: A\_n\_rows = B\_n\_cols}}
\DoxyCodeLine{352       \textcolor{keywordflow}{for}(uword i=0; i < A\_n\_rows; ++i)}
\DoxyCodeLine{353         \{}
\DoxyCodeLine{354         \textcolor{comment}{// acc += std::conj(A\_colptr[i]) * std::conj(B.at(k,i));}}
\DoxyCodeLine{355         }
\DoxyCodeLine{356         \textcolor{keyword}{const} std::complex<T>\& xx = A\_colptr[i];}
\DoxyCodeLine{357         \textcolor{keyword}{const} std::complex<T>\& yy = \mbox{\hyperlink{structB}{B}}.at(k, i);}
\DoxyCodeLine{358         }
\DoxyCodeLine{359         \textcolor{keyword}{const} T a =  xx.real();}
\DoxyCodeLine{360         \textcolor{keyword}{const} T b = -\/xx.imag();  \textcolor{comment}{// take the conjugate}}
\DoxyCodeLine{361         }
\DoxyCodeLine{362         \textcolor{keyword}{const} T c =  yy.real();}
\DoxyCodeLine{363         \textcolor{keyword}{const} T d = -\/yy.imag();  \textcolor{comment}{// take the conjugate}}
\DoxyCodeLine{364         }
\DoxyCodeLine{365         acc\_real += (a*c) -\/ (b*d);}
\DoxyCodeLine{366         acc\_imag += (a*d) + (b*c);}
\DoxyCodeLine{367         \}}
\DoxyCodeLine{368       \}}
\DoxyCodeLine{369     }
\DoxyCodeLine{370     acc = std::complex<T>(acc\_real, acc\_imag);}
\DoxyCodeLine{371     \}}
\DoxyCodeLine{372   }
\DoxyCodeLine{373   \textcolor{keywordflow}{return} (use\_alpha) ? eT(alpha * acc) : eT(acc);}
\DoxyCodeLine{374   \}}
\DoxyCodeLine{375 }
\DoxyCodeLine{376 }
\DoxyCodeLine{377 }
\DoxyCodeLine{379 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{380 arma\_warn\_unused}
\DoxyCodeLine{381 \textcolor{keyword}{inline}}
\DoxyCodeLine{382 \textcolor{keyword}{typename} T1::elem\_type}
\DoxyCodeLine{383 \mbox{\hyperlink{group__fn__trace_ga2604bb0f64c12abb8a3577f1bde42b35}{trace}}(\textcolor{keyword}{const} \mbox{\hyperlink{structSpBase}{SpBase<typename T1::elem\_type,T1>}}\& expr)}
\DoxyCodeLine{384   \{}
\DoxyCodeLine{385   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{386   }
\DoxyCodeLine{387   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{388   }
\DoxyCodeLine{389   \textcolor{keyword}{const} \mbox{\hyperlink{classSpProxy}{SpProxy<T1>}} P(expr.get\_ref());}
\DoxyCodeLine{390   }
\DoxyCodeLine{391   \textcolor{keyword}{const} uword N = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(P.get\_n\_rows(), P.get\_n\_cols());}
\DoxyCodeLine{392   }
\DoxyCodeLine{393   eT acc = eT(0);}
\DoxyCodeLine{394   }
\DoxyCodeLine{395   \textcolor{keywordflow}{if}( (\mbox{\hyperlink{structis__SpMat}{is\_SpMat}}<\textcolor{keyword}{typename} \mbox{\hyperlink{classSpProxy}{SpProxy<T1>::stored\_type}}>::value) \&\& (P.get\_n\_nonzero() >= 5*N) )}
\DoxyCodeLine{396     \{}
\DoxyCodeLine{397     \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap__spmat}{unwrap\_spmat<typename SpProxy<T1>::stored\_type}}> U(P.Q);}
\DoxyCodeLine{398     }
\DoxyCodeLine{399     \textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& X = U.M;}
\DoxyCodeLine{400     }
\DoxyCodeLine{401     \textcolor{keywordflow}{for}(uword i=0; i < N; ++i)}
\DoxyCodeLine{402       \{}
\DoxyCodeLine{403       acc += X.at(i,i);  \textcolor{comment}{// use binary search}}
\DoxyCodeLine{404       \}}
\DoxyCodeLine{405     \}}
\DoxyCodeLine{406   \textcolor{keywordflow}{else}}
\DoxyCodeLine{407     \{}
\DoxyCodeLine{408     \textcolor{keyword}{typename} \mbox{\hyperlink{classSpProxy}{SpProxy<T1>::const\_iterator\_type}} it = P.begin();}
\DoxyCodeLine{409     }
\DoxyCodeLine{410     \textcolor{keyword}{const} uword P\_n\_nz = P.get\_n\_nonzero();}
\DoxyCodeLine{411     }
\DoxyCodeLine{412     \textcolor{keywordflow}{for}(uword i=0; i < P\_n\_nz; ++i)}
\DoxyCodeLine{413       \{}
\DoxyCodeLine{414       \textcolor{keywordflow}{if}(it.row() == it.col())  \{ acc += (*it); \}}
\DoxyCodeLine{415       }
\DoxyCodeLine{416       ++it;}
\DoxyCodeLine{417       \}}
\DoxyCodeLine{418     \}}
\DoxyCodeLine{419   }
\DoxyCodeLine{420   \textcolor{keywordflow}{return} acc;}
\DoxyCodeLine{421   \}}
\DoxyCodeLine{422 }
\DoxyCodeLine{423 }
\DoxyCodeLine{424 }
\DoxyCodeLine{426 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{427 arma\_warn\_unused}
\DoxyCodeLine{428 \textcolor{keyword}{inline}}
\DoxyCodeLine{429 \textcolor{keyword}{typename} T1::elem\_type}
\DoxyCodeLine{430 \mbox{\hyperlink{group__fn__trace_ga2604bb0f64c12abb8a3577f1bde42b35}{trace}}(\textcolor{keyword}{const} \mbox{\hyperlink{classSpGlue}{SpGlue<T1, T2, spglue\_plus>}}\& expr)}
\DoxyCodeLine{431   \{}
\DoxyCodeLine{432   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{433   }
\DoxyCodeLine{434   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap__spmat}{unwrap\_spmat<T1>}} UA(expr.\mbox{\hyperlink{classSpGlue_a9ed0576165e8a3f183d911e489019d2a}{A}});}
\DoxyCodeLine{435   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap__spmat}{unwrap\_spmat<T2>}} UB(expr.\mbox{\hyperlink{classSpGlue_a714444ca62a6511c4b59d53539e45556}{B}});}
\DoxyCodeLine{436   }
\DoxyCodeLine{437   arma\_debug\_assert\_same\_size(UA.M.n\_rows, UA.M.n\_cols, UB.M.n\_rows, UB.M.n\_cols, \textcolor{stringliteral}{"{}addition"{}});}
\DoxyCodeLine{438   }
\DoxyCodeLine{439   \textcolor{keywordflow}{return} (\mbox{\hyperlink{group__fn__trace_ga2604bb0f64c12abb8a3577f1bde42b35}{trace}}(UA.M) + \mbox{\hyperlink{group__fn__trace_ga2604bb0f64c12abb8a3577f1bde42b35}{trace}}(UB.M));}
\DoxyCodeLine{440   \}}
\DoxyCodeLine{441 }
\DoxyCodeLine{442 }
\DoxyCodeLine{443 }
\DoxyCodeLine{445 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{446 arma\_warn\_unused}
\DoxyCodeLine{447 \textcolor{keyword}{inline}}
\DoxyCodeLine{448 \textcolor{keyword}{typename} T1::elem\_type}
\DoxyCodeLine{449 \mbox{\hyperlink{group__fn__trace_ga2604bb0f64c12abb8a3577f1bde42b35}{trace}}(\textcolor{keyword}{const} \mbox{\hyperlink{classSpGlue}{SpGlue<T1, T2, spglue\_minus>}}\& expr)}
\DoxyCodeLine{450   \{}
\DoxyCodeLine{451   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{452   }
\DoxyCodeLine{453   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap__spmat}{unwrap\_spmat<T1>}} UA(expr.\mbox{\hyperlink{classSpGlue_a9ed0576165e8a3f183d911e489019d2a}{A}});}
\DoxyCodeLine{454   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap__spmat}{unwrap\_spmat<T2>}} UB(expr.\mbox{\hyperlink{classSpGlue_a714444ca62a6511c4b59d53539e45556}{B}});}
\DoxyCodeLine{455   }
\DoxyCodeLine{456   arma\_debug\_assert\_same\_size(UA.M.n\_rows, UA.M.n\_cols, UB.M.n\_rows, UB.M.n\_cols, \textcolor{stringliteral}{"{}subtraction"{}});}
\DoxyCodeLine{457   }
\DoxyCodeLine{458   \textcolor{keywordflow}{return} (\mbox{\hyperlink{group__fn__trace_ga2604bb0f64c12abb8a3577f1bde42b35}{trace}}(UA.M) -\/ \mbox{\hyperlink{group__fn__trace_ga2604bb0f64c12abb8a3577f1bde42b35}{trace}}(UB.M));}
\DoxyCodeLine{459   \}}
\DoxyCodeLine{460 }
\DoxyCodeLine{461 }
\DoxyCodeLine{462 }
\DoxyCodeLine{464 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{465 arma\_warn\_unused}
\DoxyCodeLine{466 \textcolor{keyword}{inline}}
\DoxyCodeLine{467 \textcolor{keyword}{typename} T1::elem\_type}
\DoxyCodeLine{468 \mbox{\hyperlink{group__fn__trace_ga2604bb0f64c12abb8a3577f1bde42b35}{trace}}(\textcolor{keyword}{const} \mbox{\hyperlink{classSpGlue}{SpGlue<T1, T2, spglue\_schur>}}\& expr)}
\DoxyCodeLine{469   \{}
\DoxyCodeLine{470   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{471   }
\DoxyCodeLine{472   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{473   }
\DoxyCodeLine{474   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap__spmat}{unwrap\_spmat<T1>}} UA(expr.\mbox{\hyperlink{classSpGlue_a9ed0576165e8a3f183d911e489019d2a}{A}});}
\DoxyCodeLine{475   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap__spmat}{unwrap\_spmat<T2>}} UB(expr.\mbox{\hyperlink{classSpGlue_a714444ca62a6511c4b59d53539e45556}{B}});}
\DoxyCodeLine{476   }
\DoxyCodeLine{477   \textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& \mbox{\hyperlink{structA}{A}} = UA.M;}
\DoxyCodeLine{478   \textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& \mbox{\hyperlink{structB}{B}} = UB.M;}
\DoxyCodeLine{479   }
\DoxyCodeLine{480   arma\_debug\_assert\_same\_size(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structB}{B}}.n\_rows, \mbox{\hyperlink{structB}{B}}.n\_cols, \textcolor{stringliteral}{"{}element-\/wise multiplication"{}});}
\DoxyCodeLine{481   }
\DoxyCodeLine{482   \textcolor{keyword}{const} uword N = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{483   }
\DoxyCodeLine{484   eT acc = eT(0);}
\DoxyCodeLine{485   }
\DoxyCodeLine{486   \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)}
\DoxyCodeLine{487     \{}
\DoxyCodeLine{488     acc += \mbox{\hyperlink{structA}{A}}.at(i,i) * \mbox{\hyperlink{structB}{B}}.at(i,i);}
\DoxyCodeLine{489     \}}
\DoxyCodeLine{490   }
\DoxyCodeLine{491   \textcolor{keywordflow}{return} acc;}
\DoxyCodeLine{492   \}}
\DoxyCodeLine{493 }
\DoxyCodeLine{494 }
\DoxyCodeLine{495 }
\DoxyCodeLine{497 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{498 arma\_warn\_unused}
\DoxyCodeLine{499 \textcolor{keyword}{inline}}
\DoxyCodeLine{500 \textcolor{keyword}{typename} T1::elem\_type}
\DoxyCodeLine{501 \mbox{\hyperlink{group__fn__trace_ga2604bb0f64c12abb8a3577f1bde42b35}{trace}}(\textcolor{keyword}{const} \mbox{\hyperlink{classSpGlue}{SpGlue<T1, T2, spglue\_times>}}\& expr)}
\DoxyCodeLine{502   \{}
\DoxyCodeLine{503   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{504   }
\DoxyCodeLine{505   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{506   }
\DoxyCodeLine{507   \textcolor{comment}{// better-\/than-\/nothing implementation}}
\DoxyCodeLine{508   }
\DoxyCodeLine{509   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap__spmat}{unwrap\_spmat<T1>}} UA(expr.\mbox{\hyperlink{classSpGlue_a9ed0576165e8a3f183d911e489019d2a}{A}});}
\DoxyCodeLine{510   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap__spmat}{unwrap\_spmat<T2>}} UB(expr.\mbox{\hyperlink{classSpGlue_a714444ca62a6511c4b59d53539e45556}{B}});}
\DoxyCodeLine{511   }
\DoxyCodeLine{512   \textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& \mbox{\hyperlink{structA}{A}} = UA.M;}
\DoxyCodeLine{513   \textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& \mbox{\hyperlink{structB}{B}} = UB.M;}
\DoxyCodeLine{514   }
\DoxyCodeLine{515   arma\_debug\_assert\_mul\_size(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structB}{B}}.n\_rows, \mbox{\hyperlink{structB}{B}}.n\_cols, \textcolor{stringliteral}{"{}matrix multiplication"{}});}
\DoxyCodeLine{516   }
\DoxyCodeLine{517   \textcolor{keywordflow}{if}( (\mbox{\hyperlink{structA}{A}}.n\_nonzero == 0) || (\mbox{\hyperlink{structB}{B}}.n\_nonzero == 0) )}
\DoxyCodeLine{518     \{}
\DoxyCodeLine{519     \textcolor{keywordflow}{return} eT(0);}
\DoxyCodeLine{520     \}}
\DoxyCodeLine{521   }
\DoxyCodeLine{522   \textcolor{keyword}{const} uword N = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{523   }
\DoxyCodeLine{524   eT acc = eT(0);}
\DoxyCodeLine{525   }
\DoxyCodeLine{526   \textcolor{comment}{// TODO: the threshold may need tuning for complex matrices}}
\DoxyCodeLine{527   \textcolor{keywordflow}{if}( (\mbox{\hyperlink{structA}{A}}.n\_nonzero >= 5*N) || (\mbox{\hyperlink{structB}{B}}.n\_nonzero >= 5*N) )}
\DoxyCodeLine{528     \{}
\DoxyCodeLine{529     \textcolor{keywordflow}{for}(uword k=0; k < N; ++k)}
\DoxyCodeLine{530       \{}
\DoxyCodeLine{531       \textcolor{keyword}{typename} \mbox{\hyperlink{classSpMat_1_1const__iterator}{SpMat<eT>::const\_col\_iterator}} B\_it     = \mbox{\hyperlink{structB}{B}}.begin\_col\_no\_sync(k);}
\DoxyCodeLine{532       \textcolor{keyword}{typename} \mbox{\hyperlink{classSpMat_1_1const__iterator}{SpMat<eT>::const\_col\_iterator}} B\_it\_end = \mbox{\hyperlink{structB}{B}}.end\_col\_no\_sync(k);}
\DoxyCodeLine{533       }
\DoxyCodeLine{534       \textcolor{keywordflow}{while}(B\_it != B\_it\_end)}
\DoxyCodeLine{535         \{}
\DoxyCodeLine{536         \textcolor{keyword}{const} eT    B\_val = (*B\_it);}
\DoxyCodeLine{537         \textcolor{keyword}{const} uword i     = B\_it.row();}
\DoxyCodeLine{538         }
\DoxyCodeLine{539         acc += \mbox{\hyperlink{structA}{A}}.at(k,i) * B\_val;}
\DoxyCodeLine{540         }
\DoxyCodeLine{541         ++B\_it;}
\DoxyCodeLine{542         \}}
\DoxyCodeLine{543       \}}
\DoxyCodeLine{544     \}}
\DoxyCodeLine{545   \textcolor{keywordflow}{else}}
\DoxyCodeLine{546     \{}
\DoxyCodeLine{547     \textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}} AB = \mbox{\hyperlink{structA}{A}} * \mbox{\hyperlink{structB}{B}};}
\DoxyCodeLine{548     }
\DoxyCodeLine{549     acc = \mbox{\hyperlink{group__fn__trace_ga2604bb0f64c12abb8a3577f1bde42b35}{trace}}(AB);}
\DoxyCodeLine{550     \}}
\DoxyCodeLine{551   }
\DoxyCodeLine{552   \textcolor{keywordflow}{return} acc;}
\DoxyCodeLine{553   \}}
\DoxyCodeLine{554 }
\DoxyCodeLine{555 }
\DoxyCodeLine{556 }
\DoxyCodeLine{558 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{559 arma\_warn\_unused}
\DoxyCodeLine{560 \textcolor{keyword}{inline}}
\DoxyCodeLine{561 \textcolor{keyword}{typename} \mbox{\hyperlink{structenable__if2}{enable\_if2< is\_cx<typename T1::elem\_type>::no}}, \textcolor{keyword}{typename} T1::elem\_type>::result}
\DoxyCodeLine{562 \mbox{\hyperlink{group__fn__trace_ga2604bb0f64c12abb8a3577f1bde42b35}{trace}}(\textcolor{keyword}{const} \mbox{\hyperlink{classSpGlue}{SpGlue}}<\mbox{\hyperlink{classSpOp}{SpOp<T1, spop\_htrans>}}, T2, \mbox{\hyperlink{classspglue__times}{spglue\_times}}>\& expr)}
\DoxyCodeLine{563   \{}
\DoxyCodeLine{564   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{565   }
\DoxyCodeLine{566   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{567   }
\DoxyCodeLine{568   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap__spmat}{unwrap\_spmat<T1>}} UA(expr.A.m);}
\DoxyCodeLine{569   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap__spmat}{unwrap\_spmat<T2>}} UB(expr.B);}
\DoxyCodeLine{570   }
\DoxyCodeLine{571   \textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& \mbox{\hyperlink{structA}{A}} = UA.M;}
\DoxyCodeLine{572   \textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& \mbox{\hyperlink{structB}{B}} = UB.M;}
\DoxyCodeLine{573   }
\DoxyCodeLine{574   \textcolor{comment}{// NOTE: deliberately swapped A.n\_rows and A.n\_cols to take into account the requested transpose operation}}
\DoxyCodeLine{575   arma\_debug\_assert\_mul\_size(\mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structB}{B}}.n\_rows, \mbox{\hyperlink{structB}{B}}.n\_cols, \textcolor{stringliteral}{"{}matrix multiplication"{}});}
\DoxyCodeLine{576   }
\DoxyCodeLine{577   \textcolor{keywordflow}{if}( (\mbox{\hyperlink{structA}{A}}.n\_nonzero == 0) || (\mbox{\hyperlink{structB}{B}}.n\_nonzero == 0) )}
\DoxyCodeLine{578     \{}
\DoxyCodeLine{579     \textcolor{keywordflow}{return} eT(0);}
\DoxyCodeLine{580     \}}
\DoxyCodeLine{581   }
\DoxyCodeLine{582   \textcolor{keyword}{const} uword N = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(\mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{583   }
\DoxyCodeLine{584   eT acc = eT(0);}
\DoxyCodeLine{585   }
\DoxyCodeLine{586   \textcolor{keywordflow}{if}( (\mbox{\hyperlink{structA}{A}}.n\_nonzero >= 5*N) || (\mbox{\hyperlink{structB}{B}}.n\_nonzero >= 5*N) )}
\DoxyCodeLine{587     \{}
\DoxyCodeLine{588     \textcolor{keywordflow}{for}(uword k=0; k < N; ++k)}
\DoxyCodeLine{589       \{}
\DoxyCodeLine{590       \textcolor{keyword}{typename} \mbox{\hyperlink{classSpMat_1_1const__iterator}{SpMat<eT>::const\_col\_iterator}} B\_it     = \mbox{\hyperlink{structB}{B}}.begin\_col\_no\_sync(k);}
\DoxyCodeLine{591       \textcolor{keyword}{typename} \mbox{\hyperlink{classSpMat_1_1const__iterator}{SpMat<eT>::const\_col\_iterator}} B\_it\_end = \mbox{\hyperlink{structB}{B}}.end\_col\_no\_sync(k);}
\DoxyCodeLine{592       }
\DoxyCodeLine{593       \textcolor{keywordflow}{while}(B\_it != B\_it\_end)}
\DoxyCodeLine{594         \{}
\DoxyCodeLine{595         \textcolor{keyword}{const} eT    B\_val = (*B\_it);}
\DoxyCodeLine{596         \textcolor{keyword}{const} uword i     = B\_it.row();}
\DoxyCodeLine{597         }
\DoxyCodeLine{598         acc += \mbox{\hyperlink{structA}{A}}.at(i,k) * B\_val;}
\DoxyCodeLine{599         }
\DoxyCodeLine{600         ++B\_it;}
\DoxyCodeLine{601         \}}
\DoxyCodeLine{602       \}}
\DoxyCodeLine{603     \}}
\DoxyCodeLine{604   \textcolor{keywordflow}{else}}
\DoxyCodeLine{605     \{}
\DoxyCodeLine{606     \textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}} AtB = \mbox{\hyperlink{structA}{A}}.t() * \mbox{\hyperlink{structB}{B}};}
\DoxyCodeLine{607     }
\DoxyCodeLine{608     acc = \mbox{\hyperlink{group__fn__trace_ga2604bb0f64c12abb8a3577f1bde42b35}{trace}}(AtB);}
\DoxyCodeLine{609     \}}
\DoxyCodeLine{610   }
\DoxyCodeLine{611   \textcolor{keywordflow}{return} acc;}
\DoxyCodeLine{612   \}}
\DoxyCodeLine{613 }
\DoxyCodeLine{614 }
\DoxyCodeLine{615 }
\DoxyCodeLine{617 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{618 arma\_warn\_unused}
\DoxyCodeLine{619 \textcolor{keyword}{inline}}
\DoxyCodeLine{620 \textcolor{keyword}{typename} \mbox{\hyperlink{structenable__if2}{enable\_if2< is\_cx<typename T1::elem\_type>::yes}}, \textcolor{keyword}{typename} T1::elem\_type>::result}
\DoxyCodeLine{621 \mbox{\hyperlink{group__fn__trace_ga2604bb0f64c12abb8a3577f1bde42b35}{trace}}(\textcolor{keyword}{const} \mbox{\hyperlink{classSpGlue}{SpGlue}}<\mbox{\hyperlink{classSpOp}{SpOp<T1, spop\_htrans>}}, T2, \mbox{\hyperlink{classspglue__times}{spglue\_times}}>\& expr)}
\DoxyCodeLine{622   \{}
\DoxyCodeLine{623   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{624   }
\DoxyCodeLine{625   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{626   }
\DoxyCodeLine{627   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap__spmat}{unwrap\_spmat<T1>}} UA(expr.A.m);}
\DoxyCodeLine{628   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap__spmat}{unwrap\_spmat<T2>}} UB(expr.B);}
\DoxyCodeLine{629   }
\DoxyCodeLine{630   \textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& \mbox{\hyperlink{structA}{A}} = UA.M;}
\DoxyCodeLine{631   \textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& \mbox{\hyperlink{structB}{B}} = UB.M;}
\DoxyCodeLine{632   }
\DoxyCodeLine{633   \textcolor{comment}{// NOTE: deliberately swapped A.n\_rows and A.n\_cols to take into account the requested transpose operation}}
\DoxyCodeLine{634   arma\_debug\_assert\_mul\_size(\mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structB}{B}}.n\_rows, \mbox{\hyperlink{structB}{B}}.n\_cols, \textcolor{stringliteral}{"{}matrix multiplication"{}});}
\DoxyCodeLine{635   }
\DoxyCodeLine{636   \textcolor{keywordflow}{if}( (\mbox{\hyperlink{structA}{A}}.n\_nonzero == 0) || (\mbox{\hyperlink{structB}{B}}.n\_nonzero == 0) )}
\DoxyCodeLine{637     \{}
\DoxyCodeLine{638     \textcolor{keywordflow}{return} eT(0);}
\DoxyCodeLine{639     \}}
\DoxyCodeLine{640   }
\DoxyCodeLine{641   \textcolor{keyword}{const} uword N = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(\mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{642   }
\DoxyCodeLine{643   eT acc = eT(0);}
\DoxyCodeLine{644   }
\DoxyCodeLine{645   \textcolor{comment}{// TODO: the threshold may need tuning for complex matrices}}
\DoxyCodeLine{646   \textcolor{keywordflow}{if}( (\mbox{\hyperlink{structA}{A}}.n\_nonzero >= 5*N) || (\mbox{\hyperlink{structB}{B}}.n\_nonzero >= 5*N) )}
\DoxyCodeLine{647     \{}
\DoxyCodeLine{648     \textcolor{keywordflow}{for}(uword k=0; k < N; ++k)}
\DoxyCodeLine{649       \{}
\DoxyCodeLine{650       \textcolor{keyword}{typename} \mbox{\hyperlink{classSpMat_1_1const__iterator}{SpMat<eT>::const\_col\_iterator}} B\_it     = \mbox{\hyperlink{structB}{B}}.begin\_col\_no\_sync(k);}
\DoxyCodeLine{651       \textcolor{keyword}{typename} \mbox{\hyperlink{classSpMat_1_1const__iterator}{SpMat<eT>::const\_col\_iterator}} B\_it\_end = \mbox{\hyperlink{structB}{B}}.end\_col\_no\_sync(k);}
\DoxyCodeLine{652       }
\DoxyCodeLine{653       \textcolor{keywordflow}{while}(B\_it != B\_it\_end)}
\DoxyCodeLine{654         \{}
\DoxyCodeLine{655         \textcolor{keyword}{const} eT    B\_val = (*B\_it);}
\DoxyCodeLine{656         \textcolor{keyword}{const} uword i     = B\_it.row();}
\DoxyCodeLine{657         }
\DoxyCodeLine{658         acc += std::conj(\mbox{\hyperlink{structA}{A}}.at(i,k)) * B\_val;}
\DoxyCodeLine{659         }
\DoxyCodeLine{660         ++B\_it;}
\DoxyCodeLine{661         \}}
\DoxyCodeLine{662       \}}
\DoxyCodeLine{663     \}}
\DoxyCodeLine{664   \textcolor{keywordflow}{else}}
\DoxyCodeLine{665     \{}
\DoxyCodeLine{666     \textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}} AtB = \mbox{\hyperlink{structA}{A}}.t() * \mbox{\hyperlink{structB}{B}};}
\DoxyCodeLine{667     }
\DoxyCodeLine{668     acc = \mbox{\hyperlink{group__fn__trace_ga2604bb0f64c12abb8a3577f1bde42b35}{trace}}(AtB);}
\DoxyCodeLine{669     \}}
\DoxyCodeLine{670   }
\DoxyCodeLine{671   \textcolor{keywordflow}{return} acc;}
\DoxyCodeLine{672   \}}
\DoxyCodeLine{673 }
\DoxyCodeLine{674 }
\DoxyCodeLine{675 }

\end{DoxyCode}
