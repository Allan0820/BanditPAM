\hypertarget{fn__conv__to_8hpp_source}{}\doxysection{fn\+\_\+conv\+\_\+to.\+hpp}
\label{fn__conv__to_8hpp_source}\index{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/fn\_conv\_to.hpp@{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/fn\_conv\_to.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008-\/2016 Conrad Sanderson (http://conradsanderson.id.au)}}
\DoxyCodeLine{2 \textcolor{comment}{// Copyright 2008-\/2016 National ICT Australia (NICTA)}}
\DoxyCodeLine{3 \textcolor{comment}{// }}
\DoxyCodeLine{4 \textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{5 \textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{6 \textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{7 \textcolor{comment}{// http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{8 \textcolor{comment}{// }}
\DoxyCodeLine{9 \textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{10 \textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{11 \textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{12 \textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{13 \textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{14 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{19 }
\DoxyCodeLine{20 }
\DoxyCodeLine{21 }
\DoxyCodeLine{24 \textcolor{keyword}{template}<\textcolor{keyword}{typename} out\_eT>}
\DoxyCodeLine{25 \textcolor{keyword}{class }\mbox{\hyperlink{classconv__to}{conv\_to}}}
\DoxyCodeLine{26   \{}
\DoxyCodeLine{27   \textcolor{keyword}{public}:}
\DoxyCodeLine{28   }
\DoxyCodeLine{29   \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{30   \textcolor{keyword}{inline} \textcolor{keyword}{static} out\_eT from(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<in\_eT, T1>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<in\_eT>::result* junk = \textcolor{keyword}{nullptr});}
\DoxyCodeLine{31 }
\DoxyCodeLine{32   \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{33   \textcolor{keyword}{inline} \textcolor{keyword}{static} out\_eT from(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<in\_eT, T1>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<in\_eT>::result}}* junk = \textcolor{keyword}{nullptr});}
\DoxyCodeLine{34   }
\DoxyCodeLine{35   \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{36   \textcolor{keyword}{inline} \textcolor{keyword}{static} out\_eT from(\textcolor{keyword}{const} \mbox{\hyperlink{structBaseCube}{BaseCube<in\_eT, T1>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<in\_eT>::result* junk = \textcolor{keyword}{nullptr});}
\DoxyCodeLine{37   }
\DoxyCodeLine{38   \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{39   \textcolor{keyword}{inline} \textcolor{keyword}{static} out\_eT from(\textcolor{keyword}{const} \mbox{\hyperlink{structBaseCube}{BaseCube<in\_eT, T1>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<in\_eT>::result}}* junk = \textcolor{keyword}{nullptr});}
\DoxyCodeLine{40   \};}
\DoxyCodeLine{41 }
\DoxyCodeLine{42 }
\DoxyCodeLine{43 }
\DoxyCodeLine{44 \textcolor{keyword}{template}<\textcolor{keyword}{typename} out\_eT>}
\DoxyCodeLine{45 \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{46 arma\_warn\_unused}
\DoxyCodeLine{47 \textcolor{keyword}{inline}}
\DoxyCodeLine{48 out\_eT}
\DoxyCodeLine{49 \mbox{\hyperlink{classconv__to}{conv\_to<out\_eT>::from}}(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<in\_eT, T1>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<in\_eT>::result* junk)}
\DoxyCodeLine{50   \{}
\DoxyCodeLine{51   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{52   arma\_ignore(junk);}
\DoxyCodeLine{53   }
\DoxyCodeLine{54   arma\_type\_check(( \mbox{\hyperlink{structis__supported__elem__type}{is\_supported\_elem\_type<out\_eT>::value}} == \textcolor{keyword}{false} ));}
\DoxyCodeLine{55   }
\DoxyCodeLine{56   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} P(in.get\_ref());}
\DoxyCodeLine{57   }
\DoxyCodeLine{58   arma\_debug\_check( (P.get\_n\_elem() != 1), \textcolor{stringliteral}{"{}conv\_to(): given object doesn't have exactly one element"{}} );}
\DoxyCodeLine{59   }
\DoxyCodeLine{60   \textcolor{keywordflow}{return} out\_eT(\mbox{\hyperlink{classProxy}{Proxy<T1>::use\_at}} ? P.at(0,0) : P[0]);}
\DoxyCodeLine{61   \}}
\DoxyCodeLine{62 }
\DoxyCodeLine{63 }
\DoxyCodeLine{64 }
\DoxyCodeLine{65 \textcolor{keyword}{template}<\textcolor{keyword}{typename} out\_eT>}
\DoxyCodeLine{66 \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{67 arma\_warn\_unused}
\DoxyCodeLine{68 \textcolor{keyword}{inline}}
\DoxyCodeLine{69 out\_eT}
\DoxyCodeLine{70 \mbox{\hyperlink{classconv__to}{conv\_to<out\_eT>::from}}(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<in\_eT, T1>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<in\_eT>::result}}* junk)}
\DoxyCodeLine{71   \{}
\DoxyCodeLine{72   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{73   arma\_ignore(junk);}
\DoxyCodeLine{74   }
\DoxyCodeLine{75   arma\_type\_check(( \mbox{\hyperlink{structis__supported__elem__type}{is\_supported\_elem\_type<out\_eT>::value}} == \textcolor{keyword}{false} ));}
\DoxyCodeLine{76   }
\DoxyCodeLine{77   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} P(in.get\_ref());}
\DoxyCodeLine{78   }
\DoxyCodeLine{79   arma\_debug\_check( (P.get\_n\_elem() != 1), \textcolor{stringliteral}{"{}conv\_to(): given object doesn't have exactly one element"{}} );}
\DoxyCodeLine{80   }
\DoxyCodeLine{81   out\_eT out;}
\DoxyCodeLine{82   }
\DoxyCodeLine{83   arrayops::convert\_cx\_scalar(out, (\mbox{\hyperlink{classProxy}{Proxy<T1>::use\_at}} ? P.at(0,0) : P[0]));}
\DoxyCodeLine{84   }
\DoxyCodeLine{85   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{86   \}}
\DoxyCodeLine{87 }
\DoxyCodeLine{88 }
\DoxyCodeLine{89 }
\DoxyCodeLine{90 \textcolor{keyword}{template}<\textcolor{keyword}{typename} out\_eT>}
\DoxyCodeLine{91 \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{92 arma\_warn\_unused}
\DoxyCodeLine{93 \textcolor{keyword}{inline}}
\DoxyCodeLine{94 out\_eT}
\DoxyCodeLine{95 \mbox{\hyperlink{classconv__to}{conv\_to<out\_eT>::from}}(\textcolor{keyword}{const} \mbox{\hyperlink{structBaseCube}{BaseCube<in\_eT, T1>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<in\_eT>::result* junk)}
\DoxyCodeLine{96   \{}
\DoxyCodeLine{97   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{98   arma\_ignore(junk);}
\DoxyCodeLine{99   }
\DoxyCodeLine{100   arma\_type\_check(( \mbox{\hyperlink{structis__supported__elem__type}{is\_supported\_elem\_type<out\_eT>::value}} == \textcolor{keyword}{false} ));}
\DoxyCodeLine{101   }
\DoxyCodeLine{102   \textcolor{keyword}{const} \mbox{\hyperlink{classProxyCube}{ProxyCube<T1>}} P(in.get\_ref());}
\DoxyCodeLine{103   }
\DoxyCodeLine{104   arma\_debug\_check( (P.get\_n\_elem() != 1), \textcolor{stringliteral}{"{}conv\_to(): given object doesn't have exactly one element"{}} );}
\DoxyCodeLine{105   }
\DoxyCodeLine{106   \textcolor{keywordflow}{return} out\_eT(\mbox{\hyperlink{classProxyCube}{ProxyCube<T1>::use\_at}} ? P.at(0,0,0) : P[0]);}
\DoxyCodeLine{107   \}}
\DoxyCodeLine{108 }
\DoxyCodeLine{109 }
\DoxyCodeLine{110 }
\DoxyCodeLine{111 \textcolor{keyword}{template}<\textcolor{keyword}{typename} out\_eT>}
\DoxyCodeLine{112 \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{113 arma\_warn\_unused}
\DoxyCodeLine{114 \textcolor{keyword}{inline}}
\DoxyCodeLine{115 out\_eT}
\DoxyCodeLine{116 \mbox{\hyperlink{classconv__to}{conv\_to<out\_eT>::from}}(\textcolor{keyword}{const} \mbox{\hyperlink{structBaseCube}{BaseCube<in\_eT, T1>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<in\_eT>::result}}* junk)}
\DoxyCodeLine{117   \{}
\DoxyCodeLine{118   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{119   arma\_ignore(junk);}
\DoxyCodeLine{120   }
\DoxyCodeLine{121   arma\_type\_check(( \mbox{\hyperlink{structis__supported__elem__type}{is\_supported\_elem\_type<out\_eT>::value}} == \textcolor{keyword}{false} ));}
\DoxyCodeLine{122   }
\DoxyCodeLine{123   \textcolor{keyword}{const} \mbox{\hyperlink{classProxyCube}{ProxyCube<T1>}} P(in.get\_ref());}
\DoxyCodeLine{124   }
\DoxyCodeLine{125   arma\_debug\_check( (P.get\_n\_elem() != 1), \textcolor{stringliteral}{"{}conv\_to(): given object doesn't have exactly one element"{}} );}
\DoxyCodeLine{126   }
\DoxyCodeLine{127   out\_eT out;}
\DoxyCodeLine{128   }
\DoxyCodeLine{129   arrayops::convert\_cx\_scalar(out, (\mbox{\hyperlink{classProxyCube}{ProxyCube<T1>::use\_at}} ? P.at(0,0,0) : P[0]));}
\DoxyCodeLine{130   }
\DoxyCodeLine{131   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{132   \}}
\DoxyCodeLine{133 }
\DoxyCodeLine{134 }
\DoxyCodeLine{135 }
\DoxyCodeLine{137 \textcolor{keyword}{template}<\textcolor{keyword}{typename} out\_eT>}
\DoxyCodeLine{138 \textcolor{keyword}{class }\mbox{\hyperlink{classconv__to}{conv\_to}}< \mbox{\hyperlink{classMat}{Mat}}<out\_eT> >}
\DoxyCodeLine{139   \{}
\DoxyCodeLine{140   \textcolor{keyword}{public}:}
\DoxyCodeLine{141   }
\DoxyCodeLine{142   \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{143   \textcolor{keyword}{inline} \textcolor{keyword}{static} \mbox{\hyperlink{classMat}{Mat<out\_eT>}} from(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<in\_eT, T1>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<in\_eT>::result* junk = \textcolor{keyword}{nullptr});}
\DoxyCodeLine{144   }
\DoxyCodeLine{145   \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{146   \textcolor{keyword}{inline} \textcolor{keyword}{static} \mbox{\hyperlink{classMat}{Mat<out\_eT>}} from(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<in\_eT, T1>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<in\_eT>::result}}* junk = \textcolor{keyword}{nullptr});}
\DoxyCodeLine{147   }
\DoxyCodeLine{148   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{149   \textcolor{keyword}{inline} \textcolor{keyword}{static} \mbox{\hyperlink{classMat}{Mat<out\_eT>}} from(\textcolor{keyword}{const} \mbox{\hyperlink{structSpBase}{SpBase<out\_eT, T1>}}\& in);}
\DoxyCodeLine{150   }
\DoxyCodeLine{151   }
\DoxyCodeLine{152   }
\DoxyCodeLine{153   \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT>}
\DoxyCodeLine{154   \textcolor{keyword}{inline} \textcolor{keyword}{static} \mbox{\hyperlink{classMat}{Mat<out\_eT>}} from(\textcolor{keyword}{const} std::vector<in\_eT>\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<in\_eT>::result* junk = \textcolor{keyword}{nullptr});}
\DoxyCodeLine{155   }
\DoxyCodeLine{156   \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT>}
\DoxyCodeLine{157   \textcolor{keyword}{inline} \textcolor{keyword}{static} \mbox{\hyperlink{classMat}{Mat<out\_eT>}} from(\textcolor{keyword}{const} std::vector<in\_eT>\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<in\_eT>::result}}* junk = \textcolor{keyword}{nullptr});}
\DoxyCodeLine{158   \};}
\DoxyCodeLine{159 }
\DoxyCodeLine{160 }
\DoxyCodeLine{161 }
\DoxyCodeLine{162 \textcolor{keyword}{template}<\textcolor{keyword}{typename} out\_eT>}
\DoxyCodeLine{163 \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{164 arma\_warn\_unused}
\DoxyCodeLine{165 \textcolor{keyword}{inline}}
\DoxyCodeLine{166 \mbox{\hyperlink{classMat}{Mat<out\_eT>}}}
\DoxyCodeLine{167 \mbox{\hyperlink{classconv__to}{conv\_to< Mat<out\_eT>}} >::from(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<in\_eT, T1>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<in\_eT>::result* junk)}
\DoxyCodeLine{168   \{}
\DoxyCodeLine{169   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{170   arma\_ignore(junk);}
\DoxyCodeLine{171   }
\DoxyCodeLine{172   \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} tmp(in.get\_ref());}
\DoxyCodeLine{173   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<in\_eT>}}\& X  = tmp.M;}
\DoxyCodeLine{174   }
\DoxyCodeLine{175   \mbox{\hyperlink{classMat}{Mat<out\_eT>}} out(X.n\_rows, X.n\_cols, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{176   }
\DoxyCodeLine{177   arrayops::convert( out.memptr(), X.memptr(), X.n\_elem );}
\DoxyCodeLine{178   }
\DoxyCodeLine{179   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{180   \}}
\DoxyCodeLine{181 }
\DoxyCodeLine{182 }
\DoxyCodeLine{183 }
\DoxyCodeLine{184 \textcolor{keyword}{template}<\textcolor{keyword}{typename} out\_eT>}
\DoxyCodeLine{185 \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{186 arma\_warn\_unused}
\DoxyCodeLine{187 \textcolor{keyword}{inline}}
\DoxyCodeLine{188 \mbox{\hyperlink{classMat}{Mat<out\_eT>}}}
\DoxyCodeLine{189 \mbox{\hyperlink{classconv__to}{conv\_to< Mat<out\_eT>}} >::from(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<in\_eT, T1>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<in\_eT>::result}}* junk)}
\DoxyCodeLine{190   \{}
\DoxyCodeLine{191   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{192   arma\_ignore(junk);}
\DoxyCodeLine{193   }
\DoxyCodeLine{194   \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} tmp(in.get\_ref());}
\DoxyCodeLine{195   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<in\_eT>}}\& X  = tmp.M;}
\DoxyCodeLine{196   }
\DoxyCodeLine{197   \mbox{\hyperlink{classMat}{Mat<out\_eT>}} out(X.n\_rows, X.n\_cols, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{198   }
\DoxyCodeLine{199   arrayops::convert\_cx( out.memptr(), X.memptr(), X.n\_elem );}
\DoxyCodeLine{200   }
\DoxyCodeLine{201   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{202   \}}
\DoxyCodeLine{203 }
\DoxyCodeLine{204 }
\DoxyCodeLine{205 }
\DoxyCodeLine{206 \textcolor{keyword}{template}<\textcolor{keyword}{typename} out\_eT>}
\DoxyCodeLine{207 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{208 arma\_warn\_unused}
\DoxyCodeLine{209 \textcolor{keyword}{inline}}
\DoxyCodeLine{210 \mbox{\hyperlink{classMat}{Mat<out\_eT>}}}
\DoxyCodeLine{211 \mbox{\hyperlink{classconv__to}{conv\_to< Mat<out\_eT>}} >::from(\textcolor{keyword}{const} \mbox{\hyperlink{structSpBase}{SpBase<out\_eT, T1>}}\& in)}
\DoxyCodeLine{212   \{}
\DoxyCodeLine{213   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{214   }
\DoxyCodeLine{215   \textcolor{keywordflow}{return} \mbox{\hyperlink{classMat}{Mat<out\_eT>}}(in.get\_ref());}
\DoxyCodeLine{216   \}}
\DoxyCodeLine{217 }
\DoxyCodeLine{218 }
\DoxyCodeLine{219 }
\DoxyCodeLine{220 \textcolor{keyword}{template}<\textcolor{keyword}{typename} out\_eT>}
\DoxyCodeLine{221 \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT>}
\DoxyCodeLine{222 arma\_warn\_unused}
\DoxyCodeLine{223 \textcolor{keyword}{inline}}
\DoxyCodeLine{224 \mbox{\hyperlink{classMat}{Mat<out\_eT>}}}
\DoxyCodeLine{225 \mbox{\hyperlink{classconv__to}{conv\_to< Mat<out\_eT>}} >::from(\textcolor{keyword}{const} std::vector<in\_eT>\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<in\_eT>::result* junk)}
\DoxyCodeLine{226   \{}
\DoxyCodeLine{227   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{228   arma\_ignore(junk);}
\DoxyCodeLine{229   }
\DoxyCodeLine{230   \textcolor{keyword}{const} uword N = uword( in.size() );}
\DoxyCodeLine{231   }
\DoxyCodeLine{232   \mbox{\hyperlink{classMat}{Mat<out\_eT>}} out(N, 1, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{233   }
\DoxyCodeLine{234   \textcolor{keywordflow}{if}(N > 0)}
\DoxyCodeLine{235     \{}
\DoxyCodeLine{236     arrayops::convert( out.memptr(), \&(in[0]), N );}
\DoxyCodeLine{237     \}}
\DoxyCodeLine{238   }
\DoxyCodeLine{239   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{240   \}}
\DoxyCodeLine{241 }
\DoxyCodeLine{242 }
\DoxyCodeLine{243 }
\DoxyCodeLine{244 \textcolor{keyword}{template}<\textcolor{keyword}{typename} out\_eT>}
\DoxyCodeLine{245 \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT>}
\DoxyCodeLine{246 arma\_warn\_unused}
\DoxyCodeLine{247 \textcolor{keyword}{inline}}
\DoxyCodeLine{248 \mbox{\hyperlink{classMat}{Mat<out\_eT>}}}
\DoxyCodeLine{249 \mbox{\hyperlink{classconv__to}{conv\_to< Mat<out\_eT>}} >::from(\textcolor{keyword}{const} std::vector<in\_eT>\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<in\_eT>::result}}* junk)}
\DoxyCodeLine{250   \{}
\DoxyCodeLine{251   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{252   arma\_ignore(junk);}
\DoxyCodeLine{253   }
\DoxyCodeLine{254   \textcolor{keyword}{const} uword N = uword( in.size() );}
\DoxyCodeLine{255   }
\DoxyCodeLine{256   \mbox{\hyperlink{classMat}{Mat<out\_eT>}} out(N, 1, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{257   }
\DoxyCodeLine{258   \textcolor{keywordflow}{if}(N > 0)}
\DoxyCodeLine{259     \{}
\DoxyCodeLine{260     arrayops::convert\_cx( out.memptr(), \&(in[0]), N );}
\DoxyCodeLine{261     \}}
\DoxyCodeLine{262   }
\DoxyCodeLine{263   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{264   \}}
\DoxyCodeLine{265 }
\DoxyCodeLine{266 }
\DoxyCodeLine{267 }
\DoxyCodeLine{269 \textcolor{keyword}{template}<\textcolor{keyword}{typename} out\_eT>}
\DoxyCodeLine{270 \textcolor{keyword}{class }\mbox{\hyperlink{classconv__to}{conv\_to}}< \mbox{\hyperlink{classRow}{Row}}<out\_eT> >}
\DoxyCodeLine{271   \{}
\DoxyCodeLine{272   \textcolor{keyword}{public}:}
\DoxyCodeLine{273   }
\DoxyCodeLine{274   \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{275   \textcolor{keyword}{inline} \textcolor{keyword}{static} \mbox{\hyperlink{classRow}{Row<out\_eT>}} from(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<in\_eT, T1>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<in\_eT>::result* junk = \textcolor{keyword}{nullptr});}
\DoxyCodeLine{276   }
\DoxyCodeLine{277   \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{278   \textcolor{keyword}{inline} \textcolor{keyword}{static} \mbox{\hyperlink{classRow}{Row<out\_eT>}} from(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<in\_eT, T1>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<in\_eT>::result}}* junk = \textcolor{keyword}{nullptr});}
\DoxyCodeLine{279   }
\DoxyCodeLine{280   }
\DoxyCodeLine{281   }
\DoxyCodeLine{282   \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT>}
\DoxyCodeLine{283   \textcolor{keyword}{inline} \textcolor{keyword}{static} \mbox{\hyperlink{classRow}{Row<out\_eT>}} from(\textcolor{keyword}{const} std::vector<in\_eT>\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<in\_eT>::result* junk = \textcolor{keyword}{nullptr});}
\DoxyCodeLine{284   }
\DoxyCodeLine{285   \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT>}
\DoxyCodeLine{286   \textcolor{keyword}{inline} \textcolor{keyword}{static} \mbox{\hyperlink{classRow}{Row<out\_eT>}} from(\textcolor{keyword}{const} std::vector<in\_eT>\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<in\_eT>::result}}* junk = \textcolor{keyword}{nullptr});}
\DoxyCodeLine{287   \};}
\DoxyCodeLine{288 }
\DoxyCodeLine{289 }
\DoxyCodeLine{290 }
\DoxyCodeLine{291 \textcolor{keyword}{template}<\textcolor{keyword}{typename} out\_eT>}
\DoxyCodeLine{292 \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{293 arma\_warn\_unused}
\DoxyCodeLine{294 \textcolor{keyword}{inline}}
\DoxyCodeLine{295 \mbox{\hyperlink{classRow}{Row<out\_eT>}}}
\DoxyCodeLine{296 \mbox{\hyperlink{classconv__to}{conv\_to< Row<out\_eT>}} >::from(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<in\_eT, T1>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<in\_eT>::result* junk)}
\DoxyCodeLine{297   \{}
\DoxyCodeLine{298   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{299   arma\_ignore(junk);}
\DoxyCodeLine{300   }
\DoxyCodeLine{301   \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} tmp(in.get\_ref());}
\DoxyCodeLine{302   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<in\_eT>}}\& X  = tmp.M;}
\DoxyCodeLine{303   }
\DoxyCodeLine{304   arma\_debug\_check( ( (X.is\_vec() == \textcolor{keyword}{false}) \&\& (X.is\_empty() == \textcolor{keyword}{false}) ), \textcolor{stringliteral}{"{}conv\_to(): given object can't be interpreted as a vector"{}} );}
\DoxyCodeLine{305   }
\DoxyCodeLine{306   \mbox{\hyperlink{classRow}{Row<out\_eT>}} out(X.n\_elem, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{307   }
\DoxyCodeLine{308   arrayops::convert( out.memptr(), X.memptr(), X.n\_elem );}
\DoxyCodeLine{309   }
\DoxyCodeLine{310   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{311   \}}
\DoxyCodeLine{312 }
\DoxyCodeLine{313 }
\DoxyCodeLine{314 }
\DoxyCodeLine{315 \textcolor{keyword}{template}<\textcolor{keyword}{typename} out\_eT>}
\DoxyCodeLine{316 \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{317 arma\_warn\_unused}
\DoxyCodeLine{318 \textcolor{keyword}{inline}}
\DoxyCodeLine{319 \mbox{\hyperlink{classRow}{Row<out\_eT>}}}
\DoxyCodeLine{320 \mbox{\hyperlink{classconv__to}{conv\_to< Row<out\_eT>}} >::from(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<in\_eT, T1>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<in\_eT>::result}}* junk)}
\DoxyCodeLine{321   \{}
\DoxyCodeLine{322   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{323   arma\_ignore(junk);}
\DoxyCodeLine{324   }
\DoxyCodeLine{325   \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} tmp(in.get\_ref());}
\DoxyCodeLine{326   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<in\_eT>}}\& X  = tmp.M;}
\DoxyCodeLine{327   }
\DoxyCodeLine{328   arma\_debug\_check( ( (X.is\_vec() == \textcolor{keyword}{false}) \&\& (X.is\_empty() == \textcolor{keyword}{false}) ), \textcolor{stringliteral}{"{}conv\_to(): given object can't be interpreted as a vector"{}} );}
\DoxyCodeLine{329   }
\DoxyCodeLine{330   \mbox{\hyperlink{classRow}{Row<out\_eT>}} out(X.n\_rows, X.n\_cols, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{331   }
\DoxyCodeLine{332   arrayops::convert\_cx( out.memptr(), X.memptr(), X.n\_elem );}
\DoxyCodeLine{333   }
\DoxyCodeLine{334   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{335   \}}
\DoxyCodeLine{336 }
\DoxyCodeLine{337 }
\DoxyCodeLine{338 }
\DoxyCodeLine{339 \textcolor{keyword}{template}<\textcolor{keyword}{typename} out\_eT>}
\DoxyCodeLine{340 \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT>}
\DoxyCodeLine{341 arma\_warn\_unused}
\DoxyCodeLine{342 \textcolor{keyword}{inline}}
\DoxyCodeLine{343 \mbox{\hyperlink{classRow}{Row<out\_eT>}}}
\DoxyCodeLine{344 \mbox{\hyperlink{classconv__to}{conv\_to< Row<out\_eT>}} >::from(\textcolor{keyword}{const} std::vector<in\_eT>\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<in\_eT>::result* junk)}
\DoxyCodeLine{345   \{}
\DoxyCodeLine{346   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{347   arma\_ignore(junk);}
\DoxyCodeLine{348   }
\DoxyCodeLine{349   \textcolor{keyword}{const} uword N = uword( in.size() );}
\DoxyCodeLine{350   }
\DoxyCodeLine{351   \mbox{\hyperlink{classRow}{Row<out\_eT>}} out(N, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{352   }
\DoxyCodeLine{353   \textcolor{keywordflow}{if}(N > 0)}
\DoxyCodeLine{354     \{}
\DoxyCodeLine{355     arrayops::convert( out.memptr(), \&(in[0]), N );}
\DoxyCodeLine{356     \}}
\DoxyCodeLine{357   }
\DoxyCodeLine{358   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{359   \}}
\DoxyCodeLine{360 }
\DoxyCodeLine{361 }
\DoxyCodeLine{362 }
\DoxyCodeLine{363 \textcolor{keyword}{template}<\textcolor{keyword}{typename} out\_eT>}
\DoxyCodeLine{364 \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT>}
\DoxyCodeLine{365 arma\_warn\_unused}
\DoxyCodeLine{366 \textcolor{keyword}{inline}}
\DoxyCodeLine{367 \mbox{\hyperlink{classRow}{Row<out\_eT>}}}
\DoxyCodeLine{368 \mbox{\hyperlink{classconv__to}{conv\_to< Row<out\_eT>}} >::from(\textcolor{keyword}{const} std::vector<in\_eT>\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<in\_eT>::result}}* junk)}
\DoxyCodeLine{369   \{}
\DoxyCodeLine{370   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{371   arma\_ignore(junk);}
\DoxyCodeLine{372   }
\DoxyCodeLine{373   \textcolor{keyword}{const} uword N = uword( in.size() );}
\DoxyCodeLine{374   }
\DoxyCodeLine{375   \mbox{\hyperlink{classRow}{Row<out\_eT>}} out(N, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{376   }
\DoxyCodeLine{377   \textcolor{keywordflow}{if}(N > 0)}
\DoxyCodeLine{378     \{}
\DoxyCodeLine{379     arrayops::convert\_cx( out.memptr(), \&(in[0]), N );}
\DoxyCodeLine{380     \}}
\DoxyCodeLine{381   }
\DoxyCodeLine{382   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{383   \}}
\DoxyCodeLine{384 }
\DoxyCodeLine{385 }
\DoxyCodeLine{386 }
\DoxyCodeLine{388 \textcolor{keyword}{template}<\textcolor{keyword}{typename} out\_eT>}
\DoxyCodeLine{389 \textcolor{keyword}{class }\mbox{\hyperlink{classconv__to}{conv\_to}}< \mbox{\hyperlink{classCol}{Col}}<out\_eT> >}
\DoxyCodeLine{390   \{}
\DoxyCodeLine{391   \textcolor{keyword}{public}:}
\DoxyCodeLine{392   }
\DoxyCodeLine{393   \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{394   \textcolor{keyword}{inline} \textcolor{keyword}{static} \mbox{\hyperlink{classCol}{Col<out\_eT>}} from(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<in\_eT, T1>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<in\_eT>::result* junk = \textcolor{keyword}{nullptr});}
\DoxyCodeLine{395   }
\DoxyCodeLine{396   \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{397   \textcolor{keyword}{inline} \textcolor{keyword}{static} \mbox{\hyperlink{classCol}{Col<out\_eT>}} from(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<in\_eT, T1>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<in\_eT>::result}}* junk = \textcolor{keyword}{nullptr});}
\DoxyCodeLine{398   }
\DoxyCodeLine{399   }
\DoxyCodeLine{400   }
\DoxyCodeLine{401   \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT>}
\DoxyCodeLine{402   \textcolor{keyword}{inline} \textcolor{keyword}{static} \mbox{\hyperlink{classCol}{Col<out\_eT>}} from(\textcolor{keyword}{const} std::vector<in\_eT>\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<in\_eT>::result* junk = \textcolor{keyword}{nullptr});}
\DoxyCodeLine{403   }
\DoxyCodeLine{404   \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT>}
\DoxyCodeLine{405   \textcolor{keyword}{inline} \textcolor{keyword}{static} \mbox{\hyperlink{classCol}{Col<out\_eT>}} from(\textcolor{keyword}{const} std::vector<in\_eT>\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<in\_eT>::result}}* junk = \textcolor{keyword}{nullptr});}
\DoxyCodeLine{406   \};}
\DoxyCodeLine{407 }
\DoxyCodeLine{408 }
\DoxyCodeLine{409 }
\DoxyCodeLine{410 \textcolor{keyword}{template}<\textcolor{keyword}{typename} out\_eT>}
\DoxyCodeLine{411 \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{412 arma\_warn\_unused}
\DoxyCodeLine{413 \textcolor{keyword}{inline}}
\DoxyCodeLine{414 \mbox{\hyperlink{classCol}{Col<out\_eT>}}}
\DoxyCodeLine{415 \mbox{\hyperlink{classconv__to}{conv\_to< Col<out\_eT>}} >::from(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<in\_eT, T1>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<in\_eT>::result* junk)}
\DoxyCodeLine{416   \{}
\DoxyCodeLine{417   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{418   arma\_ignore(junk);}
\DoxyCodeLine{419   }
\DoxyCodeLine{420   \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} tmp(in.get\_ref());}
\DoxyCodeLine{421   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<in\_eT>}}\& X  = tmp.M;}
\DoxyCodeLine{422   }
\DoxyCodeLine{423   arma\_debug\_check( ( (X.is\_vec() == \textcolor{keyword}{false}) \&\& (X.is\_empty() == \textcolor{keyword}{false}) ), \textcolor{stringliteral}{"{}conv\_to(): given object can't be interpreted as a vector"{}} );}
\DoxyCodeLine{424   }
\DoxyCodeLine{425   \mbox{\hyperlink{classCol}{Col<out\_eT>}} out(X.n\_elem, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{426   }
\DoxyCodeLine{427   arrayops::convert( out.memptr(), X.memptr(), X.n\_elem );}
\DoxyCodeLine{428   }
\DoxyCodeLine{429   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{430   \}}
\DoxyCodeLine{431 }
\DoxyCodeLine{432 }
\DoxyCodeLine{433 }
\DoxyCodeLine{434 \textcolor{keyword}{template}<\textcolor{keyword}{typename} out\_eT>}
\DoxyCodeLine{435 \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{436 arma\_warn\_unused}
\DoxyCodeLine{437 \textcolor{keyword}{inline}}
\DoxyCodeLine{438 \mbox{\hyperlink{classCol}{Col<out\_eT>}}}
\DoxyCodeLine{439 \mbox{\hyperlink{classconv__to}{conv\_to< Col<out\_eT>}} >::from(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<in\_eT, T1>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<in\_eT>::result}}* junk)}
\DoxyCodeLine{440   \{}
\DoxyCodeLine{441   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{442   arma\_ignore(junk);}
\DoxyCodeLine{443   }
\DoxyCodeLine{444   \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} tmp(in.get\_ref());}
\DoxyCodeLine{445   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<in\_eT>}}\& X  = tmp.M;}
\DoxyCodeLine{446   }
\DoxyCodeLine{447   arma\_debug\_check( ( (X.is\_vec() == \textcolor{keyword}{false}) \&\& (X.is\_empty() == \textcolor{keyword}{false}) ), \textcolor{stringliteral}{"{}conv\_to(): given object can't be interpreted as a vector"{}} );}
\DoxyCodeLine{448   }
\DoxyCodeLine{449   \mbox{\hyperlink{classCol}{Col<out\_eT>}} out(X.n\_rows, X.n\_cols, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{450   }
\DoxyCodeLine{451   arrayops::convert\_cx( out.memptr(), X.memptr(), X.n\_elem );}
\DoxyCodeLine{452   }
\DoxyCodeLine{453   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{454   \}}
\DoxyCodeLine{455 }
\DoxyCodeLine{456 }
\DoxyCodeLine{457 }
\DoxyCodeLine{458 \textcolor{keyword}{template}<\textcolor{keyword}{typename} out\_eT>}
\DoxyCodeLine{459 \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT>}
\DoxyCodeLine{460 arma\_warn\_unused}
\DoxyCodeLine{461 \textcolor{keyword}{inline}}
\DoxyCodeLine{462 \mbox{\hyperlink{classCol}{Col<out\_eT>}}}
\DoxyCodeLine{463 \mbox{\hyperlink{classconv__to}{conv\_to< Col<out\_eT>}} >::from(\textcolor{keyword}{const} std::vector<in\_eT>\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<in\_eT>::result* junk)}
\DoxyCodeLine{464   \{}
\DoxyCodeLine{465   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{466   arma\_ignore(junk);}
\DoxyCodeLine{467   }
\DoxyCodeLine{468   \textcolor{keyword}{const} uword N = uword( in.size() );}
\DoxyCodeLine{469   }
\DoxyCodeLine{470   \mbox{\hyperlink{classCol}{Col<out\_eT>}} out(N, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{471   }
\DoxyCodeLine{472   \textcolor{keywordflow}{if}(N > 0)}
\DoxyCodeLine{473     \{}
\DoxyCodeLine{474     arrayops::convert( out.memptr(), \&(in[0]), N );}
\DoxyCodeLine{475     \}}
\DoxyCodeLine{476   }
\DoxyCodeLine{477   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{478   \}}
\DoxyCodeLine{479 }
\DoxyCodeLine{480 }
\DoxyCodeLine{481 }
\DoxyCodeLine{482 \textcolor{keyword}{template}<\textcolor{keyword}{typename} out\_eT>}
\DoxyCodeLine{483 \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT>}
\DoxyCodeLine{484 arma\_warn\_unused}
\DoxyCodeLine{485 \textcolor{keyword}{inline}}
\DoxyCodeLine{486 \mbox{\hyperlink{classCol}{Col<out\_eT>}}}
\DoxyCodeLine{487 \mbox{\hyperlink{classconv__to}{conv\_to< Col<out\_eT>}} >::from(\textcolor{keyword}{const} std::vector<in\_eT>\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<in\_eT>::result}}* junk)}
\DoxyCodeLine{488   \{}
\DoxyCodeLine{489   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{490   arma\_ignore(junk);}
\DoxyCodeLine{491   }
\DoxyCodeLine{492   \textcolor{keyword}{const} uword N = uword( in.size() );}
\DoxyCodeLine{493   }
\DoxyCodeLine{494   \mbox{\hyperlink{classCol}{Col<out\_eT>}} out(N, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{495   }
\DoxyCodeLine{496   \textcolor{keywordflow}{if}(N > 0)}
\DoxyCodeLine{497     \{}
\DoxyCodeLine{498     arrayops::convert\_cx( out.memptr(), \&(in[0]), N );}
\DoxyCodeLine{499     \}}
\DoxyCodeLine{500   }
\DoxyCodeLine{501   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{502   \}}
\DoxyCodeLine{503 }
\DoxyCodeLine{504 }
\DoxyCodeLine{505 }
\DoxyCodeLine{507 \textcolor{keyword}{template}<\textcolor{keyword}{typename} out\_eT>}
\DoxyCodeLine{508 \textcolor{keyword}{class }\mbox{\hyperlink{classconv__to}{conv\_to}}< \mbox{\hyperlink{classSpMat}{SpMat}}<out\_eT> >}
\DoxyCodeLine{509   \{}
\DoxyCodeLine{510   \textcolor{keyword}{public}:}
\DoxyCodeLine{511   }
\DoxyCodeLine{512   \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{513   \textcolor{keyword}{inline} \textcolor{keyword}{static} \mbox{\hyperlink{classSpMat}{SpMat<out\_eT>}} from(\textcolor{keyword}{const} \mbox{\hyperlink{structSpBase}{SpBase<in\_eT, T1>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<in\_eT>::result* junk = \textcolor{keyword}{nullptr});}
\DoxyCodeLine{514   }
\DoxyCodeLine{515   \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{516   \textcolor{keyword}{inline} \textcolor{keyword}{static} \mbox{\hyperlink{classSpMat}{SpMat<out\_eT>}} from(\textcolor{keyword}{const} \mbox{\hyperlink{structSpBase}{SpBase<in\_eT, T1>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<in\_eT>::result}}* junk = \textcolor{keyword}{nullptr});}
\DoxyCodeLine{517   }
\DoxyCodeLine{518   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{519   \textcolor{keyword}{inline} \textcolor{keyword}{static} \mbox{\hyperlink{classSpMat}{SpMat<out\_eT>}} from(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<out\_eT, T1>}}\& in);}
\DoxyCodeLine{520   \};}
\DoxyCodeLine{521 }
\DoxyCodeLine{522 }
\DoxyCodeLine{523 }
\DoxyCodeLine{524 \textcolor{keyword}{template}<\textcolor{keyword}{typename} out\_eT>}
\DoxyCodeLine{525 \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{526 arma\_warn\_unused}
\DoxyCodeLine{527 \textcolor{keyword}{inline}}
\DoxyCodeLine{528 \mbox{\hyperlink{classSpMat}{SpMat<out\_eT>}}}
\DoxyCodeLine{529 \mbox{\hyperlink{classconv__to}{conv\_to< SpMat<out\_eT>}} >::from(\textcolor{keyword}{const} \mbox{\hyperlink{structSpBase}{SpBase<in\_eT, T1>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<in\_eT>::result* junk)}
\DoxyCodeLine{530   \{}
\DoxyCodeLine{531   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{532   arma\_ignore(junk);}
\DoxyCodeLine{533   }
\DoxyCodeLine{534   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap__spmat}{unwrap\_spmat<T1>}}  tmp(in.get\_ref());}
\DoxyCodeLine{535   \textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<in\_eT>}}\& X = tmp.M;}
\DoxyCodeLine{536   }
\DoxyCodeLine{537   \mbox{\hyperlink{classSpMat}{SpMat<out\_eT>}} out(\mbox{\hyperlink{structarma__layout__indicator}{arma\_layout\_indicator}}(), X);}
\DoxyCodeLine{538   }
\DoxyCodeLine{539   arrayops::convert( access::rwp(out.values), X.values, X.n\_nonzero );}
\DoxyCodeLine{540   }
\DoxyCodeLine{541   out.remove\_zeros();}
\DoxyCodeLine{542   }
\DoxyCodeLine{543   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{544   \}}
\DoxyCodeLine{545 }
\DoxyCodeLine{546 }
\DoxyCodeLine{547 }
\DoxyCodeLine{548 \textcolor{keyword}{template}<\textcolor{keyword}{typename} out\_eT>}
\DoxyCodeLine{549 \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{550 arma\_warn\_unused}
\DoxyCodeLine{551 \textcolor{keyword}{inline}}
\DoxyCodeLine{552 \mbox{\hyperlink{classSpMat}{SpMat<out\_eT>}}}
\DoxyCodeLine{553 \mbox{\hyperlink{classconv__to}{conv\_to< SpMat<out\_eT>}} >::from(\textcolor{keyword}{const} \mbox{\hyperlink{structSpBase}{SpBase<in\_eT, T1>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<in\_eT>::result}}* junk)}
\DoxyCodeLine{554   \{}
\DoxyCodeLine{555   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{556   arma\_ignore(junk);}
\DoxyCodeLine{557   }
\DoxyCodeLine{558   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap__spmat}{unwrap\_spmat<T1>}}  tmp(in.get\_ref());}
\DoxyCodeLine{559   \textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<in\_eT>}}\& X = tmp.M;}
\DoxyCodeLine{560   }
\DoxyCodeLine{561   \mbox{\hyperlink{classSpMat}{SpMat<out\_eT>}} out(\mbox{\hyperlink{structarma__layout__indicator}{arma\_layout\_indicator}}(), X);}
\DoxyCodeLine{562   }
\DoxyCodeLine{563   arrayops::convert\_cx( access::rwp(out.values), X.values, X.n\_nonzero );}
\DoxyCodeLine{564   }
\DoxyCodeLine{565   out.remove\_zeros();}
\DoxyCodeLine{566   }
\DoxyCodeLine{567   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{568   \}}
\DoxyCodeLine{569 }
\DoxyCodeLine{570 }
\DoxyCodeLine{571 }
\DoxyCodeLine{572 \textcolor{keyword}{template}<\textcolor{keyword}{typename} out\_eT>}
\DoxyCodeLine{573 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{574 arma\_warn\_unused}
\DoxyCodeLine{575 \textcolor{keyword}{inline}}
\DoxyCodeLine{576 \mbox{\hyperlink{classSpMat}{SpMat<out\_eT>}}}
\DoxyCodeLine{577 \mbox{\hyperlink{classconv__to}{conv\_to< SpMat<out\_eT>}} >::from(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<out\_eT, T1>}}\& in)}
\DoxyCodeLine{578   \{}
\DoxyCodeLine{579   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{580   }
\DoxyCodeLine{581   \textcolor{keywordflow}{return} \mbox{\hyperlink{classSpMat}{SpMat<out\_eT>}}(in.get\_ref());}
\DoxyCodeLine{582   \}}
\DoxyCodeLine{583 }
\DoxyCodeLine{584 }
\DoxyCodeLine{585 }
\DoxyCodeLine{587 \textcolor{keyword}{template}<\textcolor{keyword}{typename} out\_eT>}
\DoxyCodeLine{588 \textcolor{keyword}{class }\mbox{\hyperlink{classconv__to}{conv\_to}}< \mbox{\hyperlink{classCube}{Cube}}<out\_eT> >}
\DoxyCodeLine{589   \{}
\DoxyCodeLine{590   \textcolor{keyword}{public}:}
\DoxyCodeLine{591   }
\DoxyCodeLine{592   \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{593   \textcolor{keyword}{inline} \textcolor{keyword}{static} \mbox{\hyperlink{classCube}{Cube<out\_eT>}} from(\textcolor{keyword}{const} \mbox{\hyperlink{structBaseCube}{BaseCube<in\_eT, T1>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<in\_eT>::result* junk = \textcolor{keyword}{nullptr});}
\DoxyCodeLine{594   }
\DoxyCodeLine{595   \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{596   \textcolor{keyword}{inline} \textcolor{keyword}{static} \mbox{\hyperlink{classCube}{Cube<out\_eT>}} from(\textcolor{keyword}{const} \mbox{\hyperlink{structBaseCube}{BaseCube<in\_eT, T1>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<in\_eT>::result}}* junk = \textcolor{keyword}{nullptr});}
\DoxyCodeLine{597   \};}
\DoxyCodeLine{598 }
\DoxyCodeLine{599 }
\DoxyCodeLine{600 }
\DoxyCodeLine{601 \textcolor{keyword}{template}<\textcolor{keyword}{typename} out\_eT>}
\DoxyCodeLine{602 \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{603 arma\_warn\_unused}
\DoxyCodeLine{604 \textcolor{keyword}{inline}}
\DoxyCodeLine{605 \mbox{\hyperlink{classCube}{Cube<out\_eT>}}}
\DoxyCodeLine{606 \mbox{\hyperlink{classconv__to}{conv\_to< Cube<out\_eT>}} >::from(\textcolor{keyword}{const} \mbox{\hyperlink{structBaseCube}{BaseCube<in\_eT, T1>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<in\_eT>::result* junk)}
\DoxyCodeLine{607   \{}
\DoxyCodeLine{608   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{609   arma\_ignore(junk);}
\DoxyCodeLine{610   }
\DoxyCodeLine{611   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap__cube}{unwrap\_cube<T1>}}  tmp( in.get\_ref() );}
\DoxyCodeLine{612   \textcolor{keyword}{const} \mbox{\hyperlink{classCube}{Cube<in\_eT>}}\& X = tmp.M;}
\DoxyCodeLine{613   }
\DoxyCodeLine{614   \mbox{\hyperlink{classCube}{Cube<out\_eT>}} out(X.n\_rows, X.n\_cols, X.n\_slices, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{615   }
\DoxyCodeLine{616   arrayops::convert( out.memptr(), X.memptr(), X.n\_elem );}
\DoxyCodeLine{617   }
\DoxyCodeLine{618   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{619   \}}
\DoxyCodeLine{620 }
\DoxyCodeLine{621 }
\DoxyCodeLine{622 }
\DoxyCodeLine{623 \textcolor{keyword}{template}<\textcolor{keyword}{typename} out\_eT>}
\DoxyCodeLine{624 \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{625 arma\_warn\_unused}
\DoxyCodeLine{626 \textcolor{keyword}{inline}}
\DoxyCodeLine{627 \mbox{\hyperlink{classCube}{Cube<out\_eT>}}}
\DoxyCodeLine{628 \mbox{\hyperlink{classconv__to}{conv\_to< Cube<out\_eT>}} >::from(\textcolor{keyword}{const} \mbox{\hyperlink{structBaseCube}{BaseCube<in\_eT, T1>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<in\_eT>::result}}* junk)}
\DoxyCodeLine{629   \{}
\DoxyCodeLine{630   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{631   arma\_ignore(junk);}
\DoxyCodeLine{632   }
\DoxyCodeLine{633   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap__cube}{unwrap\_cube<T1>}}  tmp( in.get\_ref() );}
\DoxyCodeLine{634   \textcolor{keyword}{const} \mbox{\hyperlink{classCube}{Cube<in\_eT>}}\& X = tmp.M;}
\DoxyCodeLine{635   }
\DoxyCodeLine{636   \mbox{\hyperlink{classCube}{Cube<out\_eT>}} out(X.n\_rows, X.n\_cols, X.n\_slices, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{637   }
\DoxyCodeLine{638   arrayops::convert\_cx( out.memptr(), X.memptr(), X.n\_elem );}
\DoxyCodeLine{639   }
\DoxyCodeLine{640   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{641   \}}
\DoxyCodeLine{642 }
\DoxyCodeLine{643 }
\DoxyCodeLine{644 }
\DoxyCodeLine{646 \textcolor{keyword}{template}<\textcolor{keyword}{typename} out\_eT>}
\DoxyCodeLine{647 \textcolor{keyword}{class }\mbox{\hyperlink{classconv__to}{conv\_to}}< std::vector<out\_eT> >}
\DoxyCodeLine{648   \{}
\DoxyCodeLine{649   \textcolor{keyword}{public}:}
\DoxyCodeLine{650   }
\DoxyCodeLine{651   \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{652   \textcolor{keyword}{inline} \textcolor{keyword}{static} std::vector<out\_eT> from(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<in\_eT, T1>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<in\_eT>::result* junk = \textcolor{keyword}{nullptr});}
\DoxyCodeLine{653   }
\DoxyCodeLine{654   \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{655   \textcolor{keyword}{inline} \textcolor{keyword}{static} std::vector<out\_eT> from(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<in\_eT, T1>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<in\_eT>::result}}* junk = \textcolor{keyword}{nullptr});}
\DoxyCodeLine{656   \};}
\DoxyCodeLine{657 }
\DoxyCodeLine{658 }
\DoxyCodeLine{659 }
\DoxyCodeLine{660 \textcolor{keyword}{template}<\textcolor{keyword}{typename} out\_eT>}
\DoxyCodeLine{661 \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{662 arma\_warn\_unused}
\DoxyCodeLine{663 \textcolor{keyword}{inline}}
\DoxyCodeLine{664 std::vector<out\_eT>}
\DoxyCodeLine{665 \mbox{\hyperlink{classconv__to}{conv\_to< std::vector<out\_eT>}} >::from(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<in\_eT, T1>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<in\_eT>::result* junk)}
\DoxyCodeLine{666   \{}
\DoxyCodeLine{667   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{668   arma\_ignore(junk);}
\DoxyCodeLine{669   }
\DoxyCodeLine{670   \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} tmp(in.get\_ref());}
\DoxyCodeLine{671   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<in\_eT>}}\& X  = tmp.M;}
\DoxyCodeLine{672   }
\DoxyCodeLine{673   arma\_debug\_check( ( (X.is\_vec() == \textcolor{keyword}{false}) \&\& (X.is\_empty() == \textcolor{keyword}{false}) ), \textcolor{stringliteral}{"{}conv\_to(): given object can't be interpreted as a vector"{}} );}
\DoxyCodeLine{674   }
\DoxyCodeLine{675   \textcolor{keyword}{const} uword N = X.n\_elem;}
\DoxyCodeLine{676   }
\DoxyCodeLine{677   std::vector<out\_eT> out(N);}
\DoxyCodeLine{678   }
\DoxyCodeLine{679   \textcolor{keywordflow}{if}(N > 0)}
\DoxyCodeLine{680     \{}
\DoxyCodeLine{681     arrayops::convert( \&(out[0]), X.memptr(), N );}
\DoxyCodeLine{682     \}}
\DoxyCodeLine{683   }
\DoxyCodeLine{684   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{685   \}}
\DoxyCodeLine{686 }
\DoxyCodeLine{687 }
\DoxyCodeLine{688 }
\DoxyCodeLine{689 \textcolor{keyword}{template}<\textcolor{keyword}{typename} out\_eT>}
\DoxyCodeLine{690 \textcolor{keyword}{template}<\textcolor{keyword}{typename} in\_eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{691 arma\_warn\_unused}
\DoxyCodeLine{692 \textcolor{keyword}{inline}}
\DoxyCodeLine{693 std::vector<out\_eT>}
\DoxyCodeLine{694 \mbox{\hyperlink{classconv__to}{conv\_to< std::vector<out\_eT>}} >::from(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<in\_eT, T1>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<in\_eT>::result}}* junk)}
\DoxyCodeLine{695   \{}
\DoxyCodeLine{696   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{697   arma\_ignore(junk);}
\DoxyCodeLine{698   }
\DoxyCodeLine{699   \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} tmp(in.get\_ref());}
\DoxyCodeLine{700   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<in\_eT>}}\& X  = tmp.M;}
\DoxyCodeLine{701   }
\DoxyCodeLine{702   arma\_debug\_check( ( (X.is\_vec() == \textcolor{keyword}{false}) \&\& (X.is\_empty() == \textcolor{keyword}{false}) ), \textcolor{stringliteral}{"{}conv\_to(): given object can't be interpreted as a vector"{}} );}
\DoxyCodeLine{703   }
\DoxyCodeLine{704   \textcolor{keyword}{const} uword N = X.n\_elem;}
\DoxyCodeLine{705   }
\DoxyCodeLine{706   std::vector<out\_eT> out(N);}
\DoxyCodeLine{707   }
\DoxyCodeLine{708   \textcolor{keywordflow}{if}(N > 0)}
\DoxyCodeLine{709     \{}
\DoxyCodeLine{710     arrayops::convert\_cx( \&(out[0]), X.memptr(), N );}
\DoxyCodeLine{711     \}}
\DoxyCodeLine{712   }
\DoxyCodeLine{713   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{714   \}}
\DoxyCodeLine{715 }
\DoxyCodeLine{716 }
\DoxyCodeLine{717 }

\end{DoxyCode}
