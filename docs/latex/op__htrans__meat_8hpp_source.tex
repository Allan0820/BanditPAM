\hypertarget{op__htrans__meat_8hpp_source}{}\doxysection{op\+\_\+htrans\+\_\+meat.\+hpp}
\label{op__htrans__meat_8hpp_source}\index{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/op\_htrans\_meat.hpp@{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/op\_htrans\_meat.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008-\/2016 Conrad Sanderson (http://conradsanderson.id.au)}}
\DoxyCodeLine{2 \textcolor{comment}{// Copyright 2008-\/2016 National ICT Australia (NICTA)}}
\DoxyCodeLine{3 \textcolor{comment}{// }}
\DoxyCodeLine{4 \textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{5 \textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{6 \textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{7 \textcolor{comment}{// http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{8 \textcolor{comment}{// }}
\DoxyCodeLine{9 \textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{10 \textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{11 \textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{12 \textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{13 \textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{14 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{19 }
\DoxyCodeLine{20 }
\DoxyCodeLine{21 }
\DoxyCodeLine{22 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{23 arma\_inline}
\DoxyCodeLine{24 \textcolor{keywordtype}{void}}
\DoxyCodeLine{25 op\_htrans::apply\_mat\_noalias(\mbox{\hyperlink{classMat}{Mat<eT>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<eT>::result* junk)}
\DoxyCodeLine{26   \{}
\DoxyCodeLine{27   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{28   arma\_ignore(junk);}
\DoxyCodeLine{29   }
\DoxyCodeLine{30   \mbox{\hyperlink{group__op__strans_gafd56208012c4a9b31acbeaf21cfa63cc}{op\_strans::apply\_mat\_noalias}}(out, \mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{31   \}}
\DoxyCodeLine{32 }
\DoxyCodeLine{33 }
\DoxyCodeLine{34 }
\DoxyCodeLine{35 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{36 arma\_hot}
\DoxyCodeLine{37 \textcolor{keyword}{inline}}
\DoxyCodeLine{38 \textcolor{keywordtype}{void}}
\DoxyCodeLine{39 op\_htrans::apply\_mat\_noalias(\mbox{\hyperlink{classMat}{Mat<eT>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<eT>::result}}* junk)}
\DoxyCodeLine{40   \{}
\DoxyCodeLine{41   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{42   arma\_ignore(junk);}
\DoxyCodeLine{43   }
\DoxyCodeLine{44   \textcolor{keyword}{const} uword A\_n\_rows = \mbox{\hyperlink{structA}{A}}.n\_rows;}
\DoxyCodeLine{45   \textcolor{keyword}{const} uword A\_n\_cols = \mbox{\hyperlink{structA}{A}}.n\_cols;}
\DoxyCodeLine{46   }
\DoxyCodeLine{47   out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(A\_n\_cols, A\_n\_rows);}
\DoxyCodeLine{48   }
\DoxyCodeLine{49   \textcolor{keywordflow}{if}( (A\_n\_cols == 1) || (A\_n\_rows == 1) )}
\DoxyCodeLine{50     \{}
\DoxyCodeLine{51     \textcolor{keyword}{const} uword n\_elem = \mbox{\hyperlink{structA}{A}}.n\_elem;}
\DoxyCodeLine{52     }
\DoxyCodeLine{53     \textcolor{keyword}{const} eT* A\_mem   = \mbox{\hyperlink{structA}{A}}.memptr();}
\DoxyCodeLine{54           eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{55     }
\DoxyCodeLine{56     \textcolor{keywordflow}{for}(uword i=0; i < n\_elem; ++i)}
\DoxyCodeLine{57       \{}
\DoxyCodeLine{58       out\_mem[i] = std::conj(A\_mem[i]);}
\DoxyCodeLine{59       \}}
\DoxyCodeLine{60     \}}
\DoxyCodeLine{61   \textcolor{keywordflow}{else}}
\DoxyCodeLine{62   \textcolor{keywordflow}{if}( (A\_n\_rows >= 512) \&\& (A\_n\_cols >= 512) )}
\DoxyCodeLine{63     \{}
\DoxyCodeLine{64     op\_htrans::apply\_mat\_noalias\_large(out, \mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{65     \}}
\DoxyCodeLine{66   \textcolor{keywordflow}{else}}
\DoxyCodeLine{67     \{}
\DoxyCodeLine{68     eT* outptr = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{69     }
\DoxyCodeLine{70     \textcolor{keywordflow}{for}(uword k=0; k < A\_n\_rows; ++k)}
\DoxyCodeLine{71       \{}
\DoxyCodeLine{72       \textcolor{keyword}{const} eT* Aptr = \&(\mbox{\hyperlink{structA}{A}}.at(k,0));}
\DoxyCodeLine{73       }
\DoxyCodeLine{74       \textcolor{keywordflow}{for}(uword j=0; j < A\_n\_cols; ++j)}
\DoxyCodeLine{75         \{}
\DoxyCodeLine{76         (*outptr) = std::conj(*Aptr);}
\DoxyCodeLine{77         }
\DoxyCodeLine{78         Aptr += A\_n\_rows;}
\DoxyCodeLine{79         outptr++;}
\DoxyCodeLine{80         \}}
\DoxyCodeLine{81       \}}
\DoxyCodeLine{82     \}}
\DoxyCodeLine{83   \}}
\DoxyCodeLine{84 }
\DoxyCodeLine{85 }
\DoxyCodeLine{86 }
\DoxyCodeLine{87 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{88 arma\_hot}
\DoxyCodeLine{89 \textcolor{keyword}{inline}}
\DoxyCodeLine{90 \textcolor{keywordtype}{void}}
\DoxyCodeLine{91 op\_htrans::block\_worker(std::complex<T>* Y, \textcolor{keyword}{const} std::complex<T>* X, \textcolor{keyword}{const} uword X\_n\_rows, \textcolor{keyword}{const} uword Y\_n\_rows, \textcolor{keyword}{const} uword n\_rows, \textcolor{keyword}{const} uword n\_cols)}
\DoxyCodeLine{92   \{}
\DoxyCodeLine{93   \textcolor{keywordflow}{for}(uword row = 0; row < n\_rows; ++row)}
\DoxyCodeLine{94     \{}
\DoxyCodeLine{95     \textcolor{keyword}{const} uword Y\_offset = row * Y\_n\_rows;}
\DoxyCodeLine{96     }
\DoxyCodeLine{97     \textcolor{keywordflow}{for}(uword col = 0; col < n\_cols; ++col)}
\DoxyCodeLine{98       \{}
\DoxyCodeLine{99       \textcolor{keyword}{const} uword X\_offset = col * X\_n\_rows;}
\DoxyCodeLine{100       }
\DoxyCodeLine{101       Y[col + Y\_offset] = std::conj(X[row + X\_offset]);}
\DoxyCodeLine{102       \}}
\DoxyCodeLine{103     \}}
\DoxyCodeLine{104   \}}
\DoxyCodeLine{105 }
\DoxyCodeLine{106 }
\DoxyCodeLine{107 }
\DoxyCodeLine{108 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{109 arma\_hot}
\DoxyCodeLine{110 \textcolor{keyword}{inline}}
\DoxyCodeLine{111 \textcolor{keywordtype}{void}}
\DoxyCodeLine{112 op\_htrans::apply\_mat\_noalias\_large(\mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& \mbox{\hyperlink{structA}{A}})}
\DoxyCodeLine{113   \{}
\DoxyCodeLine{114   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{115   }
\DoxyCodeLine{116   \textcolor{keyword}{const} uword n\_rows = \mbox{\hyperlink{structA}{A}}.n\_rows;}
\DoxyCodeLine{117   \textcolor{keyword}{const} uword n\_cols = \mbox{\hyperlink{structA}{A}}.n\_cols;}
\DoxyCodeLine{118   }
\DoxyCodeLine{119   \textcolor{keyword}{const} uword block\_size = 64;}
\DoxyCodeLine{120   }
\DoxyCodeLine{121   \textcolor{keyword}{const} uword n\_rows\_base = block\_size * (n\_rows / block\_size);}
\DoxyCodeLine{122   \textcolor{keyword}{const} uword n\_cols\_base = block\_size * (n\_cols / block\_size);}
\DoxyCodeLine{123   }
\DoxyCodeLine{124   \textcolor{keyword}{const} uword n\_rows\_extra = n\_rows -\/ n\_rows\_base;}
\DoxyCodeLine{125   \textcolor{keyword}{const} uword n\_cols\_extra = n\_cols -\/ n\_cols\_base;}
\DoxyCodeLine{126   }
\DoxyCodeLine{127   \textcolor{keyword}{const} std::complex<T>* X =   \mbox{\hyperlink{structA}{A}}.memptr();}
\DoxyCodeLine{128         std::complex<T>* Y = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{129   }
\DoxyCodeLine{130   \textcolor{keywordflow}{for}(uword row = 0; row < n\_rows\_base; row += block\_size)}
\DoxyCodeLine{131     \{}
\DoxyCodeLine{132     \textcolor{keyword}{const} uword Y\_offset = row * n\_cols;}
\DoxyCodeLine{133     }
\DoxyCodeLine{134     \textcolor{keywordflow}{for}(uword col = 0; col < n\_cols\_base; col += block\_size)}
\DoxyCodeLine{135       \{}
\DoxyCodeLine{136       \textcolor{keyword}{const} uword X\_offset = col * n\_rows;}
\DoxyCodeLine{137       }
\DoxyCodeLine{138       op\_htrans::block\_worker(\&Y[col + Y\_offset], \&X[row + X\_offset], n\_rows, n\_cols, block\_size, block\_size);}
\DoxyCodeLine{139       \}}
\DoxyCodeLine{140     }
\DoxyCodeLine{141     \textcolor{keyword}{const} uword X\_offset = n\_cols\_base * n\_rows;}
\DoxyCodeLine{142     }
\DoxyCodeLine{143     op\_htrans::block\_worker(\&Y[n\_cols\_base + Y\_offset], \&X[row + X\_offset], n\_rows, n\_cols, block\_size, n\_cols\_extra);}
\DoxyCodeLine{144     \}}
\DoxyCodeLine{145 }
\DoxyCodeLine{146   \textcolor{keywordflow}{if}(n\_rows\_extra == 0)  \{ \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{147   }
\DoxyCodeLine{148   \textcolor{keyword}{const} uword Y\_offset = n\_rows\_base * n\_cols;}
\DoxyCodeLine{149   }
\DoxyCodeLine{150   \textcolor{keywordflow}{for}(uword col = 0; col < n\_cols\_base; col += block\_size)}
\DoxyCodeLine{151     \{}
\DoxyCodeLine{152     \textcolor{keyword}{const} uword X\_offset = col * n\_rows;}
\DoxyCodeLine{153     }
\DoxyCodeLine{154     op\_htrans::block\_worker(\&Y[col + Y\_offset], \&X[n\_rows\_base + X\_offset], n\_rows, n\_cols, n\_rows\_extra, block\_size);}
\DoxyCodeLine{155     \}}
\DoxyCodeLine{156   }
\DoxyCodeLine{157   \textcolor{keyword}{const} uword X\_offset = n\_cols\_base * n\_rows;}
\DoxyCodeLine{158   }
\DoxyCodeLine{159   op\_htrans::block\_worker(\&Y[n\_cols\_base + Y\_offset], \&X[n\_rows\_base + X\_offset], n\_rows, n\_cols, n\_rows\_extra, n\_cols\_extra);}
\DoxyCodeLine{160   \}}
\DoxyCodeLine{161 }
\DoxyCodeLine{162 }
\DoxyCodeLine{163 }
\DoxyCodeLine{164 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{165 arma\_inline}
\DoxyCodeLine{166 \textcolor{keywordtype}{void}}
\DoxyCodeLine{167 op\_htrans::apply\_mat\_inplace(\mbox{\hyperlink{classMat}{Mat<eT>}}\& out, \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<eT>::result* junk)}
\DoxyCodeLine{168   \{}
\DoxyCodeLine{169   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{170   arma\_ignore(junk);}
\DoxyCodeLine{171   }
\DoxyCodeLine{172   op\_strans::apply\_mat\_inplace(out);}
\DoxyCodeLine{173   \}}
\DoxyCodeLine{174 }
\DoxyCodeLine{175 }
\DoxyCodeLine{176 }
\DoxyCodeLine{177 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{178 arma\_hot}
\DoxyCodeLine{179 \textcolor{keyword}{inline}}
\DoxyCodeLine{180 \textcolor{keywordtype}{void}}
\DoxyCodeLine{181 op\_htrans::apply\_mat\_inplace(\mbox{\hyperlink{classMat}{Mat<eT>}}\& out, \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<eT>::result}}* junk)}
\DoxyCodeLine{182   \{}
\DoxyCodeLine{183   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{184   arma\_ignore(junk);}
\DoxyCodeLine{185   }
\DoxyCodeLine{186   \textcolor{keyword}{const} uword n\_rows = out.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}};}
\DoxyCodeLine{187   \textcolor{keyword}{const} uword n\_cols = out.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}};}
\DoxyCodeLine{188     }
\DoxyCodeLine{189   \textcolor{keywordflow}{if}(n\_rows == n\_cols)}
\DoxyCodeLine{190     \{}
\DoxyCodeLine{191     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}doing in-\/place hermitian transpose of a square matrix"{}});}
\DoxyCodeLine{192     }
\DoxyCodeLine{193     \textcolor{keywordflow}{for}(uword col=0; col < n\_cols; ++col)}
\DoxyCodeLine{194       \{}
\DoxyCodeLine{195       eT* coldata = out.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(col);}
\DoxyCodeLine{196       }
\DoxyCodeLine{197       out.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(col,col) = std::conj( out.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(col,col) );}
\DoxyCodeLine{198       }
\DoxyCodeLine{199       \textcolor{keywordflow}{for}(uword row=(col+1); row < n\_rows; ++row)}
\DoxyCodeLine{200         \{}
\DoxyCodeLine{201         \textcolor{keyword}{const} eT val1 = std::conj(coldata[row]);}
\DoxyCodeLine{202         \textcolor{keyword}{const} eT val2 = std::conj(out.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(col,row));}
\DoxyCodeLine{203         }
\DoxyCodeLine{204         out.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(col,row) = val1;}
\DoxyCodeLine{205         coldata[row]    = val2;}
\DoxyCodeLine{206         \}}
\DoxyCodeLine{207       \}}
\DoxyCodeLine{208     \}}
\DoxyCodeLine{209   \textcolor{keywordflow}{else}}
\DoxyCodeLine{210     \{}
\DoxyCodeLine{211     \mbox{\hyperlink{classMat}{Mat<eT>}} tmp;}
\DoxyCodeLine{212     }
\DoxyCodeLine{213     op\_htrans::apply\_mat\_noalias(tmp, out);}
\DoxyCodeLine{214     }
\DoxyCodeLine{215     out.\mbox{\hyperlink{group__Mat_gaff06a75771f96605f7cc4f8c6b3fceb7}{steal\_mem}}(tmp);}
\DoxyCodeLine{216     \}}
\DoxyCodeLine{217   \}}
\DoxyCodeLine{218 }
\DoxyCodeLine{219 }
\DoxyCodeLine{220 }
\DoxyCodeLine{221 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{222 arma\_inline}
\DoxyCodeLine{223 \textcolor{keywordtype}{void}}
\DoxyCodeLine{224 op\_htrans::apply\_mat(\mbox{\hyperlink{classMat}{Mat<eT>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<eT>::result* junk)}
\DoxyCodeLine{225   \{}
\DoxyCodeLine{226   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{227   arma\_ignore(junk);}
\DoxyCodeLine{228   }
\DoxyCodeLine{229   op\_strans::apply\_mat(out, \mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{230   \}}
\DoxyCodeLine{231 }
\DoxyCodeLine{232 }
\DoxyCodeLine{233 }
\DoxyCodeLine{234 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{235 arma\_hot}
\DoxyCodeLine{236 \textcolor{keyword}{inline}}
\DoxyCodeLine{237 \textcolor{keywordtype}{void}}
\DoxyCodeLine{238 op\_htrans::apply\_mat(\mbox{\hyperlink{classMat}{Mat<eT>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<eT>::result}}* junk)}
\DoxyCodeLine{239   \{}
\DoxyCodeLine{240   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{241   arma\_ignore(junk);}
\DoxyCodeLine{242   }
\DoxyCodeLine{243   \textcolor{keywordflow}{if}(\&out != \&\mbox{\hyperlink{structA}{A}})}
\DoxyCodeLine{244     \{}
\DoxyCodeLine{245     op\_htrans::apply\_mat\_noalias(out, \mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{246     \}}
\DoxyCodeLine{247   \textcolor{keywordflow}{else}}
\DoxyCodeLine{248     \{}
\DoxyCodeLine{249     op\_htrans::apply\_mat\_inplace(out);}
\DoxyCodeLine{250     \}}
\DoxyCodeLine{251   \}}
\DoxyCodeLine{252 }
\DoxyCodeLine{253 }
\DoxyCodeLine{254 }
\DoxyCodeLine{255 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{256 arma\_hot}
\DoxyCodeLine{257 \textcolor{keyword}{inline}}
\DoxyCodeLine{258 \textcolor{keywordtype}{void}}
\DoxyCodeLine{259 op\_htrans::apply\_proxy(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} T1\& X)}
\DoxyCodeLine{260   \{}
\DoxyCodeLine{261   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{262   }
\DoxyCodeLine{263   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{264   }
\DoxyCodeLine{265   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} P(X);}
\DoxyCodeLine{266   }
\DoxyCodeLine{267   \textcolor{keyword}{const} uword n\_rows = P.get\_n\_rows();}
\DoxyCodeLine{268   \textcolor{keyword}{const} uword n\_cols = P.get\_n\_cols();}
\DoxyCodeLine{269   }
\DoxyCodeLine{270   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} is\_alias = P.is\_alias(out);}
\DoxyCodeLine{271   }
\DoxyCodeLine{272   \textcolor{keywordflow}{if}( (\mbox{\hyperlink{structresolves__to__vector}{resolves\_to\_vector<T1>::yes}}) \&\& (\mbox{\hyperlink{classProxy}{Proxy<T1>::use\_at}} == \textcolor{keyword}{false}) )}
\DoxyCodeLine{273     \{}
\DoxyCodeLine{274     \textcolor{keywordflow}{if}(is\_alias == \textcolor{keyword}{false})}
\DoxyCodeLine{275       \{}
\DoxyCodeLine{276       out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(n\_cols, n\_rows);}
\DoxyCodeLine{277       }
\DoxyCodeLine{278       eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{279       }
\DoxyCodeLine{280       \textcolor{keyword}{const} uword n\_elem = P.get\_n\_elem();}
\DoxyCodeLine{281       }
\DoxyCodeLine{282       \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::ea\_type}} Pea = P.get\_ea();}
\DoxyCodeLine{283       }
\DoxyCodeLine{284       \textcolor{keywordflow}{for}(uword i=0; i < n\_elem; ++i)}
\DoxyCodeLine{285         \{}
\DoxyCodeLine{286         out\_mem[i] = std::conj(Pea[i]);}
\DoxyCodeLine{287         \}}
\DoxyCodeLine{288       \}}
\DoxyCodeLine{289     \textcolor{keywordflow}{else}  \textcolor{comment}{// aliasing}}
\DoxyCodeLine{290       \{}
\DoxyCodeLine{291       \mbox{\hyperlink{classMat}{Mat<eT>}} out2(n\_cols, n\_rows, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{292       }
\DoxyCodeLine{293       eT* out\_mem = out2.memptr();}
\DoxyCodeLine{294       }
\DoxyCodeLine{295       \textcolor{keyword}{const} uword n\_elem = P.get\_n\_elem();}
\DoxyCodeLine{296       }
\DoxyCodeLine{297       \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::ea\_type}} Pea = P.get\_ea();}
\DoxyCodeLine{298       }
\DoxyCodeLine{299       \textcolor{keywordflow}{for}(uword i=0; i < n\_elem; ++i)}
\DoxyCodeLine{300         \{}
\DoxyCodeLine{301         out\_mem[i] = std::conj(Pea[i]);}
\DoxyCodeLine{302         \}}
\DoxyCodeLine{303       }
\DoxyCodeLine{304       out.\mbox{\hyperlink{group__Mat_gaff06a75771f96605f7cc4f8c6b3fceb7}{steal\_mem}}(out2);}
\DoxyCodeLine{305       \}}
\DoxyCodeLine{306     \}}
\DoxyCodeLine{307   \textcolor{keywordflow}{else}}
\DoxyCodeLine{308     \{}
\DoxyCodeLine{309     \textcolor{keywordflow}{if}(is\_alias == \textcolor{keyword}{false})}
\DoxyCodeLine{310       \{}
\DoxyCodeLine{311       out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(n\_cols, n\_rows);}
\DoxyCodeLine{312       }
\DoxyCodeLine{313       eT* outptr = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{314       }
\DoxyCodeLine{315       \textcolor{keywordflow}{for}(uword k=0; k < n\_rows; ++k)}
\DoxyCodeLine{316         \{}
\DoxyCodeLine{317         \textcolor{keywordflow}{for}(uword j=0; j < n\_cols; ++j)}
\DoxyCodeLine{318           \{}
\DoxyCodeLine{319           (*outptr) = std::conj(P.at(k,j));}
\DoxyCodeLine{320           }
\DoxyCodeLine{321           outptr++;}
\DoxyCodeLine{322           \}}
\DoxyCodeLine{323         \}}
\DoxyCodeLine{324       \}}
\DoxyCodeLine{325     \textcolor{keywordflow}{else} \textcolor{comment}{// aliasing}}
\DoxyCodeLine{326       \{}
\DoxyCodeLine{327       \mbox{\hyperlink{classMat}{Mat<eT>}} out2(n\_cols, n\_rows, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{328       }
\DoxyCodeLine{329       eT* out2ptr = out2.memptr();}
\DoxyCodeLine{330       }
\DoxyCodeLine{331       \textcolor{keywordflow}{for}(uword k=0; k < n\_rows; ++k)}
\DoxyCodeLine{332         \{}
\DoxyCodeLine{333         \textcolor{keywordflow}{for}(uword j=0; j < n\_cols; ++j)}
\DoxyCodeLine{334           \{}
\DoxyCodeLine{335           (*out2ptr) = std::conj(P.at(k,j));}
\DoxyCodeLine{336           }
\DoxyCodeLine{337           out2ptr++;}
\DoxyCodeLine{338           \}}
\DoxyCodeLine{339         \}}
\DoxyCodeLine{340       }
\DoxyCodeLine{341       out.\mbox{\hyperlink{group__Mat_gaff06a75771f96605f7cc4f8c6b3fceb7}{steal\_mem}}(out2);}
\DoxyCodeLine{342       \}}
\DoxyCodeLine{343     \}}
\DoxyCodeLine{344   \}}
\DoxyCodeLine{345 }
\DoxyCodeLine{346 }
\DoxyCodeLine{347 }
\DoxyCodeLine{348 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{349 arma\_hot}
\DoxyCodeLine{350 \textcolor{keyword}{inline}}
\DoxyCodeLine{351 \textcolor{keywordtype}{void}}
\DoxyCodeLine{352 op\_htrans::apply\_direct(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} T1\& X)}
\DoxyCodeLine{353   \{}
\DoxyCodeLine{354   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{355   }
\DoxyCodeLine{356   \textcolor{comment}{// allow detection of in-\/place transpose}}
\DoxyCodeLine{357   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__Mat}{is\_Mat<T1>::value}} || \mbox{\hyperlink{structis__Mat}{is\_Mat}}<\textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::stored\_type}}>::value || (arma\_config::openmp \&\& \mbox{\hyperlink{classProxy}{Proxy<T1>::use\_mp}}))}
\DoxyCodeLine{358     \{}
\DoxyCodeLine{359     \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap}{unwrap<T1>}} U(X);}
\DoxyCodeLine{360     }
\DoxyCodeLine{361     op\_htrans::apply\_mat(out, U.M);}
\DoxyCodeLine{362     \}}
\DoxyCodeLine{363   \textcolor{keywordflow}{else}}
\DoxyCodeLine{364     \{}
\DoxyCodeLine{365     op\_htrans::apply\_proxy(out, X);}
\DoxyCodeLine{366     \}}
\DoxyCodeLine{367   \}}
\DoxyCodeLine{368 }
\DoxyCodeLine{369 }
\DoxyCodeLine{370 }
\DoxyCodeLine{371 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{372 arma\_hot}
\DoxyCodeLine{373 \textcolor{keyword}{inline}}
\DoxyCodeLine{374 \textcolor{keywordtype}{void}}
\DoxyCodeLine{375 op\_htrans::apply(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T1,op\_htrans>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<typename T1::elem\_type>::result* junk)}
\DoxyCodeLine{376   \{}
\DoxyCodeLine{377   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{378   arma\_ignore(junk);}
\DoxyCodeLine{379   }
\DoxyCodeLine{380   op\_strans::apply\_direct(out, in.\mbox{\hyperlink{classOp_af7ab7221b6e233cdd38b9f9b69f301ce}{m}});}
\DoxyCodeLine{381   \}}
\DoxyCodeLine{382 }
\DoxyCodeLine{383 }
\DoxyCodeLine{384 }
\DoxyCodeLine{385 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{386 arma\_hot}
\DoxyCodeLine{387 \textcolor{keyword}{inline}}
\DoxyCodeLine{388 \textcolor{keywordtype}{void}}
\DoxyCodeLine{389 op\_htrans::apply(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T1,op\_htrans>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<typename T1::elem\_type>::result}}* junk)}
\DoxyCodeLine{390   \{}
\DoxyCodeLine{391   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{392   arma\_ignore(junk);}
\DoxyCodeLine{393   }
\DoxyCodeLine{394   op\_htrans::apply\_direct(out, in.\mbox{\hyperlink{classOp_af7ab7221b6e233cdd38b9f9b69f301ce}{m}});}
\DoxyCodeLine{395   \}}
\DoxyCodeLine{396 }
\DoxyCodeLine{397 }
\DoxyCodeLine{398 }
\DoxyCodeLine{399 \textcolor{comment}{//}}
\DoxyCodeLine{400 \textcolor{comment}{// op\_htrans2}}
\DoxyCodeLine{401 }
\DoxyCodeLine{402 }
\DoxyCodeLine{403 }
\DoxyCodeLine{404 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{405 \textcolor{keyword}{inline}}
\DoxyCodeLine{406 \textcolor{keywordtype}{void}}
\DoxyCodeLine{407 op\_htrans2::apply(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T1,op\_htrans2>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<typename T1::elem\_type>::result* junk)}
\DoxyCodeLine{408   \{}
\DoxyCodeLine{409   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{410   arma\_ignore(junk);}
\DoxyCodeLine{411   }
\DoxyCodeLine{412   op\_strans::apply\_direct(out, in.\mbox{\hyperlink{classOp_af7ab7221b6e233cdd38b9f9b69f301ce}{m}});}
\DoxyCodeLine{413   }
\DoxyCodeLine{414   arrayops::inplace\_mul(out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), in.\mbox{\hyperlink{classOp_a6bedb670e7a17e7f713333b55aaacf9a}{aux}}, out.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}});}
\DoxyCodeLine{415   \}}
\DoxyCodeLine{416 }
\DoxyCodeLine{417 }
\DoxyCodeLine{418 }
\DoxyCodeLine{419 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{420 \textcolor{keyword}{inline}}
\DoxyCodeLine{421 \textcolor{keywordtype}{void}}
\DoxyCodeLine{422 op\_htrans2::apply(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T1,op\_htrans2>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<typename T1::elem\_type>::result}}* junk)}
\DoxyCodeLine{423   \{}
\DoxyCodeLine{424   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{425   arma\_ignore(junk);}
\DoxyCodeLine{426   }
\DoxyCodeLine{427   op\_htrans::apply\_direct(out, in.\mbox{\hyperlink{classOp_af7ab7221b6e233cdd38b9f9b69f301ce}{m}});}
\DoxyCodeLine{428   }
\DoxyCodeLine{429   arrayops::inplace\_mul(out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), in.\mbox{\hyperlink{classOp_a6bedb670e7a17e7f713333b55aaacf9a}{aux}}, out.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}});}
\DoxyCodeLine{430   \}}
\DoxyCodeLine{431 }
\DoxyCodeLine{432 }
\DoxyCodeLine{433 }

\end{DoxyCode}
