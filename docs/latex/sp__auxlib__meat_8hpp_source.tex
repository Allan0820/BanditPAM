\hypertarget{sp__auxlib__meat_8hpp_source}{}\doxysection{sp\+\_\+auxlib\+\_\+meat.\+hpp}
\label{sp__auxlib__meat_8hpp_source}\index{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/sp\_auxlib\_meat.hpp@{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/sp\_auxlib\_meat.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008-\/2016 Conrad Sanderson (http://conradsanderson.id.au)}}
\DoxyCodeLine{2 \textcolor{comment}{// Copyright 2008-\/2016 National ICT Australia (NICTA)}}
\DoxyCodeLine{3 \textcolor{comment}{// }}
\DoxyCodeLine{4 \textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{5 \textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{6 \textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{7 \textcolor{comment}{// http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{8 \textcolor{comment}{// }}
\DoxyCodeLine{9 \textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{10 \textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{11 \textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{12 \textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{13 \textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{14 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{19 }
\DoxyCodeLine{20 }
\DoxyCodeLine{21 \textcolor{keyword}{inline}}
\DoxyCodeLine{22 sp\_auxlib::form\_type}
\DoxyCodeLine{23 sp\_auxlib::interpret\_form\_str(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* form\_str)}
\DoxyCodeLine{24   \{}
\DoxyCodeLine{25   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{26   }
\DoxyCodeLine{27   \textcolor{comment}{// the order of the 3 if statements below is important}}
\DoxyCodeLine{28   \textcolor{keywordflow}{if}( form\_str    == \textcolor{keyword}{nullptr} )  \{ \textcolor{keywordflow}{return} form\_none; \}}
\DoxyCodeLine{29   \textcolor{keywordflow}{if}( form\_str[0] == \textcolor{keywordtype}{char}(0) )  \{ \textcolor{keywordflow}{return} form\_none; \}}
\DoxyCodeLine{30   \textcolor{keywordflow}{if}( form\_str[1] == \textcolor{keywordtype}{char}(0) )  \{ \textcolor{keywordflow}{return} form\_none; \}}
\DoxyCodeLine{31   }
\DoxyCodeLine{32   \textcolor{keyword}{const} \textcolor{keywordtype}{char} c1 = form\_str[0];}
\DoxyCodeLine{33   \textcolor{keyword}{const} \textcolor{keywordtype}{char} c2 = form\_str[1];}
\DoxyCodeLine{34   }
\DoxyCodeLine{35   \textcolor{keywordflow}{if}(c1 == \textcolor{charliteral}{'l'})}
\DoxyCodeLine{36     \{}
\DoxyCodeLine{37     \textcolor{keywordflow}{if}(c2 == \textcolor{charliteral}{'m'})  \{ \textcolor{keywordflow}{return} form\_lm; \}}
\DoxyCodeLine{38     \textcolor{keywordflow}{if}(c2 == \textcolor{charliteral}{'r'})  \{ \textcolor{keywordflow}{return} form\_lr; \}}
\DoxyCodeLine{39     \textcolor{keywordflow}{if}(c2 == \textcolor{charliteral}{'i'})  \{ \textcolor{keywordflow}{return} form\_li; \}}
\DoxyCodeLine{40     \textcolor{keywordflow}{if}(c2 == \textcolor{charliteral}{'a'})  \{ \textcolor{keywordflow}{return} form\_la; \}}
\DoxyCodeLine{41     \}}
\DoxyCodeLine{42   \textcolor{keywordflow}{else}}
\DoxyCodeLine{43   \textcolor{keywordflow}{if}(c1 == \textcolor{charliteral}{'s'})}
\DoxyCodeLine{44     \{}
\DoxyCodeLine{45     \textcolor{keywordflow}{if}(c2 == \textcolor{charliteral}{'m'})  \{ \textcolor{keywordflow}{return} form\_sm; \}}
\DoxyCodeLine{46     \textcolor{keywordflow}{if}(c2 == \textcolor{charliteral}{'r'})  \{ \textcolor{keywordflow}{return} form\_sr; \}}
\DoxyCodeLine{47     \textcolor{keywordflow}{if}(c2 == \textcolor{charliteral}{'i'})  \{ \textcolor{keywordflow}{return} form\_si; \}}
\DoxyCodeLine{48     \textcolor{keywordflow}{if}(c2 == \textcolor{charliteral}{'a'})  \{ \textcolor{keywordflow}{return} form\_sa; \}}
\DoxyCodeLine{49     \}}
\DoxyCodeLine{50   }
\DoxyCodeLine{51   \textcolor{keywordflow}{return} form\_none;}
\DoxyCodeLine{52   \}}
\DoxyCodeLine{53 }
\DoxyCodeLine{54 }
\DoxyCodeLine{55 }
\DoxyCodeLine{57 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{58 \textcolor{keyword}{inline}}
\DoxyCodeLine{59 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{60 \mbox{\hyperlink{group__sp__auxlib_gad0daf84ba83e8b02f113f57428271fa7}{sp\_auxlib::eigs\_sym}}(\mbox{\hyperlink{classCol}{Col<eT>}}\& eigval, \mbox{\hyperlink{classMat}{Mat<eT>}}\& eigvec, \textcolor{keyword}{const} \mbox{\hyperlink{structSpBase}{SpBase<eT, T1>}}\& X, \textcolor{keyword}{const} uword n\_eigvals, \textcolor{keyword}{const} form\_type form\_val, \textcolor{keyword}{const} \mbox{\hyperlink{structeigs__opts}{eigs\_opts}}\& opts)}
\DoxyCodeLine{61   \{}
\DoxyCodeLine{62   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{63   }
\DoxyCodeLine{64   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap__spmat}{unwrap\_spmat<T1>}} U(X.get\_ref());}
\DoxyCodeLine{65   }
\DoxyCodeLine{66   arma\_debug\_check( (U.M.is\_square() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}eigs\_sym(): given matrix must be square sized"{}} );}
\DoxyCodeLine{67   }
\DoxyCodeLine{68   \textcolor{keywordflow}{if}((arma\_config::debug) \&\& (sp\_auxlib::rudimentary\_sym\_check(U.M) == \textcolor{keyword}{false}))}
\DoxyCodeLine{69     \{}
\DoxyCodeLine{70     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__cx}{is\_cx<eT>::no}} )  \{ arma\_debug\_warn\_level(1, \textcolor{stringliteral}{"{}eigs\_sym(): given matrix is not symmetric"{}}); \}}
\DoxyCodeLine{71     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__cx}{is\_cx<eT>::yes}})  \{ arma\_debug\_warn\_level(1, \textcolor{stringliteral}{"{}eigs\_sym(): given matrix is not hermitian"{}}); \}}
\DoxyCodeLine{72     \}}
\DoxyCodeLine{73   }
\DoxyCodeLine{74   \textcolor{comment}{// TODO: investigate optional redirection of "{}sm"{} to ARPACK as it's capable of shift-\/invert;}}
\DoxyCodeLine{75   \textcolor{comment}{// TODO: in shift-\/invert mode, "{}sm"{} maps to "{}lm"{} of the shift-\/inverted matrix (with sigma = 0)}}
\DoxyCodeLine{76   }
\DoxyCodeLine{77 \textcolor{preprocessor}{  \#if   defined(ARMA\_USE\_NEWARP)}}
\DoxyCodeLine{78     \{}
\DoxyCodeLine{79     \textcolor{keywordflow}{return} sp\_auxlib::eigs\_sym\_newarp(eigval, eigvec, U.M, n\_eigvals, form\_val, opts);}
\DoxyCodeLine{80     \}}
\DoxyCodeLine{81 \textcolor{preprocessor}{  \#elif defined(ARMA\_USE\_ARPACK)}}
\DoxyCodeLine{82     \{}
\DoxyCodeLine{83     \textcolor{keyword}{constexpr} eT sigma = eT(0);}
\DoxyCodeLine{84     }
\DoxyCodeLine{85     \textcolor{keywordflow}{return} sp\_auxlib::eigs\_sym\_arpack<eT,false>(eigval, eigvec, U.M, n\_eigvals, form\_val, sigma, opts);}
\DoxyCodeLine{86     \}}
\DoxyCodeLine{87 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{88     \{}
\DoxyCodeLine{89     arma\_ignore(eigval);}
\DoxyCodeLine{90     arma\_ignore(eigvec);}
\DoxyCodeLine{91     arma\_ignore(n\_eigvals);}
\DoxyCodeLine{92     arma\_ignore(form\_val);}
\DoxyCodeLine{93     arma\_ignore(opts);}
\DoxyCodeLine{94     }
\DoxyCodeLine{95     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}eigs\_sym(): use of NEWARP or ARPACK must be enabled"{}});}
\DoxyCodeLine{96     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{97     \}}
\DoxyCodeLine{98 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{99   \}}
\DoxyCodeLine{100 }
\DoxyCodeLine{101 }
\DoxyCodeLine{102 }
\DoxyCodeLine{104 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{105 \textcolor{keyword}{inline}}
\DoxyCodeLine{106 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{107 \mbox{\hyperlink{group__sp__auxlib_gad0daf84ba83e8b02f113f57428271fa7}{sp\_auxlib::eigs\_sym}}(\mbox{\hyperlink{classCol}{Col<eT>}}\& eigval, \mbox{\hyperlink{classMat}{Mat<eT>}}\& eigvec, \textcolor{keyword}{const} \mbox{\hyperlink{structSpBase}{SpBase<eT, T1>}}\& X, \textcolor{keyword}{const} uword n\_eigvals, \textcolor{keyword}{const} eT sigma, \textcolor{keyword}{const} \mbox{\hyperlink{structeigs__opts}{eigs\_opts}}\& opts)}
\DoxyCodeLine{108   \{}
\DoxyCodeLine{109   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{110   }
\DoxyCodeLine{111   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap__spmat}{unwrap\_spmat<T1>}} U(X.get\_ref());}
\DoxyCodeLine{112   }
\DoxyCodeLine{113   arma\_debug\_check( (U.M.is\_square() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}eigs\_sym(): given matrix must be square sized"{}} );}
\DoxyCodeLine{114   }
\DoxyCodeLine{115   \textcolor{keywordflow}{if}((arma\_config::debug) \&\& (sp\_auxlib::rudimentary\_sym\_check(U.M) == \textcolor{keyword}{false}))}
\DoxyCodeLine{116     \{}
\DoxyCodeLine{117     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__cx}{is\_cx<eT>::no}} )  \{ arma\_debug\_warn\_level(1, \textcolor{stringliteral}{"{}eigs\_sym(): given matrix is not symmetric"{}}); \}}
\DoxyCodeLine{118     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__cx}{is\_cx<eT>::yes}})  \{ arma\_debug\_warn\_level(1, \textcolor{stringliteral}{"{}eigs\_sym(): given matrix is not hermitian"{}}); \}}
\DoxyCodeLine{119     \}}
\DoxyCodeLine{120   }
\DoxyCodeLine{121 \textcolor{preprocessor}{  \#if   (defined(ARMA\_USE\_NEWARP) \&\& defined(ARMA\_USE\_SUPERLU))}}
\DoxyCodeLine{122     \{}
\DoxyCodeLine{123     \textcolor{keywordflow}{return} sp\_auxlib::eigs\_sym\_newarp(eigval, eigvec, U.M, n\_eigvals, sigma, opts);}
\DoxyCodeLine{124     \}}
\DoxyCodeLine{125 \textcolor{preprocessor}{  \#elif (defined(ARMA\_USE\_ARPACK) \&\& defined(ARMA\_USE\_SUPERLU))}}
\DoxyCodeLine{126     \{}
\DoxyCodeLine{127     \textcolor{keyword}{constexpr} form\_type form\_val = form\_sigma;}
\DoxyCodeLine{128     }
\DoxyCodeLine{129     \textcolor{keywordflow}{return} sp\_auxlib::eigs\_sym\_arpack<eT,true>(eigval, eigvec, U.M, n\_eigvals, form\_val, sigma, opts);}
\DoxyCodeLine{130     \}}
\DoxyCodeLine{131 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{132     \{}
\DoxyCodeLine{133     arma\_ignore(eigval);}
\DoxyCodeLine{134     arma\_ignore(eigvec);}
\DoxyCodeLine{135     arma\_ignore(n\_eigvals);}
\DoxyCodeLine{136     arma\_ignore(sigma);}
\DoxyCodeLine{137     arma\_ignore(opts);}
\DoxyCodeLine{138     }
\DoxyCodeLine{139     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}eigs\_sym(): use of NEWARP or ARPACK as well as SuperLU must be enabled to use 'sigma'"{}});}
\DoxyCodeLine{140     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{141     \}}
\DoxyCodeLine{142 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{143   \}}
\DoxyCodeLine{144 }
\DoxyCodeLine{145 }
\DoxyCodeLine{146 }
\DoxyCodeLine{147 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{148 \textcolor{keyword}{inline}}
\DoxyCodeLine{149 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{150 sp\_auxlib::eigs\_sym\_newarp(\mbox{\hyperlink{classCol}{Col<eT>}}\& eigval, \mbox{\hyperlink{classMat}{Mat<eT>}}\& eigvec, \textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& X, \textcolor{keyword}{const} uword n\_eigvals, \textcolor{keyword}{const} form\_type form\_val, \textcolor{keyword}{const} \mbox{\hyperlink{structeigs__opts}{eigs\_opts}}\& opts)}
\DoxyCodeLine{151   \{}
\DoxyCodeLine{152   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{153   }
\DoxyCodeLine{154 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_NEWARP)}}
\DoxyCodeLine{155     \{}
\DoxyCodeLine{156     arma\_debug\_check( (form\_val != form\_lm) \&\& (form\_val != form\_sm) \&\& (form\_val != form\_la) \&\& (form\_val != form\_sa), \textcolor{stringliteral}{"{}eigs\_sym(): unknown form specified"{}} );}
\DoxyCodeLine{157     }
\DoxyCodeLine{158     \textcolor{keywordflow}{if}(X.is\_square() == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{159     }
\DoxyCodeLine{160     \textcolor{keyword}{const} \mbox{\hyperlink{classnewarp_1_1SparseGenMatProd}{newarp::SparseGenMatProd<eT>}} op(X);}
\DoxyCodeLine{161     }
\DoxyCodeLine{162     arma\_debug\_check( (n\_eigvals >= op.n\_rows), \textcolor{stringliteral}{"{}eigs\_sym(): n\_eigvals must be less than the number of rows in the matrix"{}} );}
\DoxyCodeLine{163     }
\DoxyCodeLine{164     \textcolor{comment}{// If the matrix is empty, the case is trivial.}}
\DoxyCodeLine{165     \textcolor{keywordflow}{if}( (op.n\_cols == 0) || (n\_eigvals == 0) ) \textcolor{comment}{// We already know n\_cols == n\_rows.}}
\DoxyCodeLine{166       \{}
\DoxyCodeLine{167       eigval.reset();}
\DoxyCodeLine{168       eigvec.reset();}
\DoxyCodeLine{169       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{170       \}}
\DoxyCodeLine{171     }
\DoxyCodeLine{172     uword n   = op.n\_rows;}
\DoxyCodeLine{173     }
\DoxyCodeLine{174     \textcolor{comment}{// Use max(2*k+1, 20) as default subspace dimension for the sym case; MATLAB uses max(2*k, 20), but we need to be backward-\/compatible.}}
\DoxyCodeLine{175     uword ncv\_default = uword( ((2*n\_eigvals+1)>(20)) ? (2*n\_eigvals+1) : (20) );}
\DoxyCodeLine{176     }
\DoxyCodeLine{177     \textcolor{comment}{// Use opts.subdim only if it's within the limits, otherwise cap it.}}
\DoxyCodeLine{178     uword ncv = ncv\_default;}
\DoxyCodeLine{179     }
\DoxyCodeLine{180     \textcolor{keywordflow}{if}(opts.subdim != 0)}
\DoxyCodeLine{181       \{}
\DoxyCodeLine{182       \textcolor{keywordflow}{if}(opts.subdim < (n\_eigvals + 1))}
\DoxyCodeLine{183         \{}
\DoxyCodeLine{184         arma\_debug\_warn\_level(1, \textcolor{stringliteral}{"{}eigs\_sym(): opts.subdim must be greater than k; using k+1 instead of "{}}, opts.subdim);}
\DoxyCodeLine{185         ncv = uword(n\_eigvals + 1);}
\DoxyCodeLine{186         \}}
\DoxyCodeLine{187       \textcolor{keywordflow}{else}}
\DoxyCodeLine{188       \textcolor{keywordflow}{if}(opts.subdim > n)}
\DoxyCodeLine{189         \{}
\DoxyCodeLine{190         arma\_debug\_warn\_level(1, \textcolor{stringliteral}{"{}eigs\_sym(): opts.subdim cannot be greater than n\_rows; using n\_rows instead of "{}}, opts.subdim);}
\DoxyCodeLine{191         ncv = n;}
\DoxyCodeLine{192         \}}
\DoxyCodeLine{193       \textcolor{keywordflow}{else}}
\DoxyCodeLine{194         \{}
\DoxyCodeLine{195         ncv = uword(opts.subdim);}
\DoxyCodeLine{196         \}}
\DoxyCodeLine{197       \}}
\DoxyCodeLine{198     }
\DoxyCodeLine{199     \textcolor{comment}{// Re-\/check that we are within the limits}}
\DoxyCodeLine{200     \textcolor{keywordflow}{if}(ncv < (n\_eigvals + 1)) \{ ncv = (n\_eigvals + 1); \}}
\DoxyCodeLine{201     \textcolor{keywordflow}{if}(ncv > n              ) \{ ncv = n;               \}}
\DoxyCodeLine{202     }
\DoxyCodeLine{203     eT tol = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(eT(opts.tol), std::numeric\_limits<eT>::epsilon());}
\DoxyCodeLine{204     }
\DoxyCodeLine{205     uword maxiter = uword(opts.maxiter);}
\DoxyCodeLine{206     }
\DoxyCodeLine{207     \textcolor{comment}{// eigval.set\_size(n\_eigvals);}}
\DoxyCodeLine{208     \textcolor{comment}{// eigvec.set\_size(n, n\_eigvals);}}
\DoxyCodeLine{209     }
\DoxyCodeLine{210     \textcolor{keywordtype}{bool} status = \textcolor{keyword}{true};}
\DoxyCodeLine{211     }
\DoxyCodeLine{212     uword nconv = 0;}
\DoxyCodeLine{213     }
\DoxyCodeLine{214     \textcolor{keywordflow}{try}}
\DoxyCodeLine{215       \{}
\DoxyCodeLine{216       \textcolor{keywordflow}{if}(form\_val == form\_lm)}
\DoxyCodeLine{217         \{}
\DoxyCodeLine{218         \mbox{\hyperlink{classnewarp_1_1SymEigsSolver}{newarp::SymEigsSolver< eT, newarp::EigsSelect::LARGEST\_MAGN, newarp::SparseGenMatProd<eT>}} > eigs(op, n\_eigvals, ncv);}
\DoxyCodeLine{219         eigs.init();}
\DoxyCodeLine{220         nconv  = eigs.compute(maxiter, tol);}
\DoxyCodeLine{221         eigval = eigs.eigenvalues();}
\DoxyCodeLine{222         eigvec = eigs.eigenvectors();}
\DoxyCodeLine{223         \}}
\DoxyCodeLine{224       \textcolor{keywordflow}{else}}
\DoxyCodeLine{225       \textcolor{keywordflow}{if}(form\_val == form\_sm)}
\DoxyCodeLine{226         \{}
\DoxyCodeLine{227         \mbox{\hyperlink{classnewarp_1_1SymEigsSolver}{newarp::SymEigsSolver< eT, newarp::EigsSelect::SMALLEST\_MAGN, newarp::SparseGenMatProd<eT>}} > eigs(op, n\_eigvals, ncv);}
\DoxyCodeLine{228         eigs.init();}
\DoxyCodeLine{229         nconv  = eigs.compute(maxiter, tol);}
\DoxyCodeLine{230         eigval = eigs.eigenvalues();}
\DoxyCodeLine{231         eigvec = eigs.eigenvectors();}
\DoxyCodeLine{232         \}}
\DoxyCodeLine{233       \textcolor{keywordflow}{else}}
\DoxyCodeLine{234       \textcolor{keywordflow}{if}(form\_val == form\_la)}
\DoxyCodeLine{235         \{}
\DoxyCodeLine{236         \mbox{\hyperlink{classnewarp_1_1SymEigsSolver}{newarp::SymEigsSolver< eT, newarp::EigsSelect::LARGEST\_ALGE, newarp::SparseGenMatProd<eT>}} > eigs(op, n\_eigvals, ncv);}
\DoxyCodeLine{237         eigs.init();}
\DoxyCodeLine{238         nconv  = eigs.compute(maxiter, tol);}
\DoxyCodeLine{239         eigval = eigs.eigenvalues();}
\DoxyCodeLine{240         eigvec = eigs.eigenvectors();}
\DoxyCodeLine{241         \}}
\DoxyCodeLine{242       \textcolor{keywordflow}{else}}
\DoxyCodeLine{243       \textcolor{keywordflow}{if}(form\_val == form\_sa)}
\DoxyCodeLine{244         \{}
\DoxyCodeLine{245         \mbox{\hyperlink{classnewarp_1_1SymEigsSolver}{newarp::SymEigsSolver< eT, newarp::EigsSelect::SMALLEST\_ALGE, newarp::SparseGenMatProd<eT>}} > eigs(op, n\_eigvals, ncv);}
\DoxyCodeLine{246         eigs.init();}
\DoxyCodeLine{247         nconv  = eigs.compute(maxiter, tol);}
\DoxyCodeLine{248         eigval = eigs.eigenvalues();}
\DoxyCodeLine{249         eigvec = eigs.eigenvectors();}
\DoxyCodeLine{250         \}}
\DoxyCodeLine{251       \}}
\DoxyCodeLine{252     \textcolor{keywordflow}{catch}(\textcolor{keyword}{const} std::runtime\_error\&)}
\DoxyCodeLine{253       \{}
\DoxyCodeLine{254       status = \textcolor{keyword}{false};}
\DoxyCodeLine{255       \}}
\DoxyCodeLine{256     }
\DoxyCodeLine{257     \textcolor{keywordflow}{if}(status == \textcolor{keyword}{true})}
\DoxyCodeLine{258       \{}
\DoxyCodeLine{259       \textcolor{keywordflow}{if}(nconv == 0)  \{ status = \textcolor{keyword}{false}; \}}
\DoxyCodeLine{260       \}}
\DoxyCodeLine{261     }
\DoxyCodeLine{262     \textcolor{keywordflow}{return} status;}
\DoxyCodeLine{263     \}}
\DoxyCodeLine{264 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{265     \{}
\DoxyCodeLine{266     arma\_ignore(eigval);}
\DoxyCodeLine{267     arma\_ignore(eigvec);}
\DoxyCodeLine{268     arma\_ignore(X);}
\DoxyCodeLine{269     arma\_ignore(n\_eigvals);}
\DoxyCodeLine{270     arma\_ignore(form\_val);}
\DoxyCodeLine{271     arma\_ignore(opts);}
\DoxyCodeLine{272     }
\DoxyCodeLine{273     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{274     \}}
\DoxyCodeLine{275 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{276   \}}
\DoxyCodeLine{277 }
\DoxyCodeLine{278 }
\DoxyCodeLine{279 }
\DoxyCodeLine{280 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{281 \textcolor{keyword}{inline}}
\DoxyCodeLine{282 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{283 sp\_auxlib::eigs\_sym\_newarp(\mbox{\hyperlink{classCol}{Col<eT>}}\& eigval, \mbox{\hyperlink{classMat}{Mat<eT>}}\& eigvec, \textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& X, \textcolor{keyword}{const} uword n\_eigvals, \textcolor{keyword}{const} eT sigma, \textcolor{keyword}{const} \mbox{\hyperlink{structeigs__opts}{eigs\_opts}}\& opts)}
\DoxyCodeLine{284   \{}
\DoxyCodeLine{285   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{286   }
\DoxyCodeLine{287 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_NEWARP)}}
\DoxyCodeLine{288     \{}
\DoxyCodeLine{289     \textcolor{keywordflow}{if}(X.is\_square() == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{290     }
\DoxyCodeLine{291     \textcolor{keyword}{const} \mbox{\hyperlink{classnewarp_1_1SparseGenRealShiftSolve}{newarp::SparseGenRealShiftSolve<eT>}} op(X, sigma);}
\DoxyCodeLine{292     }
\DoxyCodeLine{293     \textcolor{keywordflow}{if}(op.valid == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{294     }
\DoxyCodeLine{295     arma\_debug\_check( (n\_eigvals >= op.n\_rows), \textcolor{stringliteral}{"{}eigs\_sym(): n\_eigvals must be less than the number of rows in the matrix"{}} );}
\DoxyCodeLine{296     }
\DoxyCodeLine{297     \textcolor{comment}{// If the matrix is empty, the case is trivial.}}
\DoxyCodeLine{298     \textcolor{keywordflow}{if}( (op.n\_cols == 0) || (n\_eigvals == 0) ) \textcolor{comment}{// We already know n\_cols == n\_rows.}}
\DoxyCodeLine{299       \{}
\DoxyCodeLine{300       eigval.reset();}
\DoxyCodeLine{301       eigvec.reset();}
\DoxyCodeLine{302       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{303       \}}
\DoxyCodeLine{304     }
\DoxyCodeLine{305     uword n   = op.n\_rows;}
\DoxyCodeLine{306     }
\DoxyCodeLine{307     \textcolor{comment}{// Use max(2*k+1, 20) as default subspace dimension for the sym case; MATLAB uses max(2*k, 20), but we need to be backward-\/compatible.}}
\DoxyCodeLine{308     uword ncv\_default = uword( ((2*n\_eigvals+1)>(20)) ? (2*n\_eigvals+1) : (20) );}
\DoxyCodeLine{309     }
\DoxyCodeLine{310     \textcolor{comment}{// Use opts.subdim only if it's within the limits, otherwise cap it.}}
\DoxyCodeLine{311     uword ncv = ncv\_default;}
\DoxyCodeLine{312     }
\DoxyCodeLine{313     \textcolor{keywordflow}{if}(opts.subdim != 0)}
\DoxyCodeLine{314       \{}
\DoxyCodeLine{315       \textcolor{keywordflow}{if}(opts.subdim < (n\_eigvals + 1))}
\DoxyCodeLine{316         \{}
\DoxyCodeLine{317         arma\_debug\_warn\_level(1, \textcolor{stringliteral}{"{}eigs\_sym(): opts.subdim must be greater than k; using k+1 instead of "{}}, opts.subdim);}
\DoxyCodeLine{318         ncv = uword(n\_eigvals + 1);}
\DoxyCodeLine{319         \}}
\DoxyCodeLine{320       \textcolor{keywordflow}{else}}
\DoxyCodeLine{321       \textcolor{keywordflow}{if}(opts.subdim > n)}
\DoxyCodeLine{322         \{}
\DoxyCodeLine{323         arma\_debug\_warn\_level(1, \textcolor{stringliteral}{"{}eigs\_sym(): opts.subdim cannot be greater than n\_rows; using n\_rows instead of "{}}, opts.subdim);}
\DoxyCodeLine{324         ncv = n;}
\DoxyCodeLine{325         \}}
\DoxyCodeLine{326       \textcolor{keywordflow}{else}}
\DoxyCodeLine{327         \{}
\DoxyCodeLine{328         ncv = uword(opts.subdim);}
\DoxyCodeLine{329         \}}
\DoxyCodeLine{330       \}}
\DoxyCodeLine{331     }
\DoxyCodeLine{332     \textcolor{comment}{// Re-\/check that we are within the limits}}
\DoxyCodeLine{333     \textcolor{keywordflow}{if}(ncv < (n\_eigvals + 1)) \{ ncv = (n\_eigvals + 1); \}}
\DoxyCodeLine{334     \textcolor{keywordflow}{if}(ncv > n              ) \{ ncv = n;               \}}
\DoxyCodeLine{335     }
\DoxyCodeLine{336     eT tol = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(eT(opts.tol), std::numeric\_limits<eT>::epsilon());}
\DoxyCodeLine{337     }
\DoxyCodeLine{338     uword maxiter = uword(opts.maxiter);}
\DoxyCodeLine{339     }
\DoxyCodeLine{340     \textcolor{comment}{// eigval.set\_size(n\_eigvals);}}
\DoxyCodeLine{341     \textcolor{comment}{// eigvec.set\_size(n, n\_eigvals);}}
\DoxyCodeLine{342     }
\DoxyCodeLine{343     \textcolor{keywordtype}{bool} status = \textcolor{keyword}{true};}
\DoxyCodeLine{344     }
\DoxyCodeLine{345     uword nconv = 0;}
\DoxyCodeLine{346     }
\DoxyCodeLine{347     \textcolor{keywordflow}{try}}
\DoxyCodeLine{348       \{}
\DoxyCodeLine{349       \mbox{\hyperlink{classnewarp_1_1SymEigsShiftSolver}{newarp::SymEigsShiftSolver< eT, newarp::EigsSelect::LARGEST\_MAGN, newarp::SparseGenRealShiftSolve<eT>}} > eigs(op, n\_eigvals, ncv, sigma);}
\DoxyCodeLine{350       eigs.init();}
\DoxyCodeLine{351       nconv  = eigs.compute(maxiter, tol);}
\DoxyCodeLine{352       eigval = eigs.eigenvalues();}
\DoxyCodeLine{353       eigvec = eigs.eigenvectors();}
\DoxyCodeLine{354       \}}
\DoxyCodeLine{355     \textcolor{keywordflow}{catch}(\textcolor{keyword}{const} std::runtime\_error\&)}
\DoxyCodeLine{356       \{}
\DoxyCodeLine{357       status = \textcolor{keyword}{false};}
\DoxyCodeLine{358       \}}
\DoxyCodeLine{359     }
\DoxyCodeLine{360     \textcolor{keywordflow}{if}(status == \textcolor{keyword}{true})}
\DoxyCodeLine{361       \{}
\DoxyCodeLine{362       \textcolor{keywordflow}{if}(nconv == 0)  \{ status = \textcolor{keyword}{false}; \}}
\DoxyCodeLine{363       \}}
\DoxyCodeLine{364     }
\DoxyCodeLine{365     \textcolor{keywordflow}{return} status;}
\DoxyCodeLine{366     \}}
\DoxyCodeLine{367 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{368     \{}
\DoxyCodeLine{369     arma\_ignore(eigval);}
\DoxyCodeLine{370     arma\_ignore(eigvec);}
\DoxyCodeLine{371     arma\_ignore(X);}
\DoxyCodeLine{372     arma\_ignore(n\_eigvals);}
\DoxyCodeLine{373     arma\_ignore(sigma);}
\DoxyCodeLine{374     arma\_ignore(opts);}
\DoxyCodeLine{375     }
\DoxyCodeLine{376     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{377     \}}
\DoxyCodeLine{378 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{379   \}}
\DoxyCodeLine{380 }
\DoxyCodeLine{381 }
\DoxyCodeLine{382 }
\DoxyCodeLine{383 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT, \textcolor{keywordtype}{bool} use\_sigma>}
\DoxyCodeLine{384 \textcolor{keyword}{inline}}
\DoxyCodeLine{385 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{386 sp\_auxlib::eigs\_sym\_arpack(\mbox{\hyperlink{classCol}{Col<eT>}}\& eigval, \mbox{\hyperlink{classMat}{Mat<eT>}}\& eigvec, \textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& X, \textcolor{keyword}{const} uword n\_eigvals, \textcolor{keyword}{const} form\_type form\_val, \textcolor{keyword}{const} eT sigma, \textcolor{keyword}{const} \mbox{\hyperlink{structeigs__opts}{eigs\_opts}}\& opts)}
\DoxyCodeLine{387   \{}
\DoxyCodeLine{388   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{389   }
\DoxyCodeLine{390 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_ARPACK)}}
\DoxyCodeLine{391     \{}
\DoxyCodeLine{392     arma\_debug\_check( (form\_val != form\_lm) \&\& (form\_val != form\_sm) \&\& (form\_val != form\_la) \&\& (form\_val != form\_sa) \&\& (form\_val != form\_sigma), \textcolor{stringliteral}{"{}eigs\_sym(): unknown form specified"{}} );}
\DoxyCodeLine{393     }
\DoxyCodeLine{394     \textcolor{keywordflow}{if}(X.is\_square() == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{395     }
\DoxyCodeLine{396     \textcolor{keywordtype}{char}  which\_sm[3] = \textcolor{stringliteral}{"{}SM"{}};}
\DoxyCodeLine{397     \textcolor{keywordtype}{char}  which\_lm[3] = \textcolor{stringliteral}{"{}LM"{}};}
\DoxyCodeLine{398     \textcolor{keywordtype}{char}  which\_sa[3] = \textcolor{stringliteral}{"{}SA"{}};}
\DoxyCodeLine{399     \textcolor{keywordtype}{char}  which\_la[3] = \textcolor{stringliteral}{"{}LA"{}};}
\DoxyCodeLine{400     \textcolor{keywordtype}{char}* which;}
\DoxyCodeLine{401     }
\DoxyCodeLine{402     \textcolor{keywordflow}{switch}(form\_val)}
\DoxyCodeLine{403       \{}
\DoxyCodeLine{404       \textcolor{keywordflow}{case} form\_sm:  which = which\_sm;  \textcolor{keywordflow}{break};}
\DoxyCodeLine{405       \textcolor{keywordflow}{case} form\_lm:  which = which\_lm;  \textcolor{keywordflow}{break};}
\DoxyCodeLine{406       \textcolor{keywordflow}{case} form\_sa:  which = which\_sa;  \textcolor{keywordflow}{break};}
\DoxyCodeLine{407       \textcolor{keywordflow}{case} form\_la:  which = which\_la;  \textcolor{keywordflow}{break};}
\DoxyCodeLine{408       }
\DoxyCodeLine{409       \textcolor{keywordflow}{default}:       which = which\_lm;  \textcolor{keywordflow}{break};}
\DoxyCodeLine{410       \}}
\DoxyCodeLine{411     }
\DoxyCodeLine{412     \textcolor{comment}{// Make sure we aren't asking for every eigenvalue.}}
\DoxyCodeLine{413     \textcolor{comment}{// The \_saupd() functions allow asking for one more eigenvalue than the \_naupd() functions.}}
\DoxyCodeLine{414     arma\_debug\_check( (n\_eigvals >= X.n\_rows), \textcolor{stringliteral}{"{}eigs\_sym(): n\_eigvals must be less than the number of rows in the matrix"{}} );}
\DoxyCodeLine{415     }
\DoxyCodeLine{416     \textcolor{comment}{// If the matrix is empty, the case is trivial.}}
\DoxyCodeLine{417     \textcolor{keywordflow}{if}( (X.n\_cols == 0) || (n\_eigvals == 0) ) \textcolor{comment}{// We already know n\_cols == n\_rows.}}
\DoxyCodeLine{418       \{}
\DoxyCodeLine{419       eigval.reset();}
\DoxyCodeLine{420       eigvec.reset();}
\DoxyCodeLine{421       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{422       \}}
\DoxyCodeLine{423     }
\DoxyCodeLine{424     \textcolor{comment}{// Set up variables that get used for neupd().}}
\DoxyCodeLine{425     blas\_int n, ncv, ncv\_default, ldv, lworkl, info, maxiter;}
\DoxyCodeLine{426     }
\DoxyCodeLine{427     eT tol  = eT(opts.tol);}
\DoxyCodeLine{428     maxiter = blas\_int(opts.maxiter);}
\DoxyCodeLine{429     }
\DoxyCodeLine{430     \mbox{\hyperlink{classpodarray}{podarray<eT>}} resid, v, workd, workl;}
\DoxyCodeLine{431     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} iparam, ipntr;}
\DoxyCodeLine{432     \mbox{\hyperlink{classpodarray}{podarray<eT>}} rwork; \textcolor{comment}{// Not used in this case.}}
\DoxyCodeLine{433     }
\DoxyCodeLine{434     n = blas\_int(X.n\_rows); \textcolor{comment}{// The size of the matrix.}}
\DoxyCodeLine{435     }
\DoxyCodeLine{436     \textcolor{comment}{// Use max(2*k+1, 20) as default subspace dimension for the sym case; MATLAB uses max(2*k, 20), but we need to be backward-\/compatible.}}
\DoxyCodeLine{437     ncv\_default = blas\_int( ((2*n\_eigvals+1)>(20)) ? (2*n\_eigvals+1) : (20) );}
\DoxyCodeLine{438     }
\DoxyCodeLine{439     \textcolor{comment}{// Use opts.subdim only if it's within the limits}}
\DoxyCodeLine{440     ncv = ncv\_default;}
\DoxyCodeLine{441     }
\DoxyCodeLine{442     \textcolor{keywordflow}{if}(opts.subdim != 0)}
\DoxyCodeLine{443       \{}
\DoxyCodeLine{444       \textcolor{keywordflow}{if}(opts.subdim < (n\_eigvals + 1))}
\DoxyCodeLine{445         \{}
\DoxyCodeLine{446         arma\_debug\_warn\_level(1, \textcolor{stringliteral}{"{}eigs\_sym(): opts.subdim must be greater than k; using k+1 instead of "{}}, opts.subdim);}
\DoxyCodeLine{447         ncv = blas\_int(n\_eigvals + 1);}
\DoxyCodeLine{448         \}}
\DoxyCodeLine{449       \textcolor{keywordflow}{else}}
\DoxyCodeLine{450       \textcolor{keywordflow}{if}(blas\_int(opts.subdim) > n)}
\DoxyCodeLine{451         \{}
\DoxyCodeLine{452         arma\_debug\_warn\_level(1, \textcolor{stringliteral}{"{}eigs\_sym(): opts.subdim cannot be greater than n\_rows; using n\_rows instead of "{}}, opts.subdim);}
\DoxyCodeLine{453         ncv = n;}
\DoxyCodeLine{454         \}}
\DoxyCodeLine{455       \textcolor{keywordflow}{else}}
\DoxyCodeLine{456         \{}
\DoxyCodeLine{457         ncv = blas\_int(opts.subdim);}
\DoxyCodeLine{458         \}}
\DoxyCodeLine{459       \}}
\DoxyCodeLine{460     }
\DoxyCodeLine{461     \textcolor{keywordflow}{if}(use\_sigma)}
\DoxyCodeLine{462     \textcolor{comment}{//if(form\_val == form\_sigma)}}
\DoxyCodeLine{463       \{}
\DoxyCodeLine{464       run\_aupd\_shiftinvert(n\_eigvals, sigma, X, \textcolor{keyword}{true} \textcolor{comment}{/* sym, not gen */}, n, tol, maxiter, resid, ncv, v, ldv, iparam, ipntr, workd, workl, lworkl, rwork, info);}
\DoxyCodeLine{465       \}}
\DoxyCodeLine{466     \textcolor{keywordflow}{else}}
\DoxyCodeLine{467       \{}
\DoxyCodeLine{468       run\_aupd\_plain(n\_eigvals, which, X, \textcolor{keyword}{true} \textcolor{comment}{/* sym, not gen */}, n, tol, maxiter, resid, ncv, v, ldv, iparam, ipntr, workd, workl, lworkl, rwork, info);}
\DoxyCodeLine{469       \}}
\DoxyCodeLine{470     }
\DoxyCodeLine{471     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{472     }
\DoxyCodeLine{473     \textcolor{comment}{// The process has converged, and now we need to recover the actual eigenvectors using seupd()}}
\DoxyCodeLine{474     blas\_int rvec = 1; \textcolor{comment}{// .TRUE}}
\DoxyCodeLine{475     blas\_int nev  = blas\_int(n\_eigvals);}
\DoxyCodeLine{476     }
\DoxyCodeLine{477     \textcolor{keywordtype}{char} howmny = \textcolor{charliteral}{'A'};}
\DoxyCodeLine{478     \textcolor{keywordtype}{char} bmat   = \textcolor{charliteral}{'I'}; \textcolor{comment}{// We are considering the standard eigenvalue problem.}}
\DoxyCodeLine{479     }
\DoxyCodeLine{480     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} select(ncv); \textcolor{comment}{// Logical array of dimension NCV.}}
\DoxyCodeLine{481     blas\_int ldz = n;}
\DoxyCodeLine{482     }
\DoxyCodeLine{483     \textcolor{comment}{// seupd() will output directly into the eigval and eigvec objects.}}
\DoxyCodeLine{484     eigval.zeros(n\_eigvals);}
\DoxyCodeLine{485     eigvec.zeros(n, n\_eigvals);}
\DoxyCodeLine{486     }
\DoxyCodeLine{487     arpack::seupd(\&rvec, \&howmny, select.memptr(), eigval.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), eigvec.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldz, (eT*) \&sigma, \&bmat, \&n, which, \&nev, \&tol, resid.memptr(), \&ncv, v.memptr(), \&ldv, iparam.memptr(), ipntr.memptr(), workd.memptr(), workl.memptr(), \&lworkl, \&info);}
\DoxyCodeLine{488     }
\DoxyCodeLine{489     \textcolor{comment}{// Check for errors.}}
\DoxyCodeLine{490     \textcolor{keywordflow}{if}(info != 0)  \{ arma\_debug\_warn\_level(1, \textcolor{stringliteral}{"{}eigs\_sym(): ARPACK error "{}}, info, \textcolor{stringliteral}{"{} in seupd()"{}}); \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{491     }
\DoxyCodeLine{492     \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{493     \}}
\DoxyCodeLine{494 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{495     \{}
\DoxyCodeLine{496     arma\_ignore(eigval);}
\DoxyCodeLine{497     arma\_ignore(eigvec);}
\DoxyCodeLine{498     arma\_ignore(X);}
\DoxyCodeLine{499     arma\_ignore(n\_eigvals);}
\DoxyCodeLine{500     arma\_ignore(form\_val);}
\DoxyCodeLine{501     arma\_ignore(sigma);}
\DoxyCodeLine{502     arma\_ignore(opts);}
\DoxyCodeLine{503     }
\DoxyCodeLine{504     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{505     \}}
\DoxyCodeLine{506 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{507   \}}
\DoxyCodeLine{508 }
\DoxyCodeLine{509 }
\DoxyCodeLine{510 }
\DoxyCodeLine{512 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{513 \textcolor{keyword}{inline}}
\DoxyCodeLine{514 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{515 \mbox{\hyperlink{group__sp__auxlib_ga89f9e9d865d35af62a1f65655dfc9635}{sp\_auxlib::eigs\_gen}}(\mbox{\hyperlink{classCol}{Col}}< std::complex<T> >\& eigval, \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& eigvec, \textcolor{keyword}{const} \mbox{\hyperlink{structSpBase}{SpBase<T, T1>}}\& X, \textcolor{keyword}{const} uword n\_eigvals, \textcolor{keyword}{const} form\_type form\_val, \textcolor{keyword}{const} \mbox{\hyperlink{structeigs__opts}{eigs\_opts}}\& opts)}
\DoxyCodeLine{516   \{}
\DoxyCodeLine{517   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{518   }
\DoxyCodeLine{519   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap__spmat}{unwrap\_spmat<T1>}} U(X.get\_ref());}
\DoxyCodeLine{520   }
\DoxyCodeLine{521   arma\_debug\_check( (U.M.is\_square() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}eigs\_gen(): given matrix must be square sized"{}} );}
\DoxyCodeLine{522   }
\DoxyCodeLine{523   \textcolor{comment}{// TODO: investigate optional redirection of "{}sm"{} to ARPACK as it's capable of shift-\/invert;}}
\DoxyCodeLine{524   \textcolor{comment}{// TODO: in shift-\/invert mode, "{}sm"{} maps to "{}lm"{} of the shift-\/inverted matrix (with sigma = 0)}}
\DoxyCodeLine{525   }
\DoxyCodeLine{526 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_NEWARP)}}
\DoxyCodeLine{527     \{}
\DoxyCodeLine{528     \textcolor{keywordflow}{return} sp\_auxlib::eigs\_gen\_newarp(eigval, eigvec, U.M, n\_eigvals, form\_val, opts);}
\DoxyCodeLine{529     \}}
\DoxyCodeLine{530 \textcolor{preprocessor}{  \#elif defined(ARMA\_USE\_ARPACK)}}
\DoxyCodeLine{531     \{}
\DoxyCodeLine{532     \textcolor{keyword}{constexpr} std::complex<T> sigma = T(0);}
\DoxyCodeLine{533     }
\DoxyCodeLine{534     \textcolor{keywordflow}{return} sp\_auxlib::eigs\_gen\_arpack<T,false>(eigval, eigvec, U.M, n\_eigvals, form\_val, sigma, opts);}
\DoxyCodeLine{535     \}}
\DoxyCodeLine{536 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{537     \{}
\DoxyCodeLine{538     arma\_ignore(eigval);}
\DoxyCodeLine{539     arma\_ignore(eigvec);}
\DoxyCodeLine{540     arma\_ignore(n\_eigvals);}
\DoxyCodeLine{541     arma\_ignore(form\_val);}
\DoxyCodeLine{542     arma\_ignore(opts);}
\DoxyCodeLine{543     }
\DoxyCodeLine{544     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}eigs\_gen(): use of NEWARP or ARPACK must be enabled"{}});}
\DoxyCodeLine{545     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{546     \}}
\DoxyCodeLine{547 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{548   \}}
\DoxyCodeLine{549 }
\DoxyCodeLine{550 }
\DoxyCodeLine{551 }
\DoxyCodeLine{553 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{554 \textcolor{keyword}{inline}}
\DoxyCodeLine{555 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{556 \mbox{\hyperlink{group__sp__auxlib_ga89f9e9d865d35af62a1f65655dfc9635}{sp\_auxlib::eigs\_gen}}(\mbox{\hyperlink{classCol}{Col}}< std::complex<T> >\& eigval, \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& eigvec, \textcolor{keyword}{const} \mbox{\hyperlink{structSpBase}{SpBase<T, T1>}}\& X, \textcolor{keyword}{const} uword n\_eigvals, \textcolor{keyword}{const} std::complex<T> sigma, \textcolor{keyword}{const} \mbox{\hyperlink{structeigs__opts}{eigs\_opts}}\& opts)}
\DoxyCodeLine{557   \{}
\DoxyCodeLine{558   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{559   }
\DoxyCodeLine{560   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap__spmat}{unwrap\_spmat<T1>}} U(X.get\_ref());}
\DoxyCodeLine{561   }
\DoxyCodeLine{562   arma\_debug\_check( (U.M.is\_square() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}eigs\_gen(): given matrix must be square sized"{}} );}
\DoxyCodeLine{563   }
\DoxyCodeLine{564 \textcolor{preprocessor}{  \#if (defined(ARMA\_USE\_ARPACK) \&\& defined(ARMA\_USE\_SUPERLU))}}
\DoxyCodeLine{565     \{}
\DoxyCodeLine{566     \textcolor{keyword}{constexpr} form\_type form\_val = form\_sigma;}
\DoxyCodeLine{567     }
\DoxyCodeLine{568     \textcolor{keywordflow}{return} sp\_auxlib::eigs\_gen\_arpack<T,true>(eigval, eigvec, U.M, n\_eigvals, form\_val, sigma, opts);}
\DoxyCodeLine{569     \}}
\DoxyCodeLine{570 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{571     \{}
\DoxyCodeLine{572     arma\_ignore(eigval);}
\DoxyCodeLine{573     arma\_ignore(eigvec);}
\DoxyCodeLine{574     arma\_ignore(n\_eigvals);}
\DoxyCodeLine{575     arma\_ignore(sigma);}
\DoxyCodeLine{576     arma\_ignore(opts);}
\DoxyCodeLine{577     }
\DoxyCodeLine{578     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}eigs\_gen(): use of ARPACK and SuperLU must be enabled to use 'sigma'"{}});}
\DoxyCodeLine{579     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{580     \}}
\DoxyCodeLine{581 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{582   \}}
\DoxyCodeLine{583 }
\DoxyCodeLine{584 }
\DoxyCodeLine{585 }
\DoxyCodeLine{586 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{587 \textcolor{keyword}{inline}}
\DoxyCodeLine{588 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{589 sp\_auxlib::eigs\_gen\_newarp(\mbox{\hyperlink{classCol}{Col}}< std::complex<T> >\& eigval, \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& eigvec, \textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<T>}}\& X, \textcolor{keyword}{const} uword n\_eigvals, \textcolor{keyword}{const} form\_type form\_val, \textcolor{keyword}{const} \mbox{\hyperlink{structeigs__opts}{eigs\_opts}}\& opts)}
\DoxyCodeLine{590   \{}
\DoxyCodeLine{591   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{592   }
\DoxyCodeLine{593 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_NEWARP)}}
\DoxyCodeLine{594     \{}
\DoxyCodeLine{595     arma\_debug\_check( (form\_val != form\_lm) \&\& (form\_val != form\_sm) \&\& (form\_val != form\_lr) \&\& (form\_val != form\_sr) \&\& (form\_val != form\_li) \&\& (form\_val != form\_si), \textcolor{stringliteral}{"{}eigs\_gen(): unknown form specified"{}} );}
\DoxyCodeLine{596     }
\DoxyCodeLine{597     \textcolor{keywordflow}{if}(X.is\_square() == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{598     }
\DoxyCodeLine{599     \textcolor{keyword}{const} \mbox{\hyperlink{classnewarp_1_1SparseGenMatProd}{newarp::SparseGenMatProd<T>}} op(X);}
\DoxyCodeLine{600     }
\DoxyCodeLine{601     arma\_debug\_check( (n\_eigvals + 1 >= op.n\_rows), \textcolor{stringliteral}{"{}eigs\_gen(): n\_eigvals + 1 must be less than the number of rows in the matrix"{}} );}
\DoxyCodeLine{602     }
\DoxyCodeLine{603     \textcolor{comment}{// If the matrix is empty, the case is trivial.}}
\DoxyCodeLine{604     \textcolor{keywordflow}{if}( (op.n\_cols == 0) || (n\_eigvals == 0) ) \textcolor{comment}{// We already know n\_cols == n\_rows.}}
\DoxyCodeLine{605       \{}
\DoxyCodeLine{606       eigval.reset();}
\DoxyCodeLine{607       eigvec.reset();}
\DoxyCodeLine{608       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{609       \}}
\DoxyCodeLine{610     }
\DoxyCodeLine{611     uword n   = op.n\_rows;}
\DoxyCodeLine{612     }
\DoxyCodeLine{613     \textcolor{comment}{// Use max(2*k+1, 20) as default subspace dimension for the gen case; same as MATLAB.}}
\DoxyCodeLine{614     uword ncv\_default = uword( ((2*n\_eigvals+1)>(20)) ? (2*n\_eigvals+1) : (20) );}
\DoxyCodeLine{615     }
\DoxyCodeLine{616     \textcolor{comment}{// Use opts.subdim only if it's within the limits}}
\DoxyCodeLine{617     uword ncv = ncv\_default;}
\DoxyCodeLine{618     }
\DoxyCodeLine{619     \textcolor{keywordflow}{if}(opts.subdim != 0)}
\DoxyCodeLine{620       \{}
\DoxyCodeLine{621       \textcolor{keywordflow}{if}(opts.subdim < (n\_eigvals + 3))}
\DoxyCodeLine{622         \{}
\DoxyCodeLine{623         arma\_debug\_warn\_level(1, \textcolor{stringliteral}{"{}eigs\_gen(): opts.subdim must be greater than k+2; using k+3 instead of "{}}, opts.subdim);}
\DoxyCodeLine{624         ncv = uword(n\_eigvals + 3);}
\DoxyCodeLine{625         \}}
\DoxyCodeLine{626       \textcolor{keywordflow}{else}}
\DoxyCodeLine{627       \textcolor{keywordflow}{if}(opts.subdim > n)}
\DoxyCodeLine{628         \{}
\DoxyCodeLine{629         arma\_debug\_warn\_level(1, \textcolor{stringliteral}{"{}eigs\_gen(): opts.subdim cannot be greater than n\_rows; using n\_rows instead of "{}}, opts.subdim);}
\DoxyCodeLine{630         ncv = n;}
\DoxyCodeLine{631         \}}
\DoxyCodeLine{632       \textcolor{keywordflow}{else}}
\DoxyCodeLine{633         \{}
\DoxyCodeLine{634         ncv = uword(opts.subdim);}
\DoxyCodeLine{635         \}}
\DoxyCodeLine{636       \}}
\DoxyCodeLine{637     }
\DoxyCodeLine{638     \textcolor{comment}{// Re-\/check that we are within the limits}}
\DoxyCodeLine{639     \textcolor{keywordflow}{if}(ncv < (n\_eigvals + 3)) \{ ncv = (n\_eigvals + 3); \}}
\DoxyCodeLine{640     \textcolor{keywordflow}{if}(ncv > n              ) \{ ncv = n;               \}}
\DoxyCodeLine{641     }
\DoxyCodeLine{642     T tol = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(T(opts.tol), std::numeric\_limits<T>::epsilon());}
\DoxyCodeLine{643     }
\DoxyCodeLine{644     uword maxiter = uword(opts.maxiter);}
\DoxyCodeLine{645     }
\DoxyCodeLine{646     \textcolor{comment}{// eigval.set\_size(n\_eigvals);}}
\DoxyCodeLine{647     \textcolor{comment}{// eigvec.set\_size(n, n\_eigvals);}}
\DoxyCodeLine{648     }
\DoxyCodeLine{649     \textcolor{keywordtype}{bool} status = \textcolor{keyword}{true};}
\DoxyCodeLine{650     }
\DoxyCodeLine{651     uword nconv = 0;}
\DoxyCodeLine{652     }
\DoxyCodeLine{653     \textcolor{keywordflow}{try}}
\DoxyCodeLine{654       \{}
\DoxyCodeLine{655       \textcolor{keywordflow}{if}(form\_val == form\_lm)}
\DoxyCodeLine{656         \{}
\DoxyCodeLine{657         \mbox{\hyperlink{classnewarp_1_1GenEigsSolver}{newarp::GenEigsSolver< T, newarp::EigsSelect::LARGEST\_MAGN, newarp::SparseGenMatProd<T>}} > eigs(op, n\_eigvals, ncv);}
\DoxyCodeLine{658         eigs.init();}
\DoxyCodeLine{659         nconv  = eigs.compute(maxiter, tol);}
\DoxyCodeLine{660         eigval = eigs.eigenvalues();}
\DoxyCodeLine{661         eigvec = eigs.eigenvectors();}
\DoxyCodeLine{662         \}}
\DoxyCodeLine{663       \textcolor{keywordflow}{else}}
\DoxyCodeLine{664       \textcolor{keywordflow}{if}(form\_val == form\_sm)}
\DoxyCodeLine{665         \{}
\DoxyCodeLine{666         \mbox{\hyperlink{classnewarp_1_1GenEigsSolver}{newarp::GenEigsSolver< T, newarp::EigsSelect::SMALLEST\_MAGN, newarp::SparseGenMatProd<T>}} > eigs(op, n\_eigvals, ncv);}
\DoxyCodeLine{667         eigs.init();}
\DoxyCodeLine{668         nconv  = eigs.compute(maxiter, tol);}
\DoxyCodeLine{669         eigval = eigs.eigenvalues();}
\DoxyCodeLine{670         eigvec = eigs.eigenvectors();}
\DoxyCodeLine{671         \}}
\DoxyCodeLine{672       \textcolor{keywordflow}{else}}
\DoxyCodeLine{673       \textcolor{keywordflow}{if}(form\_val == form\_lr)}
\DoxyCodeLine{674         \{}
\DoxyCodeLine{675         \mbox{\hyperlink{classnewarp_1_1GenEigsSolver}{newarp::GenEigsSolver< T, newarp::EigsSelect::LARGEST\_REAL, newarp::SparseGenMatProd<T>}} > eigs(op, n\_eigvals, ncv);}
\DoxyCodeLine{676         eigs.init();}
\DoxyCodeLine{677         nconv  = eigs.compute(maxiter, tol);}
\DoxyCodeLine{678         eigval = eigs.eigenvalues();}
\DoxyCodeLine{679         eigvec = eigs.eigenvectors();}
\DoxyCodeLine{680         \}}
\DoxyCodeLine{681       \textcolor{keywordflow}{else}}
\DoxyCodeLine{682       \textcolor{keywordflow}{if}(form\_val == form\_sr)}
\DoxyCodeLine{683         \{}
\DoxyCodeLine{684         \mbox{\hyperlink{classnewarp_1_1GenEigsSolver}{newarp::GenEigsSolver< T, newarp::EigsSelect::SMALLEST\_REAL, newarp::SparseGenMatProd<T>}} > eigs(op, n\_eigvals, ncv);}
\DoxyCodeLine{685         eigs.init();}
\DoxyCodeLine{686         nconv  = eigs.compute(maxiter, tol);}
\DoxyCodeLine{687         eigval = eigs.eigenvalues();}
\DoxyCodeLine{688         eigvec = eigs.eigenvectors();}
\DoxyCodeLine{689         \}}
\DoxyCodeLine{690       \textcolor{keywordflow}{else}}
\DoxyCodeLine{691       \textcolor{keywordflow}{if}(form\_val == form\_li)}
\DoxyCodeLine{692         \{}
\DoxyCodeLine{693         \mbox{\hyperlink{classnewarp_1_1GenEigsSolver}{newarp::GenEigsSolver< T, newarp::EigsSelect::LARGEST\_IMAG, newarp::SparseGenMatProd<T>}} > eigs(op, n\_eigvals, ncv);}
\DoxyCodeLine{694         eigs.init();}
\DoxyCodeLine{695         nconv  = eigs.compute(maxiter, tol);}
\DoxyCodeLine{696         eigval = eigs.eigenvalues();}
\DoxyCodeLine{697         eigvec = eigs.eigenvectors();}
\DoxyCodeLine{698         \}}
\DoxyCodeLine{699       \textcolor{keywordflow}{else}}
\DoxyCodeLine{700       \textcolor{keywordflow}{if}(form\_val == form\_si)}
\DoxyCodeLine{701         \{}
\DoxyCodeLine{702         \mbox{\hyperlink{classnewarp_1_1GenEigsSolver}{newarp::GenEigsSolver< T, newarp::EigsSelect::SMALLEST\_IMAG, newarp::SparseGenMatProd<T>}} > eigs(op, n\_eigvals, ncv);}
\DoxyCodeLine{703         eigs.init();}
\DoxyCodeLine{704         nconv  = eigs.compute(maxiter, tol);}
\DoxyCodeLine{705         eigval = eigs.eigenvalues();}
\DoxyCodeLine{706         eigvec = eigs.eigenvectors();}
\DoxyCodeLine{707         \}}
\DoxyCodeLine{708       \}}
\DoxyCodeLine{709     \textcolor{keywordflow}{catch}(\textcolor{keyword}{const} std::runtime\_error\&)}
\DoxyCodeLine{710       \{}
\DoxyCodeLine{711       status = \textcolor{keyword}{false};}
\DoxyCodeLine{712       \}}
\DoxyCodeLine{713     }
\DoxyCodeLine{714     \textcolor{keywordflow}{if}(status == \textcolor{keyword}{true})}
\DoxyCodeLine{715       \{}
\DoxyCodeLine{716       \textcolor{keywordflow}{if}(nconv == 0)  \{ status = \textcolor{keyword}{false}; \}}
\DoxyCodeLine{717       \}}
\DoxyCodeLine{718     }
\DoxyCodeLine{719     \textcolor{keywordflow}{return} status;}
\DoxyCodeLine{720     \}}
\DoxyCodeLine{721 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{722     \{}
\DoxyCodeLine{723     arma\_ignore(eigval);}
\DoxyCodeLine{724     arma\_ignore(eigvec);}
\DoxyCodeLine{725     arma\_ignore(X);}
\DoxyCodeLine{726     arma\_ignore(n\_eigvals);}
\DoxyCodeLine{727     arma\_ignore(form\_val);}
\DoxyCodeLine{728     arma\_ignore(opts);}
\DoxyCodeLine{729     }
\DoxyCodeLine{730     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{731     \}}
\DoxyCodeLine{732 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{733   \}}
\DoxyCodeLine{734 }
\DoxyCodeLine{735 }
\DoxyCodeLine{736 }
\DoxyCodeLine{737 }
\DoxyCodeLine{738 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{bool} use\_sigma>}
\DoxyCodeLine{739 \textcolor{keyword}{inline}}
\DoxyCodeLine{740 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{741 sp\_auxlib::eigs\_gen\_arpack(\mbox{\hyperlink{classCol}{Col}}< std::complex<T> >\& eigval, \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& eigvec, \textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<T>}}\& X, \textcolor{keyword}{const} uword n\_eigvals, \textcolor{keyword}{const} form\_type form\_val, \textcolor{keyword}{const} std::complex<T> sigma, \textcolor{keyword}{const} \mbox{\hyperlink{structeigs__opts}{eigs\_opts}}\& opts)}
\DoxyCodeLine{742   \{}
\DoxyCodeLine{743   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{744   }
\DoxyCodeLine{745 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_ARPACK)}}
\DoxyCodeLine{746     \{}
\DoxyCodeLine{747     arma\_debug\_check( (form\_val != form\_lm) \&\& (form\_val != form\_sm) \&\& (form\_val != form\_lr) \&\& (form\_val != form\_sr) \&\& (form\_val != form\_li) \&\& (form\_val != form\_si) \&\& (form\_val != form\_sigma), \textcolor{stringliteral}{"{}eigs\_gen(): unknown form specified"{}} );}
\DoxyCodeLine{748     }
\DoxyCodeLine{749     \textcolor{keywordflow}{if}(X.is\_square() == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{750     }
\DoxyCodeLine{751     \textcolor{keywordtype}{char} which\_lm[3] = \textcolor{stringliteral}{"{}LM"{}};}
\DoxyCodeLine{752     \textcolor{keywordtype}{char} which\_sm[3] = \textcolor{stringliteral}{"{}SM"{}};}
\DoxyCodeLine{753     \textcolor{keywordtype}{char} which\_lr[3] = \textcolor{stringliteral}{"{}LR"{}};}
\DoxyCodeLine{754     \textcolor{keywordtype}{char} which\_sr[3] = \textcolor{stringliteral}{"{}SR"{}};}
\DoxyCodeLine{755     \textcolor{keywordtype}{char} which\_li[3] = \textcolor{stringliteral}{"{}LI"{}};}
\DoxyCodeLine{756     \textcolor{keywordtype}{char} which\_si[3] = \textcolor{stringliteral}{"{}SI"{}};}
\DoxyCodeLine{757     }
\DoxyCodeLine{758     \textcolor{keywordtype}{char}* which;}
\DoxyCodeLine{759     }
\DoxyCodeLine{760     \textcolor{keywordflow}{switch}(form\_val)}
\DoxyCodeLine{761       \{}
\DoxyCodeLine{762       \textcolor{keywordflow}{case} form\_lm:  which = which\_lm;  \textcolor{keywordflow}{break};}
\DoxyCodeLine{763       \textcolor{keywordflow}{case} form\_sm:  which = which\_sm;  \textcolor{keywordflow}{break};}
\DoxyCodeLine{764       \textcolor{keywordflow}{case} form\_lr:  which = which\_lr;  \textcolor{keywordflow}{break};}
\DoxyCodeLine{765       \textcolor{keywordflow}{case} form\_sr:  which = which\_sr;  \textcolor{keywordflow}{break};}
\DoxyCodeLine{766       \textcolor{keywordflow}{case} form\_li:  which = which\_li;  \textcolor{keywordflow}{break};}
\DoxyCodeLine{767       \textcolor{keywordflow}{case} form\_si:  which = which\_si;  \textcolor{keywordflow}{break};}
\DoxyCodeLine{768       }
\DoxyCodeLine{769       \textcolor{keywordflow}{default}:       which = which\_lm;}
\DoxyCodeLine{770       \}}
\DoxyCodeLine{771     }
\DoxyCodeLine{772     \textcolor{comment}{// Make sure we aren't asking for every eigenvalue.}}
\DoxyCodeLine{773     arma\_debug\_check( (n\_eigvals + 1 >= X.n\_rows), \textcolor{stringliteral}{"{}eigs\_gen(): n\_eigvals + 1 must be less than the number of rows in the matrix"{}} );}
\DoxyCodeLine{774     }
\DoxyCodeLine{775     \textcolor{comment}{// If the matrix is empty, the case is trivial.}}
\DoxyCodeLine{776     \textcolor{keywordflow}{if}( (X.n\_cols == 0) || (n\_eigvals == 0) ) \textcolor{comment}{// We already know n\_cols == n\_rows.}}
\DoxyCodeLine{777       \{}
\DoxyCodeLine{778       eigval.reset();}
\DoxyCodeLine{779       eigvec.reset();}
\DoxyCodeLine{780       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{781       \}}
\DoxyCodeLine{782     }
\DoxyCodeLine{783     \textcolor{comment}{// Set up variables that get used for neupd().}}
\DoxyCodeLine{784     blas\_int n, ncv, ncv\_default, ldv, lworkl, info, maxiter;}
\DoxyCodeLine{785     }
\DoxyCodeLine{786     T tol   = T(opts.tol);}
\DoxyCodeLine{787     maxiter = blas\_int(opts.maxiter);}
\DoxyCodeLine{788     }
\DoxyCodeLine{789     \mbox{\hyperlink{classpodarray}{podarray<T>}} resid, v, workd, workl;}
\DoxyCodeLine{790     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} iparam, ipntr;}
\DoxyCodeLine{791     \mbox{\hyperlink{classpodarray}{podarray<T>}} rwork; \textcolor{comment}{// Not used in the real case.}}
\DoxyCodeLine{792     }
\DoxyCodeLine{793     n = blas\_int(X.n\_rows); \textcolor{comment}{// The size of the matrix.}}
\DoxyCodeLine{794     }
\DoxyCodeLine{795     \textcolor{comment}{// Use max(2*k+1, 20) as default subspace dimension for the gen case; same as MATLAB.}}
\DoxyCodeLine{796     ncv\_default = blas\_int( ((2*n\_eigvals+1)>(20)) ? (2*n\_eigvals+1) : (20) );}
\DoxyCodeLine{797     }
\DoxyCodeLine{798     \textcolor{comment}{// Use opts.subdim only if it's within the limits}}
\DoxyCodeLine{799     ncv = ncv\_default;}
\DoxyCodeLine{800     }
\DoxyCodeLine{801     \textcolor{keywordflow}{if}(opts.subdim != 0)}
\DoxyCodeLine{802       \{}
\DoxyCodeLine{803       \textcolor{keywordflow}{if}(opts.subdim < (n\_eigvals + 3))}
\DoxyCodeLine{804         \{}
\DoxyCodeLine{805         arma\_debug\_warn\_level(1, \textcolor{stringliteral}{"{}eigs\_gen(): opts.subdim must be greater than k+2; using k+3 instead of "{}}, opts.subdim);}
\DoxyCodeLine{806         ncv = blas\_int(n\_eigvals + 3);}
\DoxyCodeLine{807         \}}
\DoxyCodeLine{808       \textcolor{keywordflow}{else}}
\DoxyCodeLine{809       \textcolor{keywordflow}{if}(blas\_int(opts.subdim) > n)}
\DoxyCodeLine{810         \{}
\DoxyCodeLine{811         arma\_debug\_warn\_level(1, \textcolor{stringliteral}{"{}eigs\_gen(): opts.subdim cannot be greater than n\_rows; using n\_rows instead of "{}}, opts.subdim);}
\DoxyCodeLine{812         ncv = n;}
\DoxyCodeLine{813         \}}
\DoxyCodeLine{814       \textcolor{keywordflow}{else}}
\DoxyCodeLine{815         \{}
\DoxyCodeLine{816         ncv = blas\_int(opts.subdim);}
\DoxyCodeLine{817         \}}
\DoxyCodeLine{818       \}}
\DoxyCodeLine{819     }
\DoxyCodeLine{820     \textcolor{comment}{// WARNING!!!}}
\DoxyCodeLine{821     \textcolor{comment}{// We are still not able to apply truly complex shifts to real matrices,}}
\DoxyCodeLine{822     \textcolor{comment}{// in which case the OP that ARPACK wants is different (see [s/d]naupd).}}
\DoxyCodeLine{823     \textcolor{comment}{// Also, if sigma contains a non-\/zero imaginary part, retrieving the eigenvalues}}
\DoxyCodeLine{824     \textcolor{comment}{// becomes utterly messy (see [s/d]eupd, remark \#3).}}
\DoxyCodeLine{825     \textcolor{comment}{// We should never get to the point in which the imaginary part of sigma is non-\/zero;}}
\DoxyCodeLine{826     \textcolor{comment}{// the user-\/facing functions currently convert X from real to complex if a complex sigma is detected.}}
\DoxyCodeLine{827     \textcolor{comment}{// The check here is just for extra safety, and as a reminder of what's missing.}}
\DoxyCodeLine{828     T sigmar = real(sigma);}
\DoxyCodeLine{829     T sigmai = imag(sigma);}
\DoxyCodeLine{830     }
\DoxyCodeLine{831     \textcolor{keywordflow}{if}(use\_sigma)}
\DoxyCodeLine{832     \textcolor{comment}{//if(form\_val == form\_sigma)}}
\DoxyCodeLine{833       \{}
\DoxyCodeLine{834       \textcolor{keywordflow}{if}(sigmai != T(0))  \{ arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}eigs\_gen(): complex 'sigma' not applicable to real matrix"{}}); \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{835     }
\DoxyCodeLine{836       run\_aupd\_shiftinvert(n\_eigvals, sigmar, X, \textcolor{keyword}{false} \textcolor{comment}{/* gen, not sym */}, n, tol, maxiter, resid, ncv, v, ldv, iparam, ipntr, workd, workl, lworkl, rwork, info);}
\DoxyCodeLine{837       \}}
\DoxyCodeLine{838     \textcolor{keywordflow}{else}}
\DoxyCodeLine{839       \{}
\DoxyCodeLine{840       run\_aupd\_plain(n\_eigvals, which, X, \textcolor{keyword}{false} \textcolor{comment}{/* gen, not sym */}, n, tol, maxiter, resid, ncv, v, ldv, iparam, ipntr, workd, workl, lworkl, rwork, info);}
\DoxyCodeLine{841       \}}
\DoxyCodeLine{842     }
\DoxyCodeLine{843     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{844 }
\DoxyCodeLine{845     \textcolor{comment}{// The process has converged, and now we need to recover the actual eigenvectors using neupd().}}
\DoxyCodeLine{846     blas\_int rvec = 1; \textcolor{comment}{// .TRUE}}
\DoxyCodeLine{847     blas\_int nev  = blas\_int(n\_eigvals);}
\DoxyCodeLine{848     }
\DoxyCodeLine{849     \textcolor{keywordtype}{char} howmny = \textcolor{charliteral}{'A'};}
\DoxyCodeLine{850     \textcolor{keywordtype}{char} bmat   = \textcolor{charliteral}{'I'}; \textcolor{comment}{// We are considering the standard eigenvalue problem.}}
\DoxyCodeLine{851     }
\DoxyCodeLine{852     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} select(ncv);      \textcolor{comment}{// logical array of dimension NCV}}
\DoxyCodeLine{853     \mbox{\hyperlink{classpodarray}{podarray<T>}}        dr(nev + 1);      \textcolor{comment}{// real array of dimension NEV + 1}}
\DoxyCodeLine{854     \mbox{\hyperlink{classpodarray}{podarray<T>}}        di(nev + 1);      \textcolor{comment}{// real array of dimension NEV + 1}}
\DoxyCodeLine{855     \mbox{\hyperlink{classpodarray}{podarray<T>}}        z(n * (nev + 1)); \textcolor{comment}{// real N by NEV array if HOWMNY = 'A'}}
\DoxyCodeLine{856     blas\_int ldz = n;}
\DoxyCodeLine{857     \mbox{\hyperlink{classpodarray}{podarray<T>}}        workev(3 * ncv);}
\DoxyCodeLine{858     }
\DoxyCodeLine{859     dr.zeros();}
\DoxyCodeLine{860     di.zeros();}
\DoxyCodeLine{861     z.zeros();}
\DoxyCodeLine{862     }
\DoxyCodeLine{863     arpack::neupd(\&rvec, \&howmny, select.memptr(), dr.memptr(), di.memptr(), z.memptr(), \&ldz, (T*) \&sigmar, (T*) \&sigmai, workev.memptr(), \&bmat, \&n, which, \&nev, \&tol, resid.memptr(), \&ncv, v.memptr(), \&ldv, iparam.memptr(), ipntr.memptr(), workd.memptr(), workl.memptr(), \&lworkl, rwork.memptr(), \&info);}
\DoxyCodeLine{864     }
\DoxyCodeLine{865     \textcolor{comment}{// Check for errors.}}
\DoxyCodeLine{866     \textcolor{keywordflow}{if}(info != 0)  \{ arma\_debug\_warn\_level(1, \textcolor{stringliteral}{"{}eigs\_gen(): ARPACK error "{}}, info, \textcolor{stringliteral}{"{} in neupd()"{}}); \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{867     }
\DoxyCodeLine{868     \textcolor{comment}{// Put it into the outputs.}}
\DoxyCodeLine{869     eigval.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(n\_eigvals);}
\DoxyCodeLine{870     eigvec.zeros(n, n\_eigvals);}
\DoxyCodeLine{871     }
\DoxyCodeLine{872     \textcolor{keywordflow}{for}(uword i = 0; i < n\_eigvals; ++i)}
\DoxyCodeLine{873       \{}
\DoxyCodeLine{874       eigval[i] = std::complex<T>(dr[i], di[i]);}
\DoxyCodeLine{875       \}}
\DoxyCodeLine{876     }
\DoxyCodeLine{877     \textcolor{comment}{// Now recover the eigenvectors.}}
\DoxyCodeLine{878     \textcolor{keywordflow}{for}(uword i = 0; i < n\_eigvals; ++i)}
\DoxyCodeLine{879       \{}
\DoxyCodeLine{880       \textcolor{comment}{// ARPACK ?neupd lays things out kinda odd in memory;}}
\DoxyCodeLine{881       \textcolor{comment}{// so does LAPACK ?geev -\/-\/ see auxlib::eig\_gen()}}
\DoxyCodeLine{882       \textcolor{keywordflow}{if}((i < n\_eigvals -\/ 1) \&\& (eigval[i] == std::conj(eigval[i + 1])))}
\DoxyCodeLine{883         \{}
\DoxyCodeLine{884         \textcolor{keywordflow}{for}(uword j = 0; j < uword(n); ++j)}
\DoxyCodeLine{885           \{}
\DoxyCodeLine{886           eigvec.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(j, i)     = std::complex<T>(z[n * i + j],  z[n * (i + 1) + j]);}
\DoxyCodeLine{887           eigvec.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(j, i + 1) = std::complex<T>(z[n * i + j], -\/z[n * (i + 1) + j]);}
\DoxyCodeLine{888           \}}
\DoxyCodeLine{889         ++i; \textcolor{comment}{// Skip the next one.}}
\DoxyCodeLine{890         \}}
\DoxyCodeLine{891       \textcolor{keywordflow}{else}}
\DoxyCodeLine{892       \textcolor{keywordflow}{if}((i == n\_eigvals -\/ 1) \&\& (std::complex<T>(eigval[i]).imag() != 0.0))}
\DoxyCodeLine{893         \{}
\DoxyCodeLine{894         \textcolor{comment}{// We don't have the matched conjugate eigenvalue.}}
\DoxyCodeLine{895         \textcolor{keywordflow}{for}(uword j = 0; j < uword(n); ++j)}
\DoxyCodeLine{896           \{}
\DoxyCodeLine{897           eigvec.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(j, i) = std::complex<T>(z[n * i + j], z[n * (i + 1) + j]);}
\DoxyCodeLine{898           \}}
\DoxyCodeLine{899         \}}
\DoxyCodeLine{900       \textcolor{keywordflow}{else}}
\DoxyCodeLine{901         \{}
\DoxyCodeLine{902         \textcolor{comment}{// The eigenvector is entirely real.}}
\DoxyCodeLine{903         \textcolor{keywordflow}{for}(uword j = 0; j < uword(n); ++j)}
\DoxyCodeLine{904           \{}
\DoxyCodeLine{905           eigvec.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(j, i) = std::complex<T>(z[n * i + j], T(0));}
\DoxyCodeLine{906           \}}
\DoxyCodeLine{907         \}}
\DoxyCodeLine{908       \}}
\DoxyCodeLine{909     }
\DoxyCodeLine{910     \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{911     \}}
\DoxyCodeLine{912 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{913     \{}
\DoxyCodeLine{914     arma\_ignore(eigval);}
\DoxyCodeLine{915     arma\_ignore(eigvec);}
\DoxyCodeLine{916     arma\_ignore(X);}
\DoxyCodeLine{917     arma\_ignore(n\_eigvals);}
\DoxyCodeLine{918     arma\_ignore(form\_val);}
\DoxyCodeLine{919     arma\_ignore(sigma);}
\DoxyCodeLine{920     arma\_ignore(opts);}
\DoxyCodeLine{921     }
\DoxyCodeLine{922     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{923     \}}
\DoxyCodeLine{924 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{925   \}}
\DoxyCodeLine{926 }
\DoxyCodeLine{927 }
\DoxyCodeLine{928 }
\DoxyCodeLine{930 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{931 \textcolor{keyword}{inline}}
\DoxyCodeLine{932 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{933 \mbox{\hyperlink{group__sp__auxlib_ga89f9e9d865d35af62a1f65655dfc9635}{sp\_auxlib::eigs\_gen}}(\mbox{\hyperlink{classCol}{Col}}< std::complex<T> >\& eigval, \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& eigvec, \textcolor{keyword}{const} \mbox{\hyperlink{structSpBase}{SpBase}}< std::complex<T>, T1>\& X\_expr, \textcolor{keyword}{const} uword n\_eigvals, \textcolor{keyword}{const} form\_type form\_val, \textcolor{keyword}{const} \mbox{\hyperlink{structeigs__opts}{eigs\_opts}}\& opts)}
\DoxyCodeLine{934   \{}
\DoxyCodeLine{935   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{936   }
\DoxyCodeLine{937   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap__spmat}{unwrap\_spmat<T1>}} U(X\_expr.get\_ref());}
\DoxyCodeLine{938   }
\DoxyCodeLine{939   arma\_debug\_check( (U.M.is\_square() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}eigs\_gen(): given matrix must be square sized"{}} );}
\DoxyCodeLine{940   }
\DoxyCodeLine{941   \textcolor{keyword}{constexpr} std::complex<T> sigma = T(0);}
\DoxyCodeLine{942   }
\DoxyCodeLine{943   \textcolor{keywordflow}{return} sp\_auxlib::eigs\_gen<T, false>(eigval, eigvec, U.M, n\_eigvals, form\_val, sigma, opts);}
\DoxyCodeLine{944   \}}
\DoxyCodeLine{945 }
\DoxyCodeLine{946 }
\DoxyCodeLine{947 }
\DoxyCodeLine{949 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{950 \textcolor{keyword}{inline}}
\DoxyCodeLine{951 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{952 \mbox{\hyperlink{group__sp__auxlib_ga89f9e9d865d35af62a1f65655dfc9635}{sp\_auxlib::eigs\_gen}}(\mbox{\hyperlink{classCol}{Col}}< std::complex<T> >\& eigval, \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& eigvec, \textcolor{keyword}{const} \mbox{\hyperlink{structSpBase}{SpBase}}< std::complex<T>, T1>\& X, \textcolor{keyword}{const} uword n\_eigvals, \textcolor{keyword}{const} std::complex<T> sigma, \textcolor{keyword}{const} \mbox{\hyperlink{structeigs__opts}{eigs\_opts}}\& opts)}
\DoxyCodeLine{953   \{}
\DoxyCodeLine{954   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{955   }
\DoxyCodeLine{956   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap__spmat}{unwrap\_spmat<T1>}} U(X.get\_ref());}
\DoxyCodeLine{957   }
\DoxyCodeLine{958   arma\_debug\_check( (U.M.is\_square() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}eigs\_gen(): given matrix must be square sized"{}} );}
\DoxyCodeLine{959   }
\DoxyCodeLine{960 \textcolor{preprocessor}{  \#if (defined(ARMA\_USE\_ARPACK) \&\& defined(ARMA\_USE\_SUPERLU))}}
\DoxyCodeLine{961     \{}
\DoxyCodeLine{962     \textcolor{keyword}{constexpr} form\_type form\_val = form\_sigma;}
\DoxyCodeLine{963     }
\DoxyCodeLine{964     \textcolor{keywordflow}{return} sp\_auxlib::eigs\_gen<T, true>(eigval, eigvec, U.M, n\_eigvals, form\_val, sigma, opts);}
\DoxyCodeLine{965     \}}
\DoxyCodeLine{966 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{967     \{}
\DoxyCodeLine{968     arma\_ignore(eigval);}
\DoxyCodeLine{969     arma\_ignore(eigvec);}
\DoxyCodeLine{970     arma\_ignore(n\_eigvals);}
\DoxyCodeLine{971     arma\_ignore(sigma);}
\DoxyCodeLine{972     arma\_ignore(opts);}
\DoxyCodeLine{973     }
\DoxyCodeLine{974     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}eigs\_gen(): use of ARPACK and SuperLU must be enabled to use 'sigma'"{}});}
\DoxyCodeLine{975     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{976     \}}
\DoxyCodeLine{977 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{978   \}}
\DoxyCodeLine{979 }
\DoxyCodeLine{980 }
\DoxyCodeLine{981 }
\DoxyCodeLine{982 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{bool} use\_sigma>}
\DoxyCodeLine{983 \textcolor{keyword}{inline}}
\DoxyCodeLine{984 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{985 \mbox{\hyperlink{group__sp__auxlib_ga89f9e9d865d35af62a1f65655dfc9635}{sp\_auxlib::eigs\_gen}}(\mbox{\hyperlink{classCol}{Col}}< std::complex<T> >\& eigval, \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& eigvec, \textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat}}< std::complex<T> >\& X, \textcolor{keyword}{const} uword n\_eigvals, \textcolor{keyword}{const} form\_type form\_val, \textcolor{keyword}{const} std::complex<T> sigma, \textcolor{keyword}{const} \mbox{\hyperlink{structeigs__opts}{eigs\_opts}}\& opts)}
\DoxyCodeLine{986   \{}
\DoxyCodeLine{987   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{988   }
\DoxyCodeLine{989 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_ARPACK)}}
\DoxyCodeLine{990     \{}
\DoxyCodeLine{991     \textcolor{comment}{// typedef typename std::complex<T> eT;}}
\DoxyCodeLine{992     }
\DoxyCodeLine{993     arma\_debug\_check( (form\_val != form\_lm) \&\& (form\_val != form\_sm) \&\& (form\_val != form\_lr) \&\& (form\_val != form\_sr) \&\& (form\_val != form\_li) \&\& (form\_val != form\_si) \&\& (form\_val != form\_sigma), \textcolor{stringliteral}{"{}eigs\_gen(): unknown form specified"{}} );}
\DoxyCodeLine{994     }
\DoxyCodeLine{995     \textcolor{keywordflow}{if}(X.is\_square() == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{996     }
\DoxyCodeLine{997     \textcolor{keywordtype}{char} which\_lm[3] = \textcolor{stringliteral}{"{}LM"{}};}
\DoxyCodeLine{998     \textcolor{keywordtype}{char} which\_sm[3] = \textcolor{stringliteral}{"{}SM"{}};}
\DoxyCodeLine{999     \textcolor{keywordtype}{char} which\_lr[3] = \textcolor{stringliteral}{"{}LR"{}};}
\DoxyCodeLine{1000     \textcolor{keywordtype}{char} which\_sr[3] = \textcolor{stringliteral}{"{}SR"{}};}
\DoxyCodeLine{1001     \textcolor{keywordtype}{char} which\_li[3] = \textcolor{stringliteral}{"{}LI"{}};}
\DoxyCodeLine{1002     \textcolor{keywordtype}{char} which\_si[3] = \textcolor{stringliteral}{"{}SI"{}};}
\DoxyCodeLine{1003     }
\DoxyCodeLine{1004     \textcolor{keywordtype}{char}* which;}
\DoxyCodeLine{1005     }
\DoxyCodeLine{1006     \textcolor{keywordflow}{switch}(form\_val)}
\DoxyCodeLine{1007       \{}
\DoxyCodeLine{1008       \textcolor{keywordflow}{case} form\_lm:  which = which\_lm;  \textcolor{keywordflow}{break};}
\DoxyCodeLine{1009       \textcolor{keywordflow}{case} form\_sm:  which = which\_sm;  \textcolor{keywordflow}{break};}
\DoxyCodeLine{1010       \textcolor{keywordflow}{case} form\_lr:  which = which\_lr;  \textcolor{keywordflow}{break};}
\DoxyCodeLine{1011       \textcolor{keywordflow}{case} form\_sr:  which = which\_sr;  \textcolor{keywordflow}{break};}
\DoxyCodeLine{1012       \textcolor{keywordflow}{case} form\_li:  which = which\_li;  \textcolor{keywordflow}{break};}
\DoxyCodeLine{1013       \textcolor{keywordflow}{case} form\_si:  which = which\_si;  \textcolor{keywordflow}{break};}
\DoxyCodeLine{1014       }
\DoxyCodeLine{1015       \textcolor{keywordflow}{default}:       which = which\_lm;}
\DoxyCodeLine{1016       \}}
\DoxyCodeLine{1017     }
\DoxyCodeLine{1018     \textcolor{comment}{// Make sure we aren't asking for every eigenvalue.}}
\DoxyCodeLine{1019     arma\_debug\_check( (n\_eigvals + 1 >= X.n\_rows), \textcolor{stringliteral}{"{}eigs\_gen(): n\_eigvals + 1 must be less than the number of rows in the matrix"{}} );}
\DoxyCodeLine{1020     }
\DoxyCodeLine{1021     \textcolor{comment}{// If the matrix is empty, the case is trivial.}}
\DoxyCodeLine{1022     \textcolor{keywordflow}{if}( (X.n\_cols == 0) || (n\_eigvals == 0) ) \textcolor{comment}{// We already know n\_cols == n\_rows.}}
\DoxyCodeLine{1023       \{}
\DoxyCodeLine{1024       eigval.reset();}
\DoxyCodeLine{1025       eigvec.reset();}
\DoxyCodeLine{1026       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1027       \}}
\DoxyCodeLine{1028     }
\DoxyCodeLine{1029     \textcolor{comment}{// Set up variables that get used for neupd().}}
\DoxyCodeLine{1030     blas\_int n, ncv, ncv\_default, ldv, lworkl, info, maxiter;}
\DoxyCodeLine{1031     }
\DoxyCodeLine{1032     T tol   = T(opts.tol);}
\DoxyCodeLine{1033     maxiter = blas\_int(opts.maxiter);}
\DoxyCodeLine{1034     }
\DoxyCodeLine{1035     \mbox{\hyperlink{classpodarray}{podarray< std::complex<T>}} > resid, v, workd, workl;}
\DoxyCodeLine{1036     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} iparam, ipntr;}
\DoxyCodeLine{1037     \mbox{\hyperlink{classpodarray}{podarray<T>}} rwork;}
\DoxyCodeLine{1038     }
\DoxyCodeLine{1039     n = blas\_int(X.n\_rows); \textcolor{comment}{// The size of the matrix.}}
\DoxyCodeLine{1040     }
\DoxyCodeLine{1041     \textcolor{comment}{// Use max(2*k+1, 20) as default subspace dimension for the gen case; same as MATLAB.}}
\DoxyCodeLine{1042     ncv\_default = blas\_int( ((2*n\_eigvals+1)>(20)) ? (2*n\_eigvals+1) : (20) );}
\DoxyCodeLine{1043     }
\DoxyCodeLine{1044     \textcolor{comment}{// Use opts.subdim only if it's within the limits}}
\DoxyCodeLine{1045     ncv = ncv\_default;}
\DoxyCodeLine{1046     }
\DoxyCodeLine{1047     \textcolor{keywordflow}{if}(opts.subdim != 0)}
\DoxyCodeLine{1048       \{}
\DoxyCodeLine{1049       \textcolor{keywordflow}{if}(opts.subdim < (n\_eigvals + 3))}
\DoxyCodeLine{1050         \{}
\DoxyCodeLine{1051         arma\_debug\_warn\_level(1, \textcolor{stringliteral}{"{}eigs\_gen(): opts.subdim must be greater than k+2; using k+3 instead of "{}}, opts.subdim);}
\DoxyCodeLine{1052         ncv = blas\_int(n\_eigvals + 3);}
\DoxyCodeLine{1053         \}}
\DoxyCodeLine{1054       \textcolor{keywordflow}{else}}
\DoxyCodeLine{1055       \textcolor{keywordflow}{if}(blas\_int(opts.subdim) > n)}
\DoxyCodeLine{1056         \{}
\DoxyCodeLine{1057         arma\_debug\_warn\_level(1, \textcolor{stringliteral}{"{}eigs\_gen(): opts.subdim cannot be greater than n\_rows; using n\_rows instead of "{}}, opts.subdim);}
\DoxyCodeLine{1058         ncv = n;}
\DoxyCodeLine{1059         \}}
\DoxyCodeLine{1060       \textcolor{keywordflow}{else}}
\DoxyCodeLine{1061         \{}
\DoxyCodeLine{1062         ncv = blas\_int(opts.subdim);}
\DoxyCodeLine{1063         \}}
\DoxyCodeLine{1064       \}}
\DoxyCodeLine{1065     }
\DoxyCodeLine{1066     \textcolor{keywordflow}{if}(use\_sigma)}
\DoxyCodeLine{1067     \textcolor{comment}{//if(form\_val == form\_sigma)}}
\DoxyCodeLine{1068       \{}
\DoxyCodeLine{1069       run\_aupd\_shiftinvert(n\_eigvals, sigma, X, \textcolor{keyword}{false} \textcolor{comment}{/* gen, not sym */}, n, tol, maxiter, resid, ncv, v, ldv, iparam, ipntr, workd, workl, lworkl, rwork, info);}
\DoxyCodeLine{1070       \}}
\DoxyCodeLine{1071     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1072       \{}
\DoxyCodeLine{1073       run\_aupd\_plain(n\_eigvals, which, X, \textcolor{keyword}{false} \textcolor{comment}{/* gen, not sym */}, n, tol, maxiter, resid, ncv, v, ldv, iparam, ipntr, workd, workl, lworkl, rwork, info);}
\DoxyCodeLine{1074       \}}
\DoxyCodeLine{1075     }
\DoxyCodeLine{1076     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1077     }
\DoxyCodeLine{1078     \textcolor{comment}{// The process has converged, and now we need to recover the actual eigenvectors using neupd().}}
\DoxyCodeLine{1079     blas\_int rvec = 1; \textcolor{comment}{// .TRUE}}
\DoxyCodeLine{1080     blas\_int nev  = blas\_int(n\_eigvals);}
\DoxyCodeLine{1081     }
\DoxyCodeLine{1082     \textcolor{keywordtype}{char} howmny = \textcolor{charliteral}{'A'};}
\DoxyCodeLine{1083     \textcolor{keywordtype}{char} bmat   = \textcolor{charliteral}{'I'}; \textcolor{comment}{// We are considering the standard eigenvalue problem.}}
\DoxyCodeLine{1084     }
\DoxyCodeLine{1085     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}}        select(ncv); \textcolor{comment}{// logical array of dimension NCV}}
\DoxyCodeLine{1086     \mbox{\hyperlink{classpodarray}{podarray<std::complex<T>}}> d(nev + 1);  \textcolor{comment}{// complex array of dimension NEV + 1}}
\DoxyCodeLine{1087     \mbox{\hyperlink{classpodarray}{podarray<std::complex<T>}}> z(n * nev);  \textcolor{comment}{// complex N by NEV array if HOWMNY = 'A'}}
\DoxyCodeLine{1088     blas\_int ldz = n;}
\DoxyCodeLine{1089     \mbox{\hyperlink{classpodarray}{podarray<std::complex<T>}}> workev(2 * ncv);}
\DoxyCodeLine{1090     }
\DoxyCodeLine{1091     \textcolor{comment}{// Prepare the outputs; neupd() will write directly to them.}}
\DoxyCodeLine{1092     eigval.zeros(n\_eigvals);}
\DoxyCodeLine{1093     eigvec.zeros(n, n\_eigvals);}
\DoxyCodeLine{1094     }
\DoxyCodeLine{1095     arpack::neupd(\&rvec, \&howmny, select.memptr(), eigval.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(),}
\DoxyCodeLine{1096 (std::complex<T>*) NULL, eigvec.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldz, (std::complex<T>*) \&sigma, (std::complex<T>*) NULL, workev.memptr(), \&bmat, \&n, which, \&nev, \&tol, resid.memptr(), \&ncv, v.memptr(), \&ldv, iparam.memptr(), ipntr.memptr(), workd.memptr(), workl.memptr(), \&lworkl, rwork.memptr(), \&info);}
\DoxyCodeLine{1097     }
\DoxyCodeLine{1098     \textcolor{comment}{// Check for errors.}}
\DoxyCodeLine{1099     \textcolor{keywordflow}{if}(info != 0)  \{ arma\_debug\_warn\_level(1, \textcolor{stringliteral}{"{}eigs\_gen(): ARPACK error "{}}, info, \textcolor{stringliteral}{"{} in neupd()"{}}); \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1100     }
\DoxyCodeLine{1101     \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{1102     \}}
\DoxyCodeLine{1103 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{1104     \{}
\DoxyCodeLine{1105     arma\_ignore(eigval);}
\DoxyCodeLine{1106     arma\_ignore(eigvec);}
\DoxyCodeLine{1107     arma\_ignore(X);}
\DoxyCodeLine{1108     arma\_ignore(n\_eigvals);}
\DoxyCodeLine{1109     arma\_ignore(form\_val);}
\DoxyCodeLine{1110     arma\_ignore(sigma);}
\DoxyCodeLine{1111     arma\_ignore(opts);}
\DoxyCodeLine{1112 }
\DoxyCodeLine{1113     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}eigs\_gen(): use of ARPACK must be enabled for decomposition of complex matrices"{}});}
\DoxyCodeLine{1114     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1115     \}}
\DoxyCodeLine{1116 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{1117   \}}
\DoxyCodeLine{1118 }
\DoxyCodeLine{1119 }
\DoxyCodeLine{1120 }
\DoxyCodeLine{1121 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{1122 \textcolor{keyword}{inline}}
\DoxyCodeLine{1123 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{1124 sp\_auxlib::spsolve\_simple(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& X, \textcolor{keyword}{const} \mbox{\hyperlink{structSpBase}{SpBase<typename T1::elem\_type, T1>}}\& A\_expr, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::elem\_type, T2>}}\& B\_expr, \textcolor{keyword}{const} \mbox{\hyperlink{structsuperlu__opts}{superlu\_opts}}\& user\_opts)}
\DoxyCodeLine{1125   \{}
\DoxyCodeLine{1126   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1127   }
\DoxyCodeLine{1128 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_SUPERLU)}}
\DoxyCodeLine{1129     \{}
\DoxyCodeLine{1130     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{1131     }
\DoxyCodeLine{1132     superlu::superlu\_options\_t  \mbox{\hyperlink{classoptions}{options}};}
\DoxyCodeLine{1133     sp\_auxlib::set\_superlu\_opts(\mbox{\hyperlink{classoptions}{options}}, user\_opts);}
\DoxyCodeLine{1134     }
\DoxyCodeLine{1135     \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap__spmat}{unwrap\_spmat<T1>}} tmp1(A\_expr.get\_ref());}
\DoxyCodeLine{1136     \textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& \mbox{\hyperlink{structA}{A}} =   tmp1.M;}
\DoxyCodeLine{1137     }
\DoxyCodeLine{1138     X = B\_expr.get\_ref();   \textcolor{comment}{// superlu::gssv() uses X as input (the B matrix) and as output (the solution)}}
\DoxyCodeLine{1139     }
\DoxyCodeLine{1140     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.n\_rows > \mbox{\hyperlink{structA}{A}}.n\_cols)}
\DoxyCodeLine{1141       \{}
\DoxyCodeLine{1142       arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}spsolve(): solving over-\/determined systems currently not supported"{}});}
\DoxyCodeLine{1143       X.soft\_reset();}
\DoxyCodeLine{1144       \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1145       \}}
\DoxyCodeLine{1146     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1147     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.n\_rows < \mbox{\hyperlink{structA}{A}}.n\_cols)}
\DoxyCodeLine{1148       \{}
\DoxyCodeLine{1149       arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}spsolve(): solving under-\/determined systems currently not supported"{}});}
\DoxyCodeLine{1150       X.soft\_reset();}
\DoxyCodeLine{1151       \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1152       \}}
\DoxyCodeLine{1153     }
\DoxyCodeLine{1154     arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.n\_rows != X.n\_rows), \textcolor{stringliteral}{"{}spsolve(): number of rows in the given objects must be the same"{}} );}
\DoxyCodeLine{1155     }
\DoxyCodeLine{1156     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty() || X.is\_empty())}
\DoxyCodeLine{1157       \{}
\DoxyCodeLine{1158       X.zeros(\mbox{\hyperlink{structA}{A}}.n\_cols, X.n\_cols);}
\DoxyCodeLine{1159       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1160       \}}
\DoxyCodeLine{1161     }
\DoxyCodeLine{1162     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.n\_nonzero == uword(0))  \{ X.soft\_reset(); \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1163     }
\DoxyCodeLine{1164     \textcolor{keywordflow}{if}(arma\_config::debug)}
\DoxyCodeLine{1165       \{}
\DoxyCodeLine{1166       \textcolor{keywordtype}{bool} overflow = \textcolor{keyword}{false};}
\DoxyCodeLine{1167       }
\DoxyCodeLine{1168       overflow = (\mbox{\hyperlink{structA}{A}}.n\_nonzero > INT\_MAX);}
\DoxyCodeLine{1169       overflow = (\mbox{\hyperlink{structA}{A}}.n\_rows > INT\_MAX) || overflow;}
\DoxyCodeLine{1170       overflow = (\mbox{\hyperlink{structA}{A}}.n\_cols > INT\_MAX) || overflow;}
\DoxyCodeLine{1171       overflow = (X.n\_rows > INT\_MAX) || overflow;}
\DoxyCodeLine{1172       overflow = (X.n\_cols > INT\_MAX) || overflow;}
\DoxyCodeLine{1173       }
\DoxyCodeLine{1174       \textcolor{keywordflow}{if}(overflow)}
\DoxyCodeLine{1175         \{}
\DoxyCodeLine{1176         arma\_stop\_runtime\_error(\textcolor{stringliteral}{"{}spsolve(): integer overflow: matrix dimensions are too large for integer type used by SuperLU"{}});}
\DoxyCodeLine{1177         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1178         \}}
\DoxyCodeLine{1179       \}}
\DoxyCodeLine{1180     }
\DoxyCodeLine{1181     superlu\_supermatrix\_wrangler x;}
\DoxyCodeLine{1182     superlu\_supermatrix\_wrangler a;}
\DoxyCodeLine{1183     }
\DoxyCodeLine{1184     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} status\_x = wrap\_to\_supermatrix(x.get\_ref(), X);}
\DoxyCodeLine{1185     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} status\_a = copy\_to\_supermatrix(a.get\_ref(), \mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{1186     }
\DoxyCodeLine{1187     \textcolor{keywordflow}{if}( (status\_x == \textcolor{keyword}{false}) || (status\_a == \textcolor{keyword}{false}) )  \{ X.soft\_reset(); \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1188     }
\DoxyCodeLine{1189     superlu\_supermatrix\_wrangler l;}
\DoxyCodeLine{1190     superlu\_supermatrix\_wrangler u;}
\DoxyCodeLine{1191     }
\DoxyCodeLine{1192     \textcolor{comment}{// paranoia: use SuperLU's memory allocation, in case it reallocs}}
\DoxyCodeLine{1193     }
\DoxyCodeLine{1194     superlu\_array\_wrangler<int> perm\_c(\mbox{\hyperlink{structA}{A}}.n\_cols+1);  \textcolor{comment}{// extra paranoia: increase array length by 1}}
\DoxyCodeLine{1195     superlu\_array\_wrangler<int> perm\_r(\mbox{\hyperlink{structA}{A}}.n\_rows+1);}
\DoxyCodeLine{1196     }
\DoxyCodeLine{1197     superlu\_stat\_wrangler stat;}
\DoxyCodeLine{1198     }
\DoxyCodeLine{1199     \textcolor{keywordtype}{int} info = 0; \textcolor{comment}{// Return code.}}
\DoxyCodeLine{1200     }
\DoxyCodeLine{1201     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}superlu::gssv()"{}});}
\DoxyCodeLine{1202     superlu::gssv<eT>(\&\mbox{\hyperlink{classoptions}{options}}, a.get\_ptr(), perm\_c.get\_ptr(), perm\_r.get\_ptr(), l.get\_ptr(), u.get\_ptr(), x.get\_ptr(), stat.get\_ptr(), \&info);}
\DoxyCodeLine{1203     }
\DoxyCodeLine{1204     }
\DoxyCodeLine{1205     \textcolor{comment}{// Process the return code.}}
\DoxyCodeLine{1206     \textcolor{keywordflow}{if}( (info > 0) \&\& (info <= \textcolor{keywordtype}{int}(\mbox{\hyperlink{structA}{A}}.n\_cols)) )}
\DoxyCodeLine{1207       \{}
\DoxyCodeLine{1208       \textcolor{comment}{// std::ostringstream tmp;}}
\DoxyCodeLine{1209       \textcolor{comment}{// tmp << "{}spsolve(): could not solve system; LU factorisation completed, but detected zero in U("{} << (info-\/1) << ',' << (info-\/1) << ')';}}
\DoxyCodeLine{1210       \textcolor{comment}{// arma\_debug\_warn\_level(1, tmp.str());}}
\DoxyCodeLine{1211       \}}
\DoxyCodeLine{1212     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1213     \textcolor{keywordflow}{if}(info > \textcolor{keywordtype}{int}(\mbox{\hyperlink{structA}{A}}.n\_cols))}
\DoxyCodeLine{1214       \{}
\DoxyCodeLine{1215       arma\_debug\_warn\_level(1, \textcolor{stringliteral}{"{}spsolve(): memory allocation failure: could not allocate "{}}, (info -\/ \textcolor{keywordtype}{int}(\mbox{\hyperlink{structA}{A}}.n\_cols)), \textcolor{stringliteral}{"{} bytes"{}});}
\DoxyCodeLine{1216       \}}
\DoxyCodeLine{1217     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1218     \textcolor{keywordflow}{if}(info < 0)}
\DoxyCodeLine{1219       \{}
\DoxyCodeLine{1220       arma\_debug\_warn\_level(1, \textcolor{stringliteral}{"{}spsolve(): unknown SuperLU error code from gssv(): "{}}, info);}
\DoxyCodeLine{1221       \}}
\DoxyCodeLine{1222     }
\DoxyCodeLine{1223     \textcolor{comment}{// No need to extract the data from x, since it's using the same memory as X}}
\DoxyCodeLine{1224     }
\DoxyCodeLine{1225     \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{1226     \}}
\DoxyCodeLine{1227 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{1228     \{}
\DoxyCodeLine{1229     arma\_ignore(X);}
\DoxyCodeLine{1230     arma\_ignore(A\_expr);}
\DoxyCodeLine{1231     arma\_ignore(B\_expr);}
\DoxyCodeLine{1232     arma\_ignore(user\_opts);}
\DoxyCodeLine{1233     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}spsolve(): use of SuperLU must be enabled"{}});}
\DoxyCodeLine{1234     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1235     \}}
\DoxyCodeLine{1236 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{1237   \}}
\DoxyCodeLine{1238 }
\DoxyCodeLine{1239 }
\DoxyCodeLine{1240 }
\DoxyCodeLine{1241 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{1242 \textcolor{keyword}{inline}}
\DoxyCodeLine{1243 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{1244 sp\_auxlib::spsolve\_refine(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& X, \textcolor{keyword}{typename} T1::pod\_type\& out\_rcond, \textcolor{keyword}{const} \mbox{\hyperlink{structSpBase}{SpBase<typename T1::elem\_type, T1>}}\& A\_expr, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::elem\_type, T2>}}\& B\_expr, \textcolor{keyword}{const} \mbox{\hyperlink{structsuperlu__opts}{superlu\_opts}}\& user\_opts)}
\DoxyCodeLine{1245   \{}
\DoxyCodeLine{1246   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1247   }
\DoxyCodeLine{1248 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_SUPERLU)}}
\DoxyCodeLine{1249     \{}
\DoxyCodeLine{1250     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type   T;}
\DoxyCodeLine{1251     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{1252     }
\DoxyCodeLine{1253     superlu::superlu\_options\_t  \mbox{\hyperlink{classoptions}{options}};}
\DoxyCodeLine{1254     sp\_auxlib::set\_superlu\_opts(\mbox{\hyperlink{classoptions}{options}}, user\_opts);}
\DoxyCodeLine{1255     }
\DoxyCodeLine{1256     \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap__spmat}{unwrap\_spmat<T1>}} tmp1(A\_expr.get\_ref());}
\DoxyCodeLine{1257     \textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& \mbox{\hyperlink{structA}{A}} =   tmp1.M;}
\DoxyCodeLine{1258     }
\DoxyCodeLine{1259     \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap}{unwrap<T2>}}          tmp2(B\_expr.get\_ref());}
\DoxyCodeLine{1260     \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& B\_unwrap = tmp2.M;}
\DoxyCodeLine{1261     }
\DoxyCodeLine{1262     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} B\_is\_modified = ( (user\_opts.equilibrate) || (\&B\_unwrap == \&X) );}
\DoxyCodeLine{1263     }
\DoxyCodeLine{1264     \mbox{\hyperlink{classMat}{Mat<eT>}} B\_copy;  \textcolor{keywordflow}{if}(B\_is\_modified)  \{ B\_copy = B\_unwrap; \}}
\DoxyCodeLine{1265     }
\DoxyCodeLine{1266     \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structB}{B}} = (B\_is\_modified) ?  B\_copy : B\_unwrap;}
\DoxyCodeLine{1267     }
\DoxyCodeLine{1268     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.n\_rows > \mbox{\hyperlink{structA}{A}}.n\_cols)}
\DoxyCodeLine{1269       \{}
\DoxyCodeLine{1270       arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}spsolve(): solving over-\/determined systems currently not supported"{}});}
\DoxyCodeLine{1271       X.soft\_reset();}
\DoxyCodeLine{1272       \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1273       \}}
\DoxyCodeLine{1274     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1275     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.n\_rows < \mbox{\hyperlink{structA}{A}}.n\_cols)}
\DoxyCodeLine{1276       \{}
\DoxyCodeLine{1277       arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}spsolve(): solving under-\/determined systems currently not supported"{}});}
\DoxyCodeLine{1278       X.soft\_reset();}
\DoxyCodeLine{1279       \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1280       \}}
\DoxyCodeLine{1281     }
\DoxyCodeLine{1282     arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.n\_rows != \mbox{\hyperlink{structB}{B}}.n\_rows), \textcolor{stringliteral}{"{}spsolve(): number of rows in the given objects must be the same"{}} );}
\DoxyCodeLine{1283     }
\DoxyCodeLine{1284     X.zeros(\mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structB}{B}}.n\_cols);  \textcolor{comment}{// set the elements to zero, as we don't trust the SuperLU spaghetti code}}
\DoxyCodeLine{1285     }
\DoxyCodeLine{1286     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty() || \mbox{\hyperlink{structB}{B}}.is\_empty())}
\DoxyCodeLine{1287       \{}
\DoxyCodeLine{1288       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1289       \}}
\DoxyCodeLine{1290     }
\DoxyCodeLine{1291     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.n\_nonzero == uword(0))  \{ X.soft\_reset(); \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1292     }
\DoxyCodeLine{1293     \textcolor{keywordflow}{if}(arma\_config::debug)}
\DoxyCodeLine{1294       \{}
\DoxyCodeLine{1295       \textcolor{keywordtype}{bool} overflow;}
\DoxyCodeLine{1296       }
\DoxyCodeLine{1297       overflow = (\mbox{\hyperlink{structA}{A}}.n\_nonzero > INT\_MAX);}
\DoxyCodeLine{1298       overflow = (\mbox{\hyperlink{structA}{A}}.n\_rows > INT\_MAX) || overflow;}
\DoxyCodeLine{1299       overflow = (\mbox{\hyperlink{structA}{A}}.n\_cols > INT\_MAX) || overflow;}
\DoxyCodeLine{1300       overflow = (\mbox{\hyperlink{structB}{B}}.n\_rows > INT\_MAX) || overflow;}
\DoxyCodeLine{1301       overflow = (\mbox{\hyperlink{structB}{B}}.n\_cols > INT\_MAX) || overflow;}
\DoxyCodeLine{1302       overflow = (X.n\_rows > INT\_MAX) || overflow;}
\DoxyCodeLine{1303       overflow = (X.n\_cols > INT\_MAX) || overflow;}
\DoxyCodeLine{1304       }
\DoxyCodeLine{1305       \textcolor{keywordflow}{if}(overflow)}
\DoxyCodeLine{1306         \{}
\DoxyCodeLine{1307         arma\_stop\_runtime\_error(\textcolor{stringliteral}{"{}spsolve(): integer overflow: matrix dimensions are too large for integer type used by SuperLU"{}});}
\DoxyCodeLine{1308         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1309         \}}
\DoxyCodeLine{1310       \}}
\DoxyCodeLine{1311     }
\DoxyCodeLine{1312     superlu\_supermatrix\_wrangler x;}
\DoxyCodeLine{1313     superlu\_supermatrix\_wrangler a;}
\DoxyCodeLine{1314     superlu\_supermatrix\_wrangler b;}
\DoxyCodeLine{1315     }
\DoxyCodeLine{1316     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} status\_x = wrap\_to\_supermatrix(x.get\_ref(), X);}
\DoxyCodeLine{1317     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} status\_a = copy\_to\_supermatrix(a.get\_ref(), \mbox{\hyperlink{structA}{A}});  \textcolor{comment}{// NOTE: superlu::gssvx() modifies 'a' if equilibration is enabled}}
\DoxyCodeLine{1318     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} status\_b = wrap\_to\_supermatrix(b.get\_ref(), \mbox{\hyperlink{structB}{B}});  \textcolor{comment}{// NOTE: superlu::gssvx() modifies 'b' if equilibration is enabled}}
\DoxyCodeLine{1319     }
\DoxyCodeLine{1320     \textcolor{keywordflow}{if}( (status\_x == \textcolor{keyword}{false}) || (status\_a == \textcolor{keyword}{false}) || (status\_b == \textcolor{keyword}{false}) )  \{ X.soft\_reset(); \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1321     }
\DoxyCodeLine{1322     superlu\_supermatrix\_wrangler l;}
\DoxyCodeLine{1323     superlu\_supermatrix\_wrangler u;}
\DoxyCodeLine{1324     }
\DoxyCodeLine{1325     \textcolor{comment}{// paranoia: use SuperLU's memory allocation, in case it reallocs}}
\DoxyCodeLine{1326     }
\DoxyCodeLine{1327     superlu\_array\_wrangler<int> perm\_c(\mbox{\hyperlink{structA}{A}}.n\_cols+1);  \textcolor{comment}{// extra paranoia: increase array length by 1}}
\DoxyCodeLine{1328     superlu\_array\_wrangler<int> perm\_r(\mbox{\hyperlink{structA}{A}}.n\_rows+1);}
\DoxyCodeLine{1329     superlu\_array\_wrangler<int>  etree(\mbox{\hyperlink{structA}{A}}.n\_cols+1);}
\DoxyCodeLine{1330     }
\DoxyCodeLine{1331     superlu\_array\_wrangler<T>    R(\mbox{\hyperlink{structA}{A}}.n\_rows+1);}
\DoxyCodeLine{1332     superlu\_array\_wrangler<T>    C(\mbox{\hyperlink{structA}{A}}.n\_cols+1);}
\DoxyCodeLine{1333     superlu\_array\_wrangler<T> ferr(\mbox{\hyperlink{structB}{B}}.n\_cols+1);}
\DoxyCodeLine{1334     superlu\_array\_wrangler<T> berr(\mbox{\hyperlink{structB}{B}}.n\_cols+1);}
\DoxyCodeLine{1335     }
\DoxyCodeLine{1336     superlu::GlobalLU\_t glu;}
\DoxyCodeLine{1337     arrayops::inplace\_set(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(\&glu), \textcolor{keywordtype}{char}(0), \textcolor{keyword}{sizeof}(superlu::GlobalLU\_t));}
\DoxyCodeLine{1338     }
\DoxyCodeLine{1339     superlu::mem\_usage\_t  mu;}
\DoxyCodeLine{1340     arrayops::inplace\_set(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(\&mu), \textcolor{keywordtype}{char}(0), \textcolor{keyword}{sizeof}(superlu::mem\_usage\_t));}
\DoxyCodeLine{1341     }
\DoxyCodeLine{1342     superlu\_stat\_wrangler stat;}
\DoxyCodeLine{1343     }
\DoxyCodeLine{1344     \textcolor{keywordtype}{char} equed[8];       \textcolor{comment}{// extra characters for paranoia}}
\DoxyCodeLine{1345     T    rpg   = T(0);}
\DoxyCodeLine{1346     T    rcond = T(0);}
\DoxyCodeLine{1347     \textcolor{keywordtype}{int}  info  = int(0); \textcolor{comment}{// Return code.}}
\DoxyCodeLine{1348     }
\DoxyCodeLine{1349     \textcolor{keywordtype}{char}  work[8];}
\DoxyCodeLine{1350     \textcolor{keywordtype}{int}  lwork = int(0);  \textcolor{comment}{// 0 means superlu will allocate memory}}
\DoxyCodeLine{1351     }
\DoxyCodeLine{1352     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}superlu::gssvx()"{}});}
\DoxyCodeLine{1353     superlu::gssvx<eT>(\&\mbox{\hyperlink{classoptions}{options}}, a.get\_ptr(), perm\_c.get\_ptr(), perm\_r.get\_ptr(), etree.get\_ptr(), equed, R.get\_ptr(), C.get\_ptr(), l.get\_ptr(), u.get\_ptr(), \&work[0], lwork, b.get\_ptr(), x.get\_ptr(), \&rpg, \&rcond, ferr.get\_ptr(), berr.get\_ptr(), \&glu, \&mu, stat.get\_ptr(), \&info);}
\DoxyCodeLine{1354     }
\DoxyCodeLine{1355     \textcolor{keywordtype}{bool} status = \textcolor{keyword}{false};}
\DoxyCodeLine{1356     }
\DoxyCodeLine{1357     \textcolor{comment}{// Process the return code.}}
\DoxyCodeLine{1358     \textcolor{keywordflow}{if}(info == 0)}
\DoxyCodeLine{1359       \{}
\DoxyCodeLine{1360       status = \textcolor{keyword}{true};}
\DoxyCodeLine{1361       \}}
\DoxyCodeLine{1362     \textcolor{keywordflow}{if}( (info > 0) \&\& (info <= \textcolor{keywordtype}{int}(\mbox{\hyperlink{structA}{A}}.n\_cols)) )}
\DoxyCodeLine{1363       \{}
\DoxyCodeLine{1364       \textcolor{comment}{// std::ostringstream tmp;}}
\DoxyCodeLine{1365       \textcolor{comment}{// tmp << "{}spsolve(): could not solve system; LU factorisation completed, but detected zero in U("{} << (info-\/1) << ',' << (info-\/1) << ')';}}
\DoxyCodeLine{1366       \textcolor{comment}{// arma\_debug\_warn\_level(1, tmp.str());}}
\DoxyCodeLine{1367       \}}
\DoxyCodeLine{1368     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1369     \textcolor{keywordflow}{if}( (info == \textcolor{keywordtype}{int}(\mbox{\hyperlink{structA}{A}}.n\_cols+1)) \&\& (user\_opts.allow\_ugly) )}
\DoxyCodeLine{1370       \{}
\DoxyCodeLine{1371       arma\_debug\_warn\_level(2, \textcolor{stringliteral}{"{}spsolve(): system is singular to working precision (rcond: "{}}, rcond, \textcolor{stringliteral}{"{})"{}});}
\DoxyCodeLine{1372       status = \textcolor{keyword}{true};}
\DoxyCodeLine{1373       \}}
\DoxyCodeLine{1374     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1375     \textcolor{keywordflow}{if}(info > \textcolor{keywordtype}{int}(\mbox{\hyperlink{structA}{A}}.n\_cols+1))}
\DoxyCodeLine{1376       \{}
\DoxyCodeLine{1377       arma\_debug\_warn\_level(1, \textcolor{stringliteral}{"{}spsolve(): memory allocation failure: could not allocate "{}}, (info -\/ \textcolor{keywordtype}{int}(\mbox{\hyperlink{structA}{A}}.n\_cols)), \textcolor{stringliteral}{"{} bytes"{}});}
\DoxyCodeLine{1378       \}}
\DoxyCodeLine{1379     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1380     \textcolor{keywordflow}{if}(info < 0)}
\DoxyCodeLine{1381       \{}
\DoxyCodeLine{1382       arma\_debug\_warn\_level(1, \textcolor{stringliteral}{"{}spsolve(): unknown SuperLU error code from gssvx(): "{}}, info);}
\DoxyCodeLine{1383       \}}
\DoxyCodeLine{1384     }
\DoxyCodeLine{1385     \textcolor{comment}{// No need to extract the data from x, since it's using the same memory as X}}
\DoxyCodeLine{1386     }
\DoxyCodeLine{1387     out\_rcond = rcond;}
\DoxyCodeLine{1388     }
\DoxyCodeLine{1389     \textcolor{keywordflow}{return} status;}
\DoxyCodeLine{1390     \}}
\DoxyCodeLine{1391 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{1392     \{}
\DoxyCodeLine{1393     arma\_ignore(X);}
\DoxyCodeLine{1394     arma\_ignore(out\_rcond);}
\DoxyCodeLine{1395     arma\_ignore(A\_expr);}
\DoxyCodeLine{1396     arma\_ignore(B\_expr);}
\DoxyCodeLine{1397     arma\_ignore(user\_opts);}
\DoxyCodeLine{1398     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}spsolve(): use of SuperLU must be enabled"{}});}
\DoxyCodeLine{1399     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1400     \}}
\DoxyCodeLine{1401 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{1402   \}}
\DoxyCodeLine{1403 }
\DoxyCodeLine{1404 }
\DoxyCodeLine{1405 }
\DoxyCodeLine{1406 \textcolor{comment}{// template<typename T1>}}
\DoxyCodeLine{1407 \textcolor{comment}{// inline}}
\DoxyCodeLine{1408 \textcolor{comment}{// typename T1::pod\_type}}
\DoxyCodeLine{1409 \textcolor{comment}{// sp\_auxlib::rcond(const SpBase<typename T1::elem\_type, T1>\& A\_expr)}}
\DoxyCodeLine{1410 \textcolor{comment}{//   \{}}
\DoxyCodeLine{1411 \textcolor{comment}{//   arma\_extra\_debug\_sigprint();}}
\DoxyCodeLine{1412 \textcolor{comment}{//   }}
\DoxyCodeLine{1413 \textcolor{comment}{//   \#if defined(ARMA\_USE\_SUPERLU)}}
\DoxyCodeLine{1414 \textcolor{comment}{//     \{}}
\DoxyCodeLine{1415 \textcolor{comment}{//     typedef typename T1::pod\_type   T;}}
\DoxyCodeLine{1416 \textcolor{comment}{//     typedef typename T1::elem\_type eT;}}
\DoxyCodeLine{1417 \textcolor{comment}{//     }}
\DoxyCodeLine{1418 \textcolor{comment}{//     const unwrap\_spmat<T1> tmp1(A\_expr.get\_ref());}}
\DoxyCodeLine{1419 \textcolor{comment}{//     const SpMat<eT>\& A =   tmp1.M;}}
\DoxyCodeLine{1420 \textcolor{comment}{//     }}
\DoxyCodeLine{1421 \textcolor{comment}{//     arma\_debug\_check( (A.is\_square() == false), "{}rcond(): matrix must be square sized"{} );}}
\DoxyCodeLine{1422 \textcolor{comment}{//     }}
\DoxyCodeLine{1423 \textcolor{comment}{//     superlu\_opts superlu\_opts\_default;}}
\DoxyCodeLine{1424 \textcolor{comment}{//     superlu::superlu\_options\_t options;}}
\DoxyCodeLine{1425 \textcolor{comment}{//     sp\_auxlib::set\_superlu\_opts(options, superlu\_opts\_default);}}
\DoxyCodeLine{1426 \textcolor{comment}{//     int lwork = 0;}}
\DoxyCodeLine{1427 \textcolor{comment}{//     }}
\DoxyCodeLine{1428 \textcolor{comment}{//     superlu::GlobalLU\_t Glu;}}
\DoxyCodeLine{1429 \textcolor{comment}{//     arrayops::fill\_zeros(reinterpret\_cast<char*>(\&Glu), sizeof(superlu::GlobalLU\_t));}}
\DoxyCodeLine{1430 \textcolor{comment}{//     }}
\DoxyCodeLine{1431 \textcolor{comment}{//     superlu\_supermatrix\_wrangler a;}}
\DoxyCodeLine{1432 \textcolor{comment}{//     superlu\_supermatrix\_wrangler aC;}}
\DoxyCodeLine{1433 \textcolor{comment}{//     }}
\DoxyCodeLine{1434 \textcolor{comment}{//     const bool status\_a = sp\_auxlib::copy\_to\_supermatrix(a.get\_ref(), A);}}
\DoxyCodeLine{1435 \textcolor{comment}{//     }}
\DoxyCodeLine{1436 \textcolor{comment}{//     if(status\_a == false)  \{ arma\_stop\_runtime\_error("{}rcond(): could not construct SuperLU matrix"{}); return T(0); \}}}
\DoxyCodeLine{1437 \textcolor{comment}{//     }}
\DoxyCodeLine{1438 \textcolor{comment}{//     superlu\_supermatrix\_wrangler l;}}
\DoxyCodeLine{1439 \textcolor{comment}{//     superlu\_supermatrix\_wrangler u;}}
\DoxyCodeLine{1440 \textcolor{comment}{//     }}
\DoxyCodeLine{1441 \textcolor{comment}{//     superlu\_array\_wrangler<int> perm\_c(A.n\_cols+1);  // paranoia: increase array length by 1}}
\DoxyCodeLine{1442 \textcolor{comment}{//     superlu\_array\_wrangler<int> perm\_r(A.n\_rows+1);}}
\DoxyCodeLine{1443 \textcolor{comment}{//     superlu\_array\_wrangler<int>  etree(A.n\_cols+1);}}
\DoxyCodeLine{1444 \textcolor{comment}{//     }}
\DoxyCodeLine{1445 \textcolor{comment}{//     superlu\_stat\_wrangler stat;}}
\DoxyCodeLine{1446 \textcolor{comment}{//     }}
\DoxyCodeLine{1447 \textcolor{comment}{//     int panel\_size = superlu::sp\_ispec\_environ(1);}}
\DoxyCodeLine{1448 \textcolor{comment}{//     int relax      = superlu::sp\_ispec\_environ(2);}}
\DoxyCodeLine{1449 \textcolor{comment}{//     int slu\_info   = 0; // Return code.}}
\DoxyCodeLine{1450 \textcolor{comment}{//     }}
\DoxyCodeLine{1451 \textcolor{comment}{//     arma\_extra\_debug\_print("{}superlu::gstrf()"{});}}
\DoxyCodeLine{1452 \textcolor{comment}{//     superlu::get\_permutation\_c(options.ColPerm, a.get\_ptr(), perm\_c.get\_ptr());}}
\DoxyCodeLine{1453 \textcolor{comment}{//     superlu::sp\_preorder\_mat(\&options, a.get\_ptr(), perm\_c.get\_ptr(), etree.get\_ptr(), aC.get\_ptr());}}
\DoxyCodeLine{1454 \textcolor{comment}{//     superlu::gstrf<T>(\&options, aC.get\_ptr(), relax, panel\_size, etree.get\_ptr(), NULL, lwork, perm\_c.get\_ptr(), perm\_r.get\_ptr(), l.get\_ptr(), u.get\_ptr(), \&Glu, stat.get\_ptr(), \&slu\_info);}}
\DoxyCodeLine{1455 \textcolor{comment}{//     }}
\DoxyCodeLine{1456 \textcolor{comment}{//     if(slu\_info != 0)  \{ return T(0); \}}}
\DoxyCodeLine{1457 \textcolor{comment}{//     }}
\DoxyCodeLine{1458 \textcolor{comment}{//     T a\_norm\_val = sp\_auxlib::norm1<eT>(a.get\_ptr());}}
\DoxyCodeLine{1459 \textcolor{comment}{//     T a\_rcond    = sp\_auxlib::lu\_rcond<eT>(l.get\_ptr(), u.get\_ptr(), a\_norm\_val);}}
\DoxyCodeLine{1460 \textcolor{comment}{//     }}
\DoxyCodeLine{1461 \textcolor{comment}{//     if(arma\_isnan(a\_rcond))  \{ return T(0); \}}}
\DoxyCodeLine{1462 \textcolor{comment}{//     }}
\DoxyCodeLine{1463 \textcolor{comment}{//     return a\_rcond;}}
\DoxyCodeLine{1464 \textcolor{comment}{//     \}}}
\DoxyCodeLine{1465 \textcolor{comment}{//   \#else}}
\DoxyCodeLine{1466 \textcolor{comment}{//     \{}}
\DoxyCodeLine{1467 \textcolor{comment}{//     typename T1::pod\_type T;}}
\DoxyCodeLine{1468 \textcolor{comment}{//     }}
\DoxyCodeLine{1469 \textcolor{comment}{//     arma\_ignore(A\_expr);}}
\DoxyCodeLine{1470 \textcolor{comment}{//     arma\_stop\_logic\_error("{}rcond(): use of SuperLU must be enabled"{});}}
\DoxyCodeLine{1471 \textcolor{comment}{//     }}
\DoxyCodeLine{1472 \textcolor{comment}{//     return T(0);}}
\DoxyCodeLine{1473 \textcolor{comment}{//     \}}}
\DoxyCodeLine{1474 \textcolor{comment}{//   \#endif}}
\DoxyCodeLine{1475 \textcolor{comment}{//   \}}}
\DoxyCodeLine{1476 }
\DoxyCodeLine{1477 }
\DoxyCodeLine{1478 }
\DoxyCodeLine{1479 \textcolor{preprocessor}{\#if defined(ARMA\_USE\_SUPERLU)}}
\DoxyCodeLine{1480   }
\DoxyCodeLine{1481   \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{1482   \textcolor{keyword}{inline}}
\DoxyCodeLine{1483   \textcolor{keyword}{typename} get\_pod\_type<eT>::result}
\DoxyCodeLine{1484   sp\_auxlib::norm1(superlu::SuperMatrix* \mbox{\hyperlink{structA}{A}})}
\DoxyCodeLine{1485     \{}
\DoxyCodeLine{1486     arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1487     }
\DoxyCodeLine{1488     \textcolor{keywordtype}{char} norm\_id = \textcolor{charliteral}{'1'};}
\DoxyCodeLine{1489     }
\DoxyCodeLine{1490     \textcolor{keywordflow}{return} superlu::langs<eT>(\&norm\_id, \mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{1491     \}}
\DoxyCodeLine{1492   }
\DoxyCodeLine{1493   }
\DoxyCodeLine{1494   }
\DoxyCodeLine{1495   \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{1496   \textcolor{keyword}{inline}}
\DoxyCodeLine{1497   \textcolor{keyword}{typename} get\_pod\_type<eT>::result}
\DoxyCodeLine{1498   sp\_auxlib::lu\_rcond(superlu::SuperMatrix* L, superlu::SuperMatrix* U, \textcolor{keyword}{typename} get\_pod\_type<eT>::result norm\_val)}
\DoxyCodeLine{1499     \{}
\DoxyCodeLine{1500     arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1501     }
\DoxyCodeLine{1502     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} get\_pod\_type<eT>::result T;}
\DoxyCodeLine{1503     }
\DoxyCodeLine{1504     \textcolor{keywordtype}{char} norm\_id   = \textcolor{charliteral}{'1'};}
\DoxyCodeLine{1505     T    rcond\_out = T(0);}
\DoxyCodeLine{1506     \textcolor{keywordtype}{int}  info      = int(0);}
\DoxyCodeLine{1507     }
\DoxyCodeLine{1508     superlu\_stat\_wrangler stat;}
\DoxyCodeLine{1509     }
\DoxyCodeLine{1510     superlu::gscon<eT>(\&norm\_id, L, U, norm\_val, \&rcond\_out, stat.get\_ptr(), \&info);}
\DoxyCodeLine{1511     }
\DoxyCodeLine{1512     \textcolor{keywordflow}{return} (info == 0) ? T(rcond\_out) : T(0);}
\DoxyCodeLine{1513     \}}
\DoxyCodeLine{1514   }
\DoxyCodeLine{1515   }
\DoxyCodeLine{1516   }
\DoxyCodeLine{1517   \textcolor{keyword}{inline}}
\DoxyCodeLine{1518   \textcolor{keywordtype}{void}}
\DoxyCodeLine{1519   sp\_auxlib::set\_superlu\_opts(superlu::superlu\_options\_t\& \mbox{\hyperlink{classoptions}{options}}, \textcolor{keyword}{const} \mbox{\hyperlink{structsuperlu__opts}{superlu\_opts}}\& user\_opts)}
\DoxyCodeLine{1520     \{}
\DoxyCodeLine{1521     arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1522     }
\DoxyCodeLine{1523     \textcolor{comment}{// default options as the starting point}}
\DoxyCodeLine{1524     superlu::set\_default\_opts(\&\mbox{\hyperlink{classoptions}{options}});}
\DoxyCodeLine{1525     }
\DoxyCodeLine{1526     \textcolor{comment}{// our settings}}
\DoxyCodeLine{1527     \mbox{\hyperlink{classoptions}{options}}.Trans           = superlu::NOTRANS;}
\DoxyCodeLine{1528     \mbox{\hyperlink{classoptions}{options}}.ConditionNumber = superlu::YES;}
\DoxyCodeLine{1529    }
\DoxyCodeLine{1530     \textcolor{comment}{// process user\_opts}}
\DoxyCodeLine{1531     }
\DoxyCodeLine{1532     \textcolor{keywordflow}{if}(user\_opts.equilibrate == \textcolor{keyword}{true})   \{ \mbox{\hyperlink{classoptions}{options}}.Equil = superlu::YES; \}}
\DoxyCodeLine{1533     \textcolor{keywordflow}{if}(user\_opts.equilibrate == \textcolor{keyword}{false})  \{ \mbox{\hyperlink{classoptions}{options}}.Equil = superlu::NO;  \}}
\DoxyCodeLine{1534     }
\DoxyCodeLine{1535     \textcolor{keywordflow}{if}(user\_opts.symmetric == \textcolor{keyword}{true})   \{ \mbox{\hyperlink{classoptions}{options}}.SymmetricMode = superlu::YES; \}}
\DoxyCodeLine{1536     \textcolor{keywordflow}{if}(user\_opts.symmetric == \textcolor{keyword}{false})  \{ \mbox{\hyperlink{classoptions}{options}}.SymmetricMode = superlu::NO;  \}}
\DoxyCodeLine{1537     }
\DoxyCodeLine{1538     \mbox{\hyperlink{classoptions}{options}}.DiagPivotThresh = user\_opts.pivot\_thresh;}
\DoxyCodeLine{1539     }
\DoxyCodeLine{1540     \textcolor{keywordflow}{if}(user\_opts.permutation == superlu\_opts::NATURAL)        \{ \mbox{\hyperlink{classoptions}{options}}.ColPerm = superlu::NATURAL;       \}}
\DoxyCodeLine{1541     \textcolor{keywordflow}{if}(user\_opts.permutation == superlu\_opts::MMD\_ATA)        \{ \mbox{\hyperlink{classoptions}{options}}.ColPerm = superlu::MMD\_ATA;       \}}
\DoxyCodeLine{1542     \textcolor{keywordflow}{if}(user\_opts.permutation == superlu\_opts::MMD\_AT\_PLUS\_A)  \{ \mbox{\hyperlink{classoptions}{options}}.ColPerm = superlu::MMD\_AT\_PLUS\_A; \}}
\DoxyCodeLine{1543     \textcolor{keywordflow}{if}(user\_opts.permutation == superlu\_opts::COLAMD)         \{ \mbox{\hyperlink{classoptions}{options}}.ColPerm = superlu::COLAMD;        \}}
\DoxyCodeLine{1544     }
\DoxyCodeLine{1545     \textcolor{keywordflow}{if}(user\_opts.refine == superlu\_opts::REF\_NONE)    \{ \mbox{\hyperlink{classoptions}{options}}.IterRefine = superlu::NOREFINE;   \}}
\DoxyCodeLine{1546     \textcolor{keywordflow}{if}(user\_opts.refine == superlu\_opts::REF\_SINGLE)  \{ \mbox{\hyperlink{classoptions}{options}}.IterRefine = superlu::SLU\_SINGLE; \}}
\DoxyCodeLine{1547     \textcolor{keywordflow}{if}(user\_opts.refine == superlu\_opts::REF\_DOUBLE)  \{ \mbox{\hyperlink{classoptions}{options}}.IterRefine = superlu::SLU\_DOUBLE; \}}
\DoxyCodeLine{1548     \textcolor{keywordflow}{if}(user\_opts.refine == superlu\_opts::REF\_EXTRA)   \{ \mbox{\hyperlink{classoptions}{options}}.IterRefine = superlu::SLU\_EXTRA;  \}}
\DoxyCodeLine{1549     \}}
\DoxyCodeLine{1550   }
\DoxyCodeLine{1551   }
\DoxyCodeLine{1552   }
\DoxyCodeLine{1553   \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{1554   \textcolor{keyword}{inline}}
\DoxyCodeLine{1555   \textcolor{keywordtype}{bool}}
\DoxyCodeLine{1556   sp\_auxlib::copy\_to\_supermatrix(superlu::SuperMatrix\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& \mbox{\hyperlink{structA}{A}})}
\DoxyCodeLine{1557     \{}
\DoxyCodeLine{1558     arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1559     }
\DoxyCodeLine{1560     \textcolor{comment}{// We store in column-\/major CSC.}}
\DoxyCodeLine{1561     out.Stype = superlu::SLU\_NC;}
\DoxyCodeLine{1562     }
\DoxyCodeLine{1563          \textcolor{keywordflow}{if}(    \mbox{\hyperlink{structis__float}{is\_float<eT>::value}})  \{ out.Dtype = superlu::SLU\_S; \}}
\DoxyCodeLine{1564     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(   \mbox{\hyperlink{structis__double}{is\_double<eT>::value}})  \{ out.Dtype = superlu::SLU\_D; \}}
\DoxyCodeLine{1565     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( \mbox{\hyperlink{structis__cx__float}{is\_cx\_float<eT>::value}})  \{ out.Dtype = superlu::SLU\_C; \}}
\DoxyCodeLine{1566     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__cx__double}{is\_cx\_double<eT>::value}})  \{ out.Dtype = superlu::SLU\_Z; \}}
\DoxyCodeLine{1567     }
\DoxyCodeLine{1568     out.Mtype = superlu::SLU\_GE; \textcolor{comment}{// Just a general matrix.  We don't know more now.}}
\DoxyCodeLine{1569     }
\DoxyCodeLine{1570     \textcolor{comment}{// We have to actually create the object which stores the data.}}
\DoxyCodeLine{1571     \textcolor{comment}{// This gets cleaned by destroy\_supermatrix().}}
\DoxyCodeLine{1572     \textcolor{comment}{// We have to use SuperLU's problematic memory allocation routines since they are}}
\DoxyCodeLine{1573     \textcolor{comment}{// not guaranteed to be new and delete.  See the comments in def\_superlu.hpp}}
\DoxyCodeLine{1574     superlu::NCformat* nc = (superlu::NCformat*)superlu::malloc(\textcolor{keyword}{sizeof}(superlu::NCformat));}
\DoxyCodeLine{1575     }
\DoxyCodeLine{1576     \textcolor{keywordflow}{if}(nc == \textcolor{keyword}{nullptr})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1577     }
\DoxyCodeLine{1578     \mbox{\hyperlink{structA}{A}}.sync();}
\DoxyCodeLine{1579     }
\DoxyCodeLine{1580     nc-\/>nnz    = \mbox{\hyperlink{structA}{A}}.n\_nonzero;}
\DoxyCodeLine{1581     nc-\/>nzval  = (\textcolor{keywordtype}{void}*)          superlu::malloc(\textcolor{keyword}{sizeof}(eT)             * \mbox{\hyperlink{structA}{A}}.n\_nonzero   );}
\DoxyCodeLine{1582     nc-\/>colptr = (superlu::int\_t*)superlu::malloc(\textcolor{keyword}{sizeof}(superlu::int\_t) * (\mbox{\hyperlink{structA}{A}}.n\_cols + 1));}
\DoxyCodeLine{1583     nc-\/>rowind = (superlu::int\_t*)superlu::malloc(\textcolor{keyword}{sizeof}(superlu::int\_t) * \mbox{\hyperlink{structA}{A}}.n\_nonzero   );}
\DoxyCodeLine{1584     }
\DoxyCodeLine{1585     \textcolor{keywordflow}{if}( (nc-\/>nzval == \textcolor{keyword}{nullptr}) || (nc-\/>colptr == \textcolor{keyword}{nullptr}) || (nc-\/>rowind == \textcolor{keyword}{nullptr}) )  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1586     }
\DoxyCodeLine{1587     \textcolor{comment}{// Fill the matrix.}}
\DoxyCodeLine{1588     arrayops::copy((eT*) nc-\/>nzval, \mbox{\hyperlink{structA}{A}}.values, \mbox{\hyperlink{structA}{A}}.n\_nonzero);}
\DoxyCodeLine{1589     }
\DoxyCodeLine{1590     \textcolor{comment}{// // These have to be copied by hand, because the types may differ.}}
\DoxyCodeLine{1591     \textcolor{comment}{// for(uword i = 0; i <= A.n\_cols; ++i)  \{ nc-\/>colptr[i] = (int\_t) A.col\_ptrs[i]; \}}}
\DoxyCodeLine{1592     \textcolor{comment}{// for(uword i = 0; i < A.n\_nonzero; ++i) \{ nc-\/>rowind[i] = (int\_t) A.row\_indices[i]; \}}}
\DoxyCodeLine{1593     }
\DoxyCodeLine{1594     arrayops::convert(nc-\/>colptr, \mbox{\hyperlink{structA}{A}}.col\_ptrs,    \mbox{\hyperlink{structA}{A}}.n\_cols+1 );}
\DoxyCodeLine{1595     arrayops::convert(nc-\/>rowind, \mbox{\hyperlink{structA}{A}}.row\_indices, \mbox{\hyperlink{structA}{A}}.n\_nonzero);}
\DoxyCodeLine{1596     }
\DoxyCodeLine{1597     out.nrow  = superlu::int\_t(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{1598     out.ncol  = superlu::int\_t(\mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{1599     out.Store = (\textcolor{keywordtype}{void}*) nc;}
\DoxyCodeLine{1600     }
\DoxyCodeLine{1601     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1602     \}}
\DoxyCodeLine{1603   }
\DoxyCodeLine{1604   }
\DoxyCodeLine{1605   }
\DoxyCodeLine{1606   \textcolor{comment}{// memory efficient implementation of out = A -\/ shift*I, where A is a square matrix}}
\DoxyCodeLine{1607   \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{1608   \textcolor{keyword}{inline}}
\DoxyCodeLine{1609   \textcolor{keywordtype}{bool}}
\DoxyCodeLine{1610   sp\_auxlib::copy\_to\_supermatrix\_with\_shift(superlu::SuperMatrix\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} eT shift)}
\DoxyCodeLine{1611     \{}
\DoxyCodeLine{1612     arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1613     }
\DoxyCodeLine{1614     arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.is\_square() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}sp\_auxlib::copy\_to\_supermatrix\_with\_shift(): given matrix must be square sized"{}} );}
\DoxyCodeLine{1615     }
\DoxyCodeLine{1616     \textcolor{keywordflow}{if}(shift == eT(0))}
\DoxyCodeLine{1617       \{}
\DoxyCodeLine{1618       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}sp\_auxlib::copy\_to\_supermatrix\_with\_shift(): shift is zero; redirecting to sp\_auxlib::copy\_to\_supermatrix()"{}});}
\DoxyCodeLine{1619       \textcolor{keywordflow}{return} sp\_auxlib::copy\_to\_supermatrix(out, \mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{1620       \}}
\DoxyCodeLine{1621     }
\DoxyCodeLine{1622     \textcolor{comment}{// We store in column-\/major CSC.}}
\DoxyCodeLine{1623     out.Stype = superlu::SLU\_NC;}
\DoxyCodeLine{1624     }
\DoxyCodeLine{1625          \textcolor{keywordflow}{if}(    \mbox{\hyperlink{structis__float}{is\_float<eT>::value}})  \{ out.Dtype = superlu::SLU\_S; \}}
\DoxyCodeLine{1626     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(   \mbox{\hyperlink{structis__double}{is\_double<eT>::value}})  \{ out.Dtype = superlu::SLU\_D; \}}
\DoxyCodeLine{1627     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( \mbox{\hyperlink{structis__cx__float}{is\_cx\_float<eT>::value}})  \{ out.Dtype = superlu::SLU\_C; \}}
\DoxyCodeLine{1628     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__cx__double}{is\_cx\_double<eT>::value}})  \{ out.Dtype = superlu::SLU\_Z; \}}
\DoxyCodeLine{1629     }
\DoxyCodeLine{1630     out.Mtype = superlu::SLU\_GE; \textcolor{comment}{// Just a general matrix.  We don't know more now.}}
\DoxyCodeLine{1631     }
\DoxyCodeLine{1632     \textcolor{comment}{// We have to actually create the object which stores the data.}}
\DoxyCodeLine{1633     \textcolor{comment}{// This gets cleaned by destroy\_supermatrix().}}
\DoxyCodeLine{1634     superlu::NCformat* nc = (superlu::NCformat*)superlu::malloc(\textcolor{keyword}{sizeof}(superlu::NCformat));}
\DoxyCodeLine{1635     }
\DoxyCodeLine{1636     \textcolor{keywordflow}{if}(nc == \textcolor{keyword}{nullptr})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1637     }
\DoxyCodeLine{1638     \mbox{\hyperlink{structA}{A}}.sync();}
\DoxyCodeLine{1639     }
\DoxyCodeLine{1640     uword n\_nonzero\_diag\_old = 0;}
\DoxyCodeLine{1641     uword n\_nonzero\_diag\_new = 0;}
\DoxyCodeLine{1642     }
\DoxyCodeLine{1643     \textcolor{keyword}{const} uword n\_search\_cols = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{1644     }
\DoxyCodeLine{1645     \textcolor{keywordflow}{for}(uword j=0; j < n\_search\_cols; ++j)}
\DoxyCodeLine{1646       \{}
\DoxyCodeLine{1647       \textcolor{keyword}{const} uword      col\_offset = \mbox{\hyperlink{structA}{A}}.col\_ptrs[j    ];}
\DoxyCodeLine{1648       \textcolor{keyword}{const} uword next\_col\_offset = \mbox{\hyperlink{structA}{A}}.col\_ptrs[j + 1];}
\DoxyCodeLine{1649       }
\DoxyCodeLine{1650       \textcolor{keyword}{const} uword* start\_ptr = \&(\mbox{\hyperlink{structA}{A}}.row\_indices[     col\_offset]);}
\DoxyCodeLine{1651       \textcolor{keyword}{const} uword*   end\_ptr = \&(\mbox{\hyperlink{structA}{A}}.row\_indices[next\_col\_offset]);}
\DoxyCodeLine{1652       }
\DoxyCodeLine{1653       \textcolor{keyword}{const} uword wanted\_row = j;}
\DoxyCodeLine{1654       }
\DoxyCodeLine{1655       \textcolor{keyword}{const} uword* pos\_ptr = std::lower\_bound(start\_ptr, end\_ptr, wanted\_row);  \textcolor{comment}{// binary search}}
\DoxyCodeLine{1656       }
\DoxyCodeLine{1657       \textcolor{keywordflow}{if}( (pos\_ptr != end\_ptr) \&\& ((*pos\_ptr) == wanted\_row) )}
\DoxyCodeLine{1658         \{}
\DoxyCodeLine{1659         \textcolor{comment}{// element on the main diagonal is non-\/zero}}
\DoxyCodeLine{1660         ++n\_nonzero\_diag\_old;}
\DoxyCodeLine{1661         }
\DoxyCodeLine{1662         \textcolor{keyword}{const} uword offset = uword(pos\_ptr -\/ start\_ptr);}
\DoxyCodeLine{1663         \textcolor{keyword}{const} uword index  = offset + col\_offset;}
\DoxyCodeLine{1664         }
\DoxyCodeLine{1665         \textcolor{keyword}{const} eT new\_val = \mbox{\hyperlink{structA}{A}}.values[index] -\/ shift;}
\DoxyCodeLine{1666         }
\DoxyCodeLine{1667         \textcolor{keywordflow}{if}(new\_val != eT(0))  \{ ++n\_nonzero\_diag\_new; \}}
\DoxyCodeLine{1668         \}}
\DoxyCodeLine{1669       \textcolor{keywordflow}{else}}
\DoxyCodeLine{1670         \{}
\DoxyCodeLine{1671         \textcolor{comment}{// element on the main diagonal is zero, but sigma is non-\/zero,}}
\DoxyCodeLine{1672         \textcolor{comment}{// so the number of new non-\/zero elments on the diagonal is increased}}
\DoxyCodeLine{1673         ++n\_nonzero\_diag\_new;}
\DoxyCodeLine{1674         \}}
\DoxyCodeLine{1675       \}}
\DoxyCodeLine{1676     }
\DoxyCodeLine{1677     \textcolor{keyword}{const} uword out\_n\_nonzero = \mbox{\hyperlink{structA}{A}}.n\_nonzero -\/ n\_nonzero\_diag\_old + n\_nonzero\_diag\_new;}
\DoxyCodeLine{1678     }
\DoxyCodeLine{1679     arma\_extra\_debug\_print( \mbox{\hyperlink{classarma__str_1_1format}{arma\_str::format}}(\textcolor{stringliteral}{"{}A.n\_nonzero:        \%d"{}}) \% \mbox{\hyperlink{structA}{A}}.n\_nonzero        );}
\DoxyCodeLine{1680     arma\_extra\_debug\_print( \mbox{\hyperlink{classarma__str_1_1format}{arma\_str::format}}(\textcolor{stringliteral}{"{}n\_nonzero\_diag\_old: \%d"{}}) \% n\_nonzero\_diag\_old );}
\DoxyCodeLine{1681     arma\_extra\_debug\_print( \mbox{\hyperlink{classarma__str_1_1format}{arma\_str::format}}(\textcolor{stringliteral}{"{}n\_nonzero\_diag\_new: \%d"{}}) \% n\_nonzero\_diag\_new );}
\DoxyCodeLine{1682     arma\_extra\_debug\_print( \mbox{\hyperlink{classarma__str_1_1format}{arma\_str::format}}(\textcolor{stringliteral}{"{}out\_n\_nonzero:      \%d"{}}) \% out\_n\_nonzero      );}
\DoxyCodeLine{1683     }
\DoxyCodeLine{1684     nc-\/>nnz    = out\_n\_nonzero;}
\DoxyCodeLine{1685     nc-\/>nzval  = (\textcolor{keywordtype}{void}*)          superlu::malloc(\textcolor{keyword}{sizeof}(eT)             * out\_n\_nonzero );}
\DoxyCodeLine{1686     nc-\/>colptr = (superlu::int\_t*)superlu::malloc(\textcolor{keyword}{sizeof}(superlu::int\_t) * (\mbox{\hyperlink{structA}{A}}.n\_cols + 1));}
\DoxyCodeLine{1687     nc-\/>rowind = (superlu::int\_t*)superlu::malloc(\textcolor{keyword}{sizeof}(superlu::int\_t) * out\_n\_nonzero );}
\DoxyCodeLine{1688     }
\DoxyCodeLine{1689     \textcolor{keywordflow}{if}( (nc-\/>nzval == \textcolor{keyword}{nullptr}) || (nc-\/>colptr == \textcolor{keyword}{nullptr}) || (nc-\/>rowind == \textcolor{keyword}{nullptr}) )  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1690     }
\DoxyCodeLine{1691     \textcolor{comment}{// fill the matrix column by column, and insert diagonal elements when necessary}}
\DoxyCodeLine{1692     }
\DoxyCodeLine{1693     nc-\/>colptr[0] = 0;}
\DoxyCodeLine{1694     }
\DoxyCodeLine{1695     eT*             values\_current = (eT*) nc-\/>nzval;}
\DoxyCodeLine{1696     superlu::int\_t* rowind\_current = nc-\/>rowind;}
\DoxyCodeLine{1697     }
\DoxyCodeLine{1698     uword count = 0;}
\DoxyCodeLine{1699     }
\DoxyCodeLine{1700     \textcolor{keywordflow}{for}(uword j=0; j < \mbox{\hyperlink{structA}{A}}.n\_cols; ++j)}
\DoxyCodeLine{1701       \{}
\DoxyCodeLine{1702       \textcolor{keyword}{const} uword idx\_start = \mbox{\hyperlink{structA}{A}}.col\_ptrs[j    ];}
\DoxyCodeLine{1703       \textcolor{keyword}{const} uword idx\_end   = \mbox{\hyperlink{structA}{A}}.col\_ptrs[j + 1];}
\DoxyCodeLine{1704       }
\DoxyCodeLine{1705       \textcolor{keyword}{const} eT* values\_start = values\_current;}
\DoxyCodeLine{1706       }
\DoxyCodeLine{1707       uword i = idx\_start;}
\DoxyCodeLine{1708       }
\DoxyCodeLine{1709       \textcolor{comment}{// elements in the upper triangular part, excluding the main diagonal}}
\DoxyCodeLine{1710       \textcolor{keywordflow}{for}(; (i < idx\_end) \&\& (\mbox{\hyperlink{structA}{A}}.row\_indices[i] < j); ++i)}
\DoxyCodeLine{1711         \{}
\DoxyCodeLine{1712         (*values\_current) = \mbox{\hyperlink{structA}{A}}.values[i];}
\DoxyCodeLine{1713         (*rowind\_current) = superlu::int\_t(\mbox{\hyperlink{structA}{A}}.row\_indices[i]);}
\DoxyCodeLine{1714         }
\DoxyCodeLine{1715         ++values\_current;}
\DoxyCodeLine{1716         ++rowind\_current;}
\DoxyCodeLine{1717         }
\DoxyCodeLine{1718         ++count;}
\DoxyCodeLine{1719         \}}
\DoxyCodeLine{1720       }
\DoxyCodeLine{1721       \textcolor{comment}{// elements on the main diagonal}}
\DoxyCodeLine{1722       \textcolor{keywordflow}{if}( (i < idx\_end) \&\& (\mbox{\hyperlink{structA}{A}}.row\_indices[i] == j) )}
\DoxyCodeLine{1723         \{}
\DoxyCodeLine{1724         \textcolor{comment}{// A(j,j) is non-\/zero}}
\DoxyCodeLine{1725         }
\DoxyCodeLine{1726         \textcolor{keyword}{const} eT new\_diag\_val = \mbox{\hyperlink{structA}{A}}.values[i] -\/ shift;}
\DoxyCodeLine{1727         }
\DoxyCodeLine{1728         \textcolor{keywordflow}{if}(new\_diag\_val != eT(0))}
\DoxyCodeLine{1729           \{}
\DoxyCodeLine{1730           (*values\_current) = new\_diag\_val;}
\DoxyCodeLine{1731           (*rowind\_current) = superlu::int\_t(j);}
\DoxyCodeLine{1732           }
\DoxyCodeLine{1733           ++values\_current;}
\DoxyCodeLine{1734           ++rowind\_current;}
\DoxyCodeLine{1735           }
\DoxyCodeLine{1736           ++count;}
\DoxyCodeLine{1737           \}}
\DoxyCodeLine{1738         }
\DoxyCodeLine{1739         ++i;}
\DoxyCodeLine{1740         \}}
\DoxyCodeLine{1741       \textcolor{keywordflow}{else}}
\DoxyCodeLine{1742         \{}
\DoxyCodeLine{1743         \textcolor{comment}{// A(j,j) is zero, so insert a new element}}
\DoxyCodeLine{1744         }
\DoxyCodeLine{1745         \textcolor{keywordflow}{if}(j < n\_search\_cols)   }
\DoxyCodeLine{1746           \{}
\DoxyCodeLine{1747           (*values\_current) = -\/shift;}
\DoxyCodeLine{1748           (*rowind\_current) = superlu::int\_t(j);}
\DoxyCodeLine{1749           }
\DoxyCodeLine{1750           ++values\_current;}
\DoxyCodeLine{1751           ++rowind\_current;}
\DoxyCodeLine{1752           }
\DoxyCodeLine{1753           ++count;}
\DoxyCodeLine{1754           \}}
\DoxyCodeLine{1755         \}}
\DoxyCodeLine{1756       }
\DoxyCodeLine{1757       \textcolor{comment}{// elements in the lower triangular part, excluding the main diagonal}}
\DoxyCodeLine{1758       \textcolor{keywordflow}{for}(; i < idx\_end; ++i)}
\DoxyCodeLine{1759         \{}
\DoxyCodeLine{1760         (*values\_current) = \mbox{\hyperlink{structA}{A}}.values[i];}
\DoxyCodeLine{1761         (*rowind\_current) = superlu::int\_t(\mbox{\hyperlink{structA}{A}}.row\_indices[i]);}
\DoxyCodeLine{1762         }
\DoxyCodeLine{1763         ++values\_current;}
\DoxyCodeLine{1764         ++rowind\_current;}
\DoxyCodeLine{1765         }
\DoxyCodeLine{1766         ++count;}
\DoxyCodeLine{1767         \}}
\DoxyCodeLine{1768       }
\DoxyCodeLine{1769       \textcolor{comment}{// number of non-\/zero elements in the j-\/th column of out}}
\DoxyCodeLine{1770       \textcolor{keyword}{const} uword nnz\_col = values\_current -\/ values\_start;}
\DoxyCodeLine{1771       nc-\/>colptr[j + 1] = superlu::int\_t(nc-\/>colptr[j] + nnz\_col);}
\DoxyCodeLine{1772       \}}
\DoxyCodeLine{1773     }
\DoxyCodeLine{1774     arma\_extra\_debug\_print( \mbox{\hyperlink{classarma__str_1_1format}{arma\_str::format}}(\textcolor{stringliteral}{"{}count: \%d"{}}) \% count );}
\DoxyCodeLine{1775     }
\DoxyCodeLine{1776     \mbox{\hyperlink{group__debug_ga458beb676810b1e43df9f0668359e76f}{arma\_check}}( (count != out\_n\_nonzero), \textcolor{stringliteral}{"{}internal error: sp\_auxlib::copy\_to\_supermatrix\_with\_shift(): count != out\_n\_nonzero"{}} );}
\DoxyCodeLine{1777     }
\DoxyCodeLine{1778     out.nrow  = superlu::int\_t(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{1779     out.ncol  = superlu::int\_t(\mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{1780     out.Store = (\textcolor{keywordtype}{void}*) nc;}
\DoxyCodeLine{1781     }
\DoxyCodeLine{1782     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1783     \}}
\DoxyCodeLine{1784   }
\DoxyCodeLine{1785   }
\DoxyCodeLine{1786   }
\DoxyCodeLine{1787 \textcolor{comment}{//   // for debugging only}}
\DoxyCodeLine{1788 \textcolor{comment}{//   template<typename eT>}}
\DoxyCodeLine{1789 \textcolor{comment}{//   inline}}
\DoxyCodeLine{1790 \textcolor{comment}{//   void}}
\DoxyCodeLine{1791 \textcolor{comment}{//   sp\_auxlib::copy\_to\_spmat(SpMat<eT>\& out, const superlu::SuperMatrix\& A)}}
\DoxyCodeLine{1792 \textcolor{comment}{//     \{}}
\DoxyCodeLine{1793 \textcolor{comment}{//     arma\_extra\_debug\_sigprint();}}
\DoxyCodeLine{1794 \textcolor{comment}{//     }}
\DoxyCodeLine{1795 \textcolor{comment}{//     bool type\_matched = false;}}
\DoxyCodeLine{1796 \textcolor{comment}{//     }}
\DoxyCodeLine{1797 \textcolor{comment}{//          if(    is\_float<eT>::value)  \{ type\_matched = (A.Dtype == superlu::SLU\_S); \}}}
\DoxyCodeLine{1798 \textcolor{comment}{//     else if(   is\_double<eT>::value)  \{ type\_matched = (A.Dtype == superlu::SLU\_D); \}}}
\DoxyCodeLine{1799 \textcolor{comment}{//     else if( is\_cx\_float<eT>::value)  \{ type\_matched = (A.Dtype == superlu::SLU\_C); \}}}
\DoxyCodeLine{1800 \textcolor{comment}{//     else if(is\_cx\_double<eT>::value)  \{ type\_matched = (A.Dtype == superlu::SLU\_Z); \}}}
\DoxyCodeLine{1801 \textcolor{comment}{//     }}
\DoxyCodeLine{1802 \textcolor{comment}{//     arma\_debug\_check( (type\_matched == false),      "{}copy\_to\_spmat(): type mismatch"{}  );}}
\DoxyCodeLine{1803 \textcolor{comment}{//     arma\_debug\_check( (A.Mtype != superlu::SLU\_GE), "{}copy\_to\_spmat(): unknown layout"{} );}}
\DoxyCodeLine{1804 \textcolor{comment}{//     }}
\DoxyCodeLine{1805 \textcolor{comment}{//     const superlu::NCformat* nc = (const superlu::NCformat*)(A.Store);}}
\DoxyCodeLine{1806 \textcolor{comment}{//     }}
\DoxyCodeLine{1807 \textcolor{comment}{//     if(nc == nullptr)  \{ out.reset(); return; \}}}
\DoxyCodeLine{1808 \textcolor{comment}{//     }}
\DoxyCodeLine{1809 \textcolor{comment}{//     if( (nc-\/>nzval == nullptr) || (nc-\/>colptr == nullptr) || (nc-\/>rowind == nullptr) )  \{ out.reset(); return; \}}}
\DoxyCodeLine{1810 \textcolor{comment}{//     }}
\DoxyCodeLine{1811 \textcolor{comment}{//     const uword A\_n\_rows    = uword(A.nrow );}}
\DoxyCodeLine{1812 \textcolor{comment}{//     const uword A\_n\_cols    = uword(A.ncol );}}
\DoxyCodeLine{1813 \textcolor{comment}{//     const uword A\_n\_nonzero = uword(nc-\/>nnz);}}
\DoxyCodeLine{1814 \textcolor{comment}{//     }}
\DoxyCodeLine{1815 \textcolor{comment}{//     if(A\_n\_nonzero == 0)  \{ out.zeros(A\_n\_rows, A\_n\_cols); return; \}}}
\DoxyCodeLine{1816 \textcolor{comment}{//     }}
\DoxyCodeLine{1817 \textcolor{comment}{//     out.reserve(A\_n\_rows, A\_n\_cols, A\_n\_nonzero);}}
\DoxyCodeLine{1818 \textcolor{comment}{//     }}
\DoxyCodeLine{1819 \textcolor{comment}{//     arrayops::copy(access::rwp(out.values), (const eT*)(nc-\/>nzval), A\_n\_nonzero);}}
\DoxyCodeLine{1820 \textcolor{comment}{//     }}
\DoxyCodeLine{1821 \textcolor{comment}{//     arrayops::convert(access::rwp(out.col\_ptrs),    nc-\/>colptr, A\_n\_cols+1 );}}
\DoxyCodeLine{1822 \textcolor{comment}{//     arrayops::convert(access::rwp(out.row\_indices), nc-\/>rowind, A\_n\_nonzero);}}
\DoxyCodeLine{1823 \textcolor{comment}{//     \}}}
\DoxyCodeLine{1824   }
\DoxyCodeLine{1825   }
\DoxyCodeLine{1826   }
\DoxyCodeLine{1827   \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{1828   \textcolor{keyword}{inline}}
\DoxyCodeLine{1829   \textcolor{keywordtype}{bool}}
\DoxyCodeLine{1830   sp\_auxlib::wrap\_to\_supermatrix(superlu::SuperMatrix\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}})}
\DoxyCodeLine{1831     \{}
\DoxyCodeLine{1832     arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1833     }
\DoxyCodeLine{1834     \textcolor{comment}{// NOTE: this function re-\/uses memory from matrix A}}
\DoxyCodeLine{1835     }
\DoxyCodeLine{1836     \textcolor{comment}{// This is being stored as a dense matrix.}}
\DoxyCodeLine{1837     out.Stype = superlu::SLU\_DN;}
\DoxyCodeLine{1838     }
\DoxyCodeLine{1839          \textcolor{keywordflow}{if}(    \mbox{\hyperlink{structis__float}{is\_float<eT>::value}})  \{ out.Dtype = superlu::SLU\_S; \}}
\DoxyCodeLine{1840     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(   \mbox{\hyperlink{structis__double}{is\_double<eT>::value}})  \{ out.Dtype = superlu::SLU\_D; \}}
\DoxyCodeLine{1841     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( \mbox{\hyperlink{structis__cx__float}{is\_cx\_float<eT>::value}})  \{ out.Dtype = superlu::SLU\_C; \}}
\DoxyCodeLine{1842     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__cx__double}{is\_cx\_double<eT>::value}})  \{ out.Dtype = superlu::SLU\_Z; \}}
\DoxyCodeLine{1843     }
\DoxyCodeLine{1844     out.Mtype = superlu::SLU\_GE;}
\DoxyCodeLine{1845     }
\DoxyCodeLine{1846     \textcolor{comment}{// We have to create the object that stores the data.}}
\DoxyCodeLine{1847     superlu::DNformat* dn = (superlu::DNformat*)superlu::malloc(\textcolor{keyword}{sizeof}(superlu::DNformat));}
\DoxyCodeLine{1848     }
\DoxyCodeLine{1849     \textcolor{keywordflow}{if}(dn == \textcolor{keyword}{nullptr})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1850     }
\DoxyCodeLine{1851     dn-\/>lda   = \mbox{\hyperlink{structA}{A}}.n\_rows;}
\DoxyCodeLine{1852     dn-\/>nzval = (\textcolor{keywordtype}{void}*) \mbox{\hyperlink{structA}{A}}.memptr();  \textcolor{comment}{// re-\/use memory instead of copying}}
\DoxyCodeLine{1853     }
\DoxyCodeLine{1854     out.nrow  = \mbox{\hyperlink{structA}{A}}.n\_rows;}
\DoxyCodeLine{1855     out.ncol  = \mbox{\hyperlink{structA}{A}}.n\_cols;}
\DoxyCodeLine{1856     out.Store = (\textcolor{keywordtype}{void}*) dn;}
\DoxyCodeLine{1857     }
\DoxyCodeLine{1858     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1859     \}}
\DoxyCodeLine{1860   }
\DoxyCodeLine{1861   }
\DoxyCodeLine{1862   }
\DoxyCodeLine{1863   \textcolor{keyword}{inline}}
\DoxyCodeLine{1864   \textcolor{keywordtype}{void}}
\DoxyCodeLine{1865   sp\_auxlib::destroy\_supermatrix(superlu::SuperMatrix\& out)}
\DoxyCodeLine{1866     \{}
\DoxyCodeLine{1867     arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1868     }
\DoxyCodeLine{1869     \textcolor{comment}{// Clean up.}}
\DoxyCodeLine{1870     \textcolor{keywordflow}{if}(out.Stype == superlu::SLU\_NC)}
\DoxyCodeLine{1871       \{}
\DoxyCodeLine{1872       superlu::destroy\_compcol\_mat(\&out);}
\DoxyCodeLine{1873       \}}
\DoxyCodeLine{1874     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1875     \textcolor{keywordflow}{if}(out.Stype == superlu::SLU\_NCP)}
\DoxyCodeLine{1876       \{}
\DoxyCodeLine{1877       superlu::destroy\_compcolperm\_mat(\&out);}
\DoxyCodeLine{1878       \}}
\DoxyCodeLine{1879     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1880     \textcolor{keywordflow}{if}(out.Stype == superlu::SLU\_DN)}
\DoxyCodeLine{1881       \{}
\DoxyCodeLine{1882       \textcolor{comment}{// superlu::destroy\_dense\_mat(\&out);}}
\DoxyCodeLine{1883       }
\DoxyCodeLine{1884       \textcolor{comment}{// since dn-\/>nzval is set to re-\/use memory from a Mat object (which manages its own memory),}}
\DoxyCodeLine{1885       \textcolor{comment}{// we cannot simply call superlu::destroy\_dense\_mat().}}
\DoxyCodeLine{1886       \textcolor{comment}{// Only the out.Store structure can be freed.}}
\DoxyCodeLine{1887       }
\DoxyCodeLine{1888       superlu::DNformat* dn = (superlu::DNformat*) out.Store;}
\DoxyCodeLine{1889       }
\DoxyCodeLine{1890       \textcolor{keywordflow}{if}(dn != \textcolor{keyword}{nullptr})  \{ superlu::free(dn); \}}
\DoxyCodeLine{1891       \}}
\DoxyCodeLine{1892     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1893     \textcolor{keywordflow}{if}(out.Stype == superlu::SLU\_SC)}
\DoxyCodeLine{1894       \{}
\DoxyCodeLine{1895       superlu::destroy\_supernode\_mat(\&out);}
\DoxyCodeLine{1896       \}}
\DoxyCodeLine{1897     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1898       \{}
\DoxyCodeLine{1899       \textcolor{comment}{// Uh, crap.}}
\DoxyCodeLine{1900       }
\DoxyCodeLine{1901       std::ostringstream tmp;}
\DoxyCodeLine{1902       }
\DoxyCodeLine{1903       tmp << \textcolor{stringliteral}{"{}sp\_auxlib::destroy\_supermatrix(): unhandled Stype"{}} << std::endl;}
\DoxyCodeLine{1904       tmp << \textcolor{stringliteral}{"{}Stype  val: "{}} << out.Stype << std::endl;}
\DoxyCodeLine{1905       tmp << \textcolor{stringliteral}{"{}Stype name: "{}};}
\DoxyCodeLine{1906       }
\DoxyCodeLine{1907       \textcolor{keywordflow}{if}(out.Stype == superlu::SLU\_NC)      \{ tmp << \textcolor{stringliteral}{"{}SLU\_NC"{}};     \}}
\DoxyCodeLine{1908       \textcolor{keywordflow}{if}(out.Stype == superlu::SLU\_NCP)     \{ tmp << \textcolor{stringliteral}{"{}SLU\_NCP"{}};    \}}
\DoxyCodeLine{1909       \textcolor{keywordflow}{if}(out.Stype == superlu::SLU\_NR)      \{ tmp << \textcolor{stringliteral}{"{}SLU\_NR"{}};     \}}
\DoxyCodeLine{1910       \textcolor{keywordflow}{if}(out.Stype == superlu::SLU\_SC)      \{ tmp << \textcolor{stringliteral}{"{}SLU\_SC"{}};     \}}
\DoxyCodeLine{1911       \textcolor{keywordflow}{if}(out.Stype == superlu::SLU\_SCP)     \{ tmp << \textcolor{stringliteral}{"{}SLU\_SCP"{}};    \}}
\DoxyCodeLine{1912       \textcolor{keywordflow}{if}(out.Stype == superlu::SLU\_SR)      \{ tmp << \textcolor{stringliteral}{"{}SLU\_SR"{}};     \}}
\DoxyCodeLine{1913       \textcolor{keywordflow}{if}(out.Stype == superlu::SLU\_DN)      \{ tmp << \textcolor{stringliteral}{"{}SLU\_DN"{}};     \}}
\DoxyCodeLine{1914       \textcolor{keywordflow}{if}(out.Stype == superlu::SLU\_NR\_loc)  \{ tmp << \textcolor{stringliteral}{"{}SLU\_NR\_loc"{}}; \}}
\DoxyCodeLine{1915       }
\DoxyCodeLine{1916       arma\_debug\_warn\_level(1, tmp.str());}
\DoxyCodeLine{1917       arma\_stop\_runtime\_error(\textcolor{stringliteral}{"{}internal error: sp\_auxlib::destroy\_supermatrix()"{}});}
\DoxyCodeLine{1918       \}}
\DoxyCodeLine{1919     \}}
\DoxyCodeLine{1920   }
\DoxyCodeLine{1921 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1922 }
\DoxyCodeLine{1923 }
\DoxyCodeLine{1924 }
\DoxyCodeLine{1925 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{1926 \textcolor{keyword}{inline}}
\DoxyCodeLine{1927 \textcolor{keywordtype}{void}}
\DoxyCodeLine{1928 sp\_auxlib::run\_aupd\_plain}
\DoxyCodeLine{1929   (}
\DoxyCodeLine{1930   \textcolor{keyword}{const} uword n\_eigvals, \textcolor{keywordtype}{char}* which, }
\DoxyCodeLine{1931   \textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<T>}}\& X, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} sym,}
\DoxyCodeLine{1932   blas\_int\& n, eT\& tol, blas\_int\& maxiter,}
\DoxyCodeLine{1933   \mbox{\hyperlink{classpodarray}{podarray<T>}}\& resid, blas\_int\& ncv, \mbox{\hyperlink{classpodarray}{podarray<T>}}\& v, blas\_int\& ldv,}
\DoxyCodeLine{1934   \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}}\& iparam, \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}}\& ipntr,}
\DoxyCodeLine{1935   \mbox{\hyperlink{classpodarray}{podarray<T>}}\& workd, \mbox{\hyperlink{classpodarray}{podarray<T>}}\& workl, blas\_int\& lworkl, \mbox{\hyperlink{classpodarray}{podarray<eT>}}\& rwork,}
\DoxyCodeLine{1936   blas\_int\& info}
\DoxyCodeLine{1937   )}
\DoxyCodeLine{1938   \{}
\DoxyCodeLine{1939 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_ARPACK)}}
\DoxyCodeLine{1940     \{}
\DoxyCodeLine{1941     \textcolor{comment}{// ARPACK provides a "{}reverse communication interface"{} which is an}}
\DoxyCodeLine{1942     \textcolor{comment}{// entertainingly archaic FORTRAN software engineering technique that}}
\DoxyCodeLine{1943     \textcolor{comment}{// basically means that we call saupd()/naupd() and it tells us with some}}
\DoxyCodeLine{1944     \textcolor{comment}{// return code what we need to do next (usually a matrix-\/vector product) and}}
\DoxyCodeLine{1945     \textcolor{comment}{// then call it again.  So this results in some type of iterative process}}
\DoxyCodeLine{1946     \textcolor{comment}{// where we call saupd()/naupd() many times.}}
\DoxyCodeLine{1947     }
\DoxyCodeLine{1948     blas\_int ido = 0; \textcolor{comment}{// This must be 0 for the first call.}}
\DoxyCodeLine{1949     \textcolor{keywordtype}{char} bmat = \textcolor{charliteral}{'I'}; \textcolor{comment}{// We are considering the standard eigenvalue problem.}}
\DoxyCodeLine{1950     n = X.n\_rows; \textcolor{comment}{// The size of the matrix (should already be set outside).}}
\DoxyCodeLine{1951     blas\_int nev = n\_eigvals;}
\DoxyCodeLine{1952     }
\DoxyCodeLine{1953     resid.set\_size(n);}
\DoxyCodeLine{1954     }
\DoxyCodeLine{1955     \textcolor{comment}{// Two contraints on NCV: (NCV > NEV) for sym problems or}}
\DoxyCodeLine{1956     \textcolor{comment}{// (NCV > NEV + 2) for gen problems and (NCV <= N)}}
\DoxyCodeLine{1957     \textcolor{comment}{// }}
\DoxyCodeLine{1958     \textcolor{comment}{// We're calling either arpack::saupd() or arpack::naupd(),}}
\DoxyCodeLine{1959     \textcolor{comment}{// which have slighly different minimum constraint and recommended value for NCV:}}
\DoxyCodeLine{1960     \textcolor{comment}{// http://www.caam.rice.edu/software/ARPACK/UG/node136.html}}
\DoxyCodeLine{1961     \textcolor{comment}{// http://www.caam.rice.edu/software/ARPACK/UG/node138.html}}
\DoxyCodeLine{1962     }
\DoxyCodeLine{1963     \textcolor{keywordflow}{if}(ncv < (nev + (sym ? 1 : 3))) \{ ncv = (nev + (sym ? 1 : 3)); \}}
\DoxyCodeLine{1964     \textcolor{keywordflow}{if}(ncv > n                    ) \{ ncv = n;                     \}}
\DoxyCodeLine{1965     }
\DoxyCodeLine{1966     v.set\_size(n * ncv); \textcolor{comment}{// Array N by NCV (output).}}
\DoxyCodeLine{1967     rwork.set\_size(ncv); \textcolor{comment}{// Work array of size NCV for complex calls.}}
\DoxyCodeLine{1968     ldv = n; \textcolor{comment}{// "{}Leading dimension of V exactly as declared in the calling program."{}}}
\DoxyCodeLine{1969     }
\DoxyCodeLine{1970     \textcolor{comment}{// IPARAM: integer array of length 11.}}
\DoxyCodeLine{1971     iparam.zeros(11);}
\DoxyCodeLine{1972     iparam(0) = 1; \textcolor{comment}{// Exact shifts (not provided by us).}}
\DoxyCodeLine{1973     iparam(2) = maxiter; \textcolor{comment}{// Maximum iterations; all the examples use 300, but they were written in the ancient times.}}
\DoxyCodeLine{1974     iparam(6) = 1; \textcolor{comment}{// Mode 1: A * x = lambda * x.}}
\DoxyCodeLine{1975     }
\DoxyCodeLine{1976     \textcolor{comment}{// IPNTR: integer array of length 14 (output).}}
\DoxyCodeLine{1977     ipntr.set\_size(14);}
\DoxyCodeLine{1978     }
\DoxyCodeLine{1979     \textcolor{comment}{// Real work array used in the basic Arnoldi iteration for reverse communication.}}
\DoxyCodeLine{1980     workd.set\_size(3 * n);}
\DoxyCodeLine{1981     }
\DoxyCodeLine{1982     \textcolor{comment}{// lworkl must be at least 3 * NCV\string^2 + 6 * NCV.}}
\DoxyCodeLine{1983     lworkl = 3 * (ncv * ncv) + 6 * ncv;}
\DoxyCodeLine{1984     }
\DoxyCodeLine{1985     \textcolor{comment}{// Real work array of length lworkl.}}
\DoxyCodeLine{1986     workl.set\_size(lworkl);}
\DoxyCodeLine{1987     }
\DoxyCodeLine{1988     info = 0; \textcolor{comment}{// Set to 0 initially to use random initial vector.}}
\DoxyCodeLine{1989     }
\DoxyCodeLine{1990     \textcolor{comment}{// All the parameters have been set or created.  Time to loop a lot.}}
\DoxyCodeLine{1991     \textcolor{keywordflow}{while}(ido != 99)}
\DoxyCodeLine{1992       \{}
\DoxyCodeLine{1993       \textcolor{comment}{// Call saupd() or naupd() with the current parameters.}}
\DoxyCodeLine{1994       \textcolor{keywordflow}{if}(sym)}
\DoxyCodeLine{1995         \{}
\DoxyCodeLine{1996         arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}arpack::saupd()"{}});}
\DoxyCodeLine{1997         arpack::saupd(\&ido, \&bmat, \&n, which, \&nev, \&tol, resid.memptr(), \&ncv, v.memptr(), \&ldv, iparam.memptr(), ipntr.memptr(), workd.memptr(), workl.memptr(), \&lworkl, \&info);}
\DoxyCodeLine{1998         \}}
\DoxyCodeLine{1999       \textcolor{keywordflow}{else}}
\DoxyCodeLine{2000         \{}
\DoxyCodeLine{2001         arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}arpack::naupd()"{}});}
\DoxyCodeLine{2002         arpack::naupd(\&ido, \&bmat, \&n, which, \&nev, \&tol, resid.memptr(), \&ncv, v.memptr(), \&ldv, iparam.memptr(), ipntr.memptr(), workd.memptr(), workl.memptr(), \&lworkl, rwork.memptr(), \&info);}
\DoxyCodeLine{2003         \}}
\DoxyCodeLine{2004       }
\DoxyCodeLine{2005       \textcolor{comment}{// What do we do now?}}
\DoxyCodeLine{2006       \textcolor{keywordflow}{switch} (ido)}
\DoxyCodeLine{2007         \{}
\DoxyCodeLine{2008         \textcolor{keywordflow}{case} -\/1:}
\DoxyCodeLine{2009           \textcolor{comment}{// fallthrough}}
\DoxyCodeLine{2010         \textcolor{keywordflow}{case} 1:}
\DoxyCodeLine{2011           \{}
\DoxyCodeLine{2012           \textcolor{comment}{// We need to calculate the matrix-\/vector multiplication y = OP * x}}
\DoxyCodeLine{2013           \textcolor{comment}{// where x is of length n and starts at workd(ipntr(0)), and y is of}}
\DoxyCodeLine{2014           \textcolor{comment}{// length n and starts at workd(ipntr(1)).}}
\DoxyCodeLine{2015           }
\DoxyCodeLine{2016           \textcolor{comment}{// operator*(sp\_mat, vec) doesn't properly put the result into the}}
\DoxyCodeLine{2017           \textcolor{comment}{// right place so we'll just reimplement it here for now...}}
\DoxyCodeLine{2018           }
\DoxyCodeLine{2019           \textcolor{comment}{// Set the output to point at the right memory.  We have to subtract}}
\DoxyCodeLine{2020           \textcolor{comment}{// one from FORTRAN pointers...}}
\DoxyCodeLine{2021           \mbox{\hyperlink{classCol}{Col<T>}} out(workd.memptr() + ipntr(1) -\/ 1, n, \textcolor{keyword}{false} \textcolor{comment}{/* don't copy */});}
\DoxyCodeLine{2022           \textcolor{comment}{// Set the input to point at the right memory.}}
\DoxyCodeLine{2023           \mbox{\hyperlink{classCol}{Col<T>}} in(workd.memptr() + ipntr(0) -\/ 1, n, \textcolor{keyword}{false} \textcolor{comment}{/* don't copy */});}
\DoxyCodeLine{2024           }
\DoxyCodeLine{2025           out.zeros();}
\DoxyCodeLine{2026           }
\DoxyCodeLine{2027           \textcolor{keyword}{typename} \mbox{\hyperlink{classSpMat_1_1const__iterator}{SpMat<T>::const\_iterator}} X\_it     = X.begin();}
\DoxyCodeLine{2028           \textcolor{keyword}{typename} \mbox{\hyperlink{classSpMat_1_1const__iterator}{SpMat<T>::const\_iterator}} X\_it\_end = X.end();}
\DoxyCodeLine{2029           }
\DoxyCodeLine{2030           \textcolor{keywordflow}{while}(X\_it != X\_it\_end)}
\DoxyCodeLine{2031             \{}
\DoxyCodeLine{2032             \textcolor{keyword}{const} uword X\_it\_row = X\_it.row();}
\DoxyCodeLine{2033             \textcolor{keyword}{const} uword X\_it\_col = X\_it.col();}
\DoxyCodeLine{2034             }
\DoxyCodeLine{2035             out[X\_it\_row] += (*X\_it) * in[X\_it\_col];}
\DoxyCodeLine{2036             ++X\_it;}
\DoxyCodeLine{2037             \}}
\DoxyCodeLine{2038           }
\DoxyCodeLine{2039           \textcolor{comment}{// No need to modify memory further since it was all done in-\/place.}}
\DoxyCodeLine{2040           }
\DoxyCodeLine{2041           \textcolor{keywordflow}{break};}
\DoxyCodeLine{2042           \}}
\DoxyCodeLine{2043         \textcolor{keywordflow}{case} 99:}
\DoxyCodeLine{2044           \textcolor{comment}{// Nothing to do here, things have converged.}}
\DoxyCodeLine{2045           \textcolor{keywordflow}{break};}
\DoxyCodeLine{2046         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{2047           \{}
\DoxyCodeLine{2048           \textcolor{keywordflow}{return}; \textcolor{comment}{// Parent frame can look at the value of info.}}
\DoxyCodeLine{2049           \}}
\DoxyCodeLine{2050         \}}
\DoxyCodeLine{2051       \}}
\DoxyCodeLine{2052     }
\DoxyCodeLine{2053     \textcolor{comment}{// The process has ended; check the return code.}}
\DoxyCodeLine{2054     \textcolor{keywordflow}{if}( (info != 0) \&\& (info != 1) )}
\DoxyCodeLine{2055       \{}
\DoxyCodeLine{2056       \textcolor{comment}{// Print warnings if there was a failure.}}
\DoxyCodeLine{2057       }
\DoxyCodeLine{2058       \textcolor{keywordflow}{if}(sym)}
\DoxyCodeLine{2059         \{}
\DoxyCodeLine{2060         arma\_debug\_warn\_level(1, \textcolor{stringliteral}{"{}eigs\_sym(): ARPACK error "{}}, info, \textcolor{stringliteral}{"{} in saupd()"{}});}
\DoxyCodeLine{2061         \}}
\DoxyCodeLine{2062       \textcolor{keywordflow}{else}}
\DoxyCodeLine{2063         \{}
\DoxyCodeLine{2064         arma\_debug\_warn\_level(1, \textcolor{stringliteral}{"{}eigs\_gen(): ARPACK error "{}}, info, \textcolor{stringliteral}{"{} in naupd()"{}});}
\DoxyCodeLine{2065         \}}
\DoxyCodeLine{2066       }
\DoxyCodeLine{2067       \textcolor{keywordflow}{return}; \textcolor{comment}{// Parent frame can look at the value of info.}}
\DoxyCodeLine{2068       \}}
\DoxyCodeLine{2069     \}}
\DoxyCodeLine{2070 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{2071     \{}
\DoxyCodeLine{2072     arma\_ignore(n\_eigvals);}
\DoxyCodeLine{2073     arma\_ignore(which);}
\DoxyCodeLine{2074     arma\_ignore(X);}
\DoxyCodeLine{2075     arma\_ignore(sym);}
\DoxyCodeLine{2076     arma\_ignore(n);}
\DoxyCodeLine{2077     arma\_ignore(tol);}
\DoxyCodeLine{2078     arma\_ignore(maxiter);}
\DoxyCodeLine{2079     arma\_ignore(resid);}
\DoxyCodeLine{2080     arma\_ignore(ncv);}
\DoxyCodeLine{2081     arma\_ignore(v);}
\DoxyCodeLine{2082     arma\_ignore(ldv);}
\DoxyCodeLine{2083     arma\_ignore(iparam);}
\DoxyCodeLine{2084     arma\_ignore(ipntr);}
\DoxyCodeLine{2085     arma\_ignore(workd);}
\DoxyCodeLine{2086     arma\_ignore(workl);}
\DoxyCodeLine{2087     arma\_ignore(lworkl);}
\DoxyCodeLine{2088     arma\_ignore(rwork);}
\DoxyCodeLine{2089     arma\_ignore(info);}
\DoxyCodeLine{2090     \}}
\DoxyCodeLine{2091 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{2092   \}}
\DoxyCodeLine{2093 }
\DoxyCodeLine{2094 }
\DoxyCodeLine{2095 }
\DoxyCodeLine{2096 \textcolor{comment}{// Here 'sigma' is 'T', but should be 'eT'.}}
\DoxyCodeLine{2097 \textcolor{comment}{// Applying complex shifts to real matrices is currently not directly implemented}}
\DoxyCodeLine{2098 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{2099 \textcolor{keyword}{inline}}
\DoxyCodeLine{2100 \textcolor{keywordtype}{void}}
\DoxyCodeLine{2101 sp\_auxlib::run\_aupd\_shiftinvert}
\DoxyCodeLine{2102   (}
\DoxyCodeLine{2103   \textcolor{keyword}{const} uword n\_eigvals, \textcolor{keyword}{const} T sigma,}
\DoxyCodeLine{2104   \textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<T>}}\& X, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} sym,}
\DoxyCodeLine{2105   blas\_int\& n, eT\& tol, blas\_int\& maxiter,}
\DoxyCodeLine{2106   \mbox{\hyperlink{classpodarray}{podarray<T>}}\& resid, blas\_int\& ncv, \mbox{\hyperlink{classpodarray}{podarray<T>}}\& v, blas\_int\& ldv,}
\DoxyCodeLine{2107   \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}}\& iparam, \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}}\& ipntr,}
\DoxyCodeLine{2108   \mbox{\hyperlink{classpodarray}{podarray<T>}}\& workd, \mbox{\hyperlink{classpodarray}{podarray<T>}}\& workl, blas\_int\& lworkl, \mbox{\hyperlink{classpodarray}{podarray<eT>}}\& rwork,}
\DoxyCodeLine{2109   blas\_int\& info}
\DoxyCodeLine{2110   )}
\DoxyCodeLine{2111   \{}
\DoxyCodeLine{2112   \textcolor{comment}{// TODO: inconsistent use of type names: T can be complex while eT can be real}}
\DoxyCodeLine{2113   }
\DoxyCodeLine{2114 \textcolor{preprocessor}{  \#if (defined(ARMA\_USE\_ARPACK) \&\& defined(ARMA\_USE\_SUPERLU))}}
\DoxyCodeLine{2115     \{}
\DoxyCodeLine{2116     \textcolor{keywordtype}{char} which\_lm[3] = \textcolor{stringliteral}{"{}LM"{}};}
\DoxyCodeLine{2117     }
\DoxyCodeLine{2118     \textcolor{keywordtype}{char}* which = which\_lm;  \textcolor{comment}{// NOTE: which\_lm is the assumed operation when using shift-\/invert}}
\DoxyCodeLine{2119     }
\DoxyCodeLine{2120     blas\_int ido = 0; \textcolor{comment}{// This must be 0 for the first call.}}
\DoxyCodeLine{2121     \textcolor{keywordtype}{char} bmat = \textcolor{charliteral}{'I'}; \textcolor{comment}{// We are considering the standard eigenvalue problem.}}
\DoxyCodeLine{2122     n = X.n\_rows; \textcolor{comment}{// The size of the matrix (should already be set outside).}}
\DoxyCodeLine{2123     blas\_int nev = n\_eigvals;}
\DoxyCodeLine{2124     }
\DoxyCodeLine{2125     resid.set\_size(n);}
\DoxyCodeLine{2126     }
\DoxyCodeLine{2127     \textcolor{comment}{// Two contraints on NCV: (NCV > NEV) for sym problems or}}
\DoxyCodeLine{2128     \textcolor{comment}{// (NCV > NEV + 2) for gen problems and (NCV <= N)}}
\DoxyCodeLine{2129     \textcolor{comment}{// }}
\DoxyCodeLine{2130     \textcolor{comment}{// We're calling either arpack::saupd() or arpack::naupd(),}}
\DoxyCodeLine{2131     \textcolor{comment}{// which have slighly different minimum constraint and recommended value for NCV:}}
\DoxyCodeLine{2132     \textcolor{comment}{// http://www.caam.rice.edu/software/ARPACK/UG/node136.html}}
\DoxyCodeLine{2133     \textcolor{comment}{// http://www.caam.rice.edu/software/ARPACK/UG/node138.html}}
\DoxyCodeLine{2134     }
\DoxyCodeLine{2135     \textcolor{keywordflow}{if}(ncv < (nev + (sym ? 1 : 3))) \{ ncv = (nev + (sym ? 1 : 3)); \}}
\DoxyCodeLine{2136     \textcolor{keywordflow}{if}(ncv > n                    ) \{ ncv = n;                     \}}
\DoxyCodeLine{2137     }
\DoxyCodeLine{2138     v.set\_size(n * ncv); \textcolor{comment}{// Array N by NCV (output).}}
\DoxyCodeLine{2139     rwork.set\_size(ncv); \textcolor{comment}{// Work array of size NCV for complex calls.}}
\DoxyCodeLine{2140     ldv = n; \textcolor{comment}{// "{}Leading dimension of V exactly as declared in the calling program."{}}}
\DoxyCodeLine{2141     }
\DoxyCodeLine{2142     \textcolor{comment}{// IPARAM: integer array of length 11.}}
\DoxyCodeLine{2143     iparam.zeros(11);}
\DoxyCodeLine{2144     iparam(0) = 1; \textcolor{comment}{// Exact shifts (not provided by us).}}
\DoxyCodeLine{2145     iparam(2) = maxiter; \textcolor{comment}{// Maximum iterations; all the examples use 300, but they were written in the ancient times.}}
\DoxyCodeLine{2146     \textcolor{comment}{// iparam(6) = 1; // Mode 1: A * x = lambda * x.}}
\DoxyCodeLine{2147     }
\DoxyCodeLine{2148     \textcolor{comment}{// Change IPARAM for shift-\/invert}}
\DoxyCodeLine{2149     iparam(6) = 3; \textcolor{comment}{// Mode 3:  A * x = lambda * M * x, M symmetric semi-\/definite. OP = inv[A -\/ sigma*M]*M  (A complex)  or  Real\_Part\{ inv[A -\/ sigma*M]*M \}  (A real)  and  B = M.}}
\DoxyCodeLine{2150     }
\DoxyCodeLine{2151     \textcolor{comment}{// IPNTR: integer array of length 14 (output).}}
\DoxyCodeLine{2152     ipntr.set\_size(14);}
\DoxyCodeLine{2153     }
\DoxyCodeLine{2154     \textcolor{comment}{// Real work array used in the basic Arnoldi iteration for reverse communication.}}
\DoxyCodeLine{2155     workd.set\_size(3 * n);}
\DoxyCodeLine{2156     }
\DoxyCodeLine{2157     \textcolor{comment}{// lworkl must be at least 3 * NCV\string^2 + 6 * NCV.}}
\DoxyCodeLine{2158     lworkl = 3 * (ncv * ncv) + 6 * ncv;}
\DoxyCodeLine{2159     }
\DoxyCodeLine{2160     \textcolor{comment}{// Real work array of length lworkl.}}
\DoxyCodeLine{2161     workl.set\_size(lworkl);}
\DoxyCodeLine{2162     }
\DoxyCodeLine{2163     info = 0; \textcolor{comment}{// Set to 0 initially to use random initial vector.}}
\DoxyCodeLine{2164     }
\DoxyCodeLine{2165     \mbox{\hyperlink{structsuperlu__opts}{superlu\_opts}} superlu\_opts\_default;}
\DoxyCodeLine{2166     superlu::superlu\_options\_t \mbox{\hyperlink{classoptions}{options}};}
\DoxyCodeLine{2167     sp\_auxlib::set\_superlu\_opts(\mbox{\hyperlink{classoptions}{options}}, superlu\_opts\_default);}
\DoxyCodeLine{2168     \textcolor{keywordtype}{int} lwork = 0;}
\DoxyCodeLine{2169     superlu::trans\_t trans = superlu::NOTRANS;}
\DoxyCodeLine{2170     }
\DoxyCodeLine{2171     superlu::GlobalLU\_t Glu; \textcolor{comment}{/* Not needed on return. */}}
\DoxyCodeLine{2172     arrayops::fill\_zeros(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(\&Glu), \textcolor{keyword}{sizeof}(superlu::GlobalLU\_t));}
\DoxyCodeLine{2173     }
\DoxyCodeLine{2174     superlu\_supermatrix\_wrangler x;}
\DoxyCodeLine{2175     superlu\_supermatrix\_wrangler xC;}
\DoxyCodeLine{2176     }
\DoxyCodeLine{2177     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} status\_x = sp\_auxlib::copy\_to\_supermatrix\_with\_shift(x.get\_ref(), X, sigma);}
\DoxyCodeLine{2178     }
\DoxyCodeLine{2179     \textcolor{keywordflow}{if}(status\_x == \textcolor{keyword}{false})}
\DoxyCodeLine{2180       \{}
\DoxyCodeLine{2181       arma\_stop\_runtime\_error(\textcolor{stringliteral}{"{}run\_aupd\_shiftinvert(): could not construct SuperLU matrix"{}});}
\DoxyCodeLine{2182       info = blas\_int(-\/1);}
\DoxyCodeLine{2183       \textcolor{keywordflow}{return};}
\DoxyCodeLine{2184       \}}
\DoxyCodeLine{2185     }
\DoxyCodeLine{2186     \textcolor{comment}{// // for debugging only}}
\DoxyCodeLine{2187     \textcolor{comment}{// if(true)}}
\DoxyCodeLine{2188     \textcolor{comment}{//   \{}}
\DoxyCodeLine{2189     \textcolor{comment}{//   cout << "{}*** testing output of copy\_to\_supermatrix\_with\_shift()"{} << endl;}}
\DoxyCodeLine{2190     \textcolor{comment}{//   cout << "{}*** sigma: "{} << sigma << endl;}}
\DoxyCodeLine{2191     \textcolor{comment}{//   }}
\DoxyCodeLine{2192     \textcolor{comment}{//   SpMat<T> Y(X);}}
\DoxyCodeLine{2193     \textcolor{comment}{//   Y.diag() -\/= sigma;}}
\DoxyCodeLine{2194     \textcolor{comment}{//   }}
\DoxyCodeLine{2195     \textcolor{comment}{//   SpMat<T> Z;}}
\DoxyCodeLine{2196     \textcolor{comment}{//   }}
\DoxyCodeLine{2197     \textcolor{comment}{//   sp\_auxlib::copy\_to\_spmat(Z, x.get\_ref());}}
\DoxyCodeLine{2198     \textcolor{comment}{//   }}
\DoxyCodeLine{2199     \textcolor{comment}{//   cout << "{}*** size(Y): "{} << arma::size(Y) << endl;}}
\DoxyCodeLine{2200     \textcolor{comment}{//   cout << "{}*** size(Z): "{} << arma::size(Z) << endl;}}
\DoxyCodeLine{2201     \textcolor{comment}{//   cout << "{}*** accu(abs(Y)): "{} << accu(abs(Y)) << endl;}}
\DoxyCodeLine{2202     \textcolor{comment}{//   cout << "{}*** accu(abs(Z)): "{} << accu(abs(Z)) << endl;}}
\DoxyCodeLine{2203     \textcolor{comment}{//   }}
\DoxyCodeLine{2204     \textcolor{comment}{//   if(arma::size(Y) == arma::size(Z))}}
\DoxyCodeLine{2205     \textcolor{comment}{//     \{}}
\DoxyCodeLine{2206     \textcolor{comment}{//     cout << "{}*** error: "{} << accu(abs(Y-\/Z)) << endl;}}
\DoxyCodeLine{2207     \textcolor{comment}{//     \}}}
\DoxyCodeLine{2208     \textcolor{comment}{//   \}}}
\DoxyCodeLine{2209     }
\DoxyCodeLine{2210     superlu\_supermatrix\_wrangler l;}
\DoxyCodeLine{2211     superlu\_supermatrix\_wrangler u;}
\DoxyCodeLine{2212     }
\DoxyCodeLine{2213     superlu\_array\_wrangler<int> perm\_c(X.n\_cols+1);  \textcolor{comment}{// paranoia: increase array length by 1}}
\DoxyCodeLine{2214     superlu\_array\_wrangler<int> perm\_r(X.n\_rows+1);}
\DoxyCodeLine{2215     superlu\_array\_wrangler<int>  etree(X.n\_cols+1);}
\DoxyCodeLine{2216     }
\DoxyCodeLine{2217     superlu\_stat\_wrangler stat;}
\DoxyCodeLine{2218     }
\DoxyCodeLine{2219     \textcolor{keywordtype}{int} panel\_size = superlu::sp\_ispec\_environ(1);}
\DoxyCodeLine{2220     \textcolor{keywordtype}{int} relax      = superlu::sp\_ispec\_environ(2);}
\DoxyCodeLine{2221     \textcolor{keywordtype}{int} slu\_info   = 0; \textcolor{comment}{// Return code.}}
\DoxyCodeLine{2222     }
\DoxyCodeLine{2223     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}superlu::gstrf()"{}});}
\DoxyCodeLine{2224     superlu::get\_permutation\_c(\mbox{\hyperlink{classoptions}{options}}.ColPerm, x.get\_ptr(), perm\_c.get\_ptr());}
\DoxyCodeLine{2225     superlu::sp\_preorder\_mat(\&\mbox{\hyperlink{classoptions}{options}}, x.get\_ptr(), perm\_c.get\_ptr(), etree.get\_ptr(), xC.get\_ptr());}
\DoxyCodeLine{2226     superlu::gstrf<T>(\&\mbox{\hyperlink{classoptions}{options}}, xC.get\_ptr(), relax, panel\_size, etree.get\_ptr(), NULL, lwork, perm\_c.get\_ptr(), perm\_r.get\_ptr(), l.get\_ptr(), u.get\_ptr(), \&Glu, stat.get\_ptr(), \&slu\_info);}
\DoxyCodeLine{2227     }
\DoxyCodeLine{2228     \textcolor{keywordflow}{if}(slu\_info != 0)}
\DoxyCodeLine{2229       \{}
\DoxyCodeLine{2230       arma\_debug\_warn\_level(2, \textcolor{stringliteral}{"{}matrix is singular to working precision"{}});}
\DoxyCodeLine{2231       info = blas\_int(-\/1);}
\DoxyCodeLine{2232       \textcolor{keywordflow}{return};}
\DoxyCodeLine{2233       \}}
\DoxyCodeLine{2234     }
\DoxyCodeLine{2235     eT x\_norm\_val = sp\_auxlib::norm1<T>(x.get\_ptr());}
\DoxyCodeLine{2236     eT x\_rcond    = sp\_auxlib::lu\_rcond<T>(l.get\_ptr(), u.get\_ptr(), x\_norm\_val);}
\DoxyCodeLine{2237     }
\DoxyCodeLine{2238     \textcolor{keywordflow}{if}( (x\_rcond < std::numeric\_limits<eT>::epsilon()) || arma\_isnan(x\_rcond) )}
\DoxyCodeLine{2239       \{}
\DoxyCodeLine{2240       arma\_debug\_warn\_level(2, \textcolor{stringliteral}{"{}matrix is singular to working precision (rcond: "{}}, x\_rcond, \textcolor{stringliteral}{"{})"{}});}
\DoxyCodeLine{2241       info = blas\_int(-\/1);}
\DoxyCodeLine{2242       \textcolor{keywordflow}{return};}
\DoxyCodeLine{2243       \}}
\DoxyCodeLine{2244     }
\DoxyCodeLine{2245     \textcolor{comment}{// All the parameters have been set or created.  Time to loop a lot.}}
\DoxyCodeLine{2246     \textcolor{keywordflow}{while}(ido != 99)}
\DoxyCodeLine{2247       \{}
\DoxyCodeLine{2248       \textcolor{comment}{// Call saupd() or naupd() with the current parameters.}}
\DoxyCodeLine{2249       \textcolor{keywordflow}{if}(sym)}
\DoxyCodeLine{2250         \{}
\DoxyCodeLine{2251         arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}arpack::saupd()"{}});}
\DoxyCodeLine{2252         arpack::saupd(\&ido, \&bmat, \&n, which, \&nev, \&tol, resid.memptr(), \&ncv, v.memptr(), \&ldv, iparam.memptr(), ipntr.memptr(), workd.memptr(), workl.memptr(), \&lworkl, \&info);}
\DoxyCodeLine{2253         \}}
\DoxyCodeLine{2254       \textcolor{keywordflow}{else}}
\DoxyCodeLine{2255         \{}
\DoxyCodeLine{2256         arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}arpack::naupd()"{}});}
\DoxyCodeLine{2257         arpack::naupd(\&ido, \&bmat, \&n, which, \&nev, \&tol, resid.memptr(), \&ncv, v.memptr(), \&ldv, iparam.memptr(), ipntr.memptr(), workd.memptr(), workl.memptr(), \&lworkl, rwork.memptr(), \&info);}
\DoxyCodeLine{2258         \}}
\DoxyCodeLine{2259       }
\DoxyCodeLine{2260       \textcolor{comment}{// What do we do now?}}
\DoxyCodeLine{2261       \textcolor{keywordflow}{switch} (ido)}
\DoxyCodeLine{2262         \{}
\DoxyCodeLine{2263         \textcolor{keywordflow}{case} -\/1:}
\DoxyCodeLine{2264           \textcolor{comment}{// fallthrough}}
\DoxyCodeLine{2265         \textcolor{keywordflow}{case} 1:}
\DoxyCodeLine{2266           \{}
\DoxyCodeLine{2267           \textcolor{comment}{// We need to calculate the matrix-\/vector multiplication y = OP * x}}
\DoxyCodeLine{2268           \textcolor{comment}{// where x is of length n and starts at workd(ipntr(0)), and y is of}}
\DoxyCodeLine{2269           \textcolor{comment}{// length n and starts at workd(ipntr(1)).}}
\DoxyCodeLine{2270           }
\DoxyCodeLine{2271           \textcolor{comment}{// operator*(sp\_mat, vec) doesn't properly put the result into the}}
\DoxyCodeLine{2272           \textcolor{comment}{// right place so we'll just reimplement it here for now...}}
\DoxyCodeLine{2273           }
\DoxyCodeLine{2274           \textcolor{comment}{// Set the output to point at the right memory.  We have to subtract}}
\DoxyCodeLine{2275           \textcolor{comment}{// one from FORTRAN pointers...}}
\DoxyCodeLine{2276           \mbox{\hyperlink{classCol}{Col<T>}} out(workd.memptr() + ipntr(1) -\/ 1, n, \textcolor{keyword}{false} \textcolor{comment}{/* don't copy */});}
\DoxyCodeLine{2277           \textcolor{comment}{// Set the input to point at the right memory.}}
\DoxyCodeLine{2278           \mbox{\hyperlink{classCol}{Col<T>}} in(workd.memptr() + ipntr(0) -\/ 1, n, \textcolor{keyword}{false} \textcolor{comment}{/* don't copy */});}
\DoxyCodeLine{2279           }
\DoxyCodeLine{2280           \textcolor{comment}{// Consider getting the LU factorization from ZGSTRF, and then}}
\DoxyCodeLine{2281           \textcolor{comment}{// solve the system L*U*out = in (possibly with permutation matrix?)}}
\DoxyCodeLine{2282           \textcolor{comment}{// Instead of "{}spsolve(out,X,in)"{} we call gstrf above and gstrs below}}
\DoxyCodeLine{2283           }
\DoxyCodeLine{2284           out = in;}
\DoxyCodeLine{2285           superlu\_supermatrix\_wrangler out\_slu;}
\DoxyCodeLine{2286           }
\DoxyCodeLine{2287           \textcolor{keyword}{const} \textcolor{keywordtype}{bool} status\_out\_slu = sp\_auxlib::wrap\_to\_supermatrix(out\_slu.get\_ref(), out);}
\DoxyCodeLine{2288           }
\DoxyCodeLine{2289           \textcolor{keywordflow}{if}(status\_out\_slu == \textcolor{keyword}{false})  \{ arma\_stop\_runtime\_error(\textcolor{stringliteral}{"{}run\_aupd\_shiftinvert(): could not construct SuperLU matrix"{}}); \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{2290           }
\DoxyCodeLine{2291           arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}superlu::gstrs()"{}});}
\DoxyCodeLine{2292           superlu::gstrs<T>(trans, l.get\_ptr(), u.get\_ptr(), perm\_c.get\_ptr(), perm\_r.get\_ptr(), out\_slu.get\_ptr(), stat.get\_ptr(), \&info);}
\DoxyCodeLine{2293           }
\DoxyCodeLine{2294           \textcolor{comment}{// No need to modify memory further since it was all done in-\/place.}}
\DoxyCodeLine{2295           }
\DoxyCodeLine{2296           \textcolor{keywordflow}{break};}
\DoxyCodeLine{2297           \}}
\DoxyCodeLine{2298         \textcolor{keywordflow}{case} 99:}
\DoxyCodeLine{2299           \textcolor{comment}{// Nothing to do here, things have converged.}}
\DoxyCodeLine{2300           \textcolor{keywordflow}{break};}
\DoxyCodeLine{2301         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{2302           \{}
\DoxyCodeLine{2303           \textcolor{keywordflow}{return}; \textcolor{comment}{// Parent frame can look at the value of info.}}
\DoxyCodeLine{2304           \}}
\DoxyCodeLine{2305         \}}
\DoxyCodeLine{2306       \}}
\DoxyCodeLine{2307     }
\DoxyCodeLine{2308     \textcolor{comment}{// The process has ended; check the return code.}}
\DoxyCodeLine{2309     \textcolor{keywordflow}{if}( (info != 0) \&\& (info != 1) )}
\DoxyCodeLine{2310       \{}
\DoxyCodeLine{2311       \textcolor{comment}{// Print warnings if there was a failure.}}
\DoxyCodeLine{2312       }
\DoxyCodeLine{2313       \textcolor{keywordflow}{if}(sym)}
\DoxyCodeLine{2314         \{}
\DoxyCodeLine{2315         arma\_debug\_warn\_level(2, \textcolor{stringliteral}{"{}eigs\_sym(): ARPACK error "{}}, info, \textcolor{stringliteral}{"{} in saupd()"{}});}
\DoxyCodeLine{2316         \}}
\DoxyCodeLine{2317       \textcolor{keywordflow}{else}}
\DoxyCodeLine{2318         \{}
\DoxyCodeLine{2319         arma\_debug\_warn\_level(2, \textcolor{stringliteral}{"{}eigs\_gen(): ARPACK error "{}}, info, \textcolor{stringliteral}{"{} in naupd()"{}});}
\DoxyCodeLine{2320         \}}
\DoxyCodeLine{2321       }
\DoxyCodeLine{2322       \textcolor{keywordflow}{return}; \textcolor{comment}{// Parent frame can look at the value of info.}}
\DoxyCodeLine{2323       \}}
\DoxyCodeLine{2324     \}}
\DoxyCodeLine{2325 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{2326     \{}
\DoxyCodeLine{2327     arma\_ignore(n\_eigvals);}
\DoxyCodeLine{2328     arma\_ignore(sigma);}
\DoxyCodeLine{2329     arma\_ignore(X);}
\DoxyCodeLine{2330     arma\_ignore(sym);}
\DoxyCodeLine{2331     arma\_ignore(n);}
\DoxyCodeLine{2332     arma\_ignore(tol);}
\DoxyCodeLine{2333     arma\_ignore(maxiter);}
\DoxyCodeLine{2334     arma\_ignore(resid);}
\DoxyCodeLine{2335     arma\_ignore(ncv);}
\DoxyCodeLine{2336     arma\_ignore(v);}
\DoxyCodeLine{2337     arma\_ignore(ldv);}
\DoxyCodeLine{2338     arma\_ignore(iparam);}
\DoxyCodeLine{2339     arma\_ignore(ipntr);}
\DoxyCodeLine{2340     arma\_ignore(workd);}
\DoxyCodeLine{2341     arma\_ignore(workl);}
\DoxyCodeLine{2342     arma\_ignore(lworkl);}
\DoxyCodeLine{2343     arma\_ignore(rwork);}
\DoxyCodeLine{2344     arma\_ignore(info);}
\DoxyCodeLine{2345     \}}
\DoxyCodeLine{2346 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{2347   \}}
\DoxyCodeLine{2348 }
\DoxyCodeLine{2349 }
\DoxyCodeLine{2350 }
\DoxyCodeLine{2351 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{2352 \textcolor{keyword}{inline}}
\DoxyCodeLine{2353 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2354 sp\_auxlib::rudimentary\_sym\_check(\textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& X)}
\DoxyCodeLine{2355   \{}
\DoxyCodeLine{2356   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2357   }
\DoxyCodeLine{2358   \textcolor{keywordflow}{if}(X.n\_rows != X.n\_cols)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2359   }
\DoxyCodeLine{2360   \textcolor{keyword}{const} eT tol = eT(10000) * std::numeric\_limits<eT>::epsilon();  \textcolor{comment}{// allow some leeway}}
\DoxyCodeLine{2361   }
\DoxyCodeLine{2362   \textcolor{keyword}{typename} \mbox{\hyperlink{classSpMat_1_1const__iterator}{SpMat<eT>::const\_iterator}} it     = X.begin();}
\DoxyCodeLine{2363   \textcolor{keyword}{typename} \mbox{\hyperlink{classSpMat_1_1const__iterator}{SpMat<eT>::const\_iterator}} it\_end = X.end();}
\DoxyCodeLine{2364   }
\DoxyCodeLine{2365   \textcolor{keyword}{const} uword n\_check\_limit = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})( uword(2), uword(X.n\_nonzero/100) );}
\DoxyCodeLine{2366   }
\DoxyCodeLine{2367   uword n\_check = 1;}
\DoxyCodeLine{2368   }
\DoxyCodeLine{2369   \textcolor{keywordflow}{while}( (it != it\_end) \&\& (n\_check <= n\_check\_limit) )}
\DoxyCodeLine{2370     \{}
\DoxyCodeLine{2371     \textcolor{keyword}{const} uword it\_row = it.row();}
\DoxyCodeLine{2372     \textcolor{keyword}{const} uword it\_col = it.col();}
\DoxyCodeLine{2373     }
\DoxyCodeLine{2374     \textcolor{keywordflow}{if}(it\_row != it\_col)}
\DoxyCodeLine{2375       \{}
\DoxyCodeLine{2376       \textcolor{keyword}{const} eT \mbox{\hyperlink{structA}{A}} = (*it);}
\DoxyCodeLine{2377       \textcolor{keyword}{const} eT \mbox{\hyperlink{structB}{B}} = X.at( it\_col, it\_row );  \textcolor{comment}{// deliberately swapped}}
\DoxyCodeLine{2378       }
\DoxyCodeLine{2379       \textcolor{keyword}{const} eT C = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(std::abs(\mbox{\hyperlink{structA}{A}}), std::abs(\mbox{\hyperlink{structB}{B}}));}
\DoxyCodeLine{2380       }
\DoxyCodeLine{2381       \textcolor{keyword}{const} eT delta = std::abs(\mbox{\hyperlink{structA}{A}} -\/ \mbox{\hyperlink{structB}{B}});}
\DoxyCodeLine{2382      }
\DoxyCodeLine{2383       \textcolor{keywordflow}{if}(( (delta <= tol) || (delta <= (C * tol)) ) == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2384       }
\DoxyCodeLine{2385       ++n\_check;}
\DoxyCodeLine{2386       \}}
\DoxyCodeLine{2387     }
\DoxyCodeLine{2388     ++it;}
\DoxyCodeLine{2389     \}}
\DoxyCodeLine{2390   }
\DoxyCodeLine{2391   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2392   \}}
\DoxyCodeLine{2393 }
\DoxyCodeLine{2394 }
\DoxyCodeLine{2395 }
\DoxyCodeLine{2396 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2397 \textcolor{keyword}{inline}}
\DoxyCodeLine{2398 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2399 sp\_auxlib::rudimentary\_sym\_check(\textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat}}< std::complex<T> >\& X)}
\DoxyCodeLine{2400   \{}
\DoxyCodeLine{2401   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2402   }
\DoxyCodeLine{2403   \textcolor{comment}{// NOTE: the function name is a misnomer, as it checks for hermitian complex matrices;}}
\DoxyCodeLine{2404   \textcolor{comment}{// NOTE: for simplicity of use, the function name is the same as for real matrices}}
\DoxyCodeLine{2405   }
\DoxyCodeLine{2406   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<T> eT;}
\DoxyCodeLine{2407   }
\DoxyCodeLine{2408   \textcolor{keywordflow}{if}(X.n\_rows != X.n\_cols)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2409   }
\DoxyCodeLine{2410   \textcolor{keyword}{const} T tol = T(10000) * std::numeric\_limits<T>::epsilon();  \textcolor{comment}{// allow some leeway}}
\DoxyCodeLine{2411   }
\DoxyCodeLine{2412   \textcolor{keyword}{typename} \mbox{\hyperlink{classSpMat_1_1const__iterator}{SpMat<eT>::const\_iterator}} it     = X.begin();}
\DoxyCodeLine{2413   \textcolor{keyword}{typename} \mbox{\hyperlink{classSpMat_1_1const__iterator}{SpMat<eT>::const\_iterator}} it\_end = X.end();}
\DoxyCodeLine{2414   }
\DoxyCodeLine{2415   \textcolor{keyword}{const} uword n\_check\_limit = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})( uword(2), uword(X.n\_nonzero/100) );}
\DoxyCodeLine{2416   }
\DoxyCodeLine{2417   uword n\_check = 1;}
\DoxyCodeLine{2418   }
\DoxyCodeLine{2419   \textcolor{keywordflow}{while}( (it != it\_end) \&\& (n\_check <= n\_check\_limit) )}
\DoxyCodeLine{2420     \{}
\DoxyCodeLine{2421     \textcolor{keyword}{const} uword it\_row = it.row();}
\DoxyCodeLine{2422     \textcolor{keyword}{const} uword it\_col = it.col();}
\DoxyCodeLine{2423     }
\DoxyCodeLine{2424     \textcolor{keywordflow}{if}(it\_row != it\_col)}
\DoxyCodeLine{2425       \{}
\DoxyCodeLine{2426       \textcolor{keyword}{const} eT \mbox{\hyperlink{structA}{A}} = (*it);}
\DoxyCodeLine{2427       \textcolor{keyword}{const} eT \mbox{\hyperlink{structB}{B}} = X.at( it\_col, it\_row );  \textcolor{comment}{// deliberately swapped}}
\DoxyCodeLine{2428       }
\DoxyCodeLine{2429       \textcolor{keyword}{const} T C\_real = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(std::abs(\mbox{\hyperlink{structA}{A}}.real()), std::abs(\mbox{\hyperlink{structB}{B}}.real()));}
\DoxyCodeLine{2430       \textcolor{keyword}{const} T C\_imag = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(std::abs(\mbox{\hyperlink{structA}{A}}.imag()), std::abs(\mbox{\hyperlink{structB}{B}}.imag()));}
\DoxyCodeLine{2431       }
\DoxyCodeLine{2432       \textcolor{keyword}{const} T delta\_real = std::abs(\mbox{\hyperlink{structA}{A}}.real() -\/ \mbox{\hyperlink{structB}{B}}.real());}
\DoxyCodeLine{2433       \textcolor{keyword}{const} T delta\_imag = std::abs(\mbox{\hyperlink{structA}{A}}.imag() + \mbox{\hyperlink{structB}{B}}.imag());  \textcolor{comment}{// take into account the conjugate}}
\DoxyCodeLine{2434       }
\DoxyCodeLine{2435       \textcolor{keyword}{const} \textcolor{keywordtype}{bool} okay\_real = ( (delta\_real <= tol) || (delta\_real <= (C\_real * tol)) );}
\DoxyCodeLine{2436       \textcolor{keyword}{const} \textcolor{keywordtype}{bool} okay\_imag = ( (delta\_imag <= tol) || (delta\_imag <= (C\_imag * tol)) );}
\DoxyCodeLine{2437       }
\DoxyCodeLine{2438       \textcolor{keywordflow}{if}( (okay\_real == \textcolor{keyword}{false}) || (okay\_imag == \textcolor{keyword}{false}) )  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2439       }
\DoxyCodeLine{2440       ++n\_check;}
\DoxyCodeLine{2441       \}}
\DoxyCodeLine{2442     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2443       \{}
\DoxyCodeLine{2444       \textcolor{keyword}{const} eT \mbox{\hyperlink{structA}{A}} = (*it);}
\DoxyCodeLine{2445       }
\DoxyCodeLine{2446       \textcolor{keywordflow}{if}(std::abs(\mbox{\hyperlink{structA}{A}}.imag()) > tol)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2447       \}}
\DoxyCodeLine{2448     }
\DoxyCodeLine{2449     ++it;}
\DoxyCodeLine{2450     \}}
\DoxyCodeLine{2451   }
\DoxyCodeLine{2452   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2453   \}}
\DoxyCodeLine{2454 }
\DoxyCodeLine{2455 }
\DoxyCodeLine{2456 }
\DoxyCodeLine{2457 \textcolor{preprocessor}{\#if defined(ARMA\_USE\_SUPERLU)}}
\DoxyCodeLine{2458 }
\DoxyCodeLine{2459 \textcolor{keyword}{inline}}
\DoxyCodeLine{2460 superlu\_supermatrix\_wrangler::\string~superlu\_supermatrix\_wrangler()}
\DoxyCodeLine{2461   \{}
\DoxyCodeLine{2462   arma\_extra\_debug\_sigprint\_this(\textcolor{keyword}{this});}
\DoxyCodeLine{2463   }
\DoxyCodeLine{2464   \textcolor{keywordflow}{if}(used == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{2465   }
\DoxyCodeLine{2466   \textcolor{keywordtype}{char}* m\_char   = \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(\&m);}
\DoxyCodeLine{2467   \textcolor{keywordtype}{bool}  all\_zero = \textcolor{keyword}{true};}
\DoxyCodeLine{2468   }
\DoxyCodeLine{2469   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i=0; i < \textcolor{keyword}{sizeof}(superlu::SuperMatrix); ++i)}
\DoxyCodeLine{2470     \{}
\DoxyCodeLine{2471     \textcolor{keywordflow}{if}(m\_char[i] != \textcolor{keywordtype}{char}(0))  \{ all\_zero = \textcolor{keyword}{false}; \textcolor{keywordflow}{break}; \}}
\DoxyCodeLine{2472     \}}
\DoxyCodeLine{2473   }
\DoxyCodeLine{2474   \textcolor{keywordflow}{if}(all\_zero == \textcolor{keyword}{false})  \{ sp\_auxlib::destroy\_supermatrix(m); \}}
\DoxyCodeLine{2475   \}}
\DoxyCodeLine{2476 }
\DoxyCodeLine{2477 \textcolor{keyword}{inline}}
\DoxyCodeLine{2478 superlu\_supermatrix\_wrangler::superlu\_supermatrix\_wrangler()}
\DoxyCodeLine{2479   \{}
\DoxyCodeLine{2480   arma\_extra\_debug\_sigprint\_this(\textcolor{keyword}{this});}
\DoxyCodeLine{2481   }
\DoxyCodeLine{2482   arrayops::fill\_zeros(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(\&m), \textcolor{keyword}{sizeof}(superlu::SuperMatrix));}
\DoxyCodeLine{2483   \}}
\DoxyCodeLine{2484 }
\DoxyCodeLine{2485 \textcolor{keyword}{inline}}
\DoxyCodeLine{2486 superlu::SuperMatrix\&}
\DoxyCodeLine{2487 superlu\_supermatrix\_wrangler::get\_ref()}
\DoxyCodeLine{2488   \{}
\DoxyCodeLine{2489   used = \textcolor{keyword}{true};}
\DoxyCodeLine{2490   }
\DoxyCodeLine{2491   \textcolor{keywordflow}{return} m;}
\DoxyCodeLine{2492   \}}
\DoxyCodeLine{2493 }
\DoxyCodeLine{2494 \textcolor{keyword}{inline}}
\DoxyCodeLine{2495 superlu::SuperMatrix*}
\DoxyCodeLine{2496 superlu\_supermatrix\_wrangler::get\_ptr()}
\DoxyCodeLine{2497   \{}
\DoxyCodeLine{2498   used = \textcolor{keyword}{true};}
\DoxyCodeLine{2499   }
\DoxyCodeLine{2500   \textcolor{keywordflow}{return} \&m;}
\DoxyCodeLine{2501   \}}
\DoxyCodeLine{2502 }
\DoxyCodeLine{2503 }
\DoxyCodeLine{2504 \textcolor{comment}{//}}
\DoxyCodeLine{2505 }
\DoxyCodeLine{2506 }
\DoxyCodeLine{2507 \textcolor{keyword}{inline}}
\DoxyCodeLine{2508 superlu\_stat\_wrangler::\string~superlu\_stat\_wrangler()}
\DoxyCodeLine{2509   \{}
\DoxyCodeLine{2510   arma\_extra\_debug\_sigprint\_this(\textcolor{keyword}{this});}
\DoxyCodeLine{2511   }
\DoxyCodeLine{2512   superlu::free\_stat(\&stat);}
\DoxyCodeLine{2513   \}}
\DoxyCodeLine{2514 }
\DoxyCodeLine{2515 \textcolor{keyword}{inline}}
\DoxyCodeLine{2516 superlu\_stat\_wrangler::superlu\_stat\_wrangler()}
\DoxyCodeLine{2517   \{}
\DoxyCodeLine{2518   arma\_extra\_debug\_sigprint\_this(\textcolor{keyword}{this});}
\DoxyCodeLine{2519   }
\DoxyCodeLine{2520   arrayops::fill\_zeros(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(\&stat), \textcolor{keyword}{sizeof}(superlu::SuperLUStat\_t));}
\DoxyCodeLine{2521   }
\DoxyCodeLine{2522   superlu::init\_stat(\&stat);}
\DoxyCodeLine{2523   \}}
\DoxyCodeLine{2524 }
\DoxyCodeLine{2525 \textcolor{keyword}{inline}}
\DoxyCodeLine{2526 superlu::SuperLUStat\_t*}
\DoxyCodeLine{2527 superlu\_stat\_wrangler::get\_ptr()}
\DoxyCodeLine{2528   \{}
\DoxyCodeLine{2529   \textcolor{keywordflow}{return} \&stat;}
\DoxyCodeLine{2530   \}}
\DoxyCodeLine{2531 }
\DoxyCodeLine{2532 }
\DoxyCodeLine{2533 \textcolor{comment}{//}}
\DoxyCodeLine{2534 }
\DoxyCodeLine{2535 }
\DoxyCodeLine{2536 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{2537 \textcolor{keyword}{inline}}
\DoxyCodeLine{2538 superlu\_array\_wrangler<eT>::\string~superlu\_array\_wrangler()}
\DoxyCodeLine{2539   \{}
\DoxyCodeLine{2540   arma\_extra\_debug\_sigprint\_this(\textcolor{keyword}{this});}
\DoxyCodeLine{2541   }
\DoxyCodeLine{2542   \textcolor{keywordflow}{if}(mem != \textcolor{keyword}{nullptr})}
\DoxyCodeLine{2543     \{}
\DoxyCodeLine{2544     superlu::free(mem);}
\DoxyCodeLine{2545     mem = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{2546     \}}
\DoxyCodeLine{2547   \}}
\DoxyCodeLine{2548 }
\DoxyCodeLine{2549 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{2550 \textcolor{keyword}{inline}}
\DoxyCodeLine{2551 superlu\_array\_wrangler<eT>::superlu\_array\_wrangler(\textcolor{keyword}{const} uword n\_elem)}
\DoxyCodeLine{2552   \{}
\DoxyCodeLine{2553   arma\_extra\_debug\_sigprint\_this(\textcolor{keyword}{this});}
\DoxyCodeLine{2554   }
\DoxyCodeLine{2555   mem = (eT*)(superlu::malloc(n\_elem * \textcolor{keyword}{sizeof}(eT)));}
\DoxyCodeLine{2556   }
\DoxyCodeLine{2557   arma\_check\_bad\_alloc( (mem == \textcolor{keyword}{nullptr}), \textcolor{stringliteral}{"{}superlu::malloc(): out of memory"{}} );}
\DoxyCodeLine{2558   }
\DoxyCodeLine{2559   arrayops::fill\_zeros(mem, n\_elem);}
\DoxyCodeLine{2560   \}}
\DoxyCodeLine{2561 }
\DoxyCodeLine{2562 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{2563 \textcolor{keyword}{inline}}
\DoxyCodeLine{2564 eT*}
\DoxyCodeLine{2565 superlu\_array\_wrangler<eT>::get\_ptr()}
\DoxyCodeLine{2566   \{}
\DoxyCodeLine{2567   \textcolor{keywordflow}{return} mem;}
\DoxyCodeLine{2568   \}}
\DoxyCodeLine{2569 }
\DoxyCodeLine{2570 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2571 }
\DoxyCodeLine{2572 }

\end{DoxyCode}
