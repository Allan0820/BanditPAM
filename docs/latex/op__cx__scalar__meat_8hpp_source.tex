\hypertarget{op__cx__scalar__meat_8hpp_source}{}\doxysection{op\+\_\+cx\+\_\+scalar\+\_\+meat.\+hpp}
\label{op__cx__scalar__meat_8hpp_source}\index{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/op\_cx\_scalar\_meat.hpp@{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/op\_cx\_scalar\_meat.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008-\/2016 Conrad Sanderson (http://conradsanderson.id.au)}}
\DoxyCodeLine{2 \textcolor{comment}{// Copyright 2008-\/2016 National ICT Australia (NICTA)}}
\DoxyCodeLine{3 \textcolor{comment}{// }}
\DoxyCodeLine{4 \textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{5 \textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{6 \textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{7 \textcolor{comment}{// http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{8 \textcolor{comment}{// }}
\DoxyCodeLine{9 \textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{10 \textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{11 \textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{12 \textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{13 \textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{14 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{19 }
\DoxyCodeLine{20 }
\DoxyCodeLine{21 }
\DoxyCodeLine{22 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{23 \textcolor{keyword}{inline}}
\DoxyCodeLine{24 \textcolor{keywordtype}{void}}
\DoxyCodeLine{25 op\_cx\_scalar\_times::apply}
\DoxyCodeLine{26   (}
\DoxyCodeLine{27         \mbox{\hyperlink{classMat}{Mat}}< \textcolor{keyword}{typename} std::complex<typename T1::pod\_type> >\& out,}
\DoxyCodeLine{28   \textcolor{keyword}{const} \mbox{\hyperlink{classmtOp}{mtOp}}<\textcolor{keyword}{typename} std::complex<typename T1::pod\_type>, T1, \mbox{\hyperlink{classop__cx__scalar__times}{op\_cx\_scalar\_times}}>\& X}
\DoxyCodeLine{29   )}
\DoxyCodeLine{30   \{}
\DoxyCodeLine{31   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{32   }
\DoxyCodeLine{33   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<typename T1::pod\_type> eT;}
\DoxyCodeLine{34   }
\DoxyCodeLine{35   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} \mbox{\hyperlink{structA}{A}}(X.m);}
\DoxyCodeLine{36   }
\DoxyCodeLine{37   \textcolor{keyword}{const} uword n\_rows = \mbox{\hyperlink{structA}{A}}.get\_n\_rows();}
\DoxyCodeLine{38   \textcolor{keyword}{const} uword n\_cols = \mbox{\hyperlink{structA}{A}}.get\_n\_cols();}
\DoxyCodeLine{39   }
\DoxyCodeLine{40   out.set\_size(n\_rows, n\_cols);}
\DoxyCodeLine{41   }
\DoxyCodeLine{42   \textcolor{keyword}{const} eT  k       = X.aux\_out\_eT;}
\DoxyCodeLine{43         eT* out\_mem = out.memptr();}
\DoxyCodeLine{44   }
\DoxyCodeLine{45   \textcolor{keywordflow}{if}(\mbox{\hyperlink{classProxy}{Proxy<T1>::use\_at}} == \textcolor{keyword}{false})}
\DoxyCodeLine{46     \{}
\DoxyCodeLine{47     \textcolor{keyword}{const} uword n\_elem = \mbox{\hyperlink{structA}{A}}.get\_n\_elem();}
\DoxyCodeLine{48   }
\DoxyCodeLine{49     \textcolor{keywordflow}{for}(uword i=0; i<n\_elem; ++i)}
\DoxyCodeLine{50       \{}
\DoxyCodeLine{51       out\_mem[i] = \mbox{\hyperlink{structA}{A}}[i] * k;}
\DoxyCodeLine{52       \}}
\DoxyCodeLine{53     \}}
\DoxyCodeLine{54   \textcolor{keywordflow}{else}}
\DoxyCodeLine{55     \{}
\DoxyCodeLine{56     \textcolor{keywordflow}{for}(uword col=0; col < n\_cols; ++col)}
\DoxyCodeLine{57     \textcolor{keywordflow}{for}(uword row=0; row < n\_rows; ++row)}
\DoxyCodeLine{58       \{}
\DoxyCodeLine{59       *out\_mem = \mbox{\hyperlink{structA}{A}}.at(row,col) * k;  ++out\_mem;}
\DoxyCodeLine{60       \}}
\DoxyCodeLine{61     \}}
\DoxyCodeLine{62   \}}
\DoxyCodeLine{63 }
\DoxyCodeLine{64 }
\DoxyCodeLine{65 }
\DoxyCodeLine{66 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{67 \textcolor{keyword}{inline}}
\DoxyCodeLine{68 \textcolor{keywordtype}{void}}
\DoxyCodeLine{69 op\_cx\_scalar\_plus::apply}
\DoxyCodeLine{70   (}
\DoxyCodeLine{71         \mbox{\hyperlink{classMat}{Mat}}< \textcolor{keyword}{typename} std::complex<typename T1::pod\_type> >\& out,}
\DoxyCodeLine{72   \textcolor{keyword}{const} \mbox{\hyperlink{classmtOp}{mtOp}}<\textcolor{keyword}{typename} std::complex<typename T1::pod\_type>, T1, \mbox{\hyperlink{classop__cx__scalar__plus}{op\_cx\_scalar\_plus}}>\& X}
\DoxyCodeLine{73   )}
\DoxyCodeLine{74   \{}
\DoxyCodeLine{75   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{76   }
\DoxyCodeLine{77   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<typename T1::pod\_type> eT;}
\DoxyCodeLine{78   }
\DoxyCodeLine{79   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} \mbox{\hyperlink{structA}{A}}(X.m);}
\DoxyCodeLine{80   }
\DoxyCodeLine{81   \textcolor{keyword}{const} uword n\_rows = \mbox{\hyperlink{structA}{A}}.get\_n\_rows();}
\DoxyCodeLine{82   \textcolor{keyword}{const} uword n\_cols = \mbox{\hyperlink{structA}{A}}.get\_n\_cols();}
\DoxyCodeLine{83   }
\DoxyCodeLine{84   out.set\_size(n\_rows, n\_cols);}
\DoxyCodeLine{85   }
\DoxyCodeLine{86   \textcolor{keyword}{const} eT  k       = X.aux\_out\_eT;}
\DoxyCodeLine{87         eT* out\_mem = out.memptr();}
\DoxyCodeLine{88   }
\DoxyCodeLine{89   \textcolor{keywordflow}{if}(\mbox{\hyperlink{classProxy}{Proxy<T1>::use\_at}} == \textcolor{keyword}{false})}
\DoxyCodeLine{90     \{}
\DoxyCodeLine{91     \textcolor{keyword}{const} uword n\_elem = \mbox{\hyperlink{structA}{A}}.get\_n\_elem();}
\DoxyCodeLine{92   }
\DoxyCodeLine{93     \textcolor{keywordflow}{for}(uword i=0; i<n\_elem; ++i)}
\DoxyCodeLine{94       \{}
\DoxyCodeLine{95       out\_mem[i] = \mbox{\hyperlink{structA}{A}}[i] + k;}
\DoxyCodeLine{96       \}}
\DoxyCodeLine{97     \}}
\DoxyCodeLine{98   \textcolor{keywordflow}{else}}
\DoxyCodeLine{99     \{}
\DoxyCodeLine{100     \textcolor{keywordflow}{for}(uword col=0; col < n\_cols; ++col)}
\DoxyCodeLine{101     \textcolor{keywordflow}{for}(uword row=0; row < n\_rows; ++row)}
\DoxyCodeLine{102       \{}
\DoxyCodeLine{103       *out\_mem = \mbox{\hyperlink{structA}{A}}.at(row,col) + k;  ++out\_mem;}
\DoxyCodeLine{104       \}}
\DoxyCodeLine{105     \}}
\DoxyCodeLine{106   \}}
\DoxyCodeLine{107 }
\DoxyCodeLine{108 }
\DoxyCodeLine{109 }
\DoxyCodeLine{110 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{111 \textcolor{keyword}{inline}}
\DoxyCodeLine{112 \textcolor{keywordtype}{void}}
\DoxyCodeLine{113 op\_cx\_scalar\_minus\_pre::apply}
\DoxyCodeLine{114   (}
\DoxyCodeLine{115         \mbox{\hyperlink{classMat}{Mat}}< \textcolor{keyword}{typename} std::complex<typename T1::pod\_type> >\& out,}
\DoxyCodeLine{116   \textcolor{keyword}{const} \mbox{\hyperlink{classmtOp}{mtOp}}<\textcolor{keyword}{typename} std::complex<typename T1::pod\_type>, T1, \mbox{\hyperlink{classop__cx__scalar__minus__pre}{op\_cx\_scalar\_minus\_pre}}>\& X}
\DoxyCodeLine{117   )}
\DoxyCodeLine{118   \{}
\DoxyCodeLine{119   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{120   }
\DoxyCodeLine{121   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<typename T1::pod\_type> eT;}
\DoxyCodeLine{122   }
\DoxyCodeLine{123   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} \mbox{\hyperlink{structA}{A}}(X.m);}
\DoxyCodeLine{124   }
\DoxyCodeLine{125   \textcolor{keyword}{const} uword n\_rows = \mbox{\hyperlink{structA}{A}}.get\_n\_rows();}
\DoxyCodeLine{126   \textcolor{keyword}{const} uword n\_cols = \mbox{\hyperlink{structA}{A}}.get\_n\_cols();}
\DoxyCodeLine{127   }
\DoxyCodeLine{128   out.set\_size(n\_rows, n\_cols);}
\DoxyCodeLine{129   }
\DoxyCodeLine{130   \textcolor{keyword}{const} eT  k       = X.aux\_out\_eT;}
\DoxyCodeLine{131         eT* out\_mem = out.memptr();}
\DoxyCodeLine{132   }
\DoxyCodeLine{133   \textcolor{keywordflow}{if}(\mbox{\hyperlink{classProxy}{Proxy<T1>::use\_at}} == \textcolor{keyword}{false})}
\DoxyCodeLine{134     \{}
\DoxyCodeLine{135     \textcolor{keyword}{const} uword n\_elem = \mbox{\hyperlink{structA}{A}}.get\_n\_elem();}
\DoxyCodeLine{136   }
\DoxyCodeLine{137     \textcolor{keywordflow}{for}(uword i=0; i<n\_elem; ++i)}
\DoxyCodeLine{138       \{}
\DoxyCodeLine{139       out\_mem[i] = k -\/ \mbox{\hyperlink{structA}{A}}[i];}
\DoxyCodeLine{140       \}}
\DoxyCodeLine{141     \}}
\DoxyCodeLine{142   \textcolor{keywordflow}{else}}
\DoxyCodeLine{143     \{}
\DoxyCodeLine{144     \textcolor{keywordflow}{for}(uword col=0; col < n\_cols; ++col)}
\DoxyCodeLine{145     \textcolor{keywordflow}{for}(uword row=0; row < n\_rows; ++row)}
\DoxyCodeLine{146       \{}
\DoxyCodeLine{147       *out\_mem = k -\/ \mbox{\hyperlink{structA}{A}}.at(row,col);  ++out\_mem;}
\DoxyCodeLine{148       \}}
\DoxyCodeLine{149     \}}
\DoxyCodeLine{150   \}}
\DoxyCodeLine{151 }
\DoxyCodeLine{152 }
\DoxyCodeLine{153 }
\DoxyCodeLine{154 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{155 \textcolor{keyword}{inline}}
\DoxyCodeLine{156 \textcolor{keywordtype}{void}}
\DoxyCodeLine{157 op\_cx\_scalar\_minus\_post::apply}
\DoxyCodeLine{158   (}
\DoxyCodeLine{159         \mbox{\hyperlink{classMat}{Mat}}< \textcolor{keyword}{typename} std::complex<typename T1::pod\_type> >\& out,}
\DoxyCodeLine{160   \textcolor{keyword}{const} \mbox{\hyperlink{classmtOp}{mtOp}}<\textcolor{keyword}{typename} std::complex<typename T1::pod\_type>, T1, \mbox{\hyperlink{classop__cx__scalar__minus__post}{op\_cx\_scalar\_minus\_post}}>\& X}
\DoxyCodeLine{161   )}
\DoxyCodeLine{162   \{}
\DoxyCodeLine{163   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{164   }
\DoxyCodeLine{165   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<typename T1::pod\_type> eT;}
\DoxyCodeLine{166   }
\DoxyCodeLine{167   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} \mbox{\hyperlink{structA}{A}}(X.m);}
\DoxyCodeLine{168   }
\DoxyCodeLine{169   \textcolor{keyword}{const} uword n\_rows = \mbox{\hyperlink{structA}{A}}.get\_n\_rows();}
\DoxyCodeLine{170   \textcolor{keyword}{const} uword n\_cols = \mbox{\hyperlink{structA}{A}}.get\_n\_cols();}
\DoxyCodeLine{171   }
\DoxyCodeLine{172   out.set\_size(n\_rows, n\_cols);}
\DoxyCodeLine{173   }
\DoxyCodeLine{174   \textcolor{keyword}{const} eT  k       = X.aux\_out\_eT;}
\DoxyCodeLine{175         eT* out\_mem = out.memptr();}
\DoxyCodeLine{176   }
\DoxyCodeLine{177   \textcolor{keywordflow}{if}(\mbox{\hyperlink{classProxy}{Proxy<T1>::use\_at}} == \textcolor{keyword}{false})}
\DoxyCodeLine{178     \{}
\DoxyCodeLine{179     \textcolor{keyword}{const} uword n\_elem = \mbox{\hyperlink{structA}{A}}.get\_n\_elem();}
\DoxyCodeLine{180   }
\DoxyCodeLine{181     \textcolor{keywordflow}{for}(uword i=0; i<n\_elem; ++i)}
\DoxyCodeLine{182       \{}
\DoxyCodeLine{183       out\_mem[i] = \mbox{\hyperlink{structA}{A}}[i] -\/ k;}
\DoxyCodeLine{184       \}}
\DoxyCodeLine{185     \}}
\DoxyCodeLine{186   \textcolor{keywordflow}{else}}
\DoxyCodeLine{187     \{}
\DoxyCodeLine{188     \textcolor{keywordflow}{for}(uword col=0; col < n\_cols; ++col)}
\DoxyCodeLine{189     \textcolor{keywordflow}{for}(uword row=0; row < n\_rows; ++row)}
\DoxyCodeLine{190       \{}
\DoxyCodeLine{191       *out\_mem = \mbox{\hyperlink{structA}{A}}.at(row,col) -\/ k;  ++out\_mem;}
\DoxyCodeLine{192       \}}
\DoxyCodeLine{193     \}}
\DoxyCodeLine{194   \}}
\DoxyCodeLine{195 }
\DoxyCodeLine{196 }
\DoxyCodeLine{197 }
\DoxyCodeLine{198 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{199 \textcolor{keyword}{inline}}
\DoxyCodeLine{200 \textcolor{keywordtype}{void}}
\DoxyCodeLine{201 op\_cx\_scalar\_div\_pre::apply}
\DoxyCodeLine{202   (}
\DoxyCodeLine{203         \mbox{\hyperlink{classMat}{Mat}}< \textcolor{keyword}{typename} std::complex<typename T1::pod\_type> >\& out,}
\DoxyCodeLine{204   \textcolor{keyword}{const} \mbox{\hyperlink{classmtOp}{mtOp}}<\textcolor{keyword}{typename} std::complex<typename T1::pod\_type>, T1, \mbox{\hyperlink{classop__cx__scalar__div__pre}{op\_cx\_scalar\_div\_pre}}>\& X}
\DoxyCodeLine{205   )}
\DoxyCodeLine{206   \{}
\DoxyCodeLine{207   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{208   }
\DoxyCodeLine{209   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<typename T1::pod\_type> eT;}
\DoxyCodeLine{210   }
\DoxyCodeLine{211   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} \mbox{\hyperlink{structA}{A}}(X.m);}
\DoxyCodeLine{212   }
\DoxyCodeLine{213   \textcolor{keyword}{const} uword n\_rows = \mbox{\hyperlink{structA}{A}}.get\_n\_rows();}
\DoxyCodeLine{214   \textcolor{keyword}{const} uword n\_cols = \mbox{\hyperlink{structA}{A}}.get\_n\_cols();}
\DoxyCodeLine{215   }
\DoxyCodeLine{216   out.set\_size(n\_rows, n\_cols);}
\DoxyCodeLine{217   }
\DoxyCodeLine{218   \textcolor{keyword}{const} eT  k       = X.aux\_out\_eT;}
\DoxyCodeLine{219         eT* out\_mem = out.memptr();}
\DoxyCodeLine{220   }
\DoxyCodeLine{221   \textcolor{keywordflow}{if}(\mbox{\hyperlink{classProxy}{Proxy<T1>::use\_at}} == \textcolor{keyword}{false})}
\DoxyCodeLine{222     \{}
\DoxyCodeLine{223     \textcolor{keyword}{const} uword n\_elem = \mbox{\hyperlink{structA}{A}}.get\_n\_elem();}
\DoxyCodeLine{224   }
\DoxyCodeLine{225     \textcolor{keywordflow}{for}(uword i=0; i<n\_elem; ++i)}
\DoxyCodeLine{226       \{}
\DoxyCodeLine{227       out\_mem[i] = k / \mbox{\hyperlink{structA}{A}}[i];}
\DoxyCodeLine{228       \}}
\DoxyCodeLine{229     \}}
\DoxyCodeLine{230   \textcolor{keywordflow}{else}}
\DoxyCodeLine{231     \{}
\DoxyCodeLine{232     \textcolor{keywordflow}{for}(uword col=0; col < n\_cols; ++col)}
\DoxyCodeLine{233     \textcolor{keywordflow}{for}(uword row=0; row < n\_rows; ++row)}
\DoxyCodeLine{234       \{}
\DoxyCodeLine{235       *out\_mem = k / \mbox{\hyperlink{structA}{A}}.at(row,col);  ++out\_mem;}
\DoxyCodeLine{236       \}}
\DoxyCodeLine{237     \}}
\DoxyCodeLine{238   \}}
\DoxyCodeLine{239 }
\DoxyCodeLine{240 }
\DoxyCodeLine{241 }
\DoxyCodeLine{242 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{243 \textcolor{keyword}{inline}}
\DoxyCodeLine{244 \textcolor{keywordtype}{void}}
\DoxyCodeLine{245 op\_cx\_scalar\_div\_post::apply}
\DoxyCodeLine{246   (}
\DoxyCodeLine{247         \mbox{\hyperlink{classMat}{Mat}}< \textcolor{keyword}{typename} std::complex<typename T1::pod\_type> >\& out,}
\DoxyCodeLine{248   \textcolor{keyword}{const} \mbox{\hyperlink{classmtOp}{mtOp}}<\textcolor{keyword}{typename} std::complex<typename T1::pod\_type>, T1, \mbox{\hyperlink{classop__cx__scalar__div__post}{op\_cx\_scalar\_div\_post}}>\& X}
\DoxyCodeLine{249   )}
\DoxyCodeLine{250   \{}
\DoxyCodeLine{251   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{252   }
\DoxyCodeLine{253   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<typename T1::pod\_type> eT;}
\DoxyCodeLine{254   }
\DoxyCodeLine{255   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} \mbox{\hyperlink{structA}{A}}(X.m);}
\DoxyCodeLine{256   }
\DoxyCodeLine{257   \textcolor{keyword}{const} uword n\_rows = \mbox{\hyperlink{structA}{A}}.get\_n\_rows();}
\DoxyCodeLine{258   \textcolor{keyword}{const} uword n\_cols = \mbox{\hyperlink{structA}{A}}.get\_n\_cols();}
\DoxyCodeLine{259   }
\DoxyCodeLine{260   out.set\_size(n\_rows, n\_cols);}
\DoxyCodeLine{261   }
\DoxyCodeLine{262   \textcolor{keyword}{const} eT  k       = X.aux\_out\_eT;}
\DoxyCodeLine{263         eT* out\_mem = out.memptr();}
\DoxyCodeLine{264   }
\DoxyCodeLine{265   \textcolor{keywordflow}{if}(\mbox{\hyperlink{classProxy}{Proxy<T1>::use\_at}} == \textcolor{keyword}{false})}
\DoxyCodeLine{266     \{}
\DoxyCodeLine{267     \textcolor{keyword}{const} uword n\_elem = \mbox{\hyperlink{structA}{A}}.get\_n\_elem();}
\DoxyCodeLine{268   }
\DoxyCodeLine{269     \textcolor{keywordflow}{for}(uword i=0; i<n\_elem; ++i)}
\DoxyCodeLine{270       \{}
\DoxyCodeLine{271       out\_mem[i] = \mbox{\hyperlink{structA}{A}}[i] / k;}
\DoxyCodeLine{272       \}}
\DoxyCodeLine{273     \}}
\DoxyCodeLine{274   \textcolor{keywordflow}{else}}
\DoxyCodeLine{275     \{}
\DoxyCodeLine{276     \textcolor{keywordflow}{for}(uword col=0; col < n\_cols; ++col)}
\DoxyCodeLine{277     \textcolor{keywordflow}{for}(uword row=0; row < n\_rows; ++row)}
\DoxyCodeLine{278       \{}
\DoxyCodeLine{279       *out\_mem = \mbox{\hyperlink{structA}{A}}.at(row,col) / k;  ++out\_mem;}
\DoxyCodeLine{280       \}}
\DoxyCodeLine{281     \}}
\DoxyCodeLine{282   \}}
\DoxyCodeLine{283 }
\DoxyCodeLine{284 }
\DoxyCodeLine{285 }
\DoxyCodeLine{286 \textcolor{comment}{//}}
\DoxyCodeLine{287 \textcolor{comment}{//}}
\DoxyCodeLine{288 \textcolor{comment}{//}}
\DoxyCodeLine{289 }
\DoxyCodeLine{290 }
\DoxyCodeLine{291 }
\DoxyCodeLine{292 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{293 \textcolor{keyword}{inline}}
\DoxyCodeLine{294 \textcolor{keywordtype}{void}}
\DoxyCodeLine{295 op\_cx\_scalar\_times::apply}
\DoxyCodeLine{296   (}
\DoxyCodeLine{297            \mbox{\hyperlink{classCube}{Cube}}< \textcolor{keyword}{typename} std::complex<typename T1::pod\_type> >\& out,}
\DoxyCodeLine{298   \textcolor{keyword}{const} \mbox{\hyperlink{classmtOpCube}{mtOpCube}}<\textcolor{keyword}{typename} std::complex<typename T1::pod\_type>, T1, \mbox{\hyperlink{classop__cx__scalar__times}{op\_cx\_scalar\_times}}>\& X}
\DoxyCodeLine{299   )}
\DoxyCodeLine{300   \{}
\DoxyCodeLine{301   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{302   }
\DoxyCodeLine{303   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<typename T1::pod\_type> eT;}
\DoxyCodeLine{304   }
\DoxyCodeLine{305   \textcolor{keyword}{const} \mbox{\hyperlink{classProxyCube}{ProxyCube<T1>}} \mbox{\hyperlink{structA}{A}}(X.m);}
\DoxyCodeLine{306   }
\DoxyCodeLine{307   \textcolor{keyword}{const} uword n\_rows   = \mbox{\hyperlink{structA}{A}}.get\_n\_rows();}
\DoxyCodeLine{308   \textcolor{keyword}{const} uword n\_cols   = \mbox{\hyperlink{structA}{A}}.get\_n\_cols();}
\DoxyCodeLine{309   \textcolor{keyword}{const} uword n\_slices = \mbox{\hyperlink{structA}{A}}.get\_n\_slices();}
\DoxyCodeLine{310   }
\DoxyCodeLine{311   out.set\_size(n\_rows, n\_cols, n\_slices);}
\DoxyCodeLine{312   }
\DoxyCodeLine{313   \textcolor{keyword}{const} eT    k       = X.aux\_out\_eT;}
\DoxyCodeLine{314   \textcolor{keyword}{const} uword n\_elem  = out.n\_elem;}
\DoxyCodeLine{315         eT*   out\_mem = out.memptr();}
\DoxyCodeLine{316   }
\DoxyCodeLine{317   \textcolor{keywordflow}{if}(\mbox{\hyperlink{classProxyCube}{ProxyCube<T1>::use\_at}} == \textcolor{keyword}{false})}
\DoxyCodeLine{318     \{}
\DoxyCodeLine{319     \textcolor{keywordflow}{for}(uword i=0; i<n\_elem; ++i)}
\DoxyCodeLine{320       \{}
\DoxyCodeLine{321       out\_mem[i] = \mbox{\hyperlink{structA}{A}}[i] * k;}
\DoxyCodeLine{322       \}}
\DoxyCodeLine{323     \}}
\DoxyCodeLine{324   \textcolor{keywordflow}{else}}
\DoxyCodeLine{325     \{}
\DoxyCodeLine{326     \textcolor{keywordflow}{for}(uword \mbox{\hyperlink{classslice}{slice}} = 0; \mbox{\hyperlink{classslice}{slice}} < n\_slices; ++\mbox{\hyperlink{classslice}{slice}})}
\DoxyCodeLine{327     \textcolor{keywordflow}{for}(uword col   = 0; col   < n\_cols;   ++col  )}
\DoxyCodeLine{328     \textcolor{keywordflow}{for}(uword row   = 0; row   < n\_rows;   ++row  )}
\DoxyCodeLine{329       \{}
\DoxyCodeLine{330       *out\_mem = \mbox{\hyperlink{structA}{A}}.at(row,col,\mbox{\hyperlink{classslice}{slice}}) * k;  ++out\_mem;}
\DoxyCodeLine{331       \}}
\DoxyCodeLine{332     \}}
\DoxyCodeLine{333   \}}
\DoxyCodeLine{334 }
\DoxyCodeLine{335 }
\DoxyCodeLine{336 }
\DoxyCodeLine{337 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{338 \textcolor{keyword}{inline}}
\DoxyCodeLine{339 \textcolor{keywordtype}{void}}
\DoxyCodeLine{340 op\_cx\_scalar\_plus::apply}
\DoxyCodeLine{341   (}
\DoxyCodeLine{342            \mbox{\hyperlink{classCube}{Cube}}< \textcolor{keyword}{typename} std::complex<typename T1::pod\_type> >\& out,}
\DoxyCodeLine{343   \textcolor{keyword}{const} \mbox{\hyperlink{classmtOpCube}{mtOpCube}}<\textcolor{keyword}{typename} std::complex<typename T1::pod\_type>, T1, \mbox{\hyperlink{classop__cx__scalar__plus}{op\_cx\_scalar\_plus}}>\& X}
\DoxyCodeLine{344   )}
\DoxyCodeLine{345   \{}
\DoxyCodeLine{346   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{347   }
\DoxyCodeLine{348   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<typename T1::pod\_type> eT;}
\DoxyCodeLine{349   }
\DoxyCodeLine{350   \textcolor{keyword}{const} \mbox{\hyperlink{classProxyCube}{ProxyCube<T1>}} \mbox{\hyperlink{structA}{A}}(X.m);}
\DoxyCodeLine{351   }
\DoxyCodeLine{352   \textcolor{keyword}{const} uword n\_rows   = \mbox{\hyperlink{structA}{A}}.get\_n\_rows();}
\DoxyCodeLine{353   \textcolor{keyword}{const} uword n\_cols   = \mbox{\hyperlink{structA}{A}}.get\_n\_cols();}
\DoxyCodeLine{354   \textcolor{keyword}{const} uword n\_slices = \mbox{\hyperlink{structA}{A}}.get\_n\_slices();}
\DoxyCodeLine{355   }
\DoxyCodeLine{356   out.set\_size(n\_rows, n\_cols, n\_slices);}
\DoxyCodeLine{357   }
\DoxyCodeLine{358   \textcolor{keyword}{const} eT    k       = X.aux\_out\_eT;}
\DoxyCodeLine{359   \textcolor{keyword}{const} uword n\_elem  = out.n\_elem;}
\DoxyCodeLine{360         eT*   out\_mem = out.memptr();}
\DoxyCodeLine{361   }
\DoxyCodeLine{362   \textcolor{keywordflow}{if}(\mbox{\hyperlink{classProxyCube}{ProxyCube<T1>::use\_at}} == \textcolor{keyword}{false})}
\DoxyCodeLine{363     \{}
\DoxyCodeLine{364     \textcolor{keywordflow}{for}(uword i=0; i<n\_elem; ++i)}
\DoxyCodeLine{365       \{}
\DoxyCodeLine{366       out\_mem[i] = \mbox{\hyperlink{structA}{A}}[i] + k;}
\DoxyCodeLine{367       \}}
\DoxyCodeLine{368     \}}
\DoxyCodeLine{369   \textcolor{keywordflow}{else}}
\DoxyCodeLine{370     \{}
\DoxyCodeLine{371     \textcolor{keywordflow}{for}(uword \mbox{\hyperlink{classslice}{slice}} = 0; \mbox{\hyperlink{classslice}{slice}} < n\_slices; ++\mbox{\hyperlink{classslice}{slice}})}
\DoxyCodeLine{372     \textcolor{keywordflow}{for}(uword col   = 0; col   < n\_cols;   ++col  )}
\DoxyCodeLine{373     \textcolor{keywordflow}{for}(uword row   = 0; row   < n\_rows;   ++row  )}
\DoxyCodeLine{374       \{}
\DoxyCodeLine{375       *out\_mem = \mbox{\hyperlink{structA}{A}}.at(row,col,\mbox{\hyperlink{classslice}{slice}}) + k;  ++out\_mem;}
\DoxyCodeLine{376       \}}
\DoxyCodeLine{377     \}}
\DoxyCodeLine{378   \}}
\DoxyCodeLine{379 }
\DoxyCodeLine{380 }
\DoxyCodeLine{381 }
\DoxyCodeLine{382 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{383 \textcolor{keyword}{inline}}
\DoxyCodeLine{384 \textcolor{keywordtype}{void}}
\DoxyCodeLine{385 op\_cx\_scalar\_minus\_pre::apply}
\DoxyCodeLine{386   (}
\DoxyCodeLine{387            \mbox{\hyperlink{classCube}{Cube}}< \textcolor{keyword}{typename} std::complex<typename T1::pod\_type> >\& out,}
\DoxyCodeLine{388   \textcolor{keyword}{const} \mbox{\hyperlink{classmtOpCube}{mtOpCube}}<\textcolor{keyword}{typename} std::complex<typename T1::pod\_type>, T1, \mbox{\hyperlink{classop__cx__scalar__minus__pre}{op\_cx\_scalar\_minus\_pre}}>\& X}
\DoxyCodeLine{389   )}
\DoxyCodeLine{390   \{}
\DoxyCodeLine{391   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{392   }
\DoxyCodeLine{393   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<typename T1::pod\_type> eT;}
\DoxyCodeLine{394   }
\DoxyCodeLine{395   \textcolor{keyword}{const} \mbox{\hyperlink{classProxyCube}{ProxyCube<T1>}} \mbox{\hyperlink{structA}{A}}(X.m);}
\DoxyCodeLine{396   }
\DoxyCodeLine{397   \textcolor{keyword}{const} uword n\_rows   = \mbox{\hyperlink{structA}{A}}.get\_n\_rows();}
\DoxyCodeLine{398   \textcolor{keyword}{const} uword n\_cols   = \mbox{\hyperlink{structA}{A}}.get\_n\_cols();}
\DoxyCodeLine{399   \textcolor{keyword}{const} uword n\_slices = \mbox{\hyperlink{structA}{A}}.get\_n\_slices();}
\DoxyCodeLine{400   }
\DoxyCodeLine{401   out.set\_size(n\_rows, n\_cols, n\_slices);}
\DoxyCodeLine{402   }
\DoxyCodeLine{403   \textcolor{keyword}{const} eT    k       = X.aux\_out\_eT;}
\DoxyCodeLine{404   \textcolor{keyword}{const} uword n\_elem  = out.n\_elem;}
\DoxyCodeLine{405         eT*   out\_mem = out.memptr();}
\DoxyCodeLine{406   }
\DoxyCodeLine{407   \textcolor{keywordflow}{if}(\mbox{\hyperlink{classProxyCube}{ProxyCube<T1>::use\_at}} == \textcolor{keyword}{false})}
\DoxyCodeLine{408     \{}
\DoxyCodeLine{409     \textcolor{keywordflow}{for}(uword i=0; i<n\_elem; ++i)}
\DoxyCodeLine{410       \{}
\DoxyCodeLine{411       out\_mem[i] = k -\/ \mbox{\hyperlink{structA}{A}}[i];}
\DoxyCodeLine{412       \}}
\DoxyCodeLine{413     \}}
\DoxyCodeLine{414   \textcolor{keywordflow}{else}}
\DoxyCodeLine{415     \{}
\DoxyCodeLine{416     \textcolor{keywordflow}{for}(uword \mbox{\hyperlink{classslice}{slice}} = 0; \mbox{\hyperlink{classslice}{slice}} < n\_slices; ++\mbox{\hyperlink{classslice}{slice}})}
\DoxyCodeLine{417     \textcolor{keywordflow}{for}(uword col   = 0; col   < n\_cols;   ++col  )}
\DoxyCodeLine{418     \textcolor{keywordflow}{for}(uword row   = 0; row   < n\_rows;   ++row  )}
\DoxyCodeLine{419       \{}
\DoxyCodeLine{420       *out\_mem = k -\/ \mbox{\hyperlink{structA}{A}}.at(row,col,\mbox{\hyperlink{classslice}{slice}});  ++out\_mem;}
\DoxyCodeLine{421       \}}
\DoxyCodeLine{422     \}}
\DoxyCodeLine{423   \}}
\DoxyCodeLine{424 }
\DoxyCodeLine{425 }
\DoxyCodeLine{426 }
\DoxyCodeLine{427 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{428 \textcolor{keyword}{inline}}
\DoxyCodeLine{429 \textcolor{keywordtype}{void}}
\DoxyCodeLine{430 op\_cx\_scalar\_minus\_post::apply}
\DoxyCodeLine{431   (}
\DoxyCodeLine{432            \mbox{\hyperlink{classCube}{Cube}}< \textcolor{keyword}{typename} std::complex<typename T1::pod\_type> >\& out,}
\DoxyCodeLine{433   \textcolor{keyword}{const} \mbox{\hyperlink{classmtOpCube}{mtOpCube}}<\textcolor{keyword}{typename} std::complex<typename T1::pod\_type>, T1, \mbox{\hyperlink{classop__cx__scalar__minus__post}{op\_cx\_scalar\_minus\_post}}>\& X}
\DoxyCodeLine{434   )}
\DoxyCodeLine{435   \{}
\DoxyCodeLine{436   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{437   }
\DoxyCodeLine{438   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<typename T1::pod\_type> eT;}
\DoxyCodeLine{439   }
\DoxyCodeLine{440   \textcolor{keyword}{const} \mbox{\hyperlink{classProxyCube}{ProxyCube<T1>}} \mbox{\hyperlink{structA}{A}}(X.m);}
\DoxyCodeLine{441   }
\DoxyCodeLine{442   \textcolor{keyword}{const} uword n\_rows   = \mbox{\hyperlink{structA}{A}}.get\_n\_rows();}
\DoxyCodeLine{443   \textcolor{keyword}{const} uword n\_cols   = \mbox{\hyperlink{structA}{A}}.get\_n\_cols();}
\DoxyCodeLine{444   \textcolor{keyword}{const} uword n\_slices = \mbox{\hyperlink{structA}{A}}.get\_n\_slices();}
\DoxyCodeLine{445   }
\DoxyCodeLine{446   out.set\_size(n\_rows, n\_cols, n\_slices);}
\DoxyCodeLine{447   }
\DoxyCodeLine{448   \textcolor{keyword}{const} eT    k       = X.aux\_out\_eT;}
\DoxyCodeLine{449   \textcolor{keyword}{const} uword n\_elem  = out.n\_elem;}
\DoxyCodeLine{450         eT*   out\_mem = out.memptr();}
\DoxyCodeLine{451   }
\DoxyCodeLine{452   \textcolor{keywordflow}{if}(\mbox{\hyperlink{classProxyCube}{ProxyCube<T1>::use\_at}} == \textcolor{keyword}{false})}
\DoxyCodeLine{453     \{}
\DoxyCodeLine{454     \textcolor{keywordflow}{for}(uword i=0; i<n\_elem; ++i)}
\DoxyCodeLine{455       \{}
\DoxyCodeLine{456       out\_mem[i] = \mbox{\hyperlink{structA}{A}}[i] -\/ k;}
\DoxyCodeLine{457       \}}
\DoxyCodeLine{458     \}}
\DoxyCodeLine{459   \textcolor{keywordflow}{else}}
\DoxyCodeLine{460     \{}
\DoxyCodeLine{461     \textcolor{keywordflow}{for}(uword \mbox{\hyperlink{classslice}{slice}} = 0; \mbox{\hyperlink{classslice}{slice}} < n\_slices; ++\mbox{\hyperlink{classslice}{slice}})}
\DoxyCodeLine{462     \textcolor{keywordflow}{for}(uword col   = 0; col   < n\_cols;   ++col  )}
\DoxyCodeLine{463     \textcolor{keywordflow}{for}(uword row   = 0; row   < n\_rows;   ++row  )}
\DoxyCodeLine{464       \{}
\DoxyCodeLine{465       *out\_mem = \mbox{\hyperlink{structA}{A}}.at(row,col,\mbox{\hyperlink{classslice}{slice}}) -\/ k;  ++out\_mem;}
\DoxyCodeLine{466       \}}
\DoxyCodeLine{467     \}}
\DoxyCodeLine{468   \}}
\DoxyCodeLine{469 }
\DoxyCodeLine{470 }
\DoxyCodeLine{471 }
\DoxyCodeLine{472 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{473 \textcolor{keyword}{inline}}
\DoxyCodeLine{474 \textcolor{keywordtype}{void}}
\DoxyCodeLine{475 op\_cx\_scalar\_div\_pre::apply}
\DoxyCodeLine{476   (}
\DoxyCodeLine{477            \mbox{\hyperlink{classCube}{Cube}}< \textcolor{keyword}{typename} std::complex<typename T1::pod\_type> >\& out,}
\DoxyCodeLine{478   \textcolor{keyword}{const} \mbox{\hyperlink{classmtOpCube}{mtOpCube}}<\textcolor{keyword}{typename} std::complex<typename T1::pod\_type>, T1, \mbox{\hyperlink{classop__cx__scalar__div__pre}{op\_cx\_scalar\_div\_pre}}>\& X}
\DoxyCodeLine{479   )}
\DoxyCodeLine{480   \{}
\DoxyCodeLine{481   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{482   }
\DoxyCodeLine{483   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<typename T1::pod\_type> eT;}
\DoxyCodeLine{484   }
\DoxyCodeLine{485   \textcolor{keyword}{const} \mbox{\hyperlink{classProxyCube}{ProxyCube<T1>}} \mbox{\hyperlink{structA}{A}}(X.m);}
\DoxyCodeLine{486   }
\DoxyCodeLine{487   \textcolor{keyword}{const} uword n\_rows   = \mbox{\hyperlink{structA}{A}}.get\_n\_rows();}
\DoxyCodeLine{488   \textcolor{keyword}{const} uword n\_cols   = \mbox{\hyperlink{structA}{A}}.get\_n\_cols();}
\DoxyCodeLine{489   \textcolor{keyword}{const} uword n\_slices = \mbox{\hyperlink{structA}{A}}.get\_n\_slices();}
\DoxyCodeLine{490   }
\DoxyCodeLine{491   out.set\_size(n\_rows, n\_cols, n\_slices);}
\DoxyCodeLine{492   }
\DoxyCodeLine{493   \textcolor{keyword}{const} eT    k       = X.aux\_out\_eT;}
\DoxyCodeLine{494   \textcolor{keyword}{const} uword n\_elem  = out.n\_elem;}
\DoxyCodeLine{495         eT*   out\_mem = out.memptr();}
\DoxyCodeLine{496   }
\DoxyCodeLine{497   \textcolor{keywordflow}{if}(\mbox{\hyperlink{classProxyCube}{ProxyCube<T1>::use\_at}} == \textcolor{keyword}{false})}
\DoxyCodeLine{498     \{}
\DoxyCodeLine{499     \textcolor{keywordflow}{for}(uword i=0; i<n\_elem; ++i)}
\DoxyCodeLine{500       \{}
\DoxyCodeLine{501       out\_mem[i] = k / \mbox{\hyperlink{structA}{A}}[i];}
\DoxyCodeLine{502       \}}
\DoxyCodeLine{503     \}}
\DoxyCodeLine{504   \textcolor{keywordflow}{else}}
\DoxyCodeLine{505     \{}
\DoxyCodeLine{506     \textcolor{keywordflow}{for}(uword \mbox{\hyperlink{classslice}{slice}} = 0; \mbox{\hyperlink{classslice}{slice}} < n\_slices; ++\mbox{\hyperlink{classslice}{slice}})}
\DoxyCodeLine{507     \textcolor{keywordflow}{for}(uword col   = 0; col   < n\_cols;   ++col  )}
\DoxyCodeLine{508     \textcolor{keywordflow}{for}(uword row   = 0; row   < n\_rows;   ++row  )}
\DoxyCodeLine{509       \{}
\DoxyCodeLine{510       *out\_mem = k / \mbox{\hyperlink{structA}{A}}.at(row,col,\mbox{\hyperlink{classslice}{slice}});  ++out\_mem;}
\DoxyCodeLine{511       \}}
\DoxyCodeLine{512     \}}
\DoxyCodeLine{513   \}}
\DoxyCodeLine{514 }
\DoxyCodeLine{515 }
\DoxyCodeLine{516 }
\DoxyCodeLine{517 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{518 \textcolor{keyword}{inline}}
\DoxyCodeLine{519 \textcolor{keywordtype}{void}}
\DoxyCodeLine{520 op\_cx\_scalar\_div\_post::apply}
\DoxyCodeLine{521   (}
\DoxyCodeLine{522            \mbox{\hyperlink{classCube}{Cube}}< \textcolor{keyword}{typename} std::complex<typename T1::pod\_type> >\& out,}
\DoxyCodeLine{523   \textcolor{keyword}{const} \mbox{\hyperlink{classmtOpCube}{mtOpCube}}<\textcolor{keyword}{typename} std::complex<typename T1::pod\_type>, T1, \mbox{\hyperlink{classop__cx__scalar__div__post}{op\_cx\_scalar\_div\_post}}>\& X}
\DoxyCodeLine{524   )}
\DoxyCodeLine{525   \{}
\DoxyCodeLine{526   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{527   }
\DoxyCodeLine{528   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<typename T1::pod\_type> eT;}
\DoxyCodeLine{529   }
\DoxyCodeLine{530   \textcolor{keyword}{const} \mbox{\hyperlink{classProxyCube}{ProxyCube<T1>}} \mbox{\hyperlink{structA}{A}}(X.m);}
\DoxyCodeLine{531   }
\DoxyCodeLine{532   \textcolor{keyword}{const} uword n\_rows   = \mbox{\hyperlink{structA}{A}}.get\_n\_rows();}
\DoxyCodeLine{533   \textcolor{keyword}{const} uword n\_cols   = \mbox{\hyperlink{structA}{A}}.get\_n\_cols();}
\DoxyCodeLine{534   \textcolor{keyword}{const} uword n\_slices = \mbox{\hyperlink{structA}{A}}.get\_n\_slices();}
\DoxyCodeLine{535   }
\DoxyCodeLine{536   out.set\_size(n\_rows, n\_cols, n\_slices);}
\DoxyCodeLine{537   }
\DoxyCodeLine{538   \textcolor{keyword}{const} eT    k       = X.aux\_out\_eT;}
\DoxyCodeLine{539   \textcolor{keyword}{const} uword n\_elem  = out.n\_elem;}
\DoxyCodeLine{540         eT*   out\_mem = out.memptr();}
\DoxyCodeLine{541   }
\DoxyCodeLine{542   \textcolor{keywordflow}{if}(\mbox{\hyperlink{classProxyCube}{ProxyCube<T1>::use\_at}} == \textcolor{keyword}{false})}
\DoxyCodeLine{543     \{}
\DoxyCodeLine{544     \textcolor{keywordflow}{for}(uword i=0; i<n\_elem; ++i)}
\DoxyCodeLine{545       \{}
\DoxyCodeLine{546       out\_mem[i] = \mbox{\hyperlink{structA}{A}}[i] / k;}
\DoxyCodeLine{547       \}}
\DoxyCodeLine{548     \}}
\DoxyCodeLine{549   \textcolor{keywordflow}{else}}
\DoxyCodeLine{550     \{}
\DoxyCodeLine{551     \textcolor{keywordflow}{for}(uword \mbox{\hyperlink{classslice}{slice}} = 0; \mbox{\hyperlink{classslice}{slice}} < n\_slices; ++\mbox{\hyperlink{classslice}{slice}})}
\DoxyCodeLine{552     \textcolor{keywordflow}{for}(uword col   = 0; col   < n\_cols;   ++col  )}
\DoxyCodeLine{553     \textcolor{keywordflow}{for}(uword row   = 0; row   < n\_rows;   ++row  )}
\DoxyCodeLine{554       \{}
\DoxyCodeLine{555       *out\_mem = \mbox{\hyperlink{structA}{A}}.at(row,col,\mbox{\hyperlink{classslice}{slice}}) / k;  ++out\_mem;}
\DoxyCodeLine{556       \}}
\DoxyCodeLine{557     \}}
\DoxyCodeLine{558   \}}
\DoxyCodeLine{559 }
\DoxyCodeLine{560 }
\DoxyCodeLine{561 }

\end{DoxyCode}
