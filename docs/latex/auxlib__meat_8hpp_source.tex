\hypertarget{auxlib__meat_8hpp_source}{}\doxysection{auxlib\+\_\+meat.\+hpp}
\label{auxlib__meat_8hpp_source}\index{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/auxlib\_meat.hpp@{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/auxlib\_meat.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008-\/2016 Conrad Sanderson (http://conradsanderson.id.au)}}
\DoxyCodeLine{2 \textcolor{comment}{// Copyright 2008-\/2016 National ICT Australia (NICTA)}}
\DoxyCodeLine{3 \textcolor{comment}{// }}
\DoxyCodeLine{4 \textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{5 \textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{6 \textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{7 \textcolor{comment}{// http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{8 \textcolor{comment}{// }}
\DoxyCodeLine{9 \textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{10 \textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{11 \textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{12 \textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{13 \textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{14 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{19 }
\DoxyCodeLine{20 }
\DoxyCodeLine{21 }
\DoxyCodeLine{22 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{23 \textcolor{keyword}{inline}}
\DoxyCodeLine{24 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{25 auxlib::inv(\mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}})}
\DoxyCodeLine{26   \{}
\DoxyCodeLine{27   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{28   }
\DoxyCodeLine{29   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty())  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{30   }
\DoxyCodeLine{31 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_ATLAS)}}
\DoxyCodeLine{32     \{}
\DoxyCodeLine{33     arma\_debug\_assert\_atlas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{34     }
\DoxyCodeLine{35     \mbox{\hyperlink{classpodarray}{podarray<int>}} ipiv(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{36     }
\DoxyCodeLine{37     \textcolor{keywordtype}{int} info = 0;}
\DoxyCodeLine{38     }
\DoxyCodeLine{39     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}atlas::clapack\_getrf()"{}});}
\DoxyCodeLine{40     info = atlas::clapack\_getrf(atlas::CblasColMajor, \mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structA}{A}}.memptr(), \mbox{\hyperlink{structA}{A}}.n\_rows, ipiv.memptr());}
\DoxyCodeLine{41     }
\DoxyCodeLine{42     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{43     }
\DoxyCodeLine{44     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}atlas::clapack\_getri()"{}});}
\DoxyCodeLine{45     info = atlas::clapack\_getri(atlas::CblasColMajor, \mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.memptr(), \mbox{\hyperlink{structA}{A}}.n\_rows, ipiv.memptr());}
\DoxyCodeLine{46     }
\DoxyCodeLine{47     \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{48     \}}
\DoxyCodeLine{49 \textcolor{preprocessor}{  \#elif defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{50     \{}
\DoxyCodeLine{51     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{52     }
\DoxyCodeLine{53     blas\_int n     = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{54     blas\_int lda   = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{55     blas\_int lwork = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(blas\_int(podarray\_prealloc\_n\_elem::val), n);}
\DoxyCodeLine{56     blas\_int info  = 0;}
\DoxyCodeLine{57     }
\DoxyCodeLine{58     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} ipiv(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{59     }
\DoxyCodeLine{60     \textcolor{keywordflow}{if}(n > 16)}
\DoxyCodeLine{61       \{}
\DoxyCodeLine{62       eT        work\_query[2];}
\DoxyCodeLine{63       blas\_int lwork\_query = -\/1;}
\DoxyCodeLine{64       }
\DoxyCodeLine{65       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::getri()"{}});}
\DoxyCodeLine{66       lapack::getri(\&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, ipiv.memptr(), \&work\_query[0], \&lwork\_query, \&info);}
\DoxyCodeLine{67       }
\DoxyCodeLine{68       \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{69       }
\DoxyCodeLine{70       blas\_int lwork\_proposed = \textcolor{keyword}{static\_cast<}blas\_int\textcolor{keyword}{>}( \mbox{\hyperlink{classaccess_a9687cee4d2be0fe591998d6f5c6d0849}{access::tmp\_real}}(work\_query[0]) );}
\DoxyCodeLine{71       }
\DoxyCodeLine{72       lwork = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(lwork\_proposed, lwork);}
\DoxyCodeLine{73       \}}
\DoxyCodeLine{74     }
\DoxyCodeLine{75     \mbox{\hyperlink{classpodarray}{podarray<eT>}} work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork) );}
\DoxyCodeLine{76     }
\DoxyCodeLine{77     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::getrf()"{}});}
\DoxyCodeLine{78     lapack::getrf(\&n, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, ipiv.memptr(), \&info);}
\DoxyCodeLine{79     }
\DoxyCodeLine{80     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{81     }
\DoxyCodeLine{82     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::getri()"{}});}
\DoxyCodeLine{83     lapack::getri(\&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, ipiv.memptr(), work.memptr(), \&lwork, \&info);}
\DoxyCodeLine{84     }
\DoxyCodeLine{85     \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{86     \}}
\DoxyCodeLine{87 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{88     \{}
\DoxyCodeLine{89     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{90     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}inv(): use of ATLAS or LAPACK must be enabled"{}});}
\DoxyCodeLine{91     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{92     \}}
\DoxyCodeLine{93 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{94   \}}
\DoxyCodeLine{95 }
\DoxyCodeLine{96 }
\DoxyCodeLine{97 }
\DoxyCodeLine{98 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{99 \textcolor{keyword}{inline}}
\DoxyCodeLine{100 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{101 auxlib::inv(\mbox{\hyperlink{classMat}{Mat<eT>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X)}
\DoxyCodeLine{102   \{}
\DoxyCodeLine{103   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{104   }
\DoxyCodeLine{105   out = X;}
\DoxyCodeLine{106   }
\DoxyCodeLine{107   \textcolor{keywordflow}{return} auxlib::inv(out);}
\DoxyCodeLine{108   \}}
\DoxyCodeLine{109 }
\DoxyCodeLine{110 }
\DoxyCodeLine{111 }
\DoxyCodeLine{112 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{113 \textcolor{keyword}{inline}}
\DoxyCodeLine{114 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{115 auxlib::inv\_tr(\mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} uword layout)}
\DoxyCodeLine{116   \{}
\DoxyCodeLine{117   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{118   }
\DoxyCodeLine{119 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{120     \{}
\DoxyCodeLine{121     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty())  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{122   }
\DoxyCodeLine{123     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{124     }
\DoxyCodeLine{125     \textcolor{keywordtype}{char}     uplo = (layout == 0) ? \textcolor{charliteral}{'U'} : \textcolor{charliteral}{'L'};}
\DoxyCodeLine{126     \textcolor{keywordtype}{char}     diag = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{127     blas\_int n    = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{128     blas\_int info = 0;}
\DoxyCodeLine{129     }
\DoxyCodeLine{130     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::trtri()"{}});}
\DoxyCodeLine{131     lapack::trtri(\&uplo, \&diag, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&n, \&info);}
\DoxyCodeLine{132     }
\DoxyCodeLine{133     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{134     }
\DoxyCodeLine{135     \textcolor{keywordflow}{if}(layout == 0)}
\DoxyCodeLine{136       \{}
\DoxyCodeLine{137       \mbox{\hyperlink{structA}{A}} = trimatu(\mbox{\hyperlink{structA}{A}});  \textcolor{comment}{// upper triangular}}
\DoxyCodeLine{138       \}}
\DoxyCodeLine{139     \textcolor{keywordflow}{else}}
\DoxyCodeLine{140       \{}
\DoxyCodeLine{141       \mbox{\hyperlink{structA}{A}} = trimatl(\mbox{\hyperlink{structA}{A}});  \textcolor{comment}{// lower triangular}}
\DoxyCodeLine{142       \}}
\DoxyCodeLine{143     }
\DoxyCodeLine{144     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{145     \}}
\DoxyCodeLine{146 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{147     \{}
\DoxyCodeLine{148     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{149     arma\_ignore(layout);}
\DoxyCodeLine{150     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}inv(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{151     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{152     \}}
\DoxyCodeLine{153 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{154   \}}
\DoxyCodeLine{155 }
\DoxyCodeLine{156 }
\DoxyCodeLine{157 }
\DoxyCodeLine{158 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{159 \textcolor{keyword}{inline}}
\DoxyCodeLine{160 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{161 auxlib::inv\_sympd(\mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}})}
\DoxyCodeLine{162   \{}
\DoxyCodeLine{163   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{164   }
\DoxyCodeLine{165   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty())  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{166   }
\DoxyCodeLine{167 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_ATLAS)}}
\DoxyCodeLine{168     \{}
\DoxyCodeLine{169     arma\_debug\_assert\_atlas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{170     }
\DoxyCodeLine{171     \textcolor{keywordtype}{int} info = 0;}
\DoxyCodeLine{172     }
\DoxyCodeLine{173     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}atlas::clapack\_potrf()"{}});}
\DoxyCodeLine{174     info = atlas::clapack\_potrf(atlas::CblasColMajor, atlas::CblasLower, \mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.memptr(), \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{175     }
\DoxyCodeLine{176     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{177     }
\DoxyCodeLine{178     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}atlas::clapack\_potri()"{}});}
\DoxyCodeLine{179     info = atlas::clapack\_potri(atlas::CblasColMajor, atlas::CblasLower, \mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.memptr(), \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{180     }
\DoxyCodeLine{181     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{182     }
\DoxyCodeLine{183     \mbox{\hyperlink{structA}{A}} = symmatl(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{184     }
\DoxyCodeLine{185     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{186     \}}
\DoxyCodeLine{187 \textcolor{preprocessor}{  \#elif defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{188     \{}
\DoxyCodeLine{189     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{190     }
\DoxyCodeLine{191     \textcolor{keywordtype}{char}     uplo = \textcolor{charliteral}{'L'};}
\DoxyCodeLine{192     blas\_int n    = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{193     blas\_int info = 0;}
\DoxyCodeLine{194     }
\DoxyCodeLine{195     \textcolor{comment}{// NOTE: for complex matrices, zpotrf() assumes the matrix is hermitian (not simply symmetric)}}
\DoxyCodeLine{196     }
\DoxyCodeLine{197     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::potrf()"{}});}
\DoxyCodeLine{198     lapack::potrf(\&uplo, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&n, \&info);}
\DoxyCodeLine{199     }
\DoxyCodeLine{200     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{201     }
\DoxyCodeLine{202     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::potri()"{}});}
\DoxyCodeLine{203     lapack::potri(\&uplo, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&n, \&info);}
\DoxyCodeLine{204     }
\DoxyCodeLine{205     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{206     }
\DoxyCodeLine{207     \mbox{\hyperlink{structA}{A}} = symmatl(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{208     }
\DoxyCodeLine{209     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{210     \}}
\DoxyCodeLine{211 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{212     \{}
\DoxyCodeLine{213     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{214     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}inv\_sympd(): use of ATLAS or LAPACK must be enabled"{}});}
\DoxyCodeLine{215     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{216     \}}
\DoxyCodeLine{217 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{218   \}}
\DoxyCodeLine{219 }
\DoxyCodeLine{220 }
\DoxyCodeLine{221 }
\DoxyCodeLine{222 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{223 \textcolor{keyword}{inline}}
\DoxyCodeLine{224 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{225 auxlib::inv\_sympd(\mbox{\hyperlink{classMat}{Mat<eT>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X)}
\DoxyCodeLine{226   \{}
\DoxyCodeLine{227   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{228   }
\DoxyCodeLine{229   out = X;}
\DoxyCodeLine{230   }
\DoxyCodeLine{231   \textcolor{keywordflow}{return} auxlib::inv\_sympd(out);}
\DoxyCodeLine{232   \}}
\DoxyCodeLine{233 }
\DoxyCodeLine{234 }
\DoxyCodeLine{235 }
\DoxyCodeLine{236 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{237 \textcolor{keyword}{inline}}
\DoxyCodeLine{238 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{239 auxlib::inv\_sympd\_rcond(\mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} eT rcond\_threshold)}
\DoxyCodeLine{240   \{}
\DoxyCodeLine{241   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{242   }
\DoxyCodeLine{243   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty())  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{244   }
\DoxyCodeLine{245 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{246     \{}
\DoxyCodeLine{247     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} get\_pod\_type<eT>::result T;}
\DoxyCodeLine{248     }
\DoxyCodeLine{249     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{250     }
\DoxyCodeLine{251     \textcolor{keywordtype}{char}     norm\_id  = \textcolor{charliteral}{'1'};}
\DoxyCodeLine{252     \textcolor{keywordtype}{char}     uplo     = \textcolor{charliteral}{'L'};}
\DoxyCodeLine{253     blas\_int n        = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{254     blas\_int info     = 0;}
\DoxyCodeLine{255     T        norm\_val = T(0);}
\DoxyCodeLine{256     }
\DoxyCodeLine{257     \mbox{\hyperlink{classpodarray}{podarray<T>}} work(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{258     }
\DoxyCodeLine{259     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::lansy()"{}});}
\DoxyCodeLine{260     norm\_val = lapack::lansy(\&norm\_id, \&uplo, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&n, work.memptr());}
\DoxyCodeLine{261     }
\DoxyCodeLine{262     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::potrf()"{}});}
\DoxyCodeLine{263     lapack::potrf(\&uplo, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&n, \&info);}
\DoxyCodeLine{264     }
\DoxyCodeLine{265     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{266     }
\DoxyCodeLine{267     \textcolor{keyword}{const} T rcond = auxlib::lu\_rcond\_sympd<T>(\mbox{\hyperlink{structA}{A}}, norm\_val);}
\DoxyCodeLine{268     }
\DoxyCodeLine{269     \textcolor{keywordflow}{if}(rcond < rcond\_threshold)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{270     }
\DoxyCodeLine{271     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::potri()"{}});}
\DoxyCodeLine{272     lapack::potri(\&uplo, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&n, \&info);}
\DoxyCodeLine{273     }
\DoxyCodeLine{274     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{275     }
\DoxyCodeLine{276     \mbox{\hyperlink{structA}{A}} = symmatl(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{277     }
\DoxyCodeLine{278     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{279     \}}
\DoxyCodeLine{280 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{281     \{}
\DoxyCodeLine{282     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{283     arma\_ignore(rcond\_threshold);}
\DoxyCodeLine{284     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}inv\_sympd\_rcond(): use LAPACK must be enabled"{}});}
\DoxyCodeLine{285     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{286     \}}
\DoxyCodeLine{287 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{288   \}}
\DoxyCodeLine{289 }
\DoxyCodeLine{290 }
\DoxyCodeLine{291 }
\DoxyCodeLine{292 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{293 \textcolor{keyword}{inline}}
\DoxyCodeLine{294 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{295 auxlib::inv\_sympd\_rcond(\mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} T rcond\_threshold)}
\DoxyCodeLine{296   \{}
\DoxyCodeLine{297   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{298   }
\DoxyCodeLine{299   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty())  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{300   }
\DoxyCodeLine{301 \textcolor{preprocessor}{  \#if defined(ARMA\_CRIPPLED\_LAPACK)}}
\DoxyCodeLine{302     \{}
\DoxyCodeLine{303     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{304     arma\_ignore(rcond\_threshold);}
\DoxyCodeLine{305     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{306     \}}
\DoxyCodeLine{307 \textcolor{preprocessor}{  \#elif defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{308     \{}
\DoxyCodeLine{309     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{310     }
\DoxyCodeLine{311     \textcolor{keywordtype}{char}     norm\_id  = \textcolor{charliteral}{'1'};}
\DoxyCodeLine{312     \textcolor{keywordtype}{char}     uplo     = \textcolor{charliteral}{'L'};}
\DoxyCodeLine{313     blas\_int n        = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{314     blas\_int info     = 0;}
\DoxyCodeLine{315     T        norm\_val = T(0);}
\DoxyCodeLine{316     }
\DoxyCodeLine{317     \mbox{\hyperlink{classpodarray}{podarray<T>}} work(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{318     }
\DoxyCodeLine{319     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::lanhe()"{}});}
\DoxyCodeLine{320     norm\_val = lapack::lanhe(\&norm\_id, \&uplo, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&n, work.memptr());}
\DoxyCodeLine{321     }
\DoxyCodeLine{322     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::potrf()"{}});}
\DoxyCodeLine{323     lapack::potrf(\&uplo, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&n, \&info);}
\DoxyCodeLine{324     }
\DoxyCodeLine{325     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{326     }
\DoxyCodeLine{327     \textcolor{keyword}{const} T rcond = auxlib::lu\_rcond\_sympd<T>(\mbox{\hyperlink{structA}{A}}, norm\_val);}
\DoxyCodeLine{328     }
\DoxyCodeLine{329     \textcolor{keywordflow}{if}(rcond < rcond\_threshold)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{330     }
\DoxyCodeLine{331     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::potri()"{}});}
\DoxyCodeLine{332     lapack::potri(\&uplo, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&n, \&info);}
\DoxyCodeLine{333     }
\DoxyCodeLine{334     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{335     }
\DoxyCodeLine{336     \mbox{\hyperlink{structA}{A}} = symmatl(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{337     }
\DoxyCodeLine{338     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{339     \}}
\DoxyCodeLine{340 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{341     \{}
\DoxyCodeLine{342     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{343     arma\_ignore(rcond\_threshold);}
\DoxyCodeLine{344     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}inv\_sympd\_rcond(): use LAPACK must be enabled"{}});}
\DoxyCodeLine{345     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{346     \}}
\DoxyCodeLine{347 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{348   \}}
\DoxyCodeLine{349 }
\DoxyCodeLine{350 }
\DoxyCodeLine{351 }
\DoxyCodeLine{353 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{354 \textcolor{keyword}{inline}}
\DoxyCodeLine{355 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{356 \mbox{\hyperlink{group__auxlib_gadbec9e2bf7e46544c38212f619228391}{auxlib::det}}(eT\& out\_val, \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}})}
\DoxyCodeLine{357   \{}
\DoxyCodeLine{358   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{359   }
\DoxyCodeLine{360   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty())  \{ out\_val = eT(1); \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{361   }
\DoxyCodeLine{362 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_ATLAS)}}
\DoxyCodeLine{363     \{}
\DoxyCodeLine{364     arma\_debug\_assert\_atlas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{365     }
\DoxyCodeLine{366     \mbox{\hyperlink{classpodarray}{podarray<int>}} ipiv(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{367     }
\DoxyCodeLine{368     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}atlas::clapack\_getrf()"{}});}
\DoxyCodeLine{369     \textcolor{keyword}{const} \textcolor{keywordtype}{int} info = atlas::clapack\_getrf(atlas::CblasColMajor, \mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structA}{A}}.memptr(), \mbox{\hyperlink{structA}{A}}.n\_rows, ipiv.memptr());}
\DoxyCodeLine{370     }
\DoxyCodeLine{371     \textcolor{keywordflow}{if}(info < 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{372     }
\DoxyCodeLine{373     \textcolor{comment}{// on output A appears to be L+U\_alt, where U\_alt is U with the main diagonal set to zero}}
\DoxyCodeLine{374     eT val = \mbox{\hyperlink{structA}{A}}.at(0,0);}
\DoxyCodeLine{375     \textcolor{keywordflow}{for}(uword i=1; i < \mbox{\hyperlink{structA}{A}}.n\_rows; ++i)  \{ val *= \mbox{\hyperlink{structA}{A}}.at(i,i); \}}
\DoxyCodeLine{376     }
\DoxyCodeLine{377     \textcolor{keywordtype}{int} sign = +1;}
\DoxyCodeLine{378     \textcolor{keywordflow}{for}(uword i=0; i < \mbox{\hyperlink{structA}{A}}.n\_rows; ++i)}
\DoxyCodeLine{379       \{}
\DoxyCodeLine{380       \textcolor{comment}{// NOTE: no adjustment required, as the clapack version of getrf() assumes counting from 0}}
\DoxyCodeLine{381       \textcolor{keywordflow}{if}( \textcolor{keywordtype}{int}(i) != ipiv.\mbox{\hyperlink{classpodarray_a3235dffb0bca72b5aa2f6f7d2c696601}{mem}}[i] )  \{ sign *= -\/1; \}}
\DoxyCodeLine{382       \}}
\DoxyCodeLine{383     }
\DoxyCodeLine{384     out\_val = (sign < 0) ? eT(-\/val) : eT(val);}
\DoxyCodeLine{385     }
\DoxyCodeLine{386     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{387     \}}
\DoxyCodeLine{388 \textcolor{preprocessor}{  \#elif defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{389     \{}
\DoxyCodeLine{390     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{391     }
\DoxyCodeLine{392     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} ipiv(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{393     }
\DoxyCodeLine{394     blas\_int info   = 0;}
\DoxyCodeLine{395     blas\_int n\_rows = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{396     blas\_int n\_cols = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{397     }
\DoxyCodeLine{398     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::getrf()"{}});}
\DoxyCodeLine{399     lapack::getrf(\&n\_rows, \&n\_cols, \mbox{\hyperlink{structA}{A}}.memptr(), \&n\_rows, ipiv.memptr(), \&info);}
\DoxyCodeLine{400     }
\DoxyCodeLine{401     \textcolor{keywordflow}{if}(info < 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{402     }
\DoxyCodeLine{403     \textcolor{comment}{// on output A appears to be L+U\_alt, where U\_alt is U with the main diagonal set to zero}}
\DoxyCodeLine{404     eT val = \mbox{\hyperlink{structA}{A}}.at(0,0);}
\DoxyCodeLine{405     \textcolor{keywordflow}{for}(uword i=1; i < \mbox{\hyperlink{structA}{A}}.n\_rows; ++i)  \{ val *= \mbox{\hyperlink{structA}{A}}.at(i,i); \}}
\DoxyCodeLine{406     }
\DoxyCodeLine{407     blas\_int sign = +1;}
\DoxyCodeLine{408     \textcolor{keywordflow}{for}(uword i=0; i < \mbox{\hyperlink{structA}{A}}.n\_rows; ++i)}
\DoxyCodeLine{409       \{}
\DoxyCodeLine{410       \textcolor{comment}{// NOTE: adjustment of -\/1 is required as Fortran counts from 1}}
\DoxyCodeLine{411       \textcolor{keywordflow}{if}( blas\_int(i) != (ipiv.\mbox{\hyperlink{classpodarray_a3235dffb0bca72b5aa2f6f7d2c696601}{mem}}[i] -\/ 1) )  \{ sign *= -\/1; \}}
\DoxyCodeLine{412       \}}
\DoxyCodeLine{413     }
\DoxyCodeLine{414     out\_val = (sign < 0) ? eT(-\/val) : eT(val);}
\DoxyCodeLine{415     }
\DoxyCodeLine{416     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{417     \}}
\DoxyCodeLine{418 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{419     \{}
\DoxyCodeLine{420     arma\_ignore(out\_val);}
\DoxyCodeLine{421     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{422     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}det(): use of ATLAS or LAPACK must be enabled"{}});}
\DoxyCodeLine{423     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{424     \}}
\DoxyCodeLine{425 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{426   \}}
\DoxyCodeLine{427 }
\DoxyCodeLine{428 }
\DoxyCodeLine{429 }
\DoxyCodeLine{431 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{432 \textcolor{keyword}{inline}}
\DoxyCodeLine{433 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{434 \mbox{\hyperlink{group__auxlib_ga74d8fc5c3a1eb344df9c1053f90e1005}{auxlib::log\_det}}(eT\& out\_val, \textcolor{keyword}{typename} get\_pod\_type<eT>::result\& out\_sign, \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}})}
\DoxyCodeLine{435   \{}
\DoxyCodeLine{436   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{437   }
\DoxyCodeLine{438   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} get\_pod\_type<eT>::result T;}
\DoxyCodeLine{439   }
\DoxyCodeLine{440   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty())}
\DoxyCodeLine{441     \{}
\DoxyCodeLine{442     out\_val  = eT(0);}
\DoxyCodeLine{443     out\_sign =  T(1);}
\DoxyCodeLine{444     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{445     \}}
\DoxyCodeLine{446     }
\DoxyCodeLine{447 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_ATLAS)}}
\DoxyCodeLine{448     \{}
\DoxyCodeLine{449     arma\_debug\_assert\_atlas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{450     }
\DoxyCodeLine{451     \mbox{\hyperlink{classpodarray}{podarray<int>}} ipiv(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{452     }
\DoxyCodeLine{453     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}atlas::clapack\_getrf()"{}});}
\DoxyCodeLine{454     \textcolor{keyword}{const} \textcolor{keywordtype}{int} info = atlas::clapack\_getrf(atlas::CblasColMajor, \mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structA}{A}}.memptr(), \mbox{\hyperlink{structA}{A}}.n\_rows, ipiv.memptr());}
\DoxyCodeLine{455     }
\DoxyCodeLine{456     \textcolor{keywordflow}{if}(info < 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{457     }
\DoxyCodeLine{458     \textcolor{comment}{// on output A appears to be L+U\_alt, where U\_alt is U with the main diagonal set to zero}}
\DoxyCodeLine{459     }
\DoxyCodeLine{460     sword sign = (\mbox{\hyperlink{structis__cx}{is\_cx<eT>::no}}) ? ( (\mbox{\hyperlink{classaccess_a9687cee4d2be0fe591998d6f5c6d0849}{access::tmp\_real}}( \mbox{\hyperlink{structA}{A}}.at(0,0) ) < T(0)) ? -\/1 : +1 ) : +1;}
\DoxyCodeLine{461     eT    val  = (\mbox{\hyperlink{structis__cx}{is\_cx<eT>::no}}) ? std::log( (\mbox{\hyperlink{classaccess_a9687cee4d2be0fe591998d6f5c6d0849}{access::tmp\_real}}( \mbox{\hyperlink{structA}{A}}.at(0,0) ) < T(0)) ? \mbox{\hyperlink{structA}{A}}.at(0,0)*T(-\/1) : \mbox{\hyperlink{structA}{A}}.at(0,0) ) : std::log( \mbox{\hyperlink{structA}{A}}.at(0,0) );}
\DoxyCodeLine{462     }
\DoxyCodeLine{463     \textcolor{keywordflow}{for}(uword i=1; i < \mbox{\hyperlink{structA}{A}}.n\_rows; ++i)}
\DoxyCodeLine{464       \{}
\DoxyCodeLine{465       \textcolor{keyword}{const} eT x = \mbox{\hyperlink{structA}{A}}.at(i,i);}
\DoxyCodeLine{466       }
\DoxyCodeLine{467       sign *= (\mbox{\hyperlink{structis__cx}{is\_cx<eT>::no}}) ? ( (\mbox{\hyperlink{classaccess_a9687cee4d2be0fe591998d6f5c6d0849}{access::tmp\_real}}(x) < T(0)) ? -\/1 : +1 ) : +1;}
\DoxyCodeLine{468       val  += (\mbox{\hyperlink{structis__cx}{is\_cx<eT>::no}}) ? std::log( (\mbox{\hyperlink{classaccess_a9687cee4d2be0fe591998d6f5c6d0849}{access::tmp\_real}}(x) < T(0)) ? x*T(-\/1) : x ) : std::log(x);}
\DoxyCodeLine{469       \}}
\DoxyCodeLine{470     }
\DoxyCodeLine{471     \textcolor{keywordflow}{for}(uword i=0; i < \mbox{\hyperlink{structA}{A}}.n\_rows; ++i)}
\DoxyCodeLine{472       \{}
\DoxyCodeLine{473       \textcolor{keywordflow}{if}( \textcolor{keywordtype}{int}(i) != ipiv.\mbox{\hyperlink{classpodarray_a3235dffb0bca72b5aa2f6f7d2c696601}{mem}}[i] )  \textcolor{comment}{// NOTE: no adjustment required, as the clapack version of getrf() assumes counting from 0}}
\DoxyCodeLine{474         \{}
\DoxyCodeLine{475         sign *= -\/1;}
\DoxyCodeLine{476         \}}
\DoxyCodeLine{477       \}}
\DoxyCodeLine{478     }
\DoxyCodeLine{479     out\_val  = val;}
\DoxyCodeLine{480     out\_sign = T(sign);}
\DoxyCodeLine{481     }
\DoxyCodeLine{482     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{483     \}}
\DoxyCodeLine{484 \textcolor{preprocessor}{  \#elif defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{485     \{}
\DoxyCodeLine{486     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{487     }
\DoxyCodeLine{488     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} ipiv(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{489     }
\DoxyCodeLine{490     blas\_int info   = 0;}
\DoxyCodeLine{491     blas\_int n\_rows = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{492     blas\_int n\_cols = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{493     }
\DoxyCodeLine{494     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::getrf()"{}});}
\DoxyCodeLine{495     lapack::getrf(\&n\_rows, \&n\_cols, \mbox{\hyperlink{structA}{A}}.memptr(), \&n\_rows, ipiv.memptr(), \&info);}
\DoxyCodeLine{496     }
\DoxyCodeLine{497     \textcolor{keywordflow}{if}(info < 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{498     }
\DoxyCodeLine{499     \textcolor{comment}{// on output A appears to be L+U\_alt, where U\_alt is U with the main diagonal set to zero}}
\DoxyCodeLine{500     }
\DoxyCodeLine{501     sword sign = (\mbox{\hyperlink{structis__cx}{is\_cx<eT>::no}}) ? ( (\mbox{\hyperlink{classaccess_a9687cee4d2be0fe591998d6f5c6d0849}{access::tmp\_real}}( \mbox{\hyperlink{structA}{A}}.at(0,0) ) < T(0)) ? -\/1 : +1 ) : +1;}
\DoxyCodeLine{502     eT    val  = (\mbox{\hyperlink{structis__cx}{is\_cx<eT>::no}}) ? std::log( (\mbox{\hyperlink{classaccess_a9687cee4d2be0fe591998d6f5c6d0849}{access::tmp\_real}}( \mbox{\hyperlink{structA}{A}}.at(0,0) ) < T(0)) ? \mbox{\hyperlink{structA}{A}}.at(0,0)*T(-\/1) : \mbox{\hyperlink{structA}{A}}.at(0,0) ) : std::log( \mbox{\hyperlink{structA}{A}}.at(0,0) );}
\DoxyCodeLine{503     }
\DoxyCodeLine{504     \textcolor{keywordflow}{for}(uword i=1; i < \mbox{\hyperlink{structA}{A}}.n\_rows; ++i)}
\DoxyCodeLine{505       \{}
\DoxyCodeLine{506       \textcolor{keyword}{const} eT x = \mbox{\hyperlink{structA}{A}}.at(i,i);}
\DoxyCodeLine{507       }
\DoxyCodeLine{508       sign *= (\mbox{\hyperlink{structis__cx}{is\_cx<eT>::no}}) ? ( (\mbox{\hyperlink{classaccess_a9687cee4d2be0fe591998d6f5c6d0849}{access::tmp\_real}}(x) < T(0)) ? -\/1 : +1 ) : +1;}
\DoxyCodeLine{509       val  += (\mbox{\hyperlink{structis__cx}{is\_cx<eT>::no}}) ? std::log( (\mbox{\hyperlink{classaccess_a9687cee4d2be0fe591998d6f5c6d0849}{access::tmp\_real}}(x) < T(0)) ? x*T(-\/1) : x ) : std::log(x);}
\DoxyCodeLine{510       \}}
\DoxyCodeLine{511     }
\DoxyCodeLine{512     \textcolor{keywordflow}{for}(uword i=0; i < \mbox{\hyperlink{structA}{A}}.n\_rows; ++i)}
\DoxyCodeLine{513       \{}
\DoxyCodeLine{514       \textcolor{keywordflow}{if}( blas\_int(i) != (ipiv.\mbox{\hyperlink{classpodarray_a3235dffb0bca72b5aa2f6f7d2c696601}{mem}}[i] -\/ 1) )  \textcolor{comment}{// NOTE: adjustment of -\/1 is required as Fortran counts from 1}}
\DoxyCodeLine{515         \{}
\DoxyCodeLine{516         sign *= -\/1;}
\DoxyCodeLine{517         \}}
\DoxyCodeLine{518       \}}
\DoxyCodeLine{519     }
\DoxyCodeLine{520     out\_val  = val;}
\DoxyCodeLine{521     out\_sign = T(sign);}
\DoxyCodeLine{522     }
\DoxyCodeLine{523     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{524     \}}
\DoxyCodeLine{525 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{526     \{}
\DoxyCodeLine{527     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{528     arma\_ignore(out\_val);}
\DoxyCodeLine{529     arma\_ignore(out\_sign);}
\DoxyCodeLine{530     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}log\_det(): use of ATLAS or LAPACK must be enabled"{}});}
\DoxyCodeLine{531     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{532     \}}
\DoxyCodeLine{533 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{534   \}}
\DoxyCodeLine{535 }
\DoxyCodeLine{536 }
\DoxyCodeLine{537 }
\DoxyCodeLine{538 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{539 \textcolor{keyword}{inline}}
\DoxyCodeLine{540 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{541 auxlib::log\_det\_sympd(\textcolor{keyword}{typename} get\_pod\_type<eT>::result\& out\_val, \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}})}
\DoxyCodeLine{542   \{}
\DoxyCodeLine{543   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{544   }
\DoxyCodeLine{545   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} get\_pod\_type<eT>::result T;}
\DoxyCodeLine{546   }
\DoxyCodeLine{547   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty())  \{ out\_val = T(0); \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{548   }
\DoxyCodeLine{549 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_ATLAS)}}
\DoxyCodeLine{550     \{}
\DoxyCodeLine{551     arma\_debug\_assert\_atlas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{552     }
\DoxyCodeLine{553     \textcolor{keywordtype}{int} info = 0;}
\DoxyCodeLine{554     }
\DoxyCodeLine{555     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}atlas::clapack\_potrf()"{}});}
\DoxyCodeLine{556     info = atlas::clapack\_potrf(atlas::CblasColMajor, atlas::CblasLower, \mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.memptr(), \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{557     }
\DoxyCodeLine{558     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{559     }
\DoxyCodeLine{560     T val = std::log( \mbox{\hyperlink{classaccess_a9687cee4d2be0fe591998d6f5c6d0849}{access::tmp\_real}}(\mbox{\hyperlink{structA}{A}}.at(0,0)) );}
\DoxyCodeLine{561     }
\DoxyCodeLine{562     \textcolor{keywordflow}{for}(uword i=1; i < \mbox{\hyperlink{structA}{A}}.n\_rows; ++i)  \{ val += std::log( \mbox{\hyperlink{classaccess_a9687cee4d2be0fe591998d6f5c6d0849}{access::tmp\_real}}(\mbox{\hyperlink{structA}{A}}.at(i,i)) ); \}}
\DoxyCodeLine{563     }
\DoxyCodeLine{564     out\_val = T(2) * val;}
\DoxyCodeLine{565     }
\DoxyCodeLine{566     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{567     \}}
\DoxyCodeLine{568 \textcolor{preprocessor}{  \#elif defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{569     \{}
\DoxyCodeLine{570     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{571     }
\DoxyCodeLine{572     \textcolor{keywordtype}{char}     uplo = \textcolor{charliteral}{'L'};}
\DoxyCodeLine{573     blas\_int n    = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{574     blas\_int info = 0;}
\DoxyCodeLine{575     }
\DoxyCodeLine{576     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::potrf()"{}});}
\DoxyCodeLine{577     lapack::potrf(\&uplo, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&n, \&info);}
\DoxyCodeLine{578     }
\DoxyCodeLine{579     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{580     }
\DoxyCodeLine{581     T val = std::log( \mbox{\hyperlink{classaccess_a9687cee4d2be0fe591998d6f5c6d0849}{access::tmp\_real}}(\mbox{\hyperlink{structA}{A}}.at(0,0)) );}
\DoxyCodeLine{582     }
\DoxyCodeLine{583     \textcolor{keywordflow}{for}(uword i=1; i < \mbox{\hyperlink{structA}{A}}.n\_rows; ++i)  \{ val += std::log( \mbox{\hyperlink{classaccess_a9687cee4d2be0fe591998d6f5c6d0849}{access::tmp\_real}}(\mbox{\hyperlink{structA}{A}}.at(i,i)) ); \}}
\DoxyCodeLine{584     }
\DoxyCodeLine{585     out\_val = T(2) * val;}
\DoxyCodeLine{586     }
\DoxyCodeLine{587     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{588     \}}
\DoxyCodeLine{589 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{590     \{}
\DoxyCodeLine{591     arma\_ignore(out\_val);}
\DoxyCodeLine{592     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{593     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}det(): use of ATLAS or LAPACK must be enabled"{}});}
\DoxyCodeLine{594     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{595     \}}
\DoxyCodeLine{596 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{597   \}}
\DoxyCodeLine{598 }
\DoxyCodeLine{599 }
\DoxyCodeLine{600 }
\DoxyCodeLine{602 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{603 \textcolor{keyword}{inline}}
\DoxyCodeLine{604 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{605 \mbox{\hyperlink{group__auxlib_ga414bdef119dfc44395d8a5e54426b080}{auxlib::lu}}(\mbox{\hyperlink{classMat}{Mat<eT>}}\& L, \mbox{\hyperlink{classMat}{Mat<eT>}}\& U, \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}}\& ipiv, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<eT,T1>}}\& X)}
\DoxyCodeLine{606   \{}
\DoxyCodeLine{607   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{608   }
\DoxyCodeLine{609   U = X.get\_ref();}
\DoxyCodeLine{610   }
\DoxyCodeLine{611   \textcolor{keyword}{const} uword U\_n\_rows = U.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}};}
\DoxyCodeLine{612   \textcolor{keyword}{const} uword U\_n\_cols = U.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}};}
\DoxyCodeLine{613   }
\DoxyCodeLine{614   \textcolor{keywordflow}{if}(U.\mbox{\hyperlink{group__Mat_ga3008049216e02308ff665862f451a7ff}{is\_empty}}())}
\DoxyCodeLine{615     \{}
\DoxyCodeLine{616     L.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(U\_n\_rows, 0);}
\DoxyCodeLine{617     U.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(0, U\_n\_cols);}
\DoxyCodeLine{618     ipiv.reset();}
\DoxyCodeLine{619     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{620     \}}
\DoxyCodeLine{621   }
\DoxyCodeLine{622 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_ATLAS) || defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{623     \{}
\DoxyCodeLine{624 \textcolor{preprocessor}{    \#if defined(ARMA\_USE\_ATLAS)}}
\DoxyCodeLine{625       \{}
\DoxyCodeLine{626       arma\_debug\_assert\_atlas\_size(U);}
\DoxyCodeLine{627       }
\DoxyCodeLine{628       ipiv.set\_size( (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(U\_n\_rows, U\_n\_cols) );}
\DoxyCodeLine{629       }
\DoxyCodeLine{630       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}atlas::clapack\_getrf()"{}});}
\DoxyCodeLine{631       \textcolor{keywordtype}{int} info = atlas::clapack\_getrf(atlas::CblasColMajor, U\_n\_rows, U\_n\_cols, U.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), U\_n\_rows, ipiv.memptr());}
\DoxyCodeLine{632       }
\DoxyCodeLine{633       \textcolor{keywordflow}{if}(info < 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{634       \}}
\DoxyCodeLine{635 \textcolor{preprocessor}{    \#elif defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{636       \{}
\DoxyCodeLine{637       arma\_debug\_assert\_blas\_size(U);}
\DoxyCodeLine{638       }
\DoxyCodeLine{639       ipiv.set\_size( (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(U\_n\_rows, U\_n\_cols) );}
\DoxyCodeLine{640       }
\DoxyCodeLine{641       blas\_int info = 0;}
\DoxyCodeLine{642       }
\DoxyCodeLine{643       blas\_int n\_rows = blas\_int(U\_n\_rows);}
\DoxyCodeLine{644       blas\_int n\_cols = blas\_int(U\_n\_cols);}
\DoxyCodeLine{645       }
\DoxyCodeLine{646       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::getrf()"{}});}
\DoxyCodeLine{647       lapack::getrf(\&n\_rows, \&n\_cols, U.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&n\_rows, ipiv.memptr(), \&info);}
\DoxyCodeLine{648       }
\DoxyCodeLine{649       \textcolor{keywordflow}{if}(info < 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{650       }
\DoxyCodeLine{651       \textcolor{comment}{// take into account that Fortran counts from 1}}
\DoxyCodeLine{652       arrayops::inplace\_minus(ipiv.memptr(), blas\_int(1), ipiv.\mbox{\hyperlink{classpodarray_af419483181c4e0302ba079f42ef02f68}{n\_elem}});}
\DoxyCodeLine{653       \}}
\DoxyCodeLine{654 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{655     }
\DoxyCodeLine{656     L.\mbox{\hyperlink{group__Mat_ga9b739350523229ea160719b1ef106f96}{copy\_size}}(U);}
\DoxyCodeLine{657     }
\DoxyCodeLine{658     \textcolor{keywordflow}{for}(uword col=0; col < U\_n\_cols; ++col)}
\DoxyCodeLine{659       \{}
\DoxyCodeLine{660       \textcolor{keywordflow}{for}(uword row=0; (row < col) \&\& (row < U\_n\_rows); ++row)}
\DoxyCodeLine{661         \{}
\DoxyCodeLine{662         L.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(row,col) = eT(0);}
\DoxyCodeLine{663         \}}
\DoxyCodeLine{664       }
\DoxyCodeLine{665       \textcolor{keywordflow}{if}( L.\mbox{\hyperlink{group__Mat_ga534db9e8a1619c57efb85f22214f888a}{in\_range}}(col,col) )}
\DoxyCodeLine{666         \{}
\DoxyCodeLine{667         L.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(col,col) = eT(1);}
\DoxyCodeLine{668         \}}
\DoxyCodeLine{669       }
\DoxyCodeLine{670       \textcolor{keywordflow}{for}(uword row = (col+1); row < U\_n\_rows; ++row)}
\DoxyCodeLine{671         \{}
\DoxyCodeLine{672         L.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(row,col) = U.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(row,col);}
\DoxyCodeLine{673         U.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(row,col) = eT(0);}
\DoxyCodeLine{674         \}}
\DoxyCodeLine{675       \}}
\DoxyCodeLine{676     }
\DoxyCodeLine{677     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{678     \}}
\DoxyCodeLine{679 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{680     \{}
\DoxyCodeLine{681     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}lu(): use of ATLAS or LAPACK must be enabled"{}});}
\DoxyCodeLine{682     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{683     \}}
\DoxyCodeLine{684 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{685   \}}
\DoxyCodeLine{686 }
\DoxyCodeLine{687 }
\DoxyCodeLine{688 }
\DoxyCodeLine{689 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{690 \textcolor{keyword}{inline}}
\DoxyCodeLine{691 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{692 \mbox{\hyperlink{group__auxlib_ga414bdef119dfc44395d8a5e54426b080}{auxlib::lu}}(\mbox{\hyperlink{classMat}{Mat<eT>}}\& L, \mbox{\hyperlink{classMat}{Mat<eT>}}\& U, \mbox{\hyperlink{classMat}{Mat<eT>}}\& P, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<eT,T1>}}\& X)}
\DoxyCodeLine{693   \{}
\DoxyCodeLine{694   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{695   }
\DoxyCodeLine{696   \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} ipiv1;}
\DoxyCodeLine{697   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} status = \mbox{\hyperlink{group__auxlib_ga414bdef119dfc44395d8a5e54426b080}{auxlib::lu}}(L, U, ipiv1, X);}
\DoxyCodeLine{698   }
\DoxyCodeLine{699   \textcolor{keywordflow}{if}(status == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{700   }
\DoxyCodeLine{701   \textcolor{keywordflow}{if}(U.\mbox{\hyperlink{group__Mat_ga3008049216e02308ff665862f451a7ff}{is\_empty}}())}
\DoxyCodeLine{702     \{}
\DoxyCodeLine{703     \textcolor{comment}{// L and U have been already set to the correct empty matrices}}
\DoxyCodeLine{704     P.eye(L.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}}, L.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{705     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{706     \}}
\DoxyCodeLine{707   }
\DoxyCodeLine{708   \textcolor{keyword}{const} uword n      = ipiv1.\mbox{\hyperlink{classpodarray_af419483181c4e0302ba079f42ef02f68}{n\_elem}};}
\DoxyCodeLine{709   \textcolor{keyword}{const} uword P\_rows = U.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}};}
\DoxyCodeLine{710   }
\DoxyCodeLine{711   \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} ipiv2(P\_rows);}
\DoxyCodeLine{712   }
\DoxyCodeLine{713   \textcolor{keyword}{const} blas\_int* ipiv1\_mem = ipiv1.memptr();}
\DoxyCodeLine{714         blas\_int* ipiv2\_mem = ipiv2.memptr();}
\DoxyCodeLine{715   }
\DoxyCodeLine{716   \textcolor{keywordflow}{for}(uword i=0; i<P\_rows; ++i)}
\DoxyCodeLine{717     \{}
\DoxyCodeLine{718     ipiv2\_mem[i] = blas\_int(i);}
\DoxyCodeLine{719     \}}
\DoxyCodeLine{720   }
\DoxyCodeLine{721   \textcolor{keywordflow}{for}(uword i=0; i<n; ++i)}
\DoxyCodeLine{722     \{}
\DoxyCodeLine{723     \textcolor{keyword}{const} uword k = \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(ipiv1\_mem[i]);}
\DoxyCodeLine{724     }
\DoxyCodeLine{725     \textcolor{keywordflow}{if}( ipiv2\_mem[i] != ipiv2\_mem[k] )}
\DoxyCodeLine{726       \{}
\DoxyCodeLine{727       std::swap( ipiv2\_mem[i], ipiv2\_mem[k] );}
\DoxyCodeLine{728       \}}
\DoxyCodeLine{729     \}}
\DoxyCodeLine{730   }
\DoxyCodeLine{731   P.zeros(P\_rows, P\_rows);}
\DoxyCodeLine{732   }
\DoxyCodeLine{733   \textcolor{keywordflow}{for}(uword row=0; row<P\_rows; ++row)}
\DoxyCodeLine{734     \{}
\DoxyCodeLine{735     P.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(row, \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(ipiv2\_mem[row])) = eT(1);}
\DoxyCodeLine{736     \}}
\DoxyCodeLine{737   }
\DoxyCodeLine{738   \textcolor{keywordflow}{if}(L.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}} > U.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}})}
\DoxyCodeLine{739     \{}
\DoxyCodeLine{740     L.\mbox{\hyperlink{group__Mat_ga618ff9cb52b629c84305aed5fd59ceec}{shed\_cols}}(U.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}}, L.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}}-\/1);}
\DoxyCodeLine{741     \}}
\DoxyCodeLine{742     }
\DoxyCodeLine{743   \textcolor{keywordflow}{if}(U.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}} > L.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}})}
\DoxyCodeLine{744     \{}
\DoxyCodeLine{745     U.\mbox{\hyperlink{group__Mat_gae18e4671dd983be00b17c691ff18a4f1}{shed\_rows}}(L.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}}, U.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}}-\/1);}
\DoxyCodeLine{746     \}}
\DoxyCodeLine{747   }
\DoxyCodeLine{748   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{749   \}}
\DoxyCodeLine{750 }
\DoxyCodeLine{751 }
\DoxyCodeLine{752 }
\DoxyCodeLine{753 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{754 \textcolor{keyword}{inline}}
\DoxyCodeLine{755 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{756 \mbox{\hyperlink{group__auxlib_ga414bdef119dfc44395d8a5e54426b080}{auxlib::lu}}(\mbox{\hyperlink{classMat}{Mat<eT>}}\& L, \mbox{\hyperlink{classMat}{Mat<eT>}}\& U, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<eT,T1>}}\& X)}
\DoxyCodeLine{757   \{}
\DoxyCodeLine{758   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{759   }
\DoxyCodeLine{760   \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} ipiv1;}
\DoxyCodeLine{761   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} status = \mbox{\hyperlink{group__auxlib_ga414bdef119dfc44395d8a5e54426b080}{auxlib::lu}}(L, U, ipiv1, X);}
\DoxyCodeLine{762   }
\DoxyCodeLine{763   \textcolor{keywordflow}{if}(status == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{764   }
\DoxyCodeLine{765   \textcolor{keywordflow}{if}(U.\mbox{\hyperlink{group__Mat_ga3008049216e02308ff665862f451a7ff}{is\_empty}}())}
\DoxyCodeLine{766     \{}
\DoxyCodeLine{767     \textcolor{comment}{// L and U have been already set to the correct empty matrices}}
\DoxyCodeLine{768     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{769     \}}
\DoxyCodeLine{770   }
\DoxyCodeLine{771   \textcolor{keyword}{const} uword n      = ipiv1.\mbox{\hyperlink{classpodarray_af419483181c4e0302ba079f42ef02f68}{n\_elem}};}
\DoxyCodeLine{772   \textcolor{keyword}{const} uword P\_rows = U.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}};}
\DoxyCodeLine{773   }
\DoxyCodeLine{774   \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} ipiv2(P\_rows);}
\DoxyCodeLine{775   }
\DoxyCodeLine{776   \textcolor{keyword}{const} blas\_int* ipiv1\_mem = ipiv1.memptr();}
\DoxyCodeLine{777         blas\_int* ipiv2\_mem = ipiv2.memptr();}
\DoxyCodeLine{778   }
\DoxyCodeLine{779   \textcolor{keywordflow}{for}(uword i=0; i<P\_rows; ++i)}
\DoxyCodeLine{780     \{}
\DoxyCodeLine{781     ipiv2\_mem[i] = blas\_int(i);}
\DoxyCodeLine{782     \}}
\DoxyCodeLine{783   }
\DoxyCodeLine{784   \textcolor{keywordflow}{for}(uword i=0; i<n; ++i)}
\DoxyCodeLine{785     \{}
\DoxyCodeLine{786     \textcolor{keyword}{const} uword k = \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(ipiv1\_mem[i]);}
\DoxyCodeLine{787     }
\DoxyCodeLine{788     \textcolor{keywordflow}{if}( ipiv2\_mem[i] != ipiv2\_mem[k] )}
\DoxyCodeLine{789       \{}
\DoxyCodeLine{790       std::swap( ipiv2\_mem[i], ipiv2\_mem[k] );}
\DoxyCodeLine{791       L.swap\_rows( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(ipiv2\_mem[i]), \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(ipiv2\_mem[k]) );}
\DoxyCodeLine{792       \}}
\DoxyCodeLine{793     \}}
\DoxyCodeLine{794   }
\DoxyCodeLine{795   \textcolor{keywordflow}{if}(L.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}} > U.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}})}
\DoxyCodeLine{796     \{}
\DoxyCodeLine{797     L.\mbox{\hyperlink{group__Mat_ga618ff9cb52b629c84305aed5fd59ceec}{shed\_cols}}(U.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}}, L.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}}-\/1);}
\DoxyCodeLine{798     \}}
\DoxyCodeLine{799     }
\DoxyCodeLine{800   \textcolor{keywordflow}{if}(U.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}} > L.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}})}
\DoxyCodeLine{801     \{}
\DoxyCodeLine{802     U.\mbox{\hyperlink{group__Mat_gae18e4671dd983be00b17c691ff18a4f1}{shed\_rows}}(L.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}}, U.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}}-\/1);}
\DoxyCodeLine{803     \}}
\DoxyCodeLine{804   }
\DoxyCodeLine{805   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{806   \}}
\DoxyCodeLine{807 }
\DoxyCodeLine{808 }
\DoxyCodeLine{809 }
\DoxyCodeLine{811 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{812 \textcolor{keyword}{inline}}
\DoxyCodeLine{813 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{814 \mbox{\hyperlink{group__auxlib_ga329f7be399a3f9e90086d5e263691345}{auxlib::eig\_gen}}}
\DoxyCodeLine{815   (}
\DoxyCodeLine{816          \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\& vals,}
\DoxyCodeLine{817          \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\& vecs,}
\DoxyCodeLine{818   \textcolor{keyword}{const} \textcolor{keywordtype}{bool}                                         vecs\_on,}
\DoxyCodeLine{819   \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::pod\_type,T1>}}\&              expr}
\DoxyCodeLine{820   )}
\DoxyCodeLine{821   \{}
\DoxyCodeLine{822   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{823   }
\DoxyCodeLine{824 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{825     \{}
\DoxyCodeLine{826     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type T;}
\DoxyCodeLine{827     }
\DoxyCodeLine{828     \mbox{\hyperlink{classMat}{Mat<T>}} X = expr.get\_ref();}
\DoxyCodeLine{829     }
\DoxyCodeLine{830     arma\_debug\_check( (X.is\_square() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}eig\_gen(): given matrix must be square sized"{}} );}
\DoxyCodeLine{831     }
\DoxyCodeLine{832     arma\_debug\_assert\_blas\_size(X);}
\DoxyCodeLine{833     }
\DoxyCodeLine{834     \textcolor{keywordflow}{if}(X.is\_empty())}
\DoxyCodeLine{835       \{}
\DoxyCodeLine{836       vals.reset();}
\DoxyCodeLine{837       vecs.reset();}
\DoxyCodeLine{838       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{839       \}}
\DoxyCodeLine{840     }
\DoxyCodeLine{841     \textcolor{keywordflow}{if}(X.is\_finite() == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{842     }
\DoxyCodeLine{843     vals.set\_size(X.n\_rows, 1);}
\DoxyCodeLine{844     }
\DoxyCodeLine{845     \mbox{\hyperlink{classMat}{Mat<T>}} tmp(1, 1, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{846     }
\DoxyCodeLine{847     \textcolor{keywordflow}{if}(vecs\_on)}
\DoxyCodeLine{848       \{}
\DoxyCodeLine{849       vecs.set\_size(X.n\_rows, X.n\_rows);}
\DoxyCodeLine{850        tmp.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(X.n\_rows, X.n\_rows);}
\DoxyCodeLine{851       \}}
\DoxyCodeLine{852     }
\DoxyCodeLine{853     \mbox{\hyperlink{classpodarray}{podarray<T>}} junk(1);}
\DoxyCodeLine{854     }
\DoxyCodeLine{855     \textcolor{keywordtype}{char}     jobvl = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{856     \textcolor{keywordtype}{char}     jobvr = (vecs\_on) ? \textcolor{charliteral}{'V'} : \textcolor{charliteral}{'N'};}
\DoxyCodeLine{857     blas\_int N     = blas\_int(X.n\_rows);}
\DoxyCodeLine{858     T*       vl    = junk.memptr();}
\DoxyCodeLine{859     T*       vr    = (vecs\_on) ? tmp.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}() : junk.memptr();}
\DoxyCodeLine{860     blas\_int ldvl  = blas\_int(1);}
\DoxyCodeLine{861     blas\_int ldvr  = (vecs\_on) ? blas\_int(tmp.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}}) : blas\_int(1);}
\DoxyCodeLine{862     blas\_int lwork = 64*N;  \textcolor{comment}{// lwork\_min = (vecs\_on) ? (std::max)(blas\_int(1), 4*N) : (std::max)(blas\_int(1), 3*N)}}
\DoxyCodeLine{863     blas\_int info  = 0;}
\DoxyCodeLine{864     }
\DoxyCodeLine{865     \mbox{\hyperlink{classpodarray}{podarray<T>}} work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork) );}
\DoxyCodeLine{866     }
\DoxyCodeLine{867     \mbox{\hyperlink{classpodarray}{podarray<T>}} vals\_real(X.n\_rows);}
\DoxyCodeLine{868     \mbox{\hyperlink{classpodarray}{podarray<T>}} vals\_imag(X.n\_rows);}
\DoxyCodeLine{869     }
\DoxyCodeLine{870     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::geev() -\/-\/ START"{}});}
\DoxyCodeLine{871     lapack::geev(\&jobvl, \&jobvr, \&N, X.memptr(), \&N, vals\_real.memptr(), vals\_imag.memptr(), vl, \&ldvl, vr, \&ldvr, work.memptr(), \&lwork, \&info);}
\DoxyCodeLine{872     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::geev() -\/-\/ END"{}});}
\DoxyCodeLine{873     }
\DoxyCodeLine{874     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{875     }
\DoxyCodeLine{876     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}reformatting eigenvalues and eigenvectors"{}});}
\DoxyCodeLine{877     }
\DoxyCodeLine{878     std::complex<T>* vals\_mem = vals.memptr();}
\DoxyCodeLine{879     }
\DoxyCodeLine{880     \textcolor{keywordflow}{for}(uword i=0; i < X.n\_rows; ++i)  \{ vals\_mem[i] = std::complex<T>(vals\_real[i], vals\_imag[i]); \}}
\DoxyCodeLine{881     }
\DoxyCodeLine{882     \textcolor{keywordflow}{if}(vecs\_on)}
\DoxyCodeLine{883       \{}
\DoxyCodeLine{884       \textcolor{keywordflow}{for}(uword j=0; j < X.n\_rows; ++j)}
\DoxyCodeLine{885         \{}
\DoxyCodeLine{886         \textcolor{keywordflow}{if}( (j < (X.n\_rows-\/1)) \&\& (vals\_mem[j] == std::conj(vals\_mem[j+1])) )}
\DoxyCodeLine{887           \{}
\DoxyCodeLine{888           \textcolor{keywordflow}{for}(uword i=0; i < X.n\_rows; ++i)}
\DoxyCodeLine{889             \{}
\DoxyCodeLine{890             vecs.at(i,j)   = std::complex<T>( tmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j),  tmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j+1) );}
\DoxyCodeLine{891             vecs.at(i,j+1) = std::complex<T>( tmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j), -\/tmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j+1) );}
\DoxyCodeLine{892             \}}
\DoxyCodeLine{893           }
\DoxyCodeLine{894           ++j;}
\DoxyCodeLine{895           \}}
\DoxyCodeLine{896         \textcolor{keywordflow}{else}}
\DoxyCodeLine{897           \{}
\DoxyCodeLine{898           \textcolor{keywordflow}{for}(uword i=0; i<X.n\_rows; ++i)}
\DoxyCodeLine{899             \{}
\DoxyCodeLine{900             vecs.at(i,j) = std::complex<T>(tmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j), T(0));}
\DoxyCodeLine{901             \}}
\DoxyCodeLine{902           \}}
\DoxyCodeLine{903         \}}
\DoxyCodeLine{904       \}}
\DoxyCodeLine{905     }
\DoxyCodeLine{906     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{907     \}}
\DoxyCodeLine{908 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{909     \{}
\DoxyCodeLine{910     arma\_ignore(vals);}
\DoxyCodeLine{911     arma\_ignore(vecs);}
\DoxyCodeLine{912     arma\_ignore(vecs\_on);}
\DoxyCodeLine{913     arma\_ignore(expr);}
\DoxyCodeLine{914     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}eig\_gen(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{915     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{916     \}}
\DoxyCodeLine{917 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{918   \}}
\DoxyCodeLine{919 }
\DoxyCodeLine{920 }
\DoxyCodeLine{921 }
\DoxyCodeLine{923 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{924 \textcolor{keyword}{inline}}
\DoxyCodeLine{925 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{926 \mbox{\hyperlink{group__auxlib_ga329f7be399a3f9e90086d5e263691345}{auxlib::eig\_gen}}}
\DoxyCodeLine{927   (}
\DoxyCodeLine{928          \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\&     vals,}
\DoxyCodeLine{929          \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\&     vecs, }
\DoxyCodeLine{930   \textcolor{keyword}{const} \textcolor{keywordtype}{bool}                                             vecs\_on,}
\DoxyCodeLine{931   \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base}}< std::complex<typename T1::pod\_type>, T1 >\& expr}
\DoxyCodeLine{932   )}
\DoxyCodeLine{933   \{}
\DoxyCodeLine{934   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{935   }
\DoxyCodeLine{936 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{937     \{}
\DoxyCodeLine{938     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type     T;}
\DoxyCodeLine{939     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<T> eT;}
\DoxyCodeLine{940     }
\DoxyCodeLine{941     \mbox{\hyperlink{classMat}{Mat<eT>}} X = expr.get\_ref();}
\DoxyCodeLine{942     }
\DoxyCodeLine{943     arma\_debug\_check( (X.is\_square() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}eig\_gen(): given matrix must be square sized"{}} );}
\DoxyCodeLine{944     }
\DoxyCodeLine{945     arma\_debug\_assert\_blas\_size(X);}
\DoxyCodeLine{946     }
\DoxyCodeLine{947     \textcolor{keywordflow}{if}(X.is\_empty())}
\DoxyCodeLine{948       \{}
\DoxyCodeLine{949       vals.reset();}
\DoxyCodeLine{950       vecs.reset();}
\DoxyCodeLine{951       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{952       \}}
\DoxyCodeLine{953     }
\DoxyCodeLine{954     \textcolor{keywordflow}{if}(X.is\_finite() == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{955     }
\DoxyCodeLine{956     vals.set\_size(X.n\_rows, 1);}
\DoxyCodeLine{957     }
\DoxyCodeLine{958     \textcolor{keywordflow}{if}(vecs\_on)  \{ vecs.set\_size(X.n\_rows, X.n\_rows); \}}
\DoxyCodeLine{959     }
\DoxyCodeLine{960     \mbox{\hyperlink{classpodarray}{podarray<eT>}} junk(1);}
\DoxyCodeLine{961     }
\DoxyCodeLine{962     \textcolor{keywordtype}{char}     jobvl = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{963     \textcolor{keywordtype}{char}     jobvr = (vecs\_on) ? \textcolor{charliteral}{'V'} : \textcolor{charliteral}{'N'};}
\DoxyCodeLine{964     blas\_int N     = blas\_int(X.n\_rows);}
\DoxyCodeLine{965     eT*      vl    = junk.memptr();}
\DoxyCodeLine{966     eT*      vr    = (vecs\_on) ? vecs.memptr() : junk.memptr();}
\DoxyCodeLine{967     blas\_int ldvl  = blas\_int(1);}
\DoxyCodeLine{968     blas\_int ldvr  = (vecs\_on) ? blas\_int(vecs.n\_rows) : blas\_int(1);}
\DoxyCodeLine{969     blas\_int lwork = 64*N;  \textcolor{comment}{// lwork\_min = (std::max)(blas\_int(1), 2*N)}}
\DoxyCodeLine{970     blas\_int info  = 0;}
\DoxyCodeLine{971     }
\DoxyCodeLine{972     \mbox{\hyperlink{classpodarray}{podarray<eT>}}  work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork) );}
\DoxyCodeLine{973     \mbox{\hyperlink{classpodarray}{podarray< T>}} rwork( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(2*N)   );}
\DoxyCodeLine{974     }
\DoxyCodeLine{975     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::cx\_geev() -\/-\/ START"{}});}
\DoxyCodeLine{976     lapack::cx\_geev(\&jobvl, \&jobvr, \&N, X.memptr(), \&N, vals.memptr(), vl, \&ldvl, vr, \&ldvr, work.memptr(), \&lwork, rwork.memptr(), \&info);}
\DoxyCodeLine{977     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::cx\_geev() -\/-\/ END"{}});}
\DoxyCodeLine{978     }
\DoxyCodeLine{979     \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{980     \}}
\DoxyCodeLine{981 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{982     \{}
\DoxyCodeLine{983     arma\_ignore(vals);}
\DoxyCodeLine{984     arma\_ignore(vecs);}
\DoxyCodeLine{985     arma\_ignore(vecs\_on);}
\DoxyCodeLine{986     arma\_ignore(expr);}
\DoxyCodeLine{987     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}eig\_gen(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{988     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{989     \}}
\DoxyCodeLine{990 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{991   \}}
\DoxyCodeLine{992 }
\DoxyCodeLine{993 }
\DoxyCodeLine{994 }
\DoxyCodeLine{996 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{997 \textcolor{keyword}{inline}}
\DoxyCodeLine{998 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{999 \mbox{\hyperlink{group__auxlib_ga12c3ce0efe508ad84db233210514a98b}{auxlib::eig\_gen\_balance}}}
\DoxyCodeLine{1000   (}
\DoxyCodeLine{1001          \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\& vals,}
\DoxyCodeLine{1002          \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\& vecs,}
\DoxyCodeLine{1003   \textcolor{keyword}{const} \textcolor{keywordtype}{bool}                                         vecs\_on,}
\DoxyCodeLine{1004   \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::pod\_type,T1>}}\&              expr}
\DoxyCodeLine{1005   )}
\DoxyCodeLine{1006   \{}
\DoxyCodeLine{1007   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1008   }
\DoxyCodeLine{1009 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{1010     \{}
\DoxyCodeLine{1011     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type T;}
\DoxyCodeLine{1012     }
\DoxyCodeLine{1013     \mbox{\hyperlink{classMat}{Mat<T>}} X = expr.get\_ref();}
\DoxyCodeLine{1014     }
\DoxyCodeLine{1015     arma\_debug\_check( (X.is\_square() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}eig\_gen(): given matrix must be square sized"{}} );}
\DoxyCodeLine{1016     }
\DoxyCodeLine{1017     arma\_debug\_assert\_blas\_size(X);}
\DoxyCodeLine{1018     }
\DoxyCodeLine{1019     \textcolor{keywordflow}{if}(X.is\_empty())}
\DoxyCodeLine{1020       \{}
\DoxyCodeLine{1021       vals.reset();}
\DoxyCodeLine{1022       vecs.reset();}
\DoxyCodeLine{1023       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1024       \}}
\DoxyCodeLine{1025     }
\DoxyCodeLine{1026     \textcolor{keywordflow}{if}(X.is\_finite() == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1027     }
\DoxyCodeLine{1028     vals.set\_size(X.n\_rows, 1);}
\DoxyCodeLine{1029     }
\DoxyCodeLine{1030     \mbox{\hyperlink{classMat}{Mat<T>}} tmp(1, 1, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{1031     }
\DoxyCodeLine{1032     \textcolor{keywordflow}{if}(vecs\_on)}
\DoxyCodeLine{1033       \{}
\DoxyCodeLine{1034       vecs.set\_size(X.n\_rows, X.n\_rows);}
\DoxyCodeLine{1035        tmp.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(X.n\_rows, X.n\_rows);}
\DoxyCodeLine{1036       \}}
\DoxyCodeLine{1037     }
\DoxyCodeLine{1038     \mbox{\hyperlink{classpodarray}{podarray<T>}} junk(1);}
\DoxyCodeLine{1039     }
\DoxyCodeLine{1040     \textcolor{keywordtype}{char}     bal   = \textcolor{charliteral}{'B'}; }
\DoxyCodeLine{1041     \textcolor{keywordtype}{char}     jobvl = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{1042     \textcolor{keywordtype}{char}     jobvr = (vecs\_on) ? \textcolor{charliteral}{'V'} : \textcolor{charliteral}{'N'};}
\DoxyCodeLine{1043     \textcolor{keywordtype}{char}     sense = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{1044     blas\_int N     = blas\_int(X.n\_rows);}
\DoxyCodeLine{1045     T*       vl    = junk.memptr();}
\DoxyCodeLine{1046     T*       vr    = (vecs\_on) ? tmp.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}() : junk.memptr();}
\DoxyCodeLine{1047     blas\_int ldvl  = blas\_int(1);}
\DoxyCodeLine{1048     blas\_int ldvr  = (vecs\_on) ? blas\_int(tmp.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}}) : blas\_int(1);}
\DoxyCodeLine{1049     blas\_int ilo   = blas\_int(0);}
\DoxyCodeLine{1050     blas\_int ihi   = blas\_int(0);}
\DoxyCodeLine{1051     T        abnrm = T(0);}
\DoxyCodeLine{1052     blas\_int lwork = 64*N;  \textcolor{comment}{// lwork\_min = (vecs\_on) ? (std::max)(blas\_int(1), 2*N) : (std::max)(blas\_int(1), 3*N)}}
\DoxyCodeLine{1053     blas\_int info  = blas\_int(0);}
\DoxyCodeLine{1054     }
\DoxyCodeLine{1055     \mbox{\hyperlink{classpodarray}{podarray<T>}}  scale(X.n\_rows);}
\DoxyCodeLine{1056     \mbox{\hyperlink{classpodarray}{podarray<T>}} rconde(X.n\_rows);}
\DoxyCodeLine{1057     \mbox{\hyperlink{classpodarray}{podarray<T>}} rcondv(X.n\_rows);}
\DoxyCodeLine{1058     }
\DoxyCodeLine{1059     \mbox{\hyperlink{classpodarray}{podarray<T>}}         work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork) );}
\DoxyCodeLine{1060     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} iwork( uword(1) );  \textcolor{comment}{// iwork not used by lapack::geevx() as sense = 'N'}}
\DoxyCodeLine{1061     }
\DoxyCodeLine{1062     \mbox{\hyperlink{classpodarray}{podarray<T>}} vals\_real(X.n\_rows);}
\DoxyCodeLine{1063     \mbox{\hyperlink{classpodarray}{podarray<T>}} vals\_imag(X.n\_rows);}
\DoxyCodeLine{1064     }
\DoxyCodeLine{1065     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::geevx() -\/-\/ START"{}});}
\DoxyCodeLine{1066     lapack::geevx(\&bal, \&jobvl, \&jobvr, \&sense, \&N, X.memptr(), \&N, vals\_real.memptr(), vals\_imag.memptr(), vl, \&ldvl, vr, \&ldvr, \&ilo, \&ihi, scale.memptr(), \&abnrm, rconde.memptr(), rcondv.memptr(), work.memptr(), \&lwork, iwork.memptr(), \&info);}
\DoxyCodeLine{1067     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::geevx() -\/-\/ END"{}});}
\DoxyCodeLine{1068     }
\DoxyCodeLine{1069     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1070     }
\DoxyCodeLine{1071     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}reformatting eigenvalues and eigenvectors"{}});}
\DoxyCodeLine{1072     }
\DoxyCodeLine{1073     std::complex<T>* vals\_mem = vals.memptr();}
\DoxyCodeLine{1074     }
\DoxyCodeLine{1075     \textcolor{keywordflow}{for}(uword i=0; i < X.n\_rows; ++i)  \{ vals\_mem[i] = std::complex<T>(vals\_real[i], vals\_imag[i]); \}}
\DoxyCodeLine{1076     }
\DoxyCodeLine{1077     \textcolor{keywordflow}{if}(vecs\_on)}
\DoxyCodeLine{1078       \{}
\DoxyCodeLine{1079       \textcolor{keywordflow}{for}(uword j=0; j < X.n\_rows; ++j)}
\DoxyCodeLine{1080         \{}
\DoxyCodeLine{1081         \textcolor{keywordflow}{if}( (j < (X.n\_rows-\/1)) \&\& (vals\_mem[j] == std::conj(vals\_mem[j+1])) )}
\DoxyCodeLine{1082           \{}
\DoxyCodeLine{1083           \textcolor{keywordflow}{for}(uword i=0; i < X.n\_rows; ++i)}
\DoxyCodeLine{1084             \{}
\DoxyCodeLine{1085             vecs.at(i,j)   = std::complex<T>( tmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j),  tmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j+1) );}
\DoxyCodeLine{1086             vecs.at(i,j+1) = std::complex<T>( tmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j), -\/tmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j+1) );}
\DoxyCodeLine{1087             \}}
\DoxyCodeLine{1088           }
\DoxyCodeLine{1089           ++j;}
\DoxyCodeLine{1090           \}}
\DoxyCodeLine{1091         \textcolor{keywordflow}{else}}
\DoxyCodeLine{1092           \{}
\DoxyCodeLine{1093           \textcolor{keywordflow}{for}(uword i=0; i<X.n\_rows; ++i)}
\DoxyCodeLine{1094             \{}
\DoxyCodeLine{1095             vecs.at(i,j) = std::complex<T>(tmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j), T(0));}
\DoxyCodeLine{1096             \}}
\DoxyCodeLine{1097           \}}
\DoxyCodeLine{1098         \}}
\DoxyCodeLine{1099       \}}
\DoxyCodeLine{1100     }
\DoxyCodeLine{1101     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1102     \}}
\DoxyCodeLine{1103 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{1104     \{}
\DoxyCodeLine{1105     arma\_ignore(vals);}
\DoxyCodeLine{1106     arma\_ignore(vecs);}
\DoxyCodeLine{1107     arma\_ignore(vecs\_on);}
\DoxyCodeLine{1108     arma\_ignore(expr);}
\DoxyCodeLine{1109     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}eig\_gen(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{1110     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1111     \}}
\DoxyCodeLine{1112 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{1113   \}}
\DoxyCodeLine{1114 }
\DoxyCodeLine{1115 }
\DoxyCodeLine{1116 }
\DoxyCodeLine{1118 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{1119 \textcolor{keyword}{inline}}
\DoxyCodeLine{1120 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{1121 \mbox{\hyperlink{group__auxlib_ga12c3ce0efe508ad84db233210514a98b}{auxlib::eig\_gen\_balance}}}
\DoxyCodeLine{1122   (}
\DoxyCodeLine{1123          \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\&     vals,}
\DoxyCodeLine{1124          \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\&     vecs, }
\DoxyCodeLine{1125   \textcolor{keyword}{const} \textcolor{keywordtype}{bool}                                             vecs\_on,}
\DoxyCodeLine{1126   \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base}}< std::complex<typename T1::pod\_type>, T1 >\& expr}
\DoxyCodeLine{1127   )}
\DoxyCodeLine{1128   \{}
\DoxyCodeLine{1129   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1130   }
\DoxyCodeLine{1131 \textcolor{preprocessor}{  \#if defined(ARMA\_CRIPPLED\_LAPACK)}}
\DoxyCodeLine{1132     \{}
\DoxyCodeLine{1133     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}auxlib::eig\_gen\_balance(): redirecting to auxlib::eig\_gen() due to crippled LAPACK"{}});}
\DoxyCodeLine{1134     }
\DoxyCodeLine{1135     \textcolor{keywordflow}{return} \mbox{\hyperlink{group__auxlib_ga329f7be399a3f9e90086d5e263691345}{auxlib::eig\_gen}}(vals, vecs, vecs\_on, expr);}
\DoxyCodeLine{1136     \}}
\DoxyCodeLine{1137 \textcolor{preprocessor}{  \#elif defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{1138     \{}
\DoxyCodeLine{1139     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type     T;}
\DoxyCodeLine{1140     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<T> eT;}
\DoxyCodeLine{1141     }
\DoxyCodeLine{1142     \mbox{\hyperlink{classMat}{Mat<eT>}} X = expr.get\_ref();}
\DoxyCodeLine{1143     }
\DoxyCodeLine{1144     arma\_debug\_check( (X.is\_square() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}eig\_gen(): given matrix must be square sized"{}} );}
\DoxyCodeLine{1145     }
\DoxyCodeLine{1146     arma\_debug\_assert\_blas\_size(X);}
\DoxyCodeLine{1147     }
\DoxyCodeLine{1148     \textcolor{keywordflow}{if}(X.is\_empty())}
\DoxyCodeLine{1149       \{}
\DoxyCodeLine{1150       vals.reset();}
\DoxyCodeLine{1151       vecs.reset();}
\DoxyCodeLine{1152       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1153       \}}
\DoxyCodeLine{1154     }
\DoxyCodeLine{1155     \textcolor{keywordflow}{if}(X.is\_finite() == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1156     }
\DoxyCodeLine{1157     vals.set\_size(X.n\_rows, 1);}
\DoxyCodeLine{1158     }
\DoxyCodeLine{1159     \textcolor{keywordflow}{if}(vecs\_on)  \{ vecs.set\_size(X.n\_rows, X.n\_rows); \}}
\DoxyCodeLine{1160     }
\DoxyCodeLine{1161     \mbox{\hyperlink{classpodarray}{podarray<eT>}} junk(1);}
\DoxyCodeLine{1162     }
\DoxyCodeLine{1163     \textcolor{keywordtype}{char}     bal   = \textcolor{charliteral}{'B'};}
\DoxyCodeLine{1164     \textcolor{keywordtype}{char}     jobvl = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{1165     \textcolor{keywordtype}{char}     jobvr = (vecs\_on) ? \textcolor{charliteral}{'V'} : \textcolor{charliteral}{'N'};}
\DoxyCodeLine{1166     \textcolor{keywordtype}{char}     sense = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{1167     blas\_int N     = blas\_int(X.n\_rows);}
\DoxyCodeLine{1168     eT*      vl    = junk.memptr();}
\DoxyCodeLine{1169     eT*      vr    = (vecs\_on) ? vecs.memptr() : junk.memptr();}
\DoxyCodeLine{1170     blas\_int ldvl  = blas\_int(1);}
\DoxyCodeLine{1171     blas\_int ldvr  = (vecs\_on) ? blas\_int(vecs.n\_rows) : blas\_int(1);}
\DoxyCodeLine{1172     blas\_int ilo   = blas\_int(0);}
\DoxyCodeLine{1173     blas\_int ihi   = blas\_int(0);}
\DoxyCodeLine{1174     T        abnrm = T(0);}
\DoxyCodeLine{1175     blas\_int lwork = 64*N;  \textcolor{comment}{// lwork\_min = (std::max)(blas\_int(1), blas\_int(2*N))}}
\DoxyCodeLine{1176     blas\_int info  = blas\_int(0);}
\DoxyCodeLine{1177     }
\DoxyCodeLine{1178     \mbox{\hyperlink{classpodarray}{podarray<T>}}  scale(X.n\_rows);}
\DoxyCodeLine{1179     \mbox{\hyperlink{classpodarray}{podarray<T>}} rconde(X.n\_rows);}
\DoxyCodeLine{1180     \mbox{\hyperlink{classpodarray}{podarray<T>}} rcondv(X.n\_rows);}
\DoxyCodeLine{1181     }
\DoxyCodeLine{1182     \mbox{\hyperlink{classpodarray}{podarray<eT>}}  work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork) );}
\DoxyCodeLine{1183     \mbox{\hyperlink{classpodarray}{podarray< T>}} rwork( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(2*N)   );}
\DoxyCodeLine{1184     }
\DoxyCodeLine{1185     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::cx\_geevx() -\/-\/ START"{}});}
\DoxyCodeLine{1186     lapack::cx\_geevx(\&bal, \&jobvl, \&jobvr, \&sense, \&N, X.memptr(), \&N, vals.memptr(), vl, \&ldvl, vr, \&ldvr, \&ilo, \&ihi, scale.memptr(), \&abnrm, rconde.memptr(), rcondv.memptr(), work.memptr(), \&lwork, rwork.memptr(), \&info);}
\DoxyCodeLine{1187     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::cx\_geevx() -\/-\/ END"{}});}
\DoxyCodeLine{1188     }
\DoxyCodeLine{1189     \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{1190     \}}
\DoxyCodeLine{1191 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{1192     \{}
\DoxyCodeLine{1193     arma\_ignore(vals);}
\DoxyCodeLine{1194     arma\_ignore(vecs);}
\DoxyCodeLine{1195     arma\_ignore(vecs\_on);}
\DoxyCodeLine{1196     arma\_ignore(expr);}
\DoxyCodeLine{1197     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}eig\_gen(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{1198     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1199     \}}
\DoxyCodeLine{1200 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{1201   \}}
\DoxyCodeLine{1202 }
\DoxyCodeLine{1203 }
\DoxyCodeLine{1204 }
\DoxyCodeLine{1206 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{1207 \textcolor{keyword}{inline}}
\DoxyCodeLine{1208 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{1209 \mbox{\hyperlink{group__auxlib_gae5bd0855889e8d1b1296de4e47b7414b}{auxlib::eig\_gen\_twosided}}}
\DoxyCodeLine{1210   (}
\DoxyCodeLine{1211          \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\&  vals,}
\DoxyCodeLine{1212          \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\& lvecs,}
\DoxyCodeLine{1213          \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\& rvecs,}
\DoxyCodeLine{1214   \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::pod\_type,T1>}}\&              expr}
\DoxyCodeLine{1215   )}
\DoxyCodeLine{1216   \{}
\DoxyCodeLine{1217   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1218   }
\DoxyCodeLine{1219 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{1220     \{}
\DoxyCodeLine{1221     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type T;}
\DoxyCodeLine{1222     }
\DoxyCodeLine{1223     \mbox{\hyperlink{classMat}{Mat<T>}} X = expr.get\_ref();}
\DoxyCodeLine{1224     }
\DoxyCodeLine{1225     arma\_debug\_check( (X.is\_square() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}eig\_gen(): given matrix must be square sized"{}} );}
\DoxyCodeLine{1226     }
\DoxyCodeLine{1227     arma\_debug\_assert\_blas\_size(X);}
\DoxyCodeLine{1228     }
\DoxyCodeLine{1229     \textcolor{keywordflow}{if}(X.is\_empty())}
\DoxyCodeLine{1230       \{}
\DoxyCodeLine{1231        vals.reset();}
\DoxyCodeLine{1232       lvecs.reset();}
\DoxyCodeLine{1233       rvecs.reset();}
\DoxyCodeLine{1234       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1235       \}}
\DoxyCodeLine{1236     }
\DoxyCodeLine{1237     \textcolor{keywordflow}{if}(X.is\_finite() == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1238     }
\DoxyCodeLine{1239     vals.set\_size(X.n\_rows, 1);}
\DoxyCodeLine{1240     }
\DoxyCodeLine{1241     lvecs.set\_size(X.n\_rows, X.n\_rows);}
\DoxyCodeLine{1242     rvecs.set\_size(X.n\_rows, X.n\_rows);}
\DoxyCodeLine{1243     }
\DoxyCodeLine{1244     \mbox{\hyperlink{classMat}{Mat<T>}} ltmp(X.n\_rows, X.n\_rows, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{1245     \mbox{\hyperlink{classMat}{Mat<T>}} rtmp(X.n\_rows, X.n\_rows, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{1246     }
\DoxyCodeLine{1247     \textcolor{keywordtype}{char}     jobvl = \textcolor{charliteral}{'V'};}
\DoxyCodeLine{1248     \textcolor{keywordtype}{char}     jobvr = \textcolor{charliteral}{'V'};}
\DoxyCodeLine{1249     blas\_int N     = blas\_int(X.n\_rows);}
\DoxyCodeLine{1250     blas\_int ldvl  = blas\_int(ltmp.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{1251     blas\_int ldvr  = blas\_int(rtmp.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{1252     blas\_int lwork = 64*N;  \textcolor{comment}{// lwork\_min = (std::max)(blas\_int(1), 4*N)}}
\DoxyCodeLine{1253     blas\_int info  = 0;}
\DoxyCodeLine{1254     }
\DoxyCodeLine{1255     \mbox{\hyperlink{classpodarray}{podarray<T>}} work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork) );}
\DoxyCodeLine{1256     }
\DoxyCodeLine{1257     \mbox{\hyperlink{classpodarray}{podarray<T>}} vals\_real(X.n\_rows);}
\DoxyCodeLine{1258     \mbox{\hyperlink{classpodarray}{podarray<T>}} vals\_imag(X.n\_rows);}
\DoxyCodeLine{1259     }
\DoxyCodeLine{1260     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::geev() -\/-\/ START"{}});}
\DoxyCodeLine{1261     lapack::geev(\&jobvl, \&jobvr, \&N, X.memptr(), \&N, vals\_real.memptr(), vals\_imag.memptr(), ltmp.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldvl, rtmp.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldvr, work.memptr(), \&lwork, \&info);}
\DoxyCodeLine{1262     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::geev() -\/-\/ END"{}});}
\DoxyCodeLine{1263     }
\DoxyCodeLine{1264     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1265     }
\DoxyCodeLine{1266     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}reformatting eigenvalues and eigenvectors"{}});}
\DoxyCodeLine{1267     }
\DoxyCodeLine{1268     std::complex<T>* vals\_mem = vals.memptr();}
\DoxyCodeLine{1269     }
\DoxyCodeLine{1270     \textcolor{keywordflow}{for}(uword i=0; i < X.n\_rows; ++i)  \{ vals\_mem[i] = std::complex<T>(vals\_real[i], vals\_imag[i]); \}}
\DoxyCodeLine{1271     }
\DoxyCodeLine{1272     \textcolor{keywordflow}{for}(uword j=0; j < X.n\_rows; ++j)}
\DoxyCodeLine{1273       \{}
\DoxyCodeLine{1274       \textcolor{keywordflow}{if}( (j < (X.n\_rows-\/1)) \&\& (vals\_mem[j] == std::conj(vals\_mem[j+1])) )}
\DoxyCodeLine{1275         \{}
\DoxyCodeLine{1276         \textcolor{keywordflow}{for}(uword i=0; i < X.n\_rows; ++i)}
\DoxyCodeLine{1277           \{}
\DoxyCodeLine{1278           lvecs.at(i,j)   = std::complex<T>( ltmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j),  ltmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j+1) );}
\DoxyCodeLine{1279           lvecs.at(i,j+1) = std::complex<T>( ltmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j), -\/ltmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j+1) );}
\DoxyCodeLine{1280           rvecs.at(i,j)   = std::complex<T>( rtmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j),  rtmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j+1) );}
\DoxyCodeLine{1281           rvecs.at(i,j+1) = std::complex<T>( rtmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j), -\/rtmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j+1) );}
\DoxyCodeLine{1282           \}}
\DoxyCodeLine{1283         ++j;}
\DoxyCodeLine{1284         \}}
\DoxyCodeLine{1285       \textcolor{keywordflow}{else}}
\DoxyCodeLine{1286         \{}
\DoxyCodeLine{1287         \textcolor{keywordflow}{for}(uword i=0; i<X.n\_rows; ++i)}
\DoxyCodeLine{1288           \{}
\DoxyCodeLine{1289           lvecs.at(i,j) = std::complex<T>(ltmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j), T(0));}
\DoxyCodeLine{1290           rvecs.at(i,j) = std::complex<T>(rtmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j), T(0));}
\DoxyCodeLine{1291           \}}
\DoxyCodeLine{1292         \}}
\DoxyCodeLine{1293       \}}
\DoxyCodeLine{1294     }
\DoxyCodeLine{1295     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1296     \}}
\DoxyCodeLine{1297 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{1298     \{}
\DoxyCodeLine{1299     arma\_ignore(vals);}
\DoxyCodeLine{1300     arma\_ignore(lvecs);}
\DoxyCodeLine{1301     arma\_ignore(rvecs);}
\DoxyCodeLine{1302     arma\_ignore(expr);}
\DoxyCodeLine{1303     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}eig\_gen(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{1304     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1305     \}}
\DoxyCodeLine{1306 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{1307   \}}
\DoxyCodeLine{1308 }
\DoxyCodeLine{1309 }
\DoxyCodeLine{1310 }
\DoxyCodeLine{1312 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{1313 \textcolor{keyword}{inline}}
\DoxyCodeLine{1314 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{1315 \mbox{\hyperlink{group__auxlib_gae5bd0855889e8d1b1296de4e47b7414b}{auxlib::eig\_gen\_twosided}}}
\DoxyCodeLine{1316   (}
\DoxyCodeLine{1317          \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\&      vals,}
\DoxyCodeLine{1318          \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\&     lvecs,}
\DoxyCodeLine{1319          \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\&     rvecs,}
\DoxyCodeLine{1320   \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base}}< std::complex<typename T1::pod\_type>, T1 >\& expr}
\DoxyCodeLine{1321   )}
\DoxyCodeLine{1322   \{}
\DoxyCodeLine{1323   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1324   }
\DoxyCodeLine{1325 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{1326     \{}
\DoxyCodeLine{1327     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type     T;}
\DoxyCodeLine{1328     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<T> eT;}
\DoxyCodeLine{1329     }
\DoxyCodeLine{1330     \mbox{\hyperlink{classMat}{Mat<eT>}} X = expr.get\_ref();}
\DoxyCodeLine{1331     }
\DoxyCodeLine{1332     arma\_debug\_check( (X.is\_square() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}eig\_gen(): given matrix must be square sized"{}} );}
\DoxyCodeLine{1333     }
\DoxyCodeLine{1334     arma\_debug\_assert\_blas\_size(X);}
\DoxyCodeLine{1335     }
\DoxyCodeLine{1336     \textcolor{keywordflow}{if}(X.is\_empty())}
\DoxyCodeLine{1337       \{}
\DoxyCodeLine{1338        vals.reset();}
\DoxyCodeLine{1339       lvecs.reset();}
\DoxyCodeLine{1340       rvecs.reset();}
\DoxyCodeLine{1341       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1342       \}}
\DoxyCodeLine{1343     }
\DoxyCodeLine{1344     \textcolor{keywordflow}{if}(X.is\_finite() == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1345     }
\DoxyCodeLine{1346     vals.set\_size(X.n\_rows, 1);}
\DoxyCodeLine{1347     }
\DoxyCodeLine{1348     lvecs.set\_size(X.n\_rows, X.n\_rows);}
\DoxyCodeLine{1349     rvecs.set\_size(X.n\_rows, X.n\_rows);}
\DoxyCodeLine{1350     }
\DoxyCodeLine{1351     \textcolor{keywordtype}{char}     jobvl = \textcolor{charliteral}{'V'};}
\DoxyCodeLine{1352     \textcolor{keywordtype}{char}     jobvr = \textcolor{charliteral}{'V'};}
\DoxyCodeLine{1353     blas\_int N     = blas\_int(X.n\_rows);}
\DoxyCodeLine{1354     blas\_int ldvl  = blas\_int(lvecs.n\_rows);}
\DoxyCodeLine{1355     blas\_int ldvr  = blas\_int(rvecs.n\_rows);}
\DoxyCodeLine{1356     blas\_int lwork = 64*N;  \textcolor{comment}{// lwork\_min = (std::max)(blas\_int(1), 2*N)}}
\DoxyCodeLine{1357     blas\_int info  = 0;}
\DoxyCodeLine{1358     }
\DoxyCodeLine{1359     \mbox{\hyperlink{classpodarray}{podarray<eT>}}  work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork) );}
\DoxyCodeLine{1360     \mbox{\hyperlink{classpodarray}{podarray< T>}} rwork( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(2*N)   );}
\DoxyCodeLine{1361     }
\DoxyCodeLine{1362     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::cx\_geev() -\/-\/ START"{}});}
\DoxyCodeLine{1363     lapack::cx\_geev(\&jobvl, \&jobvr, \&N, X.memptr(), \&N, vals.memptr(), lvecs.memptr(), \&ldvl, rvecs.memptr(), \&ldvr, work.memptr(), \&lwork, rwork.memptr(), \&info);}
\DoxyCodeLine{1364     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::cx\_geev() -\/-\/ END"{}});}
\DoxyCodeLine{1365     }
\DoxyCodeLine{1366     \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{1367     \}}
\DoxyCodeLine{1368 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{1369     \{}
\DoxyCodeLine{1370     arma\_ignore(vals);}
\DoxyCodeLine{1371     arma\_ignore(lvecs);}
\DoxyCodeLine{1372     arma\_ignore(rvecs);}
\DoxyCodeLine{1373     arma\_ignore(expr);}
\DoxyCodeLine{1374     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}eig\_gen(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{1375     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1376     \}}
\DoxyCodeLine{1377 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{1378   \}}
\DoxyCodeLine{1379 }
\DoxyCodeLine{1380 }
\DoxyCodeLine{1381 }
\DoxyCodeLine{1383 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{1384 \textcolor{keyword}{inline}}
\DoxyCodeLine{1385 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{1386 \mbox{\hyperlink{group__auxlib_gaded3d1a9ddab4aab2da0a0d8bd7cadff}{auxlib::eig\_gen\_twosided\_balance}}}
\DoxyCodeLine{1387   (}
\DoxyCodeLine{1388          \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\&  vals,}
\DoxyCodeLine{1389          \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\& lvecs,}
\DoxyCodeLine{1390          \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\& rvecs,}
\DoxyCodeLine{1391   \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::pod\_type,T1>}}\&              expr}
\DoxyCodeLine{1392   )}
\DoxyCodeLine{1393   \{}
\DoxyCodeLine{1394   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1395   }
\DoxyCodeLine{1396 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{1397     \{}
\DoxyCodeLine{1398     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type T;}
\DoxyCodeLine{1399     }
\DoxyCodeLine{1400     \mbox{\hyperlink{classMat}{Mat<T>}} X = expr.get\_ref();}
\DoxyCodeLine{1401     }
\DoxyCodeLine{1402     arma\_debug\_check( (X.is\_square() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}eig\_gen(): given matrix must be square sized"{}} );}
\DoxyCodeLine{1403     }
\DoxyCodeLine{1404     arma\_debug\_assert\_blas\_size(X);}
\DoxyCodeLine{1405     }
\DoxyCodeLine{1406     \textcolor{keywordflow}{if}(X.is\_empty())}
\DoxyCodeLine{1407       \{}
\DoxyCodeLine{1408        vals.reset();}
\DoxyCodeLine{1409       lvecs.reset();}
\DoxyCodeLine{1410       rvecs.reset();}
\DoxyCodeLine{1411       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1412       \}}
\DoxyCodeLine{1413     }
\DoxyCodeLine{1414     \textcolor{keywordflow}{if}(X.is\_finite() == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1415     }
\DoxyCodeLine{1416     vals.set\_size(X.n\_rows, 1);}
\DoxyCodeLine{1417     }
\DoxyCodeLine{1418     lvecs.set\_size(X.n\_rows, X.n\_rows);}
\DoxyCodeLine{1419     rvecs.set\_size(X.n\_rows, X.n\_rows);}
\DoxyCodeLine{1420     }
\DoxyCodeLine{1421     \mbox{\hyperlink{classMat}{Mat<T>}} ltmp(X.n\_rows, X.n\_rows, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{1422     \mbox{\hyperlink{classMat}{Mat<T>}} rtmp(X.n\_rows, X.n\_rows, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{1423     }
\DoxyCodeLine{1424     \textcolor{keywordtype}{char}     bal   = \textcolor{charliteral}{'B'};}
\DoxyCodeLine{1425     \textcolor{keywordtype}{char}     jobvl = \textcolor{charliteral}{'V'};}
\DoxyCodeLine{1426     \textcolor{keywordtype}{char}     jobvr = \textcolor{charliteral}{'V'};}
\DoxyCodeLine{1427     \textcolor{keywordtype}{char}     sense = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{1428     blas\_int N     = blas\_int(X.n\_rows);}
\DoxyCodeLine{1429     blas\_int ldvl  = blas\_int(ltmp.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{1430     blas\_int ldvr  = blas\_int(rtmp.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{1431     blas\_int ilo   = blas\_int(0);}
\DoxyCodeLine{1432     blas\_int ihi   = blas\_int(0);}
\DoxyCodeLine{1433     T        abnrm = T(0);}
\DoxyCodeLine{1434     blas\_int lwork = 64*N;  \textcolor{comment}{// lwork\_min = (std::max)(blas\_int(1), blas\_int(3*N))}}
\DoxyCodeLine{1435     blas\_int info  = blas\_int(0);}
\DoxyCodeLine{1436     }
\DoxyCodeLine{1437     \mbox{\hyperlink{classpodarray}{podarray<T>}}  scale(X.n\_rows);}
\DoxyCodeLine{1438     \mbox{\hyperlink{classpodarray}{podarray<T>}} rconde(X.n\_rows);}
\DoxyCodeLine{1439     \mbox{\hyperlink{classpodarray}{podarray<T>}} rcondv(X.n\_rows);}
\DoxyCodeLine{1440     }
\DoxyCodeLine{1441     \mbox{\hyperlink{classpodarray}{podarray<T>}}         work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork) );}
\DoxyCodeLine{1442     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} iwork( uword(1) );  \textcolor{comment}{// iwork not used by lapack::geevx() as sense = 'N'}}
\DoxyCodeLine{1443     }
\DoxyCodeLine{1444     \mbox{\hyperlink{classpodarray}{podarray<T>}} vals\_real(X.n\_rows);}
\DoxyCodeLine{1445     \mbox{\hyperlink{classpodarray}{podarray<T>}} vals\_imag(X.n\_rows);}
\DoxyCodeLine{1446     }
\DoxyCodeLine{1447     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::geevx() -\/-\/ START"{}});}
\DoxyCodeLine{1448     lapack::geevx(\&bal, \&jobvl, \&jobvr, \&sense, \&N, X.memptr(), \&N, vals\_real.memptr(), vals\_imag.memptr(), ltmp.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldvl, rtmp.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldvr, \&ilo, \&ihi, scale.memptr(), \&abnrm, rconde.memptr(), rcondv.memptr(), work.memptr(), \&lwork, iwork.memptr(), \&info);}
\DoxyCodeLine{1449     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::geevx() -\/-\/ END"{}});}
\DoxyCodeLine{1450     }
\DoxyCodeLine{1451     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1452     }
\DoxyCodeLine{1453     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}reformatting eigenvalues and eigenvectors"{}});}
\DoxyCodeLine{1454     }
\DoxyCodeLine{1455     std::complex<T>* vals\_mem = vals.memptr();}
\DoxyCodeLine{1456     }
\DoxyCodeLine{1457     \textcolor{keywordflow}{for}(uword i=0; i < X.n\_rows; ++i)  \{ vals\_mem[i] = std::complex<T>(vals\_real[i], vals\_imag[i]); \}}
\DoxyCodeLine{1458     }
\DoxyCodeLine{1459     \textcolor{keywordflow}{for}(uword j=0; j < X.n\_rows; ++j)}
\DoxyCodeLine{1460       \{}
\DoxyCodeLine{1461       \textcolor{keywordflow}{if}( (j < (X.n\_rows-\/1)) \&\& (vals\_mem[j] == std::conj(vals\_mem[j+1])) )}
\DoxyCodeLine{1462         \{}
\DoxyCodeLine{1463         \textcolor{keywordflow}{for}(uword i=0; i < X.n\_rows; ++i)}
\DoxyCodeLine{1464           \{}
\DoxyCodeLine{1465           lvecs.at(i,j)   = std::complex<T>( ltmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j),  ltmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j+1) );}
\DoxyCodeLine{1466           lvecs.at(i,j+1) = std::complex<T>( ltmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j), -\/ltmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j+1) );}
\DoxyCodeLine{1467           rvecs.at(i,j)   = std::complex<T>( rtmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j),  rtmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j+1) );}
\DoxyCodeLine{1468           rvecs.at(i,j+1) = std::complex<T>( rtmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j), -\/rtmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j+1) );}
\DoxyCodeLine{1469           \}}
\DoxyCodeLine{1470         ++j;}
\DoxyCodeLine{1471         \}}
\DoxyCodeLine{1472       \textcolor{keywordflow}{else}}
\DoxyCodeLine{1473         \{}
\DoxyCodeLine{1474         \textcolor{keywordflow}{for}(uword i=0; i<X.n\_rows; ++i)}
\DoxyCodeLine{1475           \{}
\DoxyCodeLine{1476           lvecs.at(i,j) = std::complex<T>(ltmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j), T(0));}
\DoxyCodeLine{1477           rvecs.at(i,j) = std::complex<T>(rtmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j), T(0));}
\DoxyCodeLine{1478           \}}
\DoxyCodeLine{1479         \}}
\DoxyCodeLine{1480       \}}
\DoxyCodeLine{1481     }
\DoxyCodeLine{1482     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1483     \}}
\DoxyCodeLine{1484 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{1485     \{}
\DoxyCodeLine{1486     arma\_ignore(vals);}
\DoxyCodeLine{1487     arma\_ignore(lvecs);}
\DoxyCodeLine{1488     arma\_ignore(rvecs);}
\DoxyCodeLine{1489     arma\_ignore(expr);}
\DoxyCodeLine{1490     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}eig\_gen(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{1491     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1492     \}}
\DoxyCodeLine{1493 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{1494   \}}
\DoxyCodeLine{1495 }
\DoxyCodeLine{1496 }
\DoxyCodeLine{1497 }
\DoxyCodeLine{1499 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{1500 \textcolor{keyword}{inline}}
\DoxyCodeLine{1501 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{1502 \mbox{\hyperlink{group__auxlib_gaded3d1a9ddab4aab2da0a0d8bd7cadff}{auxlib::eig\_gen\_twosided\_balance}}}
\DoxyCodeLine{1503   (}
\DoxyCodeLine{1504          \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\&      vals,}
\DoxyCodeLine{1505          \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\&     lvecs,}
\DoxyCodeLine{1506          \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\&     rvecs,}
\DoxyCodeLine{1507   \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base}}< std::complex<typename T1::pod\_type>, T1 >\& expr}
\DoxyCodeLine{1508   )}
\DoxyCodeLine{1509   \{}
\DoxyCodeLine{1510   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1511   }
\DoxyCodeLine{1512 \textcolor{preprocessor}{  \#if defined(ARMA\_CRIPPLED\_LAPACK)}}
\DoxyCodeLine{1513     \{}
\DoxyCodeLine{1514     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}auxlib::eig\_gen\_twosided\_balance(): redirecting to auxlib::eig\_gen() due to crippled LAPACK"{}});}
\DoxyCodeLine{1515     }
\DoxyCodeLine{1516     \textcolor{keywordflow}{return} \mbox{\hyperlink{group__auxlib_ga329f7be399a3f9e90086d5e263691345}{auxlib::eig\_gen}}(vals, lvecs, rvecs, expr);}
\DoxyCodeLine{1517     \}}
\DoxyCodeLine{1518 \textcolor{preprocessor}{  \#elif defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{1519     \{}
\DoxyCodeLine{1520     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type     T;}
\DoxyCodeLine{1521     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<T> eT;}
\DoxyCodeLine{1522     }
\DoxyCodeLine{1523     \mbox{\hyperlink{classMat}{Mat<eT>}} X = expr.get\_ref();}
\DoxyCodeLine{1524     }
\DoxyCodeLine{1525     arma\_debug\_check( (X.is\_square() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}eig\_gen(): given matrix must be square sized"{}} );}
\DoxyCodeLine{1526     }
\DoxyCodeLine{1527     arma\_debug\_assert\_blas\_size(X);}
\DoxyCodeLine{1528     }
\DoxyCodeLine{1529     \textcolor{keywordflow}{if}(X.is\_empty())}
\DoxyCodeLine{1530       \{}
\DoxyCodeLine{1531        vals.reset();}
\DoxyCodeLine{1532       lvecs.reset();}
\DoxyCodeLine{1533       rvecs.reset();}
\DoxyCodeLine{1534       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1535       \}}
\DoxyCodeLine{1536     }
\DoxyCodeLine{1537     \textcolor{keywordflow}{if}(X.is\_finite() == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1538     }
\DoxyCodeLine{1539     vals.set\_size(X.n\_rows, 1);}
\DoxyCodeLine{1540     }
\DoxyCodeLine{1541     lvecs.set\_size(X.n\_rows, X.n\_rows);}
\DoxyCodeLine{1542     rvecs.set\_size(X.n\_rows, X.n\_rows);}
\DoxyCodeLine{1543     }
\DoxyCodeLine{1544     \textcolor{keywordtype}{char}     bal   = \textcolor{charliteral}{'B'};}
\DoxyCodeLine{1545     \textcolor{keywordtype}{char}     jobvl = \textcolor{charliteral}{'V'};}
\DoxyCodeLine{1546     \textcolor{keywordtype}{char}     jobvr = \textcolor{charliteral}{'V'};}
\DoxyCodeLine{1547     \textcolor{keywordtype}{char}     sense = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{1548     blas\_int N     = blas\_int(X.n\_rows);}
\DoxyCodeLine{1549     blas\_int ldvl  = blas\_int(lvecs.n\_rows);}
\DoxyCodeLine{1550     blas\_int ldvr  = blas\_int(rvecs.n\_rows);}
\DoxyCodeLine{1551     blas\_int ilo   = blas\_int(0);}
\DoxyCodeLine{1552     blas\_int ihi   = blas\_int(0);}
\DoxyCodeLine{1553     T        abnrm = T(0);}
\DoxyCodeLine{1554     blas\_int lwork = 64*N;  \textcolor{comment}{// lwork\_min = (std::max)(blas\_int(1), blas\_int(2*N))}}
\DoxyCodeLine{1555     blas\_int info  = blas\_int(0);}
\DoxyCodeLine{1556     }
\DoxyCodeLine{1557     \mbox{\hyperlink{classpodarray}{podarray<T>}}  scale(X.n\_rows);}
\DoxyCodeLine{1558     \mbox{\hyperlink{classpodarray}{podarray<T>}} rconde(X.n\_rows);}
\DoxyCodeLine{1559     \mbox{\hyperlink{classpodarray}{podarray<T>}} rcondv(X.n\_rows);}
\DoxyCodeLine{1560     }
\DoxyCodeLine{1561     \mbox{\hyperlink{classpodarray}{podarray<eT>}}  work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork) );}
\DoxyCodeLine{1562     \mbox{\hyperlink{classpodarray}{podarray< T>}} rwork( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(2*N)   );}
\DoxyCodeLine{1563     }
\DoxyCodeLine{1564     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::cx\_geevx() -\/-\/ START"{}});}
\DoxyCodeLine{1565     lapack::cx\_geevx(\&bal, \&jobvl, \&jobvr, \&sense, \&N, X.memptr(), \&N, vals.memptr(), lvecs.memptr(), \&ldvl, rvecs.memptr(), \&ldvr, \&ilo, \&ihi, scale.memptr(), \&abnrm, rconde.memptr(), rcondv.memptr(), work.memptr(), \&lwork, rwork.memptr(), \&info);}
\DoxyCodeLine{1566     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::cx\_geevx() -\/-\/ END"{}});}
\DoxyCodeLine{1567     }
\DoxyCodeLine{1568     \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{1569     \}}
\DoxyCodeLine{1570 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{1571     \{}
\DoxyCodeLine{1572     arma\_ignore(vals);}
\DoxyCodeLine{1573     arma\_ignore(lvecs);}
\DoxyCodeLine{1574     arma\_ignore(rvecs);}
\DoxyCodeLine{1575     arma\_ignore(expr);}
\DoxyCodeLine{1576     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}eig\_gen(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{1577     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1578     \}}
\DoxyCodeLine{1579 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{1580   \}}
\DoxyCodeLine{1581 }
\DoxyCodeLine{1582 }
\DoxyCodeLine{1583 }
\DoxyCodeLine{1585 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{1586 \textcolor{keyword}{inline}}
\DoxyCodeLine{1587 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{1588 \mbox{\hyperlink{group__auxlib_ga3f0adca5448bb1f9f444d468067d67a8}{auxlib::eig\_pair}}}
\DoxyCodeLine{1589   (}
\DoxyCodeLine{1590         \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\& vals,}
\DoxyCodeLine{1591         \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\& vecs,}
\DoxyCodeLine{1592   \textcolor{keyword}{const} \textcolor{keywordtype}{bool}                                        vecs\_on,}
\DoxyCodeLine{1593   \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::pod\_type,T1>}}\&             A\_expr,}
\DoxyCodeLine{1594   \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::pod\_type,T2>}}\&             B\_expr}
\DoxyCodeLine{1595   )}
\DoxyCodeLine{1596   \{}
\DoxyCodeLine{1597   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1598   }
\DoxyCodeLine{1599 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{1600     \{}
\DoxyCodeLine{1601     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type  T;}
\DoxyCodeLine{1602     \textcolor{keyword}{typedef} std::complex<T>       eT;}
\DoxyCodeLine{1603     }
\DoxyCodeLine{1604     \mbox{\hyperlink{classMat}{Mat<T>}} \mbox{\hyperlink{structA}{A}}(A\_expr.get\_ref());}
\DoxyCodeLine{1605     \mbox{\hyperlink{classMat}{Mat<T>}} \mbox{\hyperlink{structB}{B}}(B\_expr.get\_ref());}
\DoxyCodeLine{1606     }
\DoxyCodeLine{1607     arma\_debug\_check( ((\mbox{\hyperlink{structA}{A}}.is\_square() == \textcolor{keyword}{false}) || (\mbox{\hyperlink{structB}{B}}.is\_square() == \textcolor{keyword}{false})), \textcolor{stringliteral}{"{}eig\_pair(): given matrices must be square sized"{}} );}
\DoxyCodeLine{1608     }
\DoxyCodeLine{1609     arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.n\_rows != \mbox{\hyperlink{structB}{B}}.n\_rows), \textcolor{stringliteral}{"{}eig\_pair(): given matrices must have the same size"{}} );}
\DoxyCodeLine{1610     }
\DoxyCodeLine{1611     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{1612     }
\DoxyCodeLine{1613     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty())}
\DoxyCodeLine{1614       \{}
\DoxyCodeLine{1615       vals.reset();}
\DoxyCodeLine{1616       vecs.reset();}
\DoxyCodeLine{1617       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1618       \}}
\DoxyCodeLine{1619     }
\DoxyCodeLine{1620     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_finite() == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1621     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structB}{B}}.is\_finite() == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1622     }
\DoxyCodeLine{1623     vals.set\_size(\mbox{\hyperlink{structA}{A}}.n\_rows, 1);}
\DoxyCodeLine{1624     }
\DoxyCodeLine{1625     \mbox{\hyperlink{classMat}{Mat<T>}} tmp(1, 1, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{1626     }
\DoxyCodeLine{1627     \textcolor{keywordflow}{if}(vecs\_on)}
\DoxyCodeLine{1628       \{}
\DoxyCodeLine{1629       vecs.set\_size(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{1630        tmp.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{1631       \}}
\DoxyCodeLine{1632     }
\DoxyCodeLine{1633     \mbox{\hyperlink{classpodarray}{podarray<T>}} junk(1);}
\DoxyCodeLine{1634     }
\DoxyCodeLine{1635     \textcolor{keywordtype}{char}     jobvl = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{1636     \textcolor{keywordtype}{char}     jobvr = (vecs\_on) ? \textcolor{charliteral}{'V'} : \textcolor{charliteral}{'N'};}
\DoxyCodeLine{1637     blas\_int N     = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{1638     T*       vl    = junk.memptr();}
\DoxyCodeLine{1639     T*       vr    = (vecs\_on) ? tmp.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}() : junk.memptr();}
\DoxyCodeLine{1640     blas\_int ldvl  = blas\_int(1);}
\DoxyCodeLine{1641     blas\_int ldvr  = (vecs\_on) ? blas\_int(tmp.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}}) : blas\_int(1);}
\DoxyCodeLine{1642     blas\_int lwork = 64*N;  \textcolor{comment}{// lwork\_min = (std::max)(blas\_int(1), 8*N)}}
\DoxyCodeLine{1643     blas\_int info  = 0;}
\DoxyCodeLine{1644     }
\DoxyCodeLine{1645     \mbox{\hyperlink{classpodarray}{podarray<T>}} alphar(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{1646     \mbox{\hyperlink{classpodarray}{podarray<T>}} alphai(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{1647     \mbox{\hyperlink{classpodarray}{podarray<T>}}   beta(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{1648     }
\DoxyCodeLine{1649     \mbox{\hyperlink{classpodarray}{podarray<T>}} work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork) );}
\DoxyCodeLine{1650     }
\DoxyCodeLine{1651     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::ggev()"{}});}
\DoxyCodeLine{1652     lapack::ggev(\&jobvl, \&jobvr, \&N, \mbox{\hyperlink{structA}{A}}.memptr(), \&N,  \mbox{\hyperlink{structB}{B}}.memptr(), \&N, alphar.memptr(), alphai.memptr(), beta.memptr(), vl, \&ldvl, vr, \&ldvr, work.memptr(), \&lwork, \&info);}
\DoxyCodeLine{1653     }
\DoxyCodeLine{1654     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1655     }
\DoxyCodeLine{1656     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}reformatting eigenvalues and eigenvectors"{}});}
\DoxyCodeLine{1657     }
\DoxyCodeLine{1658           eT*   vals\_mem =   vals.memptr();}
\DoxyCodeLine{1659     \textcolor{keyword}{const}  T* alphar\_mem = alphar.memptr();}
\DoxyCodeLine{1660     \textcolor{keyword}{const}  T* alphai\_mem = alphai.memptr();}
\DoxyCodeLine{1661     \textcolor{keyword}{const}  T*   beta\_mem =   beta.memptr();}
\DoxyCodeLine{1662     }
\DoxyCodeLine{1663     \textcolor{keywordtype}{bool} beta\_has\_zero = \textcolor{keyword}{false};}
\DoxyCodeLine{1664     }
\DoxyCodeLine{1665     \textcolor{keywordflow}{for}(uword j=0; j<\mbox{\hyperlink{structA}{A}}.n\_rows; ++j)}
\DoxyCodeLine{1666       \{}
\DoxyCodeLine{1667       \textcolor{keyword}{const} T alphai\_val = alphai\_mem[j];}
\DoxyCodeLine{1668       \textcolor{keyword}{const} T   beta\_val =   beta\_mem[j];}
\DoxyCodeLine{1669       }
\DoxyCodeLine{1670       \textcolor{keyword}{const} T re = alphar\_mem[j] / beta\_val;}
\DoxyCodeLine{1671       \textcolor{keyword}{const} T im = alphai\_val    / beta\_val;}
\DoxyCodeLine{1672       }
\DoxyCodeLine{1673       beta\_has\_zero = (beta\_has\_zero || (beta\_val == T(0)));}
\DoxyCodeLine{1674       }
\DoxyCodeLine{1675       vals\_mem[j] = std::complex<T>(re, im);}
\DoxyCodeLine{1676       }
\DoxyCodeLine{1677       \textcolor{keywordflow}{if}( (alphai\_val > T(0)) \&\& (j < (\mbox{\hyperlink{structA}{A}}.n\_rows-\/1)) )}
\DoxyCodeLine{1678         \{}
\DoxyCodeLine{1679         ++j;}
\DoxyCodeLine{1680         vals\_mem[j] = std::complex<T>(re,-\/im);  \textcolor{comment}{// force exact conjugate}}
\DoxyCodeLine{1681         \}}
\DoxyCodeLine{1682       \}}
\DoxyCodeLine{1683     }
\DoxyCodeLine{1684     \textcolor{keywordflow}{if}(beta\_has\_zero)  \{ arma\_debug\_warn\_level(1, \textcolor{stringliteral}{"{}eig\_pair(): given matrices appear ill-\/conditioned"{}}); \}}
\DoxyCodeLine{1685     }
\DoxyCodeLine{1686     \textcolor{keywordflow}{if}(vecs\_on)}
\DoxyCodeLine{1687       \{}
\DoxyCodeLine{1688       \textcolor{keywordflow}{for}(uword j=0; j<\mbox{\hyperlink{structA}{A}}.n\_rows; ++j)}
\DoxyCodeLine{1689         \{}
\DoxyCodeLine{1690         \textcolor{keywordflow}{if}( (j < (\mbox{\hyperlink{structA}{A}}.n\_rows-\/1)) \&\& (vals\_mem[j] == std::conj(vals\_mem[j+1])) )}
\DoxyCodeLine{1691           \{}
\DoxyCodeLine{1692           \textcolor{keywordflow}{for}(uword i=0; i<\mbox{\hyperlink{structA}{A}}.n\_rows; ++i)}
\DoxyCodeLine{1693             \{}
\DoxyCodeLine{1694             vecs.at(i,j)   = std::complex<T>( tmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j),  tmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j+1) );}
\DoxyCodeLine{1695             vecs.at(i,j+1) = std::complex<T>( tmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j), -\/tmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j+1) );}
\DoxyCodeLine{1696             \}}
\DoxyCodeLine{1697           }
\DoxyCodeLine{1698           ++j;}
\DoxyCodeLine{1699           \}}
\DoxyCodeLine{1700         \textcolor{keywordflow}{else}}
\DoxyCodeLine{1701           \{}
\DoxyCodeLine{1702           \textcolor{keywordflow}{for}(uword i=0; i<\mbox{\hyperlink{structA}{A}}.n\_rows; ++i)}
\DoxyCodeLine{1703             \{}
\DoxyCodeLine{1704             vecs.at(i,j) = std::complex<T>(tmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j), T(0));}
\DoxyCodeLine{1705             \}}
\DoxyCodeLine{1706           \}}
\DoxyCodeLine{1707         \}}
\DoxyCodeLine{1708       \}}
\DoxyCodeLine{1709     }
\DoxyCodeLine{1710     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1711     \}}
\DoxyCodeLine{1712 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{1713     \{}
\DoxyCodeLine{1714     arma\_ignore(vals);}
\DoxyCodeLine{1715     arma\_ignore(vecs);}
\DoxyCodeLine{1716     arma\_ignore(vecs\_on);}
\DoxyCodeLine{1717     arma\_ignore(A\_expr);}
\DoxyCodeLine{1718     arma\_ignore(B\_expr);}
\DoxyCodeLine{1719     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}eig\_pair(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{1720     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1721     \}}
\DoxyCodeLine{1722 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{1723   \}}
\DoxyCodeLine{1724 }
\DoxyCodeLine{1725 }
\DoxyCodeLine{1726 }
\DoxyCodeLine{1728 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{1729 \textcolor{keyword}{inline}}
\DoxyCodeLine{1730 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{1731 \mbox{\hyperlink{group__auxlib_ga3f0adca5448bb1f9f444d468067d67a8}{auxlib::eig\_pair}}}
\DoxyCodeLine{1732   (}
\DoxyCodeLine{1733         \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\&      vals,}
\DoxyCodeLine{1734         \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\&      vecs,}
\DoxyCodeLine{1735   \textcolor{keyword}{const} \textcolor{keywordtype}{bool}                                             vecs\_on,}
\DoxyCodeLine{1736   \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base}}< std::complex<typename T1::pod\_type>, T1 >\& A\_expr,}
\DoxyCodeLine{1737   \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base}}< std::complex<typename T1::pod\_type>, T2 >\& B\_expr}
\DoxyCodeLine{1738   )}
\DoxyCodeLine{1739   \{}
\DoxyCodeLine{1740   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1741   }
\DoxyCodeLine{1742 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{1743     \{}
\DoxyCodeLine{1744     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type     T;}
\DoxyCodeLine{1745     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<T> eT;}
\DoxyCodeLine{1746     }
\DoxyCodeLine{1747     \mbox{\hyperlink{classMat}{Mat<eT>}} \mbox{\hyperlink{structA}{A}}(A\_expr.get\_ref());}
\DoxyCodeLine{1748     \mbox{\hyperlink{classMat}{Mat<eT>}} \mbox{\hyperlink{structB}{B}}(B\_expr.get\_ref());}
\DoxyCodeLine{1749     }
\DoxyCodeLine{1750     arma\_debug\_check( ((\mbox{\hyperlink{structA}{A}}.is\_square() == \textcolor{keyword}{false}) || (\mbox{\hyperlink{structB}{B}}.is\_square() == \textcolor{keyword}{false})), \textcolor{stringliteral}{"{}eig\_pair(): given matrices must be square sized"{}} );}
\DoxyCodeLine{1751     }
\DoxyCodeLine{1752     arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.n\_rows != \mbox{\hyperlink{structB}{B}}.n\_rows), \textcolor{stringliteral}{"{}eig\_pair(): given matrices must have the same size"{}} );}
\DoxyCodeLine{1753     }
\DoxyCodeLine{1754     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{1755     }
\DoxyCodeLine{1756     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty())}
\DoxyCodeLine{1757       \{}
\DoxyCodeLine{1758       vals.reset();}
\DoxyCodeLine{1759       vecs.reset();}
\DoxyCodeLine{1760       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1761       \}}
\DoxyCodeLine{1762     }
\DoxyCodeLine{1763     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_finite() == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1764     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structB}{B}}.is\_finite() == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1765     }
\DoxyCodeLine{1766     vals.set\_size(\mbox{\hyperlink{structA}{A}}.n\_rows, 1);}
\DoxyCodeLine{1767     }
\DoxyCodeLine{1768     \textcolor{keywordflow}{if}(vecs\_on)  \{ vecs.set\_size(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_rows); \}}
\DoxyCodeLine{1769     }
\DoxyCodeLine{1770     \mbox{\hyperlink{classpodarray}{podarray<eT>}} junk(1);}
\DoxyCodeLine{1771     }
\DoxyCodeLine{1772     \textcolor{keywordtype}{char}     jobvl = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{1773     \textcolor{keywordtype}{char}     jobvr = (vecs\_on) ? \textcolor{charliteral}{'V'} : \textcolor{charliteral}{'N'};}
\DoxyCodeLine{1774     blas\_int N     = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{1775     eT*      vl    = junk.memptr();}
\DoxyCodeLine{1776     eT*      vr    = (vecs\_on) ? vecs.memptr() : junk.memptr();}
\DoxyCodeLine{1777     blas\_int ldvl  = blas\_int(1);}
\DoxyCodeLine{1778     blas\_int ldvr  = (vecs\_on) ? blas\_int(vecs.n\_rows) : blas\_int(1);}
\DoxyCodeLine{1779     blas\_int lwork = 64*N;  \textcolor{comment}{// lwork\_min = (std::max)(blas\_int(1),2*N)}}
\DoxyCodeLine{1780     blas\_int info  = 0;}
\DoxyCodeLine{1781     }
\DoxyCodeLine{1782     \mbox{\hyperlink{classpodarray}{podarray<eT>}} alpha(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{1783     \mbox{\hyperlink{classpodarray}{podarray<eT>}}  beta(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{1784     }
\DoxyCodeLine{1785     \mbox{\hyperlink{classpodarray}{podarray<eT>}}  work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork) );}
\DoxyCodeLine{1786     \mbox{\hyperlink{classpodarray}{podarray<T>}}  rwork( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(8*N)   );}
\DoxyCodeLine{1787     }
\DoxyCodeLine{1788     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::cx\_ggev()"{}});}
\DoxyCodeLine{1789     lapack::cx\_ggev(\&jobvl, \&jobvr, \&N, \mbox{\hyperlink{structA}{A}}.memptr(), \&N, \mbox{\hyperlink{structB}{B}}.memptr(), \&N, alpha.memptr(), beta.memptr(), vl, \&ldvl, vr, \&ldvr, work.memptr(), \&lwork, rwork.memptr(), \&info);}
\DoxyCodeLine{1790     }
\DoxyCodeLine{1791     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1792     }
\DoxyCodeLine{1793           eT*   vals\_mem =  vals.memptr();}
\DoxyCodeLine{1794     \textcolor{keyword}{const} eT*  alpha\_mem = alpha.memptr();}
\DoxyCodeLine{1795     \textcolor{keyword}{const} eT*   beta\_mem =  beta.memptr();}
\DoxyCodeLine{1796     }
\DoxyCodeLine{1797     \textcolor{keyword}{const} std::complex<T> zero(T(0), T(0));}
\DoxyCodeLine{1798     }
\DoxyCodeLine{1799     \textcolor{keywordtype}{bool} beta\_has\_zero = \textcolor{keyword}{false};}
\DoxyCodeLine{1800     }
\DoxyCodeLine{1801     \textcolor{keywordflow}{for}(uword i=0; i<\mbox{\hyperlink{structA}{A}}.n\_rows; ++i)}
\DoxyCodeLine{1802       \{}
\DoxyCodeLine{1803       \textcolor{keyword}{const} eT\& beta\_val = beta\_mem[i];}
\DoxyCodeLine{1804       }
\DoxyCodeLine{1805       vals\_mem[i] = alpha\_mem[i] / beta\_val;}
\DoxyCodeLine{1806       }
\DoxyCodeLine{1807       beta\_has\_zero = (beta\_has\_zero || (beta\_val == zero));}
\DoxyCodeLine{1808       \}}
\DoxyCodeLine{1809     }
\DoxyCodeLine{1810     \textcolor{keywordflow}{if}(beta\_has\_zero)  \{ arma\_debug\_warn\_level(1, \textcolor{stringliteral}{"{}eig\_pair(): given matrices appear ill-\/conditioned"{}}); \}}
\DoxyCodeLine{1811     }
\DoxyCodeLine{1812     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1813     \}}
\DoxyCodeLine{1814 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{1815     \{}
\DoxyCodeLine{1816     arma\_ignore(vals);}
\DoxyCodeLine{1817     arma\_ignore(vecs);}
\DoxyCodeLine{1818     arma\_ignore(vecs\_on);}
\DoxyCodeLine{1819     arma\_ignore(A\_expr);}
\DoxyCodeLine{1820     arma\_ignore(B\_expr);}
\DoxyCodeLine{1821     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}eig\_pair(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{1822     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1823     \}}
\DoxyCodeLine{1824 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{1825   \}}
\DoxyCodeLine{1826 }
\DoxyCodeLine{1827 }
\DoxyCodeLine{1828 }
\DoxyCodeLine{1830 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{1831 \textcolor{keyword}{inline}}
\DoxyCodeLine{1832 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{1833 \mbox{\hyperlink{group__auxlib_ga01e77782db942d53c334d0a8cca7242c}{auxlib::eig\_pair\_twosided}}}
\DoxyCodeLine{1834   (}
\DoxyCodeLine{1835         \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\&  vals,}
\DoxyCodeLine{1836         \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\& lvecs,}
\DoxyCodeLine{1837         \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\& rvecs,}
\DoxyCodeLine{1838   \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::pod\_type,T1>}}\&             A\_expr,}
\DoxyCodeLine{1839   \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::pod\_type,T2>}}\&             B\_expr}
\DoxyCodeLine{1840   )}
\DoxyCodeLine{1841   \{}
\DoxyCodeLine{1842   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1843   }
\DoxyCodeLine{1844 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{1845     \{}
\DoxyCodeLine{1846     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type  T;}
\DoxyCodeLine{1847     \textcolor{keyword}{typedef} std::complex<T>       eT;}
\DoxyCodeLine{1848     }
\DoxyCodeLine{1849     \mbox{\hyperlink{classMat}{Mat<T>}} \mbox{\hyperlink{structA}{A}}(A\_expr.get\_ref());}
\DoxyCodeLine{1850     \mbox{\hyperlink{classMat}{Mat<T>}} \mbox{\hyperlink{structB}{B}}(B\_expr.get\_ref());}
\DoxyCodeLine{1851     }
\DoxyCodeLine{1852     arma\_debug\_check( ((\mbox{\hyperlink{structA}{A}}.is\_square() == \textcolor{keyword}{false}) || (\mbox{\hyperlink{structB}{B}}.is\_square() == \textcolor{keyword}{false})), \textcolor{stringliteral}{"{}eig\_pair(): given matrices must be square sized"{}} );}
\DoxyCodeLine{1853     }
\DoxyCodeLine{1854     arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.n\_rows != \mbox{\hyperlink{structB}{B}}.n\_rows), \textcolor{stringliteral}{"{}eig\_pair(): given matrices must have the same size"{}} );}
\DoxyCodeLine{1855     }
\DoxyCodeLine{1856     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{1857     }
\DoxyCodeLine{1858     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty())}
\DoxyCodeLine{1859       \{}
\DoxyCodeLine{1860        vals.reset();}
\DoxyCodeLine{1861       lvecs.reset();}
\DoxyCodeLine{1862       rvecs.reset();}
\DoxyCodeLine{1863       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1864       \}}
\DoxyCodeLine{1865     }
\DoxyCodeLine{1866     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_finite() == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1867     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structB}{B}}.is\_finite() == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1868     }
\DoxyCodeLine{1869     vals.set\_size(\mbox{\hyperlink{structA}{A}}.n\_rows, 1);}
\DoxyCodeLine{1870     }
\DoxyCodeLine{1871     lvecs.set\_size(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{1872     rvecs.set\_size(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{1873     }
\DoxyCodeLine{1874     \mbox{\hyperlink{classMat}{Mat<T>}} ltmp(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{1875     \mbox{\hyperlink{classMat}{Mat<T>}} rtmp(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{1876     }
\DoxyCodeLine{1877     \textcolor{keywordtype}{char}     jobvl = \textcolor{charliteral}{'V'};}
\DoxyCodeLine{1878     \textcolor{keywordtype}{char}     jobvr = \textcolor{charliteral}{'V'};}
\DoxyCodeLine{1879     blas\_int N     = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{1880     blas\_int ldvl  = blas\_int(ltmp.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{1881     blas\_int ldvr  = blas\_int(rtmp.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{1882     blas\_int lwork = 64*N;  \textcolor{comment}{// lwork\_min = (std::max)(blas\_int(1), 8*N)}}
\DoxyCodeLine{1883     blas\_int info  = 0;}
\DoxyCodeLine{1884     }
\DoxyCodeLine{1885     \mbox{\hyperlink{classpodarray}{podarray<T>}} alphar(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{1886     \mbox{\hyperlink{classpodarray}{podarray<T>}} alphai(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{1887     \mbox{\hyperlink{classpodarray}{podarray<T>}}   beta(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{1888     }
\DoxyCodeLine{1889     \mbox{\hyperlink{classpodarray}{podarray<T>}} work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork) );}
\DoxyCodeLine{1890     }
\DoxyCodeLine{1891     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::ggev()"{}});}
\DoxyCodeLine{1892     lapack::ggev(\&jobvl, \&jobvr, \&N, \mbox{\hyperlink{structA}{A}}.memptr(), \&N,  \mbox{\hyperlink{structB}{B}}.memptr(), \&N, alphar.memptr(), alphai.memptr(), beta.memptr(), ltmp.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldvl, rtmp.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldvr, work.memptr(), \&lwork, \&info);}
\DoxyCodeLine{1893     }
\DoxyCodeLine{1894     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1895     }
\DoxyCodeLine{1896     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}reformatting eigenvalues and eigenvectors"{}});}
\DoxyCodeLine{1897     }
\DoxyCodeLine{1898           eT*   vals\_mem =   vals.memptr();}
\DoxyCodeLine{1899     \textcolor{keyword}{const}  T* alphar\_mem = alphar.memptr();}
\DoxyCodeLine{1900     \textcolor{keyword}{const}  T* alphai\_mem = alphai.memptr();}
\DoxyCodeLine{1901     \textcolor{keyword}{const}  T*   beta\_mem =   beta.memptr();}
\DoxyCodeLine{1902     }
\DoxyCodeLine{1903     \textcolor{keywordtype}{bool} beta\_has\_zero = \textcolor{keyword}{false};}
\DoxyCodeLine{1904     }
\DoxyCodeLine{1905     \textcolor{keywordflow}{for}(uword j=0; j<\mbox{\hyperlink{structA}{A}}.n\_rows; ++j)}
\DoxyCodeLine{1906       \{}
\DoxyCodeLine{1907       \textcolor{keyword}{const} T alphai\_val = alphai\_mem[j];}
\DoxyCodeLine{1908       \textcolor{keyword}{const} T   beta\_val =   beta\_mem[j];}
\DoxyCodeLine{1909       }
\DoxyCodeLine{1910       \textcolor{keyword}{const} T re = alphar\_mem[j] / beta\_val;}
\DoxyCodeLine{1911       \textcolor{keyword}{const} T im = alphai\_val    / beta\_val;}
\DoxyCodeLine{1912       }
\DoxyCodeLine{1913       beta\_has\_zero = (beta\_has\_zero || (beta\_val == T(0)));}
\DoxyCodeLine{1914       }
\DoxyCodeLine{1915       vals\_mem[j] = std::complex<T>(re, im);}
\DoxyCodeLine{1916       }
\DoxyCodeLine{1917       \textcolor{keywordflow}{if}( (alphai\_val > T(0)) \&\& (j < (\mbox{\hyperlink{structA}{A}}.n\_rows-\/1)) )}
\DoxyCodeLine{1918         \{}
\DoxyCodeLine{1919         ++j;}
\DoxyCodeLine{1920         vals\_mem[j] = std::complex<T>(re,-\/im);  \textcolor{comment}{// force exact conjugate}}
\DoxyCodeLine{1921         \}}
\DoxyCodeLine{1922       \}}
\DoxyCodeLine{1923     }
\DoxyCodeLine{1924     \textcolor{keywordflow}{if}(beta\_has\_zero)  \{ arma\_debug\_warn\_level(1, \textcolor{stringliteral}{"{}eig\_pair(): given matrices appear ill-\/conditioned"{}}); \}}
\DoxyCodeLine{1925     }
\DoxyCodeLine{1926     \textcolor{keywordflow}{for}(uword j=0; j < \mbox{\hyperlink{structA}{A}}.n\_rows; ++j)}
\DoxyCodeLine{1927       \{}
\DoxyCodeLine{1928       \textcolor{keywordflow}{if}( (j < (\mbox{\hyperlink{structA}{A}}.n\_rows-\/1)) \&\& (vals\_mem[j] == std::conj(vals\_mem[j+1])) )}
\DoxyCodeLine{1929         \{}
\DoxyCodeLine{1930         \textcolor{keywordflow}{for}(uword i=0; i < \mbox{\hyperlink{structA}{A}}.n\_rows; ++i)}
\DoxyCodeLine{1931           \{}
\DoxyCodeLine{1932           lvecs.at(i,j)   = std::complex<T>( ltmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j),  ltmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j+1) );}
\DoxyCodeLine{1933           lvecs.at(i,j+1) = std::complex<T>( ltmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j), -\/ltmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j+1) );}
\DoxyCodeLine{1934           rvecs.at(i,j)   = std::complex<T>( rtmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j),  rtmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j+1) );}
\DoxyCodeLine{1935           rvecs.at(i,j+1) = std::complex<T>( rtmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j), -\/rtmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j+1) );}
\DoxyCodeLine{1936           \}}
\DoxyCodeLine{1937         ++j;}
\DoxyCodeLine{1938         \}}
\DoxyCodeLine{1939       \textcolor{keywordflow}{else}}
\DoxyCodeLine{1940         \{}
\DoxyCodeLine{1941         \textcolor{keywordflow}{for}(uword i=0; i<\mbox{\hyperlink{structA}{A}}.n\_rows; ++i)}
\DoxyCodeLine{1942           \{}
\DoxyCodeLine{1943           lvecs.at(i,j) = std::complex<T>(ltmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j), T(0));}
\DoxyCodeLine{1944           rvecs.at(i,j) = std::complex<T>(rtmp.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,j), T(0));}
\DoxyCodeLine{1945           \}}
\DoxyCodeLine{1946         \}}
\DoxyCodeLine{1947       \}}
\DoxyCodeLine{1948     }
\DoxyCodeLine{1949     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1950     \}}
\DoxyCodeLine{1951 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{1952     \{}
\DoxyCodeLine{1953     arma\_ignore(vals);}
\DoxyCodeLine{1954     arma\_ignore(lvecs);}
\DoxyCodeLine{1955     arma\_ignore(rvecs);}
\DoxyCodeLine{1956     arma\_ignore(A\_expr);}
\DoxyCodeLine{1957     arma\_ignore(B\_expr);}
\DoxyCodeLine{1958     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}eig\_pair(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{1959     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1960     \}}
\DoxyCodeLine{1961 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{1962   \}}
\DoxyCodeLine{1963 }
\DoxyCodeLine{1964 }
\DoxyCodeLine{1965 }
\DoxyCodeLine{1967 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{1968 \textcolor{keyword}{inline}}
\DoxyCodeLine{1969 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{1970 \mbox{\hyperlink{group__auxlib_ga01e77782db942d53c334d0a8cca7242c}{auxlib::eig\_pair\_twosided}}}
\DoxyCodeLine{1971   (}
\DoxyCodeLine{1972         \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\&       vals,}
\DoxyCodeLine{1973         \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\&      lvecs,}
\DoxyCodeLine{1974         \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\&      rvecs,}
\DoxyCodeLine{1975   \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base}}< std::complex<typename T1::pod\_type>, T1 >\& A\_expr,}
\DoxyCodeLine{1976   \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base}}< std::complex<typename T1::pod\_type>, T2 >\& B\_expr}
\DoxyCodeLine{1977   )}
\DoxyCodeLine{1978   \{}
\DoxyCodeLine{1979   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1980   }
\DoxyCodeLine{1981 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{1982     \{}
\DoxyCodeLine{1983     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type     T;}
\DoxyCodeLine{1984     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<T> eT;}
\DoxyCodeLine{1985     }
\DoxyCodeLine{1986     \mbox{\hyperlink{classMat}{Mat<eT>}} \mbox{\hyperlink{structA}{A}}(A\_expr.get\_ref());}
\DoxyCodeLine{1987     \mbox{\hyperlink{classMat}{Mat<eT>}} \mbox{\hyperlink{structB}{B}}(B\_expr.get\_ref());}
\DoxyCodeLine{1988     }
\DoxyCodeLine{1989     arma\_debug\_check( ((\mbox{\hyperlink{structA}{A}}.is\_square() == \textcolor{keyword}{false}) || (\mbox{\hyperlink{structB}{B}}.is\_square() == \textcolor{keyword}{false})), \textcolor{stringliteral}{"{}eig\_pair(): given matrices must be square sized"{}} );}
\DoxyCodeLine{1990     }
\DoxyCodeLine{1991     arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.n\_rows != \mbox{\hyperlink{structB}{B}}.n\_rows), \textcolor{stringliteral}{"{}eig\_pair(): given matrices must have the same size"{}} );}
\DoxyCodeLine{1992     }
\DoxyCodeLine{1993     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{1994     }
\DoxyCodeLine{1995     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty())}
\DoxyCodeLine{1996       \{}
\DoxyCodeLine{1997        vals.reset();}
\DoxyCodeLine{1998       lvecs.reset();}
\DoxyCodeLine{1999       rvecs.reset();}
\DoxyCodeLine{2000       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2001       \}}
\DoxyCodeLine{2002     }
\DoxyCodeLine{2003     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_finite() == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2004     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structB}{B}}.is\_finite() == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2005     }
\DoxyCodeLine{2006     vals.set\_size(\mbox{\hyperlink{structA}{A}}.n\_rows, 1);}
\DoxyCodeLine{2007     }
\DoxyCodeLine{2008     lvecs.set\_size(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{2009     rvecs.set\_size(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{2010     }
\DoxyCodeLine{2011     \textcolor{keywordtype}{char}     jobvl = \textcolor{charliteral}{'V'};}
\DoxyCodeLine{2012     \textcolor{keywordtype}{char}     jobvr = \textcolor{charliteral}{'V'};}
\DoxyCodeLine{2013     blas\_int N     = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{2014     blas\_int ldvl  = blas\_int(lvecs.n\_rows);}
\DoxyCodeLine{2015     blas\_int ldvr  = blas\_int(rvecs.n\_rows);}
\DoxyCodeLine{2016     blas\_int lwork = 64*N;  \textcolor{comment}{// lwork\_min = (std::max)(blas\_int(1),2*N)}}
\DoxyCodeLine{2017     blas\_int info  = 0;}
\DoxyCodeLine{2018     }
\DoxyCodeLine{2019     \mbox{\hyperlink{classpodarray}{podarray<eT>}} alpha(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{2020     \mbox{\hyperlink{classpodarray}{podarray<eT>}}  beta(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{2021     }
\DoxyCodeLine{2022     \mbox{\hyperlink{classpodarray}{podarray<eT>}}  work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork) );}
\DoxyCodeLine{2023     \mbox{\hyperlink{classpodarray}{podarray<T>}}  rwork( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(8*N)   );}
\DoxyCodeLine{2024     }
\DoxyCodeLine{2025     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::cx\_ggev()"{}});}
\DoxyCodeLine{2026     lapack::cx\_ggev(\&jobvl, \&jobvr, \&N, \mbox{\hyperlink{structA}{A}}.memptr(), \&N, \mbox{\hyperlink{structB}{B}}.memptr(), \&N, alpha.memptr(), beta.memptr(), lvecs.memptr(), \&ldvl, rvecs.memptr(), \&ldvr, work.memptr(), \&lwork, rwork.memptr(), \&info);}
\DoxyCodeLine{2027     }
\DoxyCodeLine{2028     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2029     }
\DoxyCodeLine{2030           eT*   vals\_mem =  vals.memptr();}
\DoxyCodeLine{2031     \textcolor{keyword}{const} eT*  alpha\_mem = alpha.memptr();}
\DoxyCodeLine{2032     \textcolor{keyword}{const} eT*   beta\_mem =  beta.memptr();}
\DoxyCodeLine{2033     }
\DoxyCodeLine{2034     \textcolor{keyword}{const} std::complex<T> zero(T(0), T(0));}
\DoxyCodeLine{2035     }
\DoxyCodeLine{2036     \textcolor{keywordtype}{bool} beta\_has\_zero = \textcolor{keyword}{false};}
\DoxyCodeLine{2037     }
\DoxyCodeLine{2038     \textcolor{keywordflow}{for}(uword i=0; i<\mbox{\hyperlink{structA}{A}}.n\_rows; ++i)}
\DoxyCodeLine{2039       \{}
\DoxyCodeLine{2040       \textcolor{keyword}{const} eT\& beta\_val = beta\_mem[i];}
\DoxyCodeLine{2041       }
\DoxyCodeLine{2042       vals\_mem[i] = alpha\_mem[i] / beta\_val;}
\DoxyCodeLine{2043       }
\DoxyCodeLine{2044       beta\_has\_zero = (beta\_has\_zero || (beta\_val == zero));}
\DoxyCodeLine{2045       \}}
\DoxyCodeLine{2046     }
\DoxyCodeLine{2047     \textcolor{keywordflow}{if}(beta\_has\_zero)  \{ arma\_debug\_warn\_level(1, \textcolor{stringliteral}{"{}eig\_pair(): given matrices appear ill-\/conditioned"{}}); \}}
\DoxyCodeLine{2048     }
\DoxyCodeLine{2049     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2050     \}}
\DoxyCodeLine{2051 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{2052     \{}
\DoxyCodeLine{2053     arma\_ignore(vals);}
\DoxyCodeLine{2054     arma\_ignore(lvecs);}
\DoxyCodeLine{2055     arma\_ignore(rvecs);}
\DoxyCodeLine{2056     arma\_ignore(A\_expr);}
\DoxyCodeLine{2057     arma\_ignore(B\_expr);}
\DoxyCodeLine{2058     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}eig\_pair(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{2059     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2060     \}}
\DoxyCodeLine{2061 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{2062   \}}
\DoxyCodeLine{2063 }
\DoxyCodeLine{2064 }
\DoxyCodeLine{2065 }
\DoxyCodeLine{2067 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{2068 \textcolor{keyword}{inline}}
\DoxyCodeLine{2069 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2070 \mbox{\hyperlink{group__auxlib_ga69420c7838466b350898295a4ef72cfc}{auxlib::eig\_sym}}(\mbox{\hyperlink{classCol}{Col<eT>}}\& eigval, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<eT,T1>}}\& X)}
\DoxyCodeLine{2071   \{}
\DoxyCodeLine{2072   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2073   }
\DoxyCodeLine{2074 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{2075     \{}
\DoxyCodeLine{2076     \mbox{\hyperlink{classMat}{Mat<eT>}} \mbox{\hyperlink{structA}{A}}(X.get\_ref());}
\DoxyCodeLine{2077     }
\DoxyCodeLine{2078     arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.is\_square() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}eig\_sym(): given matrix must be square sized"{}} );}
\DoxyCodeLine{2079     }
\DoxyCodeLine{2080     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty())}
\DoxyCodeLine{2081       \{}
\DoxyCodeLine{2082       eigval.reset();}
\DoxyCodeLine{2083       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2084       \}}
\DoxyCodeLine{2085     }
\DoxyCodeLine{2086     \textcolor{comment}{// if(auxlib::rudimentary\_sym\_check(A) == false)}}
\DoxyCodeLine{2087     \textcolor{comment}{//   \{}}
\DoxyCodeLine{2088     \textcolor{comment}{//   arma\_debug\_warn\_level(1, "{}eig\_sym(): given matrix is not symmetric"{});}}
\DoxyCodeLine{2089     \textcolor{comment}{//   return false;}}
\DoxyCodeLine{2090     \textcolor{comment}{//   \}}}
\DoxyCodeLine{2091     }
\DoxyCodeLine{2092     \textcolor{keywordflow}{if}((arma\_config::debug) \&\& (auxlib::rudimentary\_sym\_check(\mbox{\hyperlink{structA}{A}}) == \textcolor{keyword}{false}))}
\DoxyCodeLine{2093       \{}
\DoxyCodeLine{2094       arma\_debug\_warn\_level(1, \textcolor{stringliteral}{"{}eig\_sym(): given matrix is not symmetric"{}});}
\DoxyCodeLine{2095       \}}
\DoxyCodeLine{2096     }
\DoxyCodeLine{2097     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{2098     }
\DoxyCodeLine{2099     eigval.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{2100     }
\DoxyCodeLine{2101     \textcolor{keywordtype}{char} jobz  = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{2102     \textcolor{keywordtype}{char} uplo  = \textcolor{charliteral}{'U'};}
\DoxyCodeLine{2103     }
\DoxyCodeLine{2104     blas\_int N     = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{2105     blas\_int lwork = (64+2)*N;  \textcolor{comment}{// lwork\_min = (std::max)(blas\_int(1), 3*N-\/1)}}
\DoxyCodeLine{2106     blas\_int info  = 0;}
\DoxyCodeLine{2107     }
\DoxyCodeLine{2108     \mbox{\hyperlink{classpodarray}{podarray<eT>}} work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork) );}
\DoxyCodeLine{2109     }
\DoxyCodeLine{2110     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::syev()"{}});}
\DoxyCodeLine{2111     lapack::syev(\&jobz, \&uplo, \&N, \mbox{\hyperlink{structA}{A}}.memptr(), \&N, eigval.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), work.memptr(), \&lwork, \&info);}
\DoxyCodeLine{2112     }
\DoxyCodeLine{2113     \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{2114     \}}
\DoxyCodeLine{2115 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{2116     \{}
\DoxyCodeLine{2117     arma\_ignore(eigval);}
\DoxyCodeLine{2118     arma\_ignore(X);}
\DoxyCodeLine{2119     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}eig\_sym(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{2120     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2121     \}}
\DoxyCodeLine{2122 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{2123   \}}
\DoxyCodeLine{2124 }
\DoxyCodeLine{2125 }
\DoxyCodeLine{2126 }
\DoxyCodeLine{2128 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{2129 \textcolor{keyword}{inline}}
\DoxyCodeLine{2130 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2131 \mbox{\hyperlink{group__auxlib_ga69420c7838466b350898295a4ef72cfc}{auxlib::eig\_sym}}(\mbox{\hyperlink{classCol}{Col<T>}}\& eigval, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base}}<std::complex<T>,T1>\& X)}
\DoxyCodeLine{2132   \{}
\DoxyCodeLine{2133   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2134   }
\DoxyCodeLine{2135 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{2136     \{}
\DoxyCodeLine{2137     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<T> eT;}
\DoxyCodeLine{2138     }
\DoxyCodeLine{2139     \mbox{\hyperlink{classMat}{Mat<eT>}} \mbox{\hyperlink{structA}{A}}(X.get\_ref());}
\DoxyCodeLine{2140     }
\DoxyCodeLine{2141     arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.is\_square() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}eig\_sym(): given matrix must be square sized"{}} );}
\DoxyCodeLine{2142     }
\DoxyCodeLine{2143     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty())}
\DoxyCodeLine{2144       \{}
\DoxyCodeLine{2145       eigval.reset();}
\DoxyCodeLine{2146       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2147       \}}
\DoxyCodeLine{2148     }
\DoxyCodeLine{2149     \textcolor{comment}{// if(auxlib::rudimentary\_sym\_check(A) == false)}}
\DoxyCodeLine{2150     \textcolor{comment}{//   \{}}
\DoxyCodeLine{2151     \textcolor{comment}{//   arma\_debug\_warn\_level(1, "{}eig\_sym(): given matrix is not hermitian"{});}}
\DoxyCodeLine{2152     \textcolor{comment}{//   return false;}}
\DoxyCodeLine{2153     \textcolor{comment}{//   \}}}
\DoxyCodeLine{2154     }
\DoxyCodeLine{2155     \textcolor{keywordflow}{if}((arma\_config::debug) \&\& (auxlib::rudimentary\_sym\_check(\mbox{\hyperlink{structA}{A}}) == \textcolor{keyword}{false}))}
\DoxyCodeLine{2156       \{}
\DoxyCodeLine{2157       arma\_debug\_warn\_level(1, \textcolor{stringliteral}{"{}eig\_sym(): given matrix is not hermitian"{}});}
\DoxyCodeLine{2158       \}}
\DoxyCodeLine{2159     }
\DoxyCodeLine{2160     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{2161     }
\DoxyCodeLine{2162     eigval.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{2163     }
\DoxyCodeLine{2164     \textcolor{keywordtype}{char} jobz  = \textcolor{charliteral}{'N'}; }
\DoxyCodeLine{2165     \textcolor{keywordtype}{char} uplo  = \textcolor{charliteral}{'U'};}
\DoxyCodeLine{2166     }
\DoxyCodeLine{2167     blas\_int N     = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{2168     blas\_int lwork = (64+1)*N;  \textcolor{comment}{// lwork\_min = (std::max)(blas\_int(1), 2*N-\/1)}}
\DoxyCodeLine{2169     blas\_int info  = 0;}
\DoxyCodeLine{2170     }
\DoxyCodeLine{2171     \mbox{\hyperlink{classpodarray}{podarray<eT>}}  work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork) );}
\DoxyCodeLine{2172     \mbox{\hyperlink{classpodarray}{podarray<T>}}  rwork( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}( (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(blas\_int(1), 3*N) ) );}
\DoxyCodeLine{2173     }
\DoxyCodeLine{2174     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::heev()"{}});}
\DoxyCodeLine{2175     lapack::heev(\&jobz, \&uplo, \&N, \mbox{\hyperlink{structA}{A}}.memptr(), \&N, eigval.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), work.memptr(), \&lwork, rwork.memptr(), \&info);}
\DoxyCodeLine{2176     }
\DoxyCodeLine{2177     \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{2178     \}}
\DoxyCodeLine{2179 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{2180     \{}
\DoxyCodeLine{2181     arma\_ignore(eigval);}
\DoxyCodeLine{2182     arma\_ignore(X);}
\DoxyCodeLine{2183     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}eig\_sym(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{2184     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2185     \}}
\DoxyCodeLine{2186 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{2187   \}}
\DoxyCodeLine{2188 }
\DoxyCodeLine{2189 }
\DoxyCodeLine{2190 }
\DoxyCodeLine{2192 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{2193 \textcolor{keyword}{inline}}
\DoxyCodeLine{2194 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2195 \mbox{\hyperlink{group__auxlib_ga69420c7838466b350898295a4ef72cfc}{auxlib::eig\_sym}}(\mbox{\hyperlink{classCol}{Col<eT>}}\& eigval, \mbox{\hyperlink{classMat}{Mat<eT>}}\& eigvec, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X)}
\DoxyCodeLine{2196   \{}
\DoxyCodeLine{2197   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2198   }
\DoxyCodeLine{2199 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{2200     \{}
\DoxyCodeLine{2201     eigvec = X;}
\DoxyCodeLine{2202     }
\DoxyCodeLine{2203     arma\_debug\_check( (eigvec.\mbox{\hyperlink{group__Mat_ga1f860b22491beb19251642270d04d8f1}{is\_square}}() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}eig\_sym(): given matrix must be square sized"{}} );}
\DoxyCodeLine{2204     }
\DoxyCodeLine{2205     \textcolor{keywordflow}{if}(eigvec.\mbox{\hyperlink{group__Mat_ga3008049216e02308ff665862f451a7ff}{is\_empty}}())}
\DoxyCodeLine{2206       \{}
\DoxyCodeLine{2207       eigval.reset();}
\DoxyCodeLine{2208       eigvec.reset();}
\DoxyCodeLine{2209       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2210       \}}
\DoxyCodeLine{2211     }
\DoxyCodeLine{2212     arma\_debug\_assert\_blas\_size(eigvec);}
\DoxyCodeLine{2213     }
\DoxyCodeLine{2214     eigval.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(eigvec.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{2215     }
\DoxyCodeLine{2216     \textcolor{keywordtype}{char} jobz  = \textcolor{charliteral}{'V'};}
\DoxyCodeLine{2217     \textcolor{keywordtype}{char} uplo  = \textcolor{charliteral}{'U'};}
\DoxyCodeLine{2218     }
\DoxyCodeLine{2219     blas\_int N     = blas\_int(eigvec.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{2220     blas\_int lwork = (64+2)*N;  \textcolor{comment}{// lwork\_min = (std::max)(blas\_int(1), 3*N-\/1)}}
\DoxyCodeLine{2221     blas\_int info  = 0;}
\DoxyCodeLine{2222     }
\DoxyCodeLine{2223     \mbox{\hyperlink{classpodarray}{podarray<eT>}} work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork) );}
\DoxyCodeLine{2224     }
\DoxyCodeLine{2225     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::syev()"{}});}
\DoxyCodeLine{2226     lapack::syev(\&jobz, \&uplo, \&N, eigvec.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&N, eigval.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), work.memptr(), \&lwork, \&info);}
\DoxyCodeLine{2227     }
\DoxyCodeLine{2228     \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{2229     \}}
\DoxyCodeLine{2230 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{2231     \{}
\DoxyCodeLine{2232     arma\_ignore(eigval);}
\DoxyCodeLine{2233     arma\_ignore(eigvec);}
\DoxyCodeLine{2234     arma\_ignore(X);}
\DoxyCodeLine{2235     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}eig\_sym(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{2236     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2237     \}}
\DoxyCodeLine{2238 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{2239   \}}
\DoxyCodeLine{2240 }
\DoxyCodeLine{2241 }
\DoxyCodeLine{2242 }
\DoxyCodeLine{2244 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2245 \textcolor{keyword}{inline}}
\DoxyCodeLine{2246 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2247 \mbox{\hyperlink{group__auxlib_ga69420c7838466b350898295a4ef72cfc}{auxlib::eig\_sym}}(\mbox{\hyperlink{classCol}{Col<T>}}\& eigval, \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& eigvec, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& X)}
\DoxyCodeLine{2248   \{}
\DoxyCodeLine{2249   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2250   }
\DoxyCodeLine{2251 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{2252     \{}
\DoxyCodeLine{2253     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<T> eT;}
\DoxyCodeLine{2254     }
\DoxyCodeLine{2255     eigvec = X;}
\DoxyCodeLine{2256     }
\DoxyCodeLine{2257     arma\_debug\_check( (eigvec.is\_square() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}eig\_sym(): given matrix must be square sized"{}} );}
\DoxyCodeLine{2258     }
\DoxyCodeLine{2259     \textcolor{keywordflow}{if}(eigvec.is\_empty())}
\DoxyCodeLine{2260       \{}
\DoxyCodeLine{2261       eigval.reset();}
\DoxyCodeLine{2262       eigvec.reset();}
\DoxyCodeLine{2263       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2264       \}}
\DoxyCodeLine{2265     }
\DoxyCodeLine{2266     arma\_debug\_assert\_blas\_size(eigvec);}
\DoxyCodeLine{2267     }
\DoxyCodeLine{2268     eigval.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(eigvec.n\_rows);}
\DoxyCodeLine{2269     }
\DoxyCodeLine{2270     \textcolor{keywordtype}{char} jobz  = \textcolor{charliteral}{'V'};}
\DoxyCodeLine{2271     \textcolor{keywordtype}{char} uplo  = \textcolor{charliteral}{'U'};}
\DoxyCodeLine{2272     }
\DoxyCodeLine{2273     blas\_int N     = blas\_int(eigvec.n\_rows);}
\DoxyCodeLine{2274     blas\_int lwork = (64+1)*N;  \textcolor{comment}{// lwork\_min = (std::max)(blas\_int(1), 2*N-\/1)}}
\DoxyCodeLine{2275     blas\_int info  = 0;}
\DoxyCodeLine{2276     }
\DoxyCodeLine{2277     \mbox{\hyperlink{classpodarray}{podarray<eT>}}  work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork) );}
\DoxyCodeLine{2278     \mbox{\hyperlink{classpodarray}{podarray<T>}}  rwork( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}((\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(blas\_int(1), 3*N)) );}
\DoxyCodeLine{2279     }
\DoxyCodeLine{2280     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::heev()"{}});}
\DoxyCodeLine{2281     lapack::heev(\&jobz, \&uplo, \&N, eigvec.memptr(), \&N, eigval.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), work.memptr(), \&lwork, rwork.memptr(), \&info);}
\DoxyCodeLine{2282     }
\DoxyCodeLine{2283     \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{2284     \}}
\DoxyCodeLine{2285 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{2286     \{}
\DoxyCodeLine{2287     arma\_ignore(eigval);}
\DoxyCodeLine{2288     arma\_ignore(eigvec);}
\DoxyCodeLine{2289     arma\_ignore(X);}
\DoxyCodeLine{2290     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}eig\_sym(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{2291     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2292     \}}
\DoxyCodeLine{2293 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{2294   \}}
\DoxyCodeLine{2295 }
\DoxyCodeLine{2296 }
\DoxyCodeLine{2297 }
\DoxyCodeLine{2299 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{2300 \textcolor{keyword}{inline}}
\DoxyCodeLine{2301 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2302 \mbox{\hyperlink{group__auxlib_gaa1d75898809ba17eaff0143e6ca8ae88}{auxlib::eig\_sym\_dc}}(\mbox{\hyperlink{classCol}{Col<eT>}}\& eigval, \mbox{\hyperlink{classMat}{Mat<eT>}}\& eigvec, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X)}
\DoxyCodeLine{2303   \{}
\DoxyCodeLine{2304   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2305   }
\DoxyCodeLine{2306 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{2307     \{}
\DoxyCodeLine{2308     eigvec = X;}
\DoxyCodeLine{2309     }
\DoxyCodeLine{2310     arma\_debug\_check( (eigvec.\mbox{\hyperlink{group__Mat_ga1f860b22491beb19251642270d04d8f1}{is\_square}}() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}eig\_sym(): given matrix must be square sized"{}} );}
\DoxyCodeLine{2311     }
\DoxyCodeLine{2312     \textcolor{keywordflow}{if}(eigvec.\mbox{\hyperlink{group__Mat_ga3008049216e02308ff665862f451a7ff}{is\_empty}}())}
\DoxyCodeLine{2313       \{}
\DoxyCodeLine{2314       eigval.reset();}
\DoxyCodeLine{2315       eigvec.reset();}
\DoxyCodeLine{2316       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2317       \}}
\DoxyCodeLine{2318     }
\DoxyCodeLine{2319     arma\_debug\_assert\_blas\_size(eigvec);}
\DoxyCodeLine{2320     }
\DoxyCodeLine{2321     eigval.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(eigvec.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{2322     }
\DoxyCodeLine{2323     \textcolor{keywordtype}{char} jobz = \textcolor{charliteral}{'V'};}
\DoxyCodeLine{2324     \textcolor{keywordtype}{char} uplo = \textcolor{charliteral}{'U'};}
\DoxyCodeLine{2325     }
\DoxyCodeLine{2326     blas\_int N          = blas\_int(eigvec.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{2327     blas\_int lwork\_min  = 1 + 6*N + 2*(N*N);}
\DoxyCodeLine{2328     blas\_int liwork\_min = 3 + 5*N;}
\DoxyCodeLine{2329     blas\_int info       = 0;}
\DoxyCodeLine{2330     }
\DoxyCodeLine{2331     blas\_int  lwork\_proposed = 0;}
\DoxyCodeLine{2332     blas\_int liwork\_proposed = 0;}
\DoxyCodeLine{2333     }
\DoxyCodeLine{2334     \textcolor{keywordflow}{if}(N >= 32)}
\DoxyCodeLine{2335       \{}
\DoxyCodeLine{2336       eT        work\_query[2];}
\DoxyCodeLine{2337       blas\_int iwork\_query[2];}
\DoxyCodeLine{2338       }
\DoxyCodeLine{2339       blas\_int  lwork\_query = -\/1;}
\DoxyCodeLine{2340       blas\_int liwork\_query = -\/1;}
\DoxyCodeLine{2341       }
\DoxyCodeLine{2342       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::syevd()"{}});}
\DoxyCodeLine{2343       lapack::syevd(\&jobz, \&uplo, \&N, eigvec.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&N, eigval.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&work\_query[0], \&lwork\_query, \&iwork\_query[0], \&liwork\_query, \&info);}
\DoxyCodeLine{2344       }
\DoxyCodeLine{2345       \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2346       }
\DoxyCodeLine{2347        lwork\_proposed = \textcolor{keyword}{static\_cast<}blas\_int\textcolor{keyword}{>}( work\_query[0] );}
\DoxyCodeLine{2348       liwork\_proposed = iwork\_query[0];}
\DoxyCodeLine{2349       \}}
\DoxyCodeLine{2350     }
\DoxyCodeLine{2351     blas\_int  lwork\_final = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})( lwork\_proposed,  lwork\_min);}
\DoxyCodeLine{2352     blas\_int liwork\_final = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(liwork\_proposed, liwork\_min);}
\DoxyCodeLine{2353     }
\DoxyCodeLine{2354     \mbox{\hyperlink{classpodarray}{podarray<eT>}}        work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}( lwork\_final) );}
\DoxyCodeLine{2355     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} iwork( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(liwork\_final) ); }
\DoxyCodeLine{2356     }
\DoxyCodeLine{2357     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::syevd()"{}});}
\DoxyCodeLine{2358     lapack::syevd(\&jobz, \&uplo, \&N, eigvec.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&N, eigval.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), work.memptr(), \&lwork\_final, iwork.memptr(), \&liwork\_final, \&info);}
\DoxyCodeLine{2359     }
\DoxyCodeLine{2360     \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{2361     \}}
\DoxyCodeLine{2362 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{2363     \{}
\DoxyCodeLine{2364     arma\_ignore(eigval);}
\DoxyCodeLine{2365     arma\_ignore(eigvec);}
\DoxyCodeLine{2366     arma\_ignore(X);}
\DoxyCodeLine{2367     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}eig\_sym(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{2368     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2369     \}}
\DoxyCodeLine{2370 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{2371   \}}
\DoxyCodeLine{2372 }
\DoxyCodeLine{2373 }
\DoxyCodeLine{2374 }
\DoxyCodeLine{2376 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2377 \textcolor{keyword}{inline}}
\DoxyCodeLine{2378 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2379 \mbox{\hyperlink{group__auxlib_gaa1d75898809ba17eaff0143e6ca8ae88}{auxlib::eig\_sym\_dc}}(\mbox{\hyperlink{classCol}{Col<T>}}\& eigval, \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& eigvec, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& X)}
\DoxyCodeLine{2380   \{}
\DoxyCodeLine{2381   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2382   }
\DoxyCodeLine{2383 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{2384     \{}
\DoxyCodeLine{2385     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<T> eT;}
\DoxyCodeLine{2386     }
\DoxyCodeLine{2387     eigvec = X;}
\DoxyCodeLine{2388     }
\DoxyCodeLine{2389     arma\_debug\_check( (eigvec.is\_square() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}eig\_sym(): given matrix must be square sized"{}} );}
\DoxyCodeLine{2390     }
\DoxyCodeLine{2391     \textcolor{keywordflow}{if}(eigvec.is\_empty())}
\DoxyCodeLine{2392       \{}
\DoxyCodeLine{2393       eigval.reset();}
\DoxyCodeLine{2394       eigvec.reset();}
\DoxyCodeLine{2395       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2396       \}}
\DoxyCodeLine{2397     }
\DoxyCodeLine{2398     arma\_debug\_assert\_blas\_size(eigvec);}
\DoxyCodeLine{2399     }
\DoxyCodeLine{2400     eigval.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(eigvec.n\_rows);}
\DoxyCodeLine{2401     }
\DoxyCodeLine{2402     \textcolor{keywordtype}{char} jobz  = \textcolor{charliteral}{'V'};}
\DoxyCodeLine{2403     \textcolor{keywordtype}{char} uplo  = \textcolor{charliteral}{'U'};}
\DoxyCodeLine{2404     }
\DoxyCodeLine{2405     blas\_int N          = blas\_int(eigvec.n\_rows);}
\DoxyCodeLine{2406     blas\_int lwork\_min  = 2*N + N*N;}
\DoxyCodeLine{2407     blas\_int lrwork\_min = 1 + 5*N + 2*(N*N);}
\DoxyCodeLine{2408     blas\_int liwork\_min = 3 + 5*N;}
\DoxyCodeLine{2409     blas\_int info       = 0;}
\DoxyCodeLine{2410     }
\DoxyCodeLine{2411     blas\_int  lwork\_proposed = 0;}
\DoxyCodeLine{2412     blas\_int lrwork\_proposed = 0;}
\DoxyCodeLine{2413     blas\_int liwork\_proposed = 0;}
\DoxyCodeLine{2414     }
\DoxyCodeLine{2415     \textcolor{keywordflow}{if}(N >= 32)}
\DoxyCodeLine{2416       \{}
\DoxyCodeLine{2417       eT        work\_query[2];}
\DoxyCodeLine{2418       T        rwork\_query[2];}
\DoxyCodeLine{2419       blas\_int iwork\_query[2];}
\DoxyCodeLine{2420       }
\DoxyCodeLine{2421       blas\_int  lwork\_query = -\/1;}
\DoxyCodeLine{2422       blas\_int lrwork\_query = -\/1;}
\DoxyCodeLine{2423       blas\_int liwork\_query = -\/1;}
\DoxyCodeLine{2424       }
\DoxyCodeLine{2425       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::heevd()"{}});}
\DoxyCodeLine{2426       lapack::heevd(\&jobz, \&uplo, \&N, eigvec.memptr(), \&N, eigval.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&work\_query[0], \&lwork\_query, \&rwork\_query[0], \&lrwork\_query, \&iwork\_query[0], \&liwork\_query, \&info);}
\DoxyCodeLine{2427       }
\DoxyCodeLine{2428       \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2429       }
\DoxyCodeLine{2430        lwork\_proposed = \textcolor{keyword}{static\_cast<}blas\_int\textcolor{keyword}{>}( \mbox{\hyperlink{classaccess_a9687cee4d2be0fe591998d6f5c6d0849}{access::tmp\_real}}(work\_query[0]) );}
\DoxyCodeLine{2431       lrwork\_proposed = \textcolor{keyword}{static\_cast<}blas\_int\textcolor{keyword}{>}( rwork\_query[0] );}
\DoxyCodeLine{2432       liwork\_proposed = iwork\_query[0];}
\DoxyCodeLine{2433       \}}
\DoxyCodeLine{2434     }
\DoxyCodeLine{2435     blas\_int  lwork\_final = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})( lwork\_proposed,  lwork\_min);}
\DoxyCodeLine{2436     blas\_int lrwork\_final = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(lrwork\_proposed, lrwork\_min);}
\DoxyCodeLine{2437     blas\_int liwork\_final = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(liwork\_proposed, liwork\_min);}
\DoxyCodeLine{2438     }
\DoxyCodeLine{2439     \mbox{\hyperlink{classpodarray}{podarray<eT>}}        work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}( lwork\_final) );}
\DoxyCodeLine{2440     \mbox{\hyperlink{classpodarray}{podarray< T>}}       rwork( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lrwork\_final) );}
\DoxyCodeLine{2441     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} iwork( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(liwork\_final) ); }
\DoxyCodeLine{2442     }
\DoxyCodeLine{2443     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::heevd()"{}});}
\DoxyCodeLine{2444     lapack::heevd(\&jobz, \&uplo, \&N, eigvec.memptr(), \&N, eigval.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), work.memptr(), \&lwork\_final, rwork.memptr(), \&lrwork\_final, iwork.memptr(), \&liwork\_final, \&info);}
\DoxyCodeLine{2445     }
\DoxyCodeLine{2446     \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{2447     \}}
\DoxyCodeLine{2448 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{2449     \{}
\DoxyCodeLine{2450     arma\_ignore(eigval);}
\DoxyCodeLine{2451     arma\_ignore(eigvec);}
\DoxyCodeLine{2452     arma\_ignore(X);}
\DoxyCodeLine{2453     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}eig\_sym(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{2454     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2455     \}}
\DoxyCodeLine{2456 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{2457   \}}
\DoxyCodeLine{2458 }
\DoxyCodeLine{2459 }
\DoxyCodeLine{2460 }
\DoxyCodeLine{2461 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{2462 \textcolor{keyword}{inline}}
\DoxyCodeLine{2463 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2464 auxlib::chol\_simple(\mbox{\hyperlink{classMat}{Mat<eT>}}\& X)}
\DoxyCodeLine{2465   \{}
\DoxyCodeLine{2466   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2467   }
\DoxyCodeLine{2468 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_ATLAS)}}
\DoxyCodeLine{2469     \{}
\DoxyCodeLine{2470     arma\_debug\_assert\_atlas\_size(X);}
\DoxyCodeLine{2471     }
\DoxyCodeLine{2472     \textcolor{keywordtype}{int} info = 0;}
\DoxyCodeLine{2473     }
\DoxyCodeLine{2474     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}atlas::clapack\_potrf()"{}});}
\DoxyCodeLine{2475     info = atlas::clapack\_potrf(atlas::CblasColMajor, atlas::CblasUpper, X.n\_rows, X.memptr(), X.n\_rows);}
\DoxyCodeLine{2476     }
\DoxyCodeLine{2477     \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{2478     \}}
\DoxyCodeLine{2479 \textcolor{preprocessor}{  \#elif defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{2480     \{}
\DoxyCodeLine{2481     arma\_debug\_assert\_blas\_size(X);}
\DoxyCodeLine{2482     }
\DoxyCodeLine{2483     \textcolor{keywordtype}{char}      uplo = \textcolor{charliteral}{'U'};}
\DoxyCodeLine{2484     blas\_int  n    = blas\_int(X.n\_rows);}
\DoxyCodeLine{2485     blas\_int  info = 0;}
\DoxyCodeLine{2486     }
\DoxyCodeLine{2487     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::potrf()"{}});}
\DoxyCodeLine{2488     lapack::potrf(\&uplo, \&n, X.memptr(), \&n, \&info);}
\DoxyCodeLine{2489     }
\DoxyCodeLine{2490     \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{2491     \}}
\DoxyCodeLine{2492 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{2493     \{}
\DoxyCodeLine{2494     arma\_ignore(X);}
\DoxyCodeLine{2495     }
\DoxyCodeLine{2496     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}chol(): use of ATLAS or LAPACK must be enabled"{}});}
\DoxyCodeLine{2497     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2498     \}}
\DoxyCodeLine{2499 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{2500   \}}
\DoxyCodeLine{2501 }
\DoxyCodeLine{2502 }
\DoxyCodeLine{2503 }
\DoxyCodeLine{2504 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{2505 \textcolor{keyword}{inline}}
\DoxyCodeLine{2506 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2507 auxlib::chol(\mbox{\hyperlink{classMat}{Mat<eT>}}\& X, \textcolor{keyword}{const} uword layout)}
\DoxyCodeLine{2508   \{}
\DoxyCodeLine{2509   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2510   }
\DoxyCodeLine{2511 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_ATLAS)}}
\DoxyCodeLine{2512     \{}
\DoxyCodeLine{2513     arma\_debug\_assert\_atlas\_size(X);}
\DoxyCodeLine{2514     }
\DoxyCodeLine{2515     \textcolor{keywordtype}{int} info = 0;}
\DoxyCodeLine{2516     }
\DoxyCodeLine{2517     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}atlas::clapack\_potrf()"{}});}
\DoxyCodeLine{2518     info = atlas::clapack\_potrf(atlas::CblasColMajor, ((layout == 0) ? atlas::CblasUpper : atlas::CblasLower), X.n\_rows, X.memptr(), X.n\_rows);}
\DoxyCodeLine{2519     }
\DoxyCodeLine{2520     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2521     }
\DoxyCodeLine{2522     X = (layout == 0) ? trimatu(X) : trimatl(X);  \textcolor{comment}{// trimatu() and trimatl() return the same type}}
\DoxyCodeLine{2523     }
\DoxyCodeLine{2524     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2525     \}}
\DoxyCodeLine{2526 \textcolor{preprocessor}{  \#elif defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{2527     \{}
\DoxyCodeLine{2528     arma\_debug\_assert\_blas\_size(X);}
\DoxyCodeLine{2529     }
\DoxyCodeLine{2530     \textcolor{keywordtype}{char}      uplo = (layout == 0) ? \textcolor{charliteral}{'U'} : \textcolor{charliteral}{'L'};}
\DoxyCodeLine{2531     blas\_int  n    = blas\_int(X.n\_rows);}
\DoxyCodeLine{2532     blas\_int  info = 0;}
\DoxyCodeLine{2533     }
\DoxyCodeLine{2534     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::potrf()"{}});}
\DoxyCodeLine{2535     lapack::potrf(\&uplo, \&n, X.memptr(), \&n, \&info);}
\DoxyCodeLine{2536     }
\DoxyCodeLine{2537     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2538     }
\DoxyCodeLine{2539     X = (layout == 0) ? trimatu(X) : trimatl(X);  \textcolor{comment}{// trimatu() and trimatl() return the same type}}
\DoxyCodeLine{2540     }
\DoxyCodeLine{2541     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2542     \}}
\DoxyCodeLine{2543 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{2544     \{}
\DoxyCodeLine{2545     arma\_ignore(X);}
\DoxyCodeLine{2546     arma\_ignore(layout);}
\DoxyCodeLine{2547     }
\DoxyCodeLine{2548     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}chol(): use of ATLAS or LAPACK must be enabled"{}});}
\DoxyCodeLine{2549     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2550     \}}
\DoxyCodeLine{2551 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{2552   \}}
\DoxyCodeLine{2553 }
\DoxyCodeLine{2554 }
\DoxyCodeLine{2555 }
\DoxyCodeLine{2556 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{2557 \textcolor{keyword}{inline}}
\DoxyCodeLine{2558 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2559 auxlib::chol\_band(\mbox{\hyperlink{classMat}{Mat<eT>}}\& X, \textcolor{keyword}{const} uword KD, \textcolor{keyword}{const} uword layout)}
\DoxyCodeLine{2560   \{}
\DoxyCodeLine{2561   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2562   }
\DoxyCodeLine{2563   \textcolor{keywordflow}{return} auxlib::chol\_band\_common(X, KD, layout);}
\DoxyCodeLine{2564   \}}
\DoxyCodeLine{2565 }
\DoxyCodeLine{2566 }
\DoxyCodeLine{2567 }
\DoxyCodeLine{2568 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2569 \textcolor{keyword}{inline}}
\DoxyCodeLine{2570 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2571 auxlib::chol\_band(\mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& X, \textcolor{keyword}{const} uword KD, \textcolor{keyword}{const} uword layout)}
\DoxyCodeLine{2572   \{}
\DoxyCodeLine{2573   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2574   }
\DoxyCodeLine{2575 \textcolor{preprocessor}{  \#if defined(ARMA\_CRIPPLED\_LAPACK)}}
\DoxyCodeLine{2576     \{}
\DoxyCodeLine{2577     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}auxlib::chol\_band(): redirecting to auxlib::chol() due to crippled LAPACK"{}});}
\DoxyCodeLine{2578     }
\DoxyCodeLine{2579     arma\_ignore(KD);}
\DoxyCodeLine{2580     }
\DoxyCodeLine{2581     \textcolor{keywordflow}{return} auxlib::chol(X, layout);}
\DoxyCodeLine{2582     \}}
\DoxyCodeLine{2583 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{2584     \{}
\DoxyCodeLine{2585     \textcolor{keywordflow}{return} auxlib::chol\_band\_common(X, KD, layout);}
\DoxyCodeLine{2586     \}}
\DoxyCodeLine{2587 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{2588   \}}
\DoxyCodeLine{2589 }
\DoxyCodeLine{2590 }
\DoxyCodeLine{2591 }
\DoxyCodeLine{2592 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{2593 \textcolor{keyword}{inline}}
\DoxyCodeLine{2594 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2595 auxlib::chol\_band\_common(\mbox{\hyperlink{classMat}{Mat<eT>}}\& X, \textcolor{keyword}{const} uword KD, \textcolor{keyword}{const} uword layout)}
\DoxyCodeLine{2596   \{}
\DoxyCodeLine{2597   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2598   }
\DoxyCodeLine{2599 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{2600     \{}
\DoxyCodeLine{2601     \textcolor{keyword}{const} uword N = X.n\_rows;}
\DoxyCodeLine{2602     }
\DoxyCodeLine{2603     \textcolor{keyword}{const} uword KL = (layout == 0) ? uword(0) : KD;}
\DoxyCodeLine{2604     \textcolor{keyword}{const} uword KU = (layout == 0) ? KD       : uword(0);}
\DoxyCodeLine{2605     }
\DoxyCodeLine{2606     \mbox{\hyperlink{classMat}{Mat<eT>}} AB;}
\DoxyCodeLine{2607     band\_helper::compress(AB, X, KL, KU, \textcolor{keyword}{false});}
\DoxyCodeLine{2608     }
\DoxyCodeLine{2609     arma\_debug\_assert\_blas\_size(AB);}
\DoxyCodeLine{2610     }
\DoxyCodeLine{2611     \textcolor{keywordtype}{char}     uplo = (layout == 0) ? \textcolor{charliteral}{'U'} : \textcolor{charliteral}{'L'};}
\DoxyCodeLine{2612     blas\_int n    = blas\_int(N);}
\DoxyCodeLine{2613     blas\_int kd   = blas\_int(KD);}
\DoxyCodeLine{2614     blas\_int ldab = blas\_int(AB.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{2615     blas\_int info = 0;}
\DoxyCodeLine{2616     }
\DoxyCodeLine{2617     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::pbtrf()"{}});}
\DoxyCodeLine{2618     lapack::pbtrf(\&uplo, \&n, \&kd, AB.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldab, \&info);}
\DoxyCodeLine{2619     }
\DoxyCodeLine{2620     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2621     }
\DoxyCodeLine{2622     band\_helper::uncompress(X, AB, KL, KU, \textcolor{keyword}{false});}
\DoxyCodeLine{2623     }
\DoxyCodeLine{2624     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2625     \}}
\DoxyCodeLine{2626 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{2627     \{}
\DoxyCodeLine{2628     arma\_ignore(X);}
\DoxyCodeLine{2629     arma\_ignore(KD);}
\DoxyCodeLine{2630     arma\_ignore(layout);}
\DoxyCodeLine{2631     }
\DoxyCodeLine{2632     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}chol(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{2633     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2634     \}}
\DoxyCodeLine{2635 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{2636   \}}
\DoxyCodeLine{2637 }
\DoxyCodeLine{2638 }
\DoxyCodeLine{2639 \textcolor{comment}{//}}
\DoxyCodeLine{2640 \textcolor{comment}{// hessenberg decomposition}}
\DoxyCodeLine{2641 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{2642 \textcolor{keyword}{inline}}
\DoxyCodeLine{2643 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2644 auxlib::hess(\mbox{\hyperlink{classMat}{Mat<eT>}}\& H, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<eT,T1>}}\& X, \mbox{\hyperlink{classCol}{Col<eT>}}\& tao)}
\DoxyCodeLine{2645   \{}
\DoxyCodeLine{2646   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2647   }
\DoxyCodeLine{2648 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{2649     \{}
\DoxyCodeLine{2650     H = X.get\_ref();}
\DoxyCodeLine{2651     }
\DoxyCodeLine{2652     arma\_debug\_check( (H.\mbox{\hyperlink{group__Mat_ga1f860b22491beb19251642270d04d8f1}{is\_square}}() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}hess(): given matrix must be square sized"{}} );}
\DoxyCodeLine{2653     }
\DoxyCodeLine{2654     \textcolor{keywordflow}{if}(H.\mbox{\hyperlink{group__Mat_ga3008049216e02308ff665862f451a7ff}{is\_empty}}())}
\DoxyCodeLine{2655       \{}
\DoxyCodeLine{2656       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2657       \}}
\DoxyCodeLine{2658     }
\DoxyCodeLine{2659     arma\_debug\_assert\_blas\_size(H);}
\DoxyCodeLine{2660     }
\DoxyCodeLine{2661     \textcolor{keywordflow}{if}(H.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}} > 2)}
\DoxyCodeLine{2662       \{}
\DoxyCodeLine{2663       tao.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(H.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}}-\/1);}
\DoxyCodeLine{2664       }
\DoxyCodeLine{2665       blas\_int  n      = blas\_int(H.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{2666       blas\_int  ilo    = 1;}
\DoxyCodeLine{2667       blas\_int  ihi    = blas\_int(H.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{2668       blas\_int  lda    = blas\_int(H.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{2669       blas\_int  lwork  = blas\_int(H.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}}) * 64;}
\DoxyCodeLine{2670       blas\_int  info   = 0;}
\DoxyCodeLine{2671       }
\DoxyCodeLine{2672       \mbox{\hyperlink{classpodarray}{podarray<eT>}} work(\textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork));}
\DoxyCodeLine{2673       }
\DoxyCodeLine{2674       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::gehrd()"{}});}
\DoxyCodeLine{2675       lapack::gehrd(\&n, \&ilo, \&ihi, H.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&lda, tao.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), work.memptr(), \&lwork, \&info);}
\DoxyCodeLine{2676       }
\DoxyCodeLine{2677       \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{2678       \}}
\DoxyCodeLine{2679     }
\DoxyCodeLine{2680     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2681     \}}
\DoxyCodeLine{2682 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{2683     \{}
\DoxyCodeLine{2684     arma\_ignore(H);}
\DoxyCodeLine{2685     arma\_ignore(X);}
\DoxyCodeLine{2686     arma\_ignore(tao);}
\DoxyCodeLine{2687     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}hess(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{2688     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2689     \}}
\DoxyCodeLine{2690 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{2691   \}}
\DoxyCodeLine{2692 }
\DoxyCodeLine{2693 }
\DoxyCodeLine{2694 }
\DoxyCodeLine{2695 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{2696 \textcolor{keyword}{inline}}
\DoxyCodeLine{2697 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2698 auxlib::qr(\mbox{\hyperlink{classMat}{Mat<eT>}}\& Q, \mbox{\hyperlink{classMat}{Mat<eT>}}\& R, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<eT,T1>}}\& X)}
\DoxyCodeLine{2699   \{}
\DoxyCodeLine{2700   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2701   }
\DoxyCodeLine{2702 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{2703     \{}
\DoxyCodeLine{2704     R = X.get\_ref();}
\DoxyCodeLine{2705     }
\DoxyCodeLine{2706     \textcolor{keyword}{const} uword R\_n\_rows = R.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}};}
\DoxyCodeLine{2707     \textcolor{keyword}{const} uword R\_n\_cols = R.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}};}
\DoxyCodeLine{2708     }
\DoxyCodeLine{2709     \textcolor{keywordflow}{if}(R.\mbox{\hyperlink{group__Mat_ga3008049216e02308ff665862f451a7ff}{is\_empty}}())}
\DoxyCodeLine{2710       \{}
\DoxyCodeLine{2711       Q.eye(R\_n\_rows, R\_n\_rows);}
\DoxyCodeLine{2712       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2713       \}}
\DoxyCodeLine{2714     }
\DoxyCodeLine{2715     arma\_debug\_assert\_blas\_size(R);}
\DoxyCodeLine{2716     }
\DoxyCodeLine{2717     blas\_int m         = \textcolor{keyword}{static\_cast<}blas\_int\textcolor{keyword}{>}(R\_n\_rows);}
\DoxyCodeLine{2718     blas\_int n         = \textcolor{keyword}{static\_cast<}blas\_int\textcolor{keyword}{>}(R\_n\_cols);}
\DoxyCodeLine{2719     blas\_int lwork\_min = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(blas\_int(1), (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(m,n));  \textcolor{comment}{// take into account requirements of geqrf() \_and\_ orgqr()/ungqr()}}
\DoxyCodeLine{2720     blas\_int k         = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(m,n);}
\DoxyCodeLine{2721     blas\_int info      = 0;}
\DoxyCodeLine{2722     }
\DoxyCodeLine{2723     \mbox{\hyperlink{classpodarray}{podarray<eT>}} tau( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(k) );}
\DoxyCodeLine{2724     }
\DoxyCodeLine{2725     eT        work\_query[2];}
\DoxyCodeLine{2726     blas\_int lwork\_query = -\/1;}
\DoxyCodeLine{2727     }
\DoxyCodeLine{2728     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::geqrf()"{}});}
\DoxyCodeLine{2729     lapack::geqrf(\&m, \&n, R.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&m, tau.memptr(), \&work\_query[0], \&lwork\_query, \&info);}
\DoxyCodeLine{2730     }
\DoxyCodeLine{2731     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2732     }
\DoxyCodeLine{2733     blas\_int lwork\_proposed = \textcolor{keyword}{static\_cast<}blas\_int\textcolor{keyword}{>}( \mbox{\hyperlink{classaccess_a9687cee4d2be0fe591998d6f5c6d0849}{access::tmp\_real}}(work\_query[0]) );}
\DoxyCodeLine{2734     blas\_int lwork\_final    = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(lwork\_proposed, lwork\_min);}
\DoxyCodeLine{2735     }
\DoxyCodeLine{2736     \mbox{\hyperlink{classpodarray}{podarray<eT>}} work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork\_final) );}
\DoxyCodeLine{2737     }
\DoxyCodeLine{2738     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::geqrf()"{}});}
\DoxyCodeLine{2739     lapack::geqrf(\&m, \&n, R.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&m, tau.memptr(), work.memptr(), \&lwork\_final, \&info);}
\DoxyCodeLine{2740     }
\DoxyCodeLine{2741     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2742     }
\DoxyCodeLine{2743     Q.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(R\_n\_rows, R\_n\_rows);}
\DoxyCodeLine{2744     }
\DoxyCodeLine{2745     arrayops::copy( Q.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), R.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(Q.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}}, R.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}}) );}
\DoxyCodeLine{2746     }
\DoxyCodeLine{2747     \textcolor{comment}{//}}
\DoxyCodeLine{2748     \textcolor{comment}{// construct R}}
\DoxyCodeLine{2749     }
\DoxyCodeLine{2750     \textcolor{keywordflow}{for}(uword col=0; col < R\_n\_cols; ++col)}
\DoxyCodeLine{2751       \{}
\DoxyCodeLine{2752       \textcolor{keywordflow}{for}(uword row=(col+1); row < R\_n\_rows; ++row)}
\DoxyCodeLine{2753         \{}
\DoxyCodeLine{2754         R.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(row,col) = eT(0);}
\DoxyCodeLine{2755         \}}
\DoxyCodeLine{2756       \}}
\DoxyCodeLine{2757     }
\DoxyCodeLine{2758     }
\DoxyCodeLine{2759     \textcolor{keywordflow}{if}( (\mbox{\hyperlink{structis__float}{is\_float<eT>::value}}) || (\mbox{\hyperlink{structis__double}{is\_double<eT>::value}}) )}
\DoxyCodeLine{2760       \{}
\DoxyCodeLine{2761       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::orgqr()"{}});}
\DoxyCodeLine{2762       lapack::orgqr(\&m, \&m, \&k, Q.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&m, tau.memptr(), work.memptr(), \&lwork\_final, \&info);}
\DoxyCodeLine{2763       \}}
\DoxyCodeLine{2764     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2765     \textcolor{keywordflow}{if}( (\mbox{\hyperlink{structis__cx__float}{is\_cx\_float<eT>::value}}) || (\mbox{\hyperlink{structis__cx__double}{is\_cx\_double<eT>::value}}) )}
\DoxyCodeLine{2766       \{}
\DoxyCodeLine{2767       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::ungqr()"{}});}
\DoxyCodeLine{2768       lapack::ungqr(\&m, \&m, \&k, Q.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&m, tau.memptr(), work.memptr(), \&lwork\_final, \&info);}
\DoxyCodeLine{2769       \}}
\DoxyCodeLine{2770     }
\DoxyCodeLine{2771     \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{2772     \}}
\DoxyCodeLine{2773 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{2774     \{}
\DoxyCodeLine{2775     arma\_ignore(Q);}
\DoxyCodeLine{2776     arma\_ignore(R);}
\DoxyCodeLine{2777     arma\_ignore(X);}
\DoxyCodeLine{2778     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}qr(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{2779     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2780     \}}
\DoxyCodeLine{2781 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{2782   \}}
\DoxyCodeLine{2783 }
\DoxyCodeLine{2784 }
\DoxyCodeLine{2785 }
\DoxyCodeLine{2786 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{2787 \textcolor{keyword}{inline}}
\DoxyCodeLine{2788 \textcolor{keywordtype}{bool} }
\DoxyCodeLine{2789 auxlib::qr\_econ(\mbox{\hyperlink{classMat}{Mat<eT>}}\& Q, \mbox{\hyperlink{classMat}{Mat<eT>}}\& R, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<eT,T1>}}\& X)}
\DoxyCodeLine{2790   \{}
\DoxyCodeLine{2791   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2792   }
\DoxyCodeLine{2793 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{2794     \{}
\DoxyCodeLine{2795     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__Mat}{is\_Mat<T1>::value}})}
\DoxyCodeLine{2796       \{}
\DoxyCodeLine{2797       \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap}{unwrap<T1>}}   tmp(X.get\_ref());}
\DoxyCodeLine{2798       \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& M = tmp.M;}
\DoxyCodeLine{2799       }
\DoxyCodeLine{2800       \textcolor{keywordflow}{if}(M.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}} < M.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}})}
\DoxyCodeLine{2801         \{}
\DoxyCodeLine{2802         \textcolor{keywordflow}{return} auxlib::qr(Q, R, X);}
\DoxyCodeLine{2803         \}}
\DoxyCodeLine{2804       \}}
\DoxyCodeLine{2805     }
\DoxyCodeLine{2806     Q = X.get\_ref();}
\DoxyCodeLine{2807     }
\DoxyCodeLine{2808     \textcolor{keyword}{const} uword Q\_n\_rows = Q.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}};}
\DoxyCodeLine{2809     \textcolor{keyword}{const} uword Q\_n\_cols = Q.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}};}
\DoxyCodeLine{2810     }
\DoxyCodeLine{2811     \textcolor{keywordflow}{if}( Q\_n\_rows <= Q\_n\_cols )}
\DoxyCodeLine{2812       \{}
\DoxyCodeLine{2813       \textcolor{keywordflow}{return} auxlib::qr(Q, R, Q);}
\DoxyCodeLine{2814       \}}
\DoxyCodeLine{2815     }
\DoxyCodeLine{2816     \textcolor{keywordflow}{if}(Q.\mbox{\hyperlink{group__Mat_ga3008049216e02308ff665862f451a7ff}{is\_empty}}())}
\DoxyCodeLine{2817       \{}
\DoxyCodeLine{2818       Q.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(Q\_n\_rows, 0       );}
\DoxyCodeLine{2819       R.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(0,        Q\_n\_cols);}
\DoxyCodeLine{2820       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2821       \}}
\DoxyCodeLine{2822     }
\DoxyCodeLine{2823     arma\_debug\_assert\_blas\_size(Q);}
\DoxyCodeLine{2824     }
\DoxyCodeLine{2825     blas\_int m         = \textcolor{keyword}{static\_cast<}blas\_int\textcolor{keyword}{>}(Q\_n\_rows);}
\DoxyCodeLine{2826     blas\_int n         = \textcolor{keyword}{static\_cast<}blas\_int\textcolor{keyword}{>}(Q\_n\_cols);}
\DoxyCodeLine{2827     blas\_int lwork\_min = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(blas\_int(1), (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(m,n));  \textcolor{comment}{// take into account requirements of geqrf() \_and\_ orgqr()/ungqr()}}
\DoxyCodeLine{2828     blas\_int k         = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(m,n);}
\DoxyCodeLine{2829     blas\_int info      = 0;}
\DoxyCodeLine{2830     }
\DoxyCodeLine{2831     \mbox{\hyperlink{classpodarray}{podarray<eT>}} tau( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(k) );}
\DoxyCodeLine{2832     }
\DoxyCodeLine{2833     eT        work\_query[2];}
\DoxyCodeLine{2834     blas\_int lwork\_query = -\/1;}
\DoxyCodeLine{2835     }
\DoxyCodeLine{2836     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::geqrf()"{}});}
\DoxyCodeLine{2837     lapack::geqrf(\&m, \&n, Q.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&m, tau.memptr(), \&work\_query[0], \&lwork\_query, \&info);}
\DoxyCodeLine{2838     }
\DoxyCodeLine{2839     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2840     }
\DoxyCodeLine{2841     blas\_int lwork\_proposed = \textcolor{keyword}{static\_cast<}blas\_int\textcolor{keyword}{>}( \mbox{\hyperlink{classaccess_a9687cee4d2be0fe591998d6f5c6d0849}{access::tmp\_real}}(work\_query[0]) );}
\DoxyCodeLine{2842     blas\_int lwork\_final    = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(lwork\_proposed, lwork\_min);}
\DoxyCodeLine{2843     }
\DoxyCodeLine{2844     \mbox{\hyperlink{classpodarray}{podarray<eT>}} work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork\_final) );}
\DoxyCodeLine{2845     }
\DoxyCodeLine{2846     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::geqrf()"{}});}
\DoxyCodeLine{2847     lapack::geqrf(\&m, \&n, Q.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&m, tau.memptr(), work.memptr(), \&lwork\_final, \&info);}
\DoxyCodeLine{2848     }
\DoxyCodeLine{2849     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2850     }
\DoxyCodeLine{2851     R.zeros(Q\_n\_cols, Q\_n\_cols);}
\DoxyCodeLine{2852     }
\DoxyCodeLine{2853     \textcolor{comment}{//}}
\DoxyCodeLine{2854     \textcolor{comment}{// construct R}}
\DoxyCodeLine{2855     }
\DoxyCodeLine{2856     \textcolor{keywordflow}{for}(uword col=0; col < Q\_n\_cols; ++col)}
\DoxyCodeLine{2857       \{}
\DoxyCodeLine{2858       \textcolor{keywordflow}{for}(uword row=0; row <= col; ++row)}
\DoxyCodeLine{2859         \{}
\DoxyCodeLine{2860         R.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(row,col) = Q.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(row,col);}
\DoxyCodeLine{2861         \}}
\DoxyCodeLine{2862       \}}
\DoxyCodeLine{2863     }
\DoxyCodeLine{2864     \textcolor{keywordflow}{if}( (\mbox{\hyperlink{structis__float}{is\_float<eT>::value}}) || (\mbox{\hyperlink{structis__double}{is\_double<eT>::value}}) )}
\DoxyCodeLine{2865       \{}
\DoxyCodeLine{2866       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::orgqr()"{}});}
\DoxyCodeLine{2867       lapack::orgqr(\&m, \&n, \&k, Q.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&m, tau.memptr(), work.memptr(), \&lwork\_final, \&info);}
\DoxyCodeLine{2868       \}}
\DoxyCodeLine{2869     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2870     \textcolor{keywordflow}{if}( (\mbox{\hyperlink{structis__cx__float}{is\_cx\_float<eT>::value}}) || (\mbox{\hyperlink{structis__cx__double}{is\_cx\_double<eT>::value}}) )}
\DoxyCodeLine{2871       \{}
\DoxyCodeLine{2872       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::ungqr()"{}});}
\DoxyCodeLine{2873       lapack::ungqr(\&m, \&n, \&k, Q.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&m, tau.memptr(), work.memptr(), \&lwork\_final, \&info);}
\DoxyCodeLine{2874       \}}
\DoxyCodeLine{2875     }
\DoxyCodeLine{2876     \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{2877     \}}
\DoxyCodeLine{2878 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{2879     \{}
\DoxyCodeLine{2880     arma\_ignore(Q);}
\DoxyCodeLine{2881     arma\_ignore(R);}
\DoxyCodeLine{2882     arma\_ignore(X);}
\DoxyCodeLine{2883     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}qr\_econ(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{2884     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2885     \}}
\DoxyCodeLine{2886 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{2887   \}}
\DoxyCodeLine{2888 }
\DoxyCodeLine{2889 }
\DoxyCodeLine{2890 }
\DoxyCodeLine{2891 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{2892 \textcolor{keyword}{inline}}
\DoxyCodeLine{2893 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2894 auxlib::qr\_pivot(\mbox{\hyperlink{classMat}{Mat<eT>}}\& Q, \mbox{\hyperlink{classMat}{Mat<eT>}}\& R, \mbox{\hyperlink{classMat}{Mat<uword>}}\& P, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<eT,T1>}}\& X)}
\DoxyCodeLine{2895   \{}
\DoxyCodeLine{2896   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2897   }
\DoxyCodeLine{2898 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{2899     \{}
\DoxyCodeLine{2900     R = X.get\_ref();}
\DoxyCodeLine{2901     }
\DoxyCodeLine{2902     \textcolor{keyword}{const} uword R\_n\_rows = R.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}};}
\DoxyCodeLine{2903     \textcolor{keyword}{const} uword R\_n\_cols = R.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}};}
\DoxyCodeLine{2904     }
\DoxyCodeLine{2905     \textcolor{keywordflow}{if}(R.\mbox{\hyperlink{group__Mat_ga3008049216e02308ff665862f451a7ff}{is\_empty}}())}
\DoxyCodeLine{2906       \{}
\DoxyCodeLine{2907       Q.eye(R\_n\_rows, R\_n\_rows);}
\DoxyCodeLine{2908       }
\DoxyCodeLine{2909       P.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(R\_n\_cols, 1);}
\DoxyCodeLine{2910       }
\DoxyCodeLine{2911       \textcolor{keywordflow}{for}(uword col=0; col < R\_n\_cols; ++col)  \{ P.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(col) = col; \}}
\DoxyCodeLine{2912       }
\DoxyCodeLine{2913       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2914       \}}
\DoxyCodeLine{2915     }
\DoxyCodeLine{2916     arma\_debug\_assert\_blas\_size(R);}
\DoxyCodeLine{2917     }
\DoxyCodeLine{2918     blas\_int m         = \textcolor{keyword}{static\_cast<}blas\_int\textcolor{keyword}{>}(R\_n\_rows);}
\DoxyCodeLine{2919     blas\_int n         = \textcolor{keyword}{static\_cast<}blas\_int\textcolor{keyword}{>}(R\_n\_cols);}
\DoxyCodeLine{2920     blas\_int lwork\_min = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(blas\_int(3*n + 1), (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(m,n));  \textcolor{comment}{// take into account requirements of geqp3() and orgqr()}}
\DoxyCodeLine{2921     blas\_int k         = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(m,n);}
\DoxyCodeLine{2922     blas\_int info      = 0;}
\DoxyCodeLine{2923     }
\DoxyCodeLine{2924     \mbox{\hyperlink{classpodarray}{podarray<eT>}}        tau( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(k) );}
\DoxyCodeLine{2925     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} jpvt( R\_n\_cols );}
\DoxyCodeLine{2926     }
\DoxyCodeLine{2927     jpvt.zeros();}
\DoxyCodeLine{2928     }
\DoxyCodeLine{2929     eT        work\_query[2];}
\DoxyCodeLine{2930     blas\_int lwork\_query = -\/1;}
\DoxyCodeLine{2931     }
\DoxyCodeLine{2932     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::geqp3()"{}});}
\DoxyCodeLine{2933     lapack::geqp3(\&m, \&n, R.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&m, jpvt.memptr(), tau.memptr(), \&work\_query[0], \&lwork\_query, \&info);}
\DoxyCodeLine{2934     }
\DoxyCodeLine{2935     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2936     }
\DoxyCodeLine{2937     blas\_int lwork\_proposed = \textcolor{keyword}{static\_cast<}blas\_int\textcolor{keyword}{>}( \mbox{\hyperlink{classaccess_a9687cee4d2be0fe591998d6f5c6d0849}{access::tmp\_real}}(work\_query[0]) );}
\DoxyCodeLine{2938     blas\_int lwork\_final    = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(lwork\_proposed, lwork\_min);}
\DoxyCodeLine{2939     }
\DoxyCodeLine{2940     \mbox{\hyperlink{classpodarray}{podarray<eT>}} work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork\_final) );}
\DoxyCodeLine{2941     }
\DoxyCodeLine{2942     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::geqp3()"{}});}
\DoxyCodeLine{2943     lapack::geqp3(\&m, \&n, R.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&m, jpvt.memptr(), tau.memptr(), work.memptr(), \&lwork\_final, \&info);}
\DoxyCodeLine{2944     }
\DoxyCodeLine{2945     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2946     }
\DoxyCodeLine{2947     Q.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(R\_n\_rows, R\_n\_rows);}
\DoxyCodeLine{2948     }
\DoxyCodeLine{2949     arrayops::copy( Q.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), R.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(Q.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}}, R.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}}) );}
\DoxyCodeLine{2950     }
\DoxyCodeLine{2951     \textcolor{comment}{//}}
\DoxyCodeLine{2952     \textcolor{comment}{// construct R and P}}
\DoxyCodeLine{2953     }
\DoxyCodeLine{2954     P.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(R\_n\_cols, 1);}
\DoxyCodeLine{2955     }
\DoxyCodeLine{2956     \textcolor{keywordflow}{for}(uword col=0; col < R\_n\_cols; ++col)}
\DoxyCodeLine{2957       \{}
\DoxyCodeLine{2958       \textcolor{keywordflow}{for}(uword row=(col+1); row < R\_n\_rows; ++row)  \{ R.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(row,col) = eT(0); \}}
\DoxyCodeLine{2959       }
\DoxyCodeLine{2960       P.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(col) = jpvt[col] -\/ 1;  \textcolor{comment}{// take into account that Fortran counts from 1}}
\DoxyCodeLine{2961       \}}
\DoxyCodeLine{2962     }
\DoxyCodeLine{2963     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::orgqr()"{}});}
\DoxyCodeLine{2964     lapack::orgqr(\&m, \&m, \&k, Q.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&m, tau.memptr(), work.memptr(), \&lwork\_final, \&info);}
\DoxyCodeLine{2965     }
\DoxyCodeLine{2966     \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{2967     \}}
\DoxyCodeLine{2968 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{2969     \{}
\DoxyCodeLine{2970     arma\_ignore(Q);}
\DoxyCodeLine{2971     arma\_ignore(R);}
\DoxyCodeLine{2972     arma\_ignore(P);}
\DoxyCodeLine{2973     arma\_ignore(X);}
\DoxyCodeLine{2974     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}qr(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{2975     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2976     \}}
\DoxyCodeLine{2977 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{2978   \}}
\DoxyCodeLine{2979 }
\DoxyCodeLine{2980 }
\DoxyCodeLine{2981 }
\DoxyCodeLine{2982 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{2983 \textcolor{keyword}{inline}}
\DoxyCodeLine{2984 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2985 auxlib::qr\_pivot(\mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& Q, \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& R, \mbox{\hyperlink{classMat}{Mat<uword>}}\& P, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base}}<std::complex<T>,T1>\& X)}
\DoxyCodeLine{2986   \{}
\DoxyCodeLine{2987   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2988   }
\DoxyCodeLine{2989 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{2990     \{}
\DoxyCodeLine{2991     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<T> eT;}
\DoxyCodeLine{2992     }
\DoxyCodeLine{2993     R = X.get\_ref();}
\DoxyCodeLine{2994     }
\DoxyCodeLine{2995     \textcolor{keyword}{const} uword R\_n\_rows = R.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}};}
\DoxyCodeLine{2996     \textcolor{keyword}{const} uword R\_n\_cols = R.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}};}
\DoxyCodeLine{2997     }
\DoxyCodeLine{2998     \textcolor{keywordflow}{if}(R.\mbox{\hyperlink{group__Mat_ga3008049216e02308ff665862f451a7ff}{is\_empty}}())}
\DoxyCodeLine{2999       \{}
\DoxyCodeLine{3000       Q.eye(R\_n\_rows, R\_n\_rows);}
\DoxyCodeLine{3001       }
\DoxyCodeLine{3002       P.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(R\_n\_cols, 1);}
\DoxyCodeLine{3003       }
\DoxyCodeLine{3004       \textcolor{keywordflow}{for}(uword col=0; col < R\_n\_cols; ++col)  \{ P.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(col) = col; \}}
\DoxyCodeLine{3005       }
\DoxyCodeLine{3006       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3007       \}}
\DoxyCodeLine{3008     }
\DoxyCodeLine{3009     arma\_debug\_assert\_blas\_size(R);}
\DoxyCodeLine{3010     }
\DoxyCodeLine{3011     blas\_int m         = \textcolor{keyword}{static\_cast<}blas\_int\textcolor{keyword}{>}(R\_n\_rows);}
\DoxyCodeLine{3012     blas\_int n         = \textcolor{keyword}{static\_cast<}blas\_int\textcolor{keyword}{>}(R\_n\_cols);}
\DoxyCodeLine{3013     blas\_int lwork\_min = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(blas\_int(3*n + 1), (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(m,n));  \textcolor{comment}{// take into account requirements of geqp3() and ungqr()}}
\DoxyCodeLine{3014     blas\_int k         = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(m,n);}
\DoxyCodeLine{3015     blas\_int info      = 0;}
\DoxyCodeLine{3016     }
\DoxyCodeLine{3017     \mbox{\hyperlink{classpodarray}{podarray<eT>}}         tau( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(k) );}
\DoxyCodeLine{3018     \mbox{\hyperlink{classpodarray}{podarray< T>}}       rwork( 2*R\_n\_cols );}
\DoxyCodeLine{3019     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}}  jpvt( R\_n\_cols );}
\DoxyCodeLine{3020     }
\DoxyCodeLine{3021     jpvt.zeros();}
\DoxyCodeLine{3022     }
\DoxyCodeLine{3023     eT        work\_query[2];}
\DoxyCodeLine{3024     blas\_int lwork\_query = -\/1;}
\DoxyCodeLine{3025     }
\DoxyCodeLine{3026     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::geqp3()"{}});}
\DoxyCodeLine{3027     lapack::cx\_geqp3(\&m, \&n, R.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&m, jpvt.memptr(), tau.memptr(), \&work\_query[0], \&lwork\_query, rwork.memptr(), \&info);}
\DoxyCodeLine{3028     }
\DoxyCodeLine{3029     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{3030     }
\DoxyCodeLine{3031     blas\_int lwork\_proposed = \textcolor{keyword}{static\_cast<}blas\_int\textcolor{keyword}{>}( \mbox{\hyperlink{classaccess_a9687cee4d2be0fe591998d6f5c6d0849}{access::tmp\_real}}(work\_query[0]) );}
\DoxyCodeLine{3032     blas\_int lwork\_final    = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(lwork\_proposed, lwork\_min);}
\DoxyCodeLine{3033     }
\DoxyCodeLine{3034     \mbox{\hyperlink{classpodarray}{podarray<eT>}} work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork\_final) );}
\DoxyCodeLine{3035     }
\DoxyCodeLine{3036     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::geqp3()"{}});}
\DoxyCodeLine{3037     lapack::cx\_geqp3(\&m, \&n, R.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&m, jpvt.memptr(), tau.memptr(), work.memptr(), \&lwork\_final, rwork.memptr(), \&info);}
\DoxyCodeLine{3038     }
\DoxyCodeLine{3039     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{3040     }
\DoxyCodeLine{3041     Q.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(R\_n\_rows, R\_n\_rows);}
\DoxyCodeLine{3042     }
\DoxyCodeLine{3043     arrayops::copy( Q.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), R.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(Q.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}}, R.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}}) );}
\DoxyCodeLine{3044     }
\DoxyCodeLine{3045     \textcolor{comment}{//}}
\DoxyCodeLine{3046     \textcolor{comment}{// construct R and P}}
\DoxyCodeLine{3047     }
\DoxyCodeLine{3048     P.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(R\_n\_cols, 1);}
\DoxyCodeLine{3049     }
\DoxyCodeLine{3050     \textcolor{keywordflow}{for}(uword col=0; col < R\_n\_cols; ++col)}
\DoxyCodeLine{3051       \{}
\DoxyCodeLine{3052       \textcolor{keywordflow}{for}(uword row=(col+1); row < R\_n\_rows; ++row)  \{ R.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(row,col) = eT(0); \}}
\DoxyCodeLine{3053       }
\DoxyCodeLine{3054       P.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(col) = jpvt[col] -\/ 1;  \textcolor{comment}{// take into account that Fortran counts from 1}}
\DoxyCodeLine{3055       \}}
\DoxyCodeLine{3056     }
\DoxyCodeLine{3057     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::ungqr()"{}});}
\DoxyCodeLine{3058     lapack::ungqr(\&m, \&m, \&k, Q.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&m, tau.memptr(), work.memptr(), \&lwork\_final, \&info);}
\DoxyCodeLine{3059     }
\DoxyCodeLine{3060     \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{3061     \}}
\DoxyCodeLine{3062 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{3063     \{}
\DoxyCodeLine{3064     arma\_ignore(Q);}
\DoxyCodeLine{3065     arma\_ignore(R);}
\DoxyCodeLine{3066     arma\_ignore(P);}
\DoxyCodeLine{3067     arma\_ignore(X);}
\DoxyCodeLine{3068     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}qr(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{3069     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3070     \}}
\DoxyCodeLine{3071 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{3072   \}}
\DoxyCodeLine{3073 }
\DoxyCodeLine{3074 }
\DoxyCodeLine{3075 }
\DoxyCodeLine{3076 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{3077 \textcolor{keyword}{inline}}
\DoxyCodeLine{3078 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{3079 auxlib::svd(\mbox{\hyperlink{classCol}{Col<eT>}}\& S, \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}})}
\DoxyCodeLine{3080   \{}
\DoxyCodeLine{3081   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{3082   }
\DoxyCodeLine{3083 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{3084     \{}
\DoxyCodeLine{3085     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty())  \{ S.reset(); \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{3086     }
\DoxyCodeLine{3087     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{3088     }
\DoxyCodeLine{3089     \mbox{\hyperlink{classMat}{Mat<eT>}} U(1, 1,        \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{3090     \mbox{\hyperlink{classMat}{Mat<eT>}} V(1, \mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{3091     }
\DoxyCodeLine{3092     \textcolor{keywordtype}{char} jobu  = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{3093     \textcolor{keywordtype}{char} jobvt = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{3094     }
\DoxyCodeLine{3095     blas\_int m         = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{3096     blas\_int n         = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{3097     blas\_int min\_mn    = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(m,n);}
\DoxyCodeLine{3098     blas\_int lda       = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{3099     blas\_int ldu       = blas\_int(U.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{3100     blas\_int ldvt      = blas\_int(V.n\_rows);}
\DoxyCodeLine{3101     blas\_int lwork\_min = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})( blas\_int(1), (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})( (3*min\_mn + (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(m,n)), 5*min\_mn ) );}
\DoxyCodeLine{3102     blas\_int info      = 0;}
\DoxyCodeLine{3103     }
\DoxyCodeLine{3104     S.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(min\_mn) );}
\DoxyCodeLine{3105     }
\DoxyCodeLine{3106     blas\_int lwork\_proposed = 0;}
\DoxyCodeLine{3107     }
\DoxyCodeLine{3108     \textcolor{keywordflow}{if}((m*n) >= 1024)}
\DoxyCodeLine{3109       \{}
\DoxyCodeLine{3110       eT        work\_query[2];}
\DoxyCodeLine{3111       blas\_int lwork\_query = -\/1;}
\DoxyCodeLine{3112       }
\DoxyCodeLine{3113       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::gesvd()"{}});}
\DoxyCodeLine{3114       lapack::gesvd<eT>(\&jobu, \&jobvt, \&m, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, S.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), U.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldu, V.memptr(), \&ldvt, \&work\_query[0], \&lwork\_query, \&info);}
\DoxyCodeLine{3115       }
\DoxyCodeLine{3116       \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{3117       }
\DoxyCodeLine{3118       lwork\_proposed = \textcolor{keyword}{static\_cast<}blas\_int\textcolor{keyword}{>}( work\_query[0] );}
\DoxyCodeLine{3119       \}}
\DoxyCodeLine{3120     }
\DoxyCodeLine{3121     blas\_int lwork\_final = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(lwork\_proposed, lwork\_min);}
\DoxyCodeLine{3122     }
\DoxyCodeLine{3123     \mbox{\hyperlink{classpodarray}{podarray<eT>}} work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork\_final) );}
\DoxyCodeLine{3124     }
\DoxyCodeLine{3125     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::gesvd()"{}});}
\DoxyCodeLine{3126     lapack::gesvd<eT>(\&jobu, \&jobvt, \&m, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, S.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), U.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldu, V.memptr(), \&ldvt, work.memptr(), \&lwork\_final, \&info);}
\DoxyCodeLine{3127     }
\DoxyCodeLine{3128     \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{3129     \}}
\DoxyCodeLine{3130 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{3131     \{}
\DoxyCodeLine{3132     arma\_ignore(S);}
\DoxyCodeLine{3133     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{3134     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}svd(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{3135     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3136     \}}
\DoxyCodeLine{3137 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{3138   \}}
\DoxyCodeLine{3139 }
\DoxyCodeLine{3140 }
\DoxyCodeLine{3141 }
\DoxyCodeLine{3142 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3143 \textcolor{keyword}{inline}}
\DoxyCodeLine{3144 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{3145 auxlib::svd(\mbox{\hyperlink{classCol}{Col<T>}}\& S, \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& \mbox{\hyperlink{structA}{A}})}
\DoxyCodeLine{3146   \{}
\DoxyCodeLine{3147   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{3148   }
\DoxyCodeLine{3149 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{3150     \{}
\DoxyCodeLine{3151     \textcolor{keyword}{typedef} std::complex<T> eT;}
\DoxyCodeLine{3152     }
\DoxyCodeLine{3153     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty())  \{ S.reset(); \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{3154     }
\DoxyCodeLine{3155     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{3156     }
\DoxyCodeLine{3157     \mbox{\hyperlink{classMat}{Mat<eT>}} U(1, 1,        \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{3158     \mbox{\hyperlink{classMat}{Mat<eT>}} V(1, \mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{3159     }
\DoxyCodeLine{3160     \textcolor{keywordtype}{char} jobu  = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{3161     \textcolor{keywordtype}{char} jobvt = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{3162     }
\DoxyCodeLine{3163     blas\_int  m         = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{3164     blas\_int  n         = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{3165     blas\_int  min\_mn    = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(m,n);}
\DoxyCodeLine{3166     blas\_int  lda       = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{3167     blas\_int  ldu       = blas\_int(U.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{3168     blas\_int  ldvt      = blas\_int(V.n\_rows);}
\DoxyCodeLine{3169     blas\_int  lwork\_min = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})( blas\_int(1), 2*min\_mn+(\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(m,n) );}
\DoxyCodeLine{3170     blas\_int  info      = 0;}
\DoxyCodeLine{3171     }
\DoxyCodeLine{3172     S.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(min\_mn) );}
\DoxyCodeLine{3173     }
\DoxyCodeLine{3174     \mbox{\hyperlink{classpodarray}{podarray<T>}} rwork( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(5*min\_mn) );}
\DoxyCodeLine{3175     }
\DoxyCodeLine{3176     blas\_int lwork\_proposed = 0;}
\DoxyCodeLine{3177     }
\DoxyCodeLine{3178     \textcolor{keywordflow}{if}((m*n) >= 1024)}
\DoxyCodeLine{3179       \{}
\DoxyCodeLine{3180       eT        work\_query[2];}
\DoxyCodeLine{3181       blas\_int lwork\_query = -\/1;  \textcolor{comment}{// query to find optimum size of workspace}}
\DoxyCodeLine{3182       }
\DoxyCodeLine{3183       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::cx\_gesvd()"{}});}
\DoxyCodeLine{3184       lapack::cx\_gesvd<T>(\&jobu, \&jobvt, \&m, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, S.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), U.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldu, V.memptr(), \&ldvt, \&work\_query[0], \&lwork\_query, rwork.memptr(), \&info);}
\DoxyCodeLine{3185       }
\DoxyCodeLine{3186       \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{3187       }
\DoxyCodeLine{3188       lwork\_proposed = \textcolor{keyword}{static\_cast<}blas\_int\textcolor{keyword}{>}( \mbox{\hyperlink{classaccess_a9687cee4d2be0fe591998d6f5c6d0849}{access::tmp\_real}}(work\_query[0]) );}
\DoxyCodeLine{3189       \}}
\DoxyCodeLine{3190     }
\DoxyCodeLine{3191     blas\_int lwork\_final = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(lwork\_proposed, lwork\_min);}
\DoxyCodeLine{3192     }
\DoxyCodeLine{3193     \mbox{\hyperlink{classpodarray}{podarray<eT>}} work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork\_final) );}
\DoxyCodeLine{3194     }
\DoxyCodeLine{3195     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::cx\_gesvd()"{}});}
\DoxyCodeLine{3196     lapack::cx\_gesvd<T>(\&jobu, \&jobvt, \&m, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, S.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), U.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldu, V.memptr(), \&ldvt, work.memptr(), \&lwork\_final, rwork.memptr(), \&info);}
\DoxyCodeLine{3197     }
\DoxyCodeLine{3198     \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{3199     \}}
\DoxyCodeLine{3200 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{3201     \{}
\DoxyCodeLine{3202     arma\_ignore(S);}
\DoxyCodeLine{3203     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{3204     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}svd(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{3205     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3206     \}}
\DoxyCodeLine{3207 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{3208   \}}
\DoxyCodeLine{3209 }
\DoxyCodeLine{3210 }
\DoxyCodeLine{3211 }
\DoxyCodeLine{3212 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{3213 \textcolor{keyword}{inline}}
\DoxyCodeLine{3214 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{3215 auxlib::svd(\mbox{\hyperlink{classMat}{Mat<eT>}}\& U, \mbox{\hyperlink{classCol}{Col<eT>}}\& S, \mbox{\hyperlink{classMat}{Mat<eT>}}\& V, \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}})}
\DoxyCodeLine{3216   \{}
\DoxyCodeLine{3217   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{3218   }
\DoxyCodeLine{3219 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{3220     \{}
\DoxyCodeLine{3221     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty())}
\DoxyCodeLine{3222       \{}
\DoxyCodeLine{3223       U.eye(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{3224       S.reset();}
\DoxyCodeLine{3225       V.eye(\mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{3226       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3227       \}}
\DoxyCodeLine{3228     }
\DoxyCodeLine{3229     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{3230     }
\DoxyCodeLine{3231     U.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{3232     V.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(\mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{3233     }
\DoxyCodeLine{3234     \textcolor{keywordtype}{char} jobu  = \textcolor{charliteral}{'A'};}
\DoxyCodeLine{3235     \textcolor{keywordtype}{char} jobvt = \textcolor{charliteral}{'A'};}
\DoxyCodeLine{3236     }
\DoxyCodeLine{3237     blas\_int  m         = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{3238     blas\_int  n         = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{3239     blas\_int  min\_mn    = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(m,n);}
\DoxyCodeLine{3240     blas\_int  lda       = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{3241     blas\_int  ldu       = blas\_int(U.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{3242     blas\_int  ldvt      = blas\_int(V.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{3243     blas\_int  lwork\_min = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})( blas\_int(1), (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})( (3*min\_mn + (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(m,n)), 5*min\_mn ) );}
\DoxyCodeLine{3244     blas\_int  info      = 0;}
\DoxyCodeLine{3245     }
\DoxyCodeLine{3246     S.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(min\_mn) );}
\DoxyCodeLine{3247     }
\DoxyCodeLine{3248     blas\_int lwork\_proposed = 0;}
\DoxyCodeLine{3249     }
\DoxyCodeLine{3250     \textcolor{keywordflow}{if}((m*n) >= 1024)}
\DoxyCodeLine{3251       \{}
\DoxyCodeLine{3252       \textcolor{comment}{// query to find optimum size of workspace}}
\DoxyCodeLine{3253       eT        work\_query[2];}
\DoxyCodeLine{3254       blas\_int lwork\_query = -\/1;}
\DoxyCodeLine{3255       }
\DoxyCodeLine{3256       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::gesvd()"{}});}
\DoxyCodeLine{3257       lapack::gesvd<eT>(\&jobu, \&jobvt, \&m, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, S.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), U.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldu, V.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldvt, \&work\_query[0], \&lwork\_query, \&info);}
\DoxyCodeLine{3258       }
\DoxyCodeLine{3259       \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{3260       }
\DoxyCodeLine{3261       lwork\_proposed = \textcolor{keyword}{static\_cast<}blas\_int\textcolor{keyword}{>}( work\_query[0] );}
\DoxyCodeLine{3262       \}}
\DoxyCodeLine{3263     }
\DoxyCodeLine{3264     blas\_int lwork\_final = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(lwork\_proposed, lwork\_min);}
\DoxyCodeLine{3265     }
\DoxyCodeLine{3266     \mbox{\hyperlink{classpodarray}{podarray<eT>}} work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork\_final) );}
\DoxyCodeLine{3267     }
\DoxyCodeLine{3268     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::gesvd()"{}});}
\DoxyCodeLine{3269     lapack::gesvd<eT>(\&jobu, \&jobvt, \&m, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, S.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), U.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldu, V.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldvt, work.memptr(), \&lwork\_final, \&info);}
\DoxyCodeLine{3270     }
\DoxyCodeLine{3271     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{3272     }
\DoxyCodeLine{3273     op\_strans::apply\_mat\_inplace(V);}
\DoxyCodeLine{3274     }
\DoxyCodeLine{3275     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3276     \}}
\DoxyCodeLine{3277 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{3278     \{}
\DoxyCodeLine{3279     arma\_ignore(U);}
\DoxyCodeLine{3280     arma\_ignore(S);}
\DoxyCodeLine{3281     arma\_ignore(V);}
\DoxyCodeLine{3282     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{3283     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}svd(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{3284     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3285     \}}
\DoxyCodeLine{3286 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{3287   \}}
\DoxyCodeLine{3288 }
\DoxyCodeLine{3289 }
\DoxyCodeLine{3290 }
\DoxyCodeLine{3291 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3292 \textcolor{keyword}{inline}}
\DoxyCodeLine{3293 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{3294 auxlib::svd(\mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& U, \mbox{\hyperlink{classCol}{Col<T>}}\& S, \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& V, \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& \mbox{\hyperlink{structA}{A}})}
\DoxyCodeLine{3295   \{}
\DoxyCodeLine{3296   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{3297   }
\DoxyCodeLine{3298 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{3299     \{}
\DoxyCodeLine{3300     \textcolor{keyword}{typedef} std::complex<T> eT;}
\DoxyCodeLine{3301     }
\DoxyCodeLine{3302     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty())}
\DoxyCodeLine{3303       \{}
\DoxyCodeLine{3304       U.eye(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{3305       S.reset();}
\DoxyCodeLine{3306       V.eye(\mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{3307       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3308       \}}
\DoxyCodeLine{3309     }
\DoxyCodeLine{3310     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{3311     }
\DoxyCodeLine{3312     U.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{3313     V.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(\mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{3314     }
\DoxyCodeLine{3315     \textcolor{keywordtype}{char} jobu  = \textcolor{charliteral}{'A'};}
\DoxyCodeLine{3316     \textcolor{keywordtype}{char} jobvt = \textcolor{charliteral}{'A'};}
\DoxyCodeLine{3317     }
\DoxyCodeLine{3318     blas\_int  m         = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{3319     blas\_int  n         = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{3320     blas\_int  min\_mn    = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(m,n);}
\DoxyCodeLine{3321     blas\_int  lda       = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{3322     blas\_int  ldu       = blas\_int(U.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{3323     blas\_int  ldvt      = blas\_int(V.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{3324     blas\_int  lwork\_min = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})( blas\_int(1), 2*min\_mn + (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(m,n) );}
\DoxyCodeLine{3325     blas\_int  info      = 0;}
\DoxyCodeLine{3326     }
\DoxyCodeLine{3327     S.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(min\_mn) );}
\DoxyCodeLine{3328     }
\DoxyCodeLine{3329     \mbox{\hyperlink{classpodarray}{podarray<T>}} rwork( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(5*min\_mn) );}
\DoxyCodeLine{3330     }
\DoxyCodeLine{3331     blas\_int lwork\_proposed = 0;}
\DoxyCodeLine{3332     }
\DoxyCodeLine{3333     \textcolor{keywordflow}{if}((m*n) >= 1024)}
\DoxyCodeLine{3334       \{}
\DoxyCodeLine{3335       eT        work\_query[2];}
\DoxyCodeLine{3336       blas\_int lwork\_query = -\/1;  \textcolor{comment}{// query to find optimum size of workspace}}
\DoxyCodeLine{3337       }
\DoxyCodeLine{3338       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::cx\_gesvd()"{}});}
\DoxyCodeLine{3339       lapack::cx\_gesvd<T>(\&jobu, \&jobvt, \&m, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, S.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), U.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldu, V.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldvt, \&work\_query[0], \&lwork\_query, rwork.memptr(), \&info);}
\DoxyCodeLine{3340       }
\DoxyCodeLine{3341       \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{3342 }
\DoxyCodeLine{3343       lwork\_proposed = \textcolor{keyword}{static\_cast<}blas\_int\textcolor{keyword}{>}( \mbox{\hyperlink{classaccess_a9687cee4d2be0fe591998d6f5c6d0849}{access::tmp\_real}}(work\_query[0]) );}
\DoxyCodeLine{3344       \}}
\DoxyCodeLine{3345     }
\DoxyCodeLine{3346     blas\_int lwork\_final = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(lwork\_proposed, lwork\_min);}
\DoxyCodeLine{3347     }
\DoxyCodeLine{3348     \mbox{\hyperlink{classpodarray}{podarray<eT>}} work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork\_final) );}
\DoxyCodeLine{3349     }
\DoxyCodeLine{3350     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::cx\_gesvd()"{}});}
\DoxyCodeLine{3351     lapack::cx\_gesvd<T>(\&jobu, \&jobvt, \&m, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, S.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), U.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldu, V.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldvt, work.memptr(), \&lwork\_final, rwork.memptr(), \&info);}
\DoxyCodeLine{3352     }
\DoxyCodeLine{3353     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{3354     }
\DoxyCodeLine{3355     op\_htrans::apply\_mat\_inplace(V);}
\DoxyCodeLine{3356     }
\DoxyCodeLine{3357     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3358     \}}
\DoxyCodeLine{3359 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{3360     \{}
\DoxyCodeLine{3361     arma\_ignore(U);}
\DoxyCodeLine{3362     arma\_ignore(S);}
\DoxyCodeLine{3363     arma\_ignore(V);}
\DoxyCodeLine{3364     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{3365     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}svd(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{3366     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3367     \}}
\DoxyCodeLine{3368 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{3369   \}}
\DoxyCodeLine{3370 }
\DoxyCodeLine{3371 }
\DoxyCodeLine{3372 }
\DoxyCodeLine{3373 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{3374 \textcolor{keyword}{inline}}
\DoxyCodeLine{3375 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{3376 auxlib::svd\_econ(\mbox{\hyperlink{classMat}{Mat<eT>}}\& U, \mbox{\hyperlink{classCol}{Col<eT>}}\& S, \mbox{\hyperlink{classMat}{Mat<eT>}}\& V, \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} \textcolor{keywordtype}{char} mode)}
\DoxyCodeLine{3377   \{}
\DoxyCodeLine{3378   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{3379   }
\DoxyCodeLine{3380 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{3381     \{}
\DoxyCodeLine{3382     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty())}
\DoxyCodeLine{3383       \{}
\DoxyCodeLine{3384       U.eye();}
\DoxyCodeLine{3385       S.reset();}
\DoxyCodeLine{3386       V.eye();}
\DoxyCodeLine{3387       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3388       \}}
\DoxyCodeLine{3389     }
\DoxyCodeLine{3390     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{3391     }
\DoxyCodeLine{3392     blas\_int m      = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{3393     blas\_int n      = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{3394     blas\_int min\_mn = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(m,n);}
\DoxyCodeLine{3395     blas\_int lda    = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{3396     }
\DoxyCodeLine{3397     S.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(min\_mn) );}
\DoxyCodeLine{3398     }
\DoxyCodeLine{3399     blas\_int ldu  = 0;}
\DoxyCodeLine{3400     blas\_int ldvt = 0;}
\DoxyCodeLine{3401     }
\DoxyCodeLine{3402     \textcolor{keywordtype}{char} jobu  = char(0);}
\DoxyCodeLine{3403     \textcolor{keywordtype}{char} jobvt = char(0);}
\DoxyCodeLine{3404     }
\DoxyCodeLine{3405     \textcolor{keywordflow}{if}(mode == \textcolor{charliteral}{'l'})}
\DoxyCodeLine{3406       \{}
\DoxyCodeLine{3407       jobu  = \textcolor{charliteral}{'S'};}
\DoxyCodeLine{3408       jobvt = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{3409       }
\DoxyCodeLine{3410       ldu  = m;}
\DoxyCodeLine{3411       ldvt = 1;}
\DoxyCodeLine{3412       }
\DoxyCodeLine{3413       U.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(ldu), \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(min\_mn) );}
\DoxyCodeLine{3414       V.reset();}
\DoxyCodeLine{3415       \}}
\DoxyCodeLine{3416     }
\DoxyCodeLine{3417     \textcolor{keywordflow}{if}(mode == \textcolor{charliteral}{'r'})}
\DoxyCodeLine{3418       \{}
\DoxyCodeLine{3419       jobu  = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{3420       jobvt = \textcolor{charliteral}{'S'};}
\DoxyCodeLine{3421       }
\DoxyCodeLine{3422       ldu = 1;}
\DoxyCodeLine{3423       ldvt = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(m,n);}
\DoxyCodeLine{3424       }
\DoxyCodeLine{3425       U.reset();}
\DoxyCodeLine{3426       V.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(ldvt), \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(n) );}
\DoxyCodeLine{3427       \}}
\DoxyCodeLine{3428     }
\DoxyCodeLine{3429     \textcolor{keywordflow}{if}(mode == \textcolor{charliteral}{'b'})}
\DoxyCodeLine{3430       \{}
\DoxyCodeLine{3431       jobu  = \textcolor{charliteral}{'S'};}
\DoxyCodeLine{3432       jobvt = \textcolor{charliteral}{'S'};}
\DoxyCodeLine{3433       }
\DoxyCodeLine{3434       ldu  = m;}
\DoxyCodeLine{3435       ldvt = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(m,n);}
\DoxyCodeLine{3436       }
\DoxyCodeLine{3437       U.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(ldu),  \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(min\_mn) );}
\DoxyCodeLine{3438       V.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(ldvt), \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(n     ) );}
\DoxyCodeLine{3439       \}}
\DoxyCodeLine{3440     }
\DoxyCodeLine{3441     }
\DoxyCodeLine{3442     blas\_int lwork\_min = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})( blas\_int(1), (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})( (3*min\_mn + (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(m,n)), 5*min\_mn ) );}
\DoxyCodeLine{3443     blas\_int info      = 0;}
\DoxyCodeLine{3444     }
\DoxyCodeLine{3445     blas\_int lwork\_proposed = 0;}
\DoxyCodeLine{3446     }
\DoxyCodeLine{3447     \textcolor{keywordflow}{if}((m*n) >= 1024)}
\DoxyCodeLine{3448       \{}
\DoxyCodeLine{3449       eT        work\_query[2];}
\DoxyCodeLine{3450       blas\_int lwork\_query = -\/1;  \textcolor{comment}{// query to find optimum size of workspace}}
\DoxyCodeLine{3451       }
\DoxyCodeLine{3452       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::gesvd()"{}});}
\DoxyCodeLine{3453       lapack::gesvd<eT>(\&jobu, \&jobvt, \&m, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, S.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), U.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldu, V.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldvt, \&work\_query[0], \&lwork\_query, \&info);}
\DoxyCodeLine{3454       }
\DoxyCodeLine{3455       \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{3456       }
\DoxyCodeLine{3457       lwork\_proposed = \textcolor{keyword}{static\_cast<}blas\_int\textcolor{keyword}{>}(work\_query[0]);}
\DoxyCodeLine{3458       \}}
\DoxyCodeLine{3459     }
\DoxyCodeLine{3460     blas\_int lwork\_final = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(lwork\_proposed, lwork\_min);}
\DoxyCodeLine{3461     }
\DoxyCodeLine{3462     \mbox{\hyperlink{classpodarray}{podarray<eT>}} work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork\_final) );}
\DoxyCodeLine{3463     }
\DoxyCodeLine{3464     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::gesvd()"{}});}
\DoxyCodeLine{3465     lapack::gesvd<eT>(\&jobu, \&jobvt, \&m, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, S.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), U.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldu, V.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldvt, work.memptr(), \&lwork\_final, \&info);}
\DoxyCodeLine{3466     }
\DoxyCodeLine{3467     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{3468     }
\DoxyCodeLine{3469     op\_strans::apply\_mat\_inplace(V);}
\DoxyCodeLine{3470     }
\DoxyCodeLine{3471     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3472     \}}
\DoxyCodeLine{3473 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{3474     \{}
\DoxyCodeLine{3475     arma\_ignore(U);}
\DoxyCodeLine{3476     arma\_ignore(S);}
\DoxyCodeLine{3477     arma\_ignore(V);}
\DoxyCodeLine{3478     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{3479     arma\_ignore(mode);}
\DoxyCodeLine{3480     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}svd(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{3481     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3482     \}}
\DoxyCodeLine{3483 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{3484   \}}
\DoxyCodeLine{3485 }
\DoxyCodeLine{3486 }
\DoxyCodeLine{3487 }
\DoxyCodeLine{3488 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3489 \textcolor{keyword}{inline}}
\DoxyCodeLine{3490 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{3491 auxlib::svd\_econ(\mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& U, \mbox{\hyperlink{classCol}{Col<T>}}\& S, \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& V, \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} \textcolor{keywordtype}{char} mode)}
\DoxyCodeLine{3492   \{}
\DoxyCodeLine{3493   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{3494   }
\DoxyCodeLine{3495 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{3496     \{}
\DoxyCodeLine{3497     \textcolor{keyword}{typedef} std::complex<T> eT;}
\DoxyCodeLine{3498     }
\DoxyCodeLine{3499     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty())}
\DoxyCodeLine{3500       \{}
\DoxyCodeLine{3501       U.eye();}
\DoxyCodeLine{3502       S.reset();}
\DoxyCodeLine{3503       V.eye();}
\DoxyCodeLine{3504       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3505       \}}
\DoxyCodeLine{3506     }
\DoxyCodeLine{3507     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{3508     }
\DoxyCodeLine{3509     blas\_int m      = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{3510     blas\_int n      = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{3511     blas\_int min\_mn = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(m,n);}
\DoxyCodeLine{3512     blas\_int lda    = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{3513     }
\DoxyCodeLine{3514     S.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(min\_mn) );}
\DoxyCodeLine{3515     }
\DoxyCodeLine{3516     blas\_int ldu  = 0;}
\DoxyCodeLine{3517     blas\_int ldvt = 0;}
\DoxyCodeLine{3518     }
\DoxyCodeLine{3519     \textcolor{keywordtype}{char} jobu  = char(0);}
\DoxyCodeLine{3520     \textcolor{keywordtype}{char} jobvt = char(0);}
\DoxyCodeLine{3521     }
\DoxyCodeLine{3522     \textcolor{keywordflow}{if}(mode == \textcolor{charliteral}{'l'})}
\DoxyCodeLine{3523       \{}
\DoxyCodeLine{3524       jobu  = \textcolor{charliteral}{'S'};}
\DoxyCodeLine{3525       jobvt = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{3526       }
\DoxyCodeLine{3527       ldu  = m;}
\DoxyCodeLine{3528       ldvt = 1;}
\DoxyCodeLine{3529       }
\DoxyCodeLine{3530       U.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(ldu), \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(min\_mn) );}
\DoxyCodeLine{3531       V.reset();}
\DoxyCodeLine{3532       \}}
\DoxyCodeLine{3533     }
\DoxyCodeLine{3534     \textcolor{keywordflow}{if}(mode == \textcolor{charliteral}{'r'})}
\DoxyCodeLine{3535       \{}
\DoxyCodeLine{3536       jobu  = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{3537       jobvt = \textcolor{charliteral}{'S'};}
\DoxyCodeLine{3538       }
\DoxyCodeLine{3539       ldu  = 1;}
\DoxyCodeLine{3540       ldvt = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(m,n);}
\DoxyCodeLine{3541       }
\DoxyCodeLine{3542       U.reset();}
\DoxyCodeLine{3543       V.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(ldvt), \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(n) );}
\DoxyCodeLine{3544       \}}
\DoxyCodeLine{3545     }
\DoxyCodeLine{3546     \textcolor{keywordflow}{if}(mode == \textcolor{charliteral}{'b'})}
\DoxyCodeLine{3547       \{}
\DoxyCodeLine{3548       jobu  = \textcolor{charliteral}{'S'};}
\DoxyCodeLine{3549       jobvt = \textcolor{charliteral}{'S'};}
\DoxyCodeLine{3550       }
\DoxyCodeLine{3551       ldu  = m;}
\DoxyCodeLine{3552       ldvt = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(m,n);}
\DoxyCodeLine{3553       }
\DoxyCodeLine{3554       U.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(ldu),  \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(min\_mn) );}
\DoxyCodeLine{3555       V.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(ldvt), \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(n)      );}
\DoxyCodeLine{3556       \}}
\DoxyCodeLine{3557     }
\DoxyCodeLine{3558     blas\_int lwork\_min = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})( blas\_int(1), (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})( (3*min\_mn + (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(m,n)), 5*min\_mn ) );}
\DoxyCodeLine{3559     blas\_int info      = 0;}
\DoxyCodeLine{3560     }
\DoxyCodeLine{3561     \mbox{\hyperlink{classpodarray}{podarray<T>}} rwork( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(5*min\_mn) );}
\DoxyCodeLine{3562     }
\DoxyCodeLine{3563     blas\_int lwork\_proposed = 0;}
\DoxyCodeLine{3564     }
\DoxyCodeLine{3565     \textcolor{keywordflow}{if}((m*n) >= 1024)}
\DoxyCodeLine{3566       \{}
\DoxyCodeLine{3567       eT        work\_query[2];}
\DoxyCodeLine{3568       blas\_int lwork\_query = -\/1;  \textcolor{comment}{// query to find optimum size of workspace}}
\DoxyCodeLine{3569       }
\DoxyCodeLine{3570       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::cx\_gesvd()"{}});}
\DoxyCodeLine{3571       lapack::cx\_gesvd<T>(\&jobu, \&jobvt, \&m, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, S.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), U.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldu, V.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldvt, \&work\_query[0], \&lwork\_query, rwork.memptr(), \&info);}
\DoxyCodeLine{3572       }
\DoxyCodeLine{3573       \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{3574       }
\DoxyCodeLine{3575       lwork\_proposed = \textcolor{keyword}{static\_cast<}blas\_int\textcolor{keyword}{>}( \mbox{\hyperlink{classaccess_a9687cee4d2be0fe591998d6f5c6d0849}{access::tmp\_real}}(work\_query[0]) );}
\DoxyCodeLine{3576       \}}
\DoxyCodeLine{3577     }
\DoxyCodeLine{3578     blas\_int lwork\_final = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(lwork\_proposed, lwork\_min);}
\DoxyCodeLine{3579     }
\DoxyCodeLine{3580     \mbox{\hyperlink{classpodarray}{podarray<eT>}} work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork\_final) );}
\DoxyCodeLine{3581     }
\DoxyCodeLine{3582     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::cx\_gesvd()"{}});}
\DoxyCodeLine{3583     lapack::cx\_gesvd<T>(\&jobu, \&jobvt, \&m, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, S.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), U.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldu, V.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldvt, work.memptr(), \&lwork\_final, rwork.memptr(), \&info);}
\DoxyCodeLine{3584     }
\DoxyCodeLine{3585     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{3586     }
\DoxyCodeLine{3587     op\_htrans::apply\_mat\_inplace(V);}
\DoxyCodeLine{3588     }
\DoxyCodeLine{3589     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3590     \}}
\DoxyCodeLine{3591 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{3592     \{}
\DoxyCodeLine{3593     arma\_ignore(U);}
\DoxyCodeLine{3594     arma\_ignore(S);}
\DoxyCodeLine{3595     arma\_ignore(V);}
\DoxyCodeLine{3596     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{3597     arma\_ignore(mode);}
\DoxyCodeLine{3598     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}svd(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{3599     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3600     \}}
\DoxyCodeLine{3601 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{3602   \}}
\DoxyCodeLine{3603 }
\DoxyCodeLine{3604 }
\DoxyCodeLine{3605 }
\DoxyCodeLine{3606 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{3607 \textcolor{keyword}{inline}}
\DoxyCodeLine{3608 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{3609 auxlib::svd\_dc(\mbox{\hyperlink{classCol}{Col<eT>}}\& S, \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}})}
\DoxyCodeLine{3610   \{}
\DoxyCodeLine{3611   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{3612   }
\DoxyCodeLine{3613 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{3614     \{}
\DoxyCodeLine{3615     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty())  \{ S.reset(); \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{3616     }
\DoxyCodeLine{3617     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{3618     }
\DoxyCodeLine{3619     \mbox{\hyperlink{classMat}{Mat<eT>}} U(1, 1, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{3620     \mbox{\hyperlink{classMat}{Mat<eT>}} V(1, 1, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{3621     }
\DoxyCodeLine{3622     \textcolor{keywordtype}{char} jobz = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{3623     }
\DoxyCodeLine{3624     blas\_int  m         = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{3625     blas\_int  n         = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{3626     blas\_int  min\_mn    = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(m,n);}
\DoxyCodeLine{3627     blas\_int  max\_mn    = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(m,n);}
\DoxyCodeLine{3628     blas\_int  lda       = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{3629     blas\_int  ldu       = blas\_int(U.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{3630     blas\_int  ldvt      = blas\_int(V.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{3631     blas\_int  lwork\_min = 3*min\_mn + (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})( max\_mn, 7*min\_mn );}
\DoxyCodeLine{3632     blas\_int  info      = 0;}
\DoxyCodeLine{3633     }
\DoxyCodeLine{3634     S.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(min\_mn) );}
\DoxyCodeLine{3635     }
\DoxyCodeLine{3636     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} iwork( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(8*min\_mn) );}
\DoxyCodeLine{3637     }
\DoxyCodeLine{3638     blas\_int lwork\_proposed = 0;}
\DoxyCodeLine{3639     }
\DoxyCodeLine{3640     \textcolor{keywordflow}{if}((m*n) >= 1024)}
\DoxyCodeLine{3641       \{}
\DoxyCodeLine{3642       eT        work\_query[2];}
\DoxyCodeLine{3643       blas\_int lwork\_query = blas\_int(-\/1);}
\DoxyCodeLine{3644       }
\DoxyCodeLine{3645       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::gesdd()"{}});}
\DoxyCodeLine{3646       lapack::gesdd<eT>(\&jobz, \&m, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, S.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), U.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldu, V.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldvt, \&work\_query[0], \&lwork\_query, iwork.memptr(), \&info);}
\DoxyCodeLine{3647       }
\DoxyCodeLine{3648       \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{3649       }
\DoxyCodeLine{3650       lwork\_proposed = \textcolor{keyword}{static\_cast<}blas\_int\textcolor{keyword}{>}( work\_query[0] );}
\DoxyCodeLine{3651       \}}
\DoxyCodeLine{3652     }
\DoxyCodeLine{3653     blas\_int lwork\_final = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(lwork\_proposed, lwork\_min);}
\DoxyCodeLine{3654     }
\DoxyCodeLine{3655     \mbox{\hyperlink{classpodarray}{podarray<eT>}} work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork\_final) );}
\DoxyCodeLine{3656     }
\DoxyCodeLine{3657     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::gesdd()"{}});}
\DoxyCodeLine{3658     lapack::gesdd<eT>(\&jobz, \&m, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, S.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), U.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldu, V.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldvt, work.memptr(), \&lwork\_final, iwork.memptr(), \&info);}
\DoxyCodeLine{3659     }
\DoxyCodeLine{3660     \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{3661     \}}
\DoxyCodeLine{3662 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{3663     \{}
\DoxyCodeLine{3664     arma\_ignore(S);}
\DoxyCodeLine{3665     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{3666     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}svd(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{3667     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3668     \}}
\DoxyCodeLine{3669 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{3670   \}}
\DoxyCodeLine{3671 }
\DoxyCodeLine{3672 }
\DoxyCodeLine{3673 }
\DoxyCodeLine{3674 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3675 \textcolor{keyword}{inline}}
\DoxyCodeLine{3676 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{3677 auxlib::svd\_dc(\mbox{\hyperlink{classCol}{Col<T>}}\& S, \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& \mbox{\hyperlink{structA}{A}})}
\DoxyCodeLine{3678   \{}
\DoxyCodeLine{3679   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{3680   }
\DoxyCodeLine{3681 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{3682     \{}
\DoxyCodeLine{3683     \textcolor{keyword}{typedef} std::complex<T> eT;}
\DoxyCodeLine{3684     }
\DoxyCodeLine{3685     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty())  \{ S.reset(); \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{3686     }
\DoxyCodeLine{3687     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{3688     }
\DoxyCodeLine{3689     \mbox{\hyperlink{classMat}{Mat<eT>}} U(1, 1, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{3690     \mbox{\hyperlink{classMat}{Mat<eT>}} V(1, 1, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{3691     }
\DoxyCodeLine{3692     \textcolor{keywordtype}{char} jobz = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{3693     }
\DoxyCodeLine{3694     blas\_int  m         = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{3695     blas\_int  n         = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{3696     blas\_int  min\_mn    = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(m,n);}
\DoxyCodeLine{3697     blas\_int  max\_mn    = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(m,n);}
\DoxyCodeLine{3698     blas\_int  lda       = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{3699     blas\_int  ldu       = blas\_int(U.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{3700     blas\_int  ldvt      = blas\_int(V.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{3701     blas\_int  lwork\_min = 2*min\_mn + max\_mn;}
\DoxyCodeLine{3702     blas\_int  info      = 0;}
\DoxyCodeLine{3703     }
\DoxyCodeLine{3704     S.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(min\_mn) );}
\DoxyCodeLine{3705     }
\DoxyCodeLine{3706     \mbox{\hyperlink{classpodarray}{podarray<T>}}        rwork( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(7*min\_mn) );  \textcolor{comment}{// from LAPACK 3.8 docs: LAPACK <= v3.6 needs 7*mn}}
\DoxyCodeLine{3707     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} iwork( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(8*min\_mn) );}
\DoxyCodeLine{3708     }
\DoxyCodeLine{3709     blas\_int lwork\_proposed = 0;}
\DoxyCodeLine{3710     }
\DoxyCodeLine{3711     \textcolor{keywordflow}{if}((m*n) >= 1024)}
\DoxyCodeLine{3712       \{}
\DoxyCodeLine{3713       eT        work\_query[2];}
\DoxyCodeLine{3714       blas\_int lwork\_query = blas\_int(-\/1);}
\DoxyCodeLine{3715       }
\DoxyCodeLine{3716       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::cx\_gesdd()"{}});}
\DoxyCodeLine{3717       lapack::cx\_gesdd<T>(\&jobz, \&m, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, S.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), U.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldu, V.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldvt, \&work\_query[0], \&lwork\_query, rwork.memptr(), iwork.memptr(), \&info);}
\DoxyCodeLine{3718       }
\DoxyCodeLine{3719       \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{3720       }
\DoxyCodeLine{3721       lwork\_proposed = \textcolor{keyword}{static\_cast<}blas\_int\textcolor{keyword}{>}( \mbox{\hyperlink{classaccess_a9687cee4d2be0fe591998d6f5c6d0849}{access::tmp\_real}}(work\_query[0]) );}
\DoxyCodeLine{3722       \}}
\DoxyCodeLine{3723     }
\DoxyCodeLine{3724     blas\_int lwork\_final = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(lwork\_proposed, lwork\_min);}
\DoxyCodeLine{3725     }
\DoxyCodeLine{3726     \mbox{\hyperlink{classpodarray}{podarray<eT>}} work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork\_final) );}
\DoxyCodeLine{3727     }
\DoxyCodeLine{3728     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::cx\_gesdd()"{}});}
\DoxyCodeLine{3729     lapack::cx\_gesdd<T>(\&jobz, \&m, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, S.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), U.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldu, V.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldvt, work.memptr(), \&lwork\_final, rwork.memptr(), iwork.memptr(), \&info);}
\DoxyCodeLine{3730     }
\DoxyCodeLine{3731     \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{3732     \}}
\DoxyCodeLine{3733 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{3734     \{}
\DoxyCodeLine{3735     arma\_ignore(S);}
\DoxyCodeLine{3736     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{3737     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}svd(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{3738     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3739     \}}
\DoxyCodeLine{3740 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{3741   \}}
\DoxyCodeLine{3742 }
\DoxyCodeLine{3743 }
\DoxyCodeLine{3744 }
\DoxyCodeLine{3745 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{3746 \textcolor{keyword}{inline}}
\DoxyCodeLine{3747 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{3748 auxlib::svd\_dc(\mbox{\hyperlink{classMat}{Mat<eT>}}\& U, \mbox{\hyperlink{classCol}{Col<eT>}}\& S, \mbox{\hyperlink{classMat}{Mat<eT>}}\& V, \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}})}
\DoxyCodeLine{3749   \{}
\DoxyCodeLine{3750   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{3751   }
\DoxyCodeLine{3752 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{3753     \{}
\DoxyCodeLine{3754     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty())}
\DoxyCodeLine{3755       \{}
\DoxyCodeLine{3756       U.eye(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{3757       S.reset();}
\DoxyCodeLine{3758       V.eye(\mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{3759       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3760       \}}
\DoxyCodeLine{3761     }
\DoxyCodeLine{3762     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{3763     }
\DoxyCodeLine{3764     U.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{3765     V.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(\mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{3766     }
\DoxyCodeLine{3767     \textcolor{keywordtype}{char} jobz = \textcolor{charliteral}{'A'};}
\DoxyCodeLine{3768     }
\DoxyCodeLine{3769     blas\_int  m         = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{3770     blas\_int  n         = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{3771     blas\_int  min\_mn    = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(m,n);}
\DoxyCodeLine{3772     blas\_int  max\_mn    = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(m,n);}
\DoxyCodeLine{3773     blas\_int  lda       = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{3774     blas\_int  ldu       = blas\_int(U.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{3775     blas\_int  ldvt      = blas\_int(V.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{3776     blas\_int  lwork1    = 3*min\_mn*min\_mn + (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(max\_mn, 4*min\_mn*min\_mn + 4*min\_mn);  \textcolor{comment}{// as per LAPACK 3.2 docs}}
\DoxyCodeLine{3777     blas\_int  lwork2    = 4*min\_mn*min\_mn + 6*min\_mn + max\_mn;  \textcolor{comment}{// as per LAPACK 3.8 docs; consistent with LAPACK 3.4 docs}}
\DoxyCodeLine{3778     blas\_int  lwork\_min = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(lwork1, lwork2);  \textcolor{comment}{// due to differences between LAPACK 3.2 and 3.8}}
\DoxyCodeLine{3779     blas\_int  info      = 0;}
\DoxyCodeLine{3780     }
\DoxyCodeLine{3781     S.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(min\_mn) );}
\DoxyCodeLine{3782     }
\DoxyCodeLine{3783     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} iwork( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(8*min\_mn) );}
\DoxyCodeLine{3784     }
\DoxyCodeLine{3785     blas\_int lwork\_proposed = 0;}
\DoxyCodeLine{3786     }
\DoxyCodeLine{3787     \textcolor{keywordflow}{if}((m*n) >= 1024)}
\DoxyCodeLine{3788       \{}
\DoxyCodeLine{3789       eT        work\_query[2];}
\DoxyCodeLine{3790       blas\_int lwork\_query = blas\_int(-\/1);}
\DoxyCodeLine{3791       }
\DoxyCodeLine{3792       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::gesdd()"{}});}
\DoxyCodeLine{3793       lapack::gesdd<eT>(\&jobz, \&m, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, S.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), U.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldu, V.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldvt, \&work\_query[0], \&lwork\_query, iwork.memptr(), \&info);}
\DoxyCodeLine{3794       }
\DoxyCodeLine{3795       \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{3796       }
\DoxyCodeLine{3797       lwork\_proposed = \textcolor{keyword}{static\_cast<}blas\_int\textcolor{keyword}{>}(work\_query[0]);}
\DoxyCodeLine{3798       \}}
\DoxyCodeLine{3799     }
\DoxyCodeLine{3800     blas\_int lwork\_final = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(lwork\_proposed, lwork\_min);}
\DoxyCodeLine{3801     }
\DoxyCodeLine{3802     \mbox{\hyperlink{classpodarray}{podarray<eT>}} work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork\_final) );}
\DoxyCodeLine{3803     }
\DoxyCodeLine{3804     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::gesdd()"{}});}
\DoxyCodeLine{3805     lapack::gesdd<eT>(\&jobz, \&m, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, S.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), U.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldu, V.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldvt, work.memptr(), \&lwork\_final, iwork.memptr(), \&info);}
\DoxyCodeLine{3806     }
\DoxyCodeLine{3807     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{3808     }
\DoxyCodeLine{3809     op\_strans::apply\_mat\_inplace(V);}
\DoxyCodeLine{3810     }
\DoxyCodeLine{3811     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3812     \}}
\DoxyCodeLine{3813 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{3814     \{}
\DoxyCodeLine{3815     arma\_ignore(U);}
\DoxyCodeLine{3816     arma\_ignore(S);}
\DoxyCodeLine{3817     arma\_ignore(V);}
\DoxyCodeLine{3818     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{3819     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}svd(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{3820     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3821     \}}
\DoxyCodeLine{3822 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{3823   \}}
\DoxyCodeLine{3824 }
\DoxyCodeLine{3825 }
\DoxyCodeLine{3826 }
\DoxyCodeLine{3827 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3828 \textcolor{keyword}{inline}}
\DoxyCodeLine{3829 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{3830 auxlib::svd\_dc(\mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& U, \mbox{\hyperlink{classCol}{Col<T>}}\& S, \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& V, \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& \mbox{\hyperlink{structA}{A}})}
\DoxyCodeLine{3831   \{}
\DoxyCodeLine{3832   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{3833   }
\DoxyCodeLine{3834 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{3835     \{}
\DoxyCodeLine{3836     \textcolor{keyword}{typedef} std::complex<T> eT;}
\DoxyCodeLine{3837     }
\DoxyCodeLine{3838     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty())}
\DoxyCodeLine{3839       \{}
\DoxyCodeLine{3840       U.eye(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{3841       S.reset();}
\DoxyCodeLine{3842       V.eye(\mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{3843       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3844       \}}
\DoxyCodeLine{3845     }
\DoxyCodeLine{3846     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{3847     }
\DoxyCodeLine{3848     U.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{3849     V.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(\mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{3850     }
\DoxyCodeLine{3851     \textcolor{keywordtype}{char} jobz = \textcolor{charliteral}{'A'};}
\DoxyCodeLine{3852     }
\DoxyCodeLine{3853     blas\_int m         = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{3854     blas\_int n         = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{3855     blas\_int min\_mn    = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(m,n);}
\DoxyCodeLine{3856     blas\_int max\_mn    = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(m,n);}
\DoxyCodeLine{3857     blas\_int lda       = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{3858     blas\_int ldu       = blas\_int(U.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{3859     blas\_int ldvt      = blas\_int(V.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{3860     blas\_int lwork\_min = min\_mn*min\_mn + 2*min\_mn + max\_mn;  \textcolor{comment}{// as per LAPACK 3.2, 3.4, 3.8 docs}}
\DoxyCodeLine{3861     blas\_int lrwork    = min\_mn * ((\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(5*min\_mn+7, 2*max\_mn + 2*min\_mn+1));   \textcolor{comment}{// as per LAPACK 3.4 docs; LAPACK 3.8 uses 5*min\_mn+5 instead of 5*min\_mn+7}}
\DoxyCodeLine{3862     blas\_int info      = 0;}
\DoxyCodeLine{3863     }
\DoxyCodeLine{3864     S.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(min\_mn) );}
\DoxyCodeLine{3865     }
\DoxyCodeLine{3866     \mbox{\hyperlink{classpodarray}{podarray<T>}}        rwork( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lrwork  ) );}
\DoxyCodeLine{3867     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} iwork( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(8*min\_mn) );}
\DoxyCodeLine{3868     }
\DoxyCodeLine{3869     blas\_int lwork\_proposed = 0;}
\DoxyCodeLine{3870     }
\DoxyCodeLine{3871     \textcolor{keywordflow}{if}((m*n) >= 1024)}
\DoxyCodeLine{3872       \{}
\DoxyCodeLine{3873       eT        work\_query[2];}
\DoxyCodeLine{3874       blas\_int lwork\_query = blas\_int(-\/1);}
\DoxyCodeLine{3875       }
\DoxyCodeLine{3876       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::cx\_gesdd()"{}});}
\DoxyCodeLine{3877       lapack::cx\_gesdd<T>(\&jobz, \&m, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, S.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), U.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldu, V.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldvt, \&work\_query[0], \&lwork\_query, rwork.memptr(), iwork.memptr(), \&info);}
\DoxyCodeLine{3878       }
\DoxyCodeLine{3879       \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{3880       }
\DoxyCodeLine{3881       lwork\_proposed = \textcolor{keyword}{static\_cast<}blas\_int\textcolor{keyword}{>}( \mbox{\hyperlink{classaccess_a9687cee4d2be0fe591998d6f5c6d0849}{access::tmp\_real}}(work\_query[0]) );}
\DoxyCodeLine{3882       \}}
\DoxyCodeLine{3883     }
\DoxyCodeLine{3884     blas\_int lwork\_final = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(lwork\_proposed, lwork\_min);}
\DoxyCodeLine{3885     }
\DoxyCodeLine{3886     \mbox{\hyperlink{classpodarray}{podarray<eT>}} work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork\_final) );}
\DoxyCodeLine{3887     }
\DoxyCodeLine{3888     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::cx\_gesdd()"{}});}
\DoxyCodeLine{3889     lapack::cx\_gesdd<T>(\&jobz, \&m, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, S.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), U.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldu, V.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldvt, work.memptr(), \&lwork\_final, rwork.memptr(), iwork.memptr(), \&info);}
\DoxyCodeLine{3890     }
\DoxyCodeLine{3891     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{3892     }
\DoxyCodeLine{3893     op\_htrans::apply\_mat\_inplace(V);}
\DoxyCodeLine{3894     }
\DoxyCodeLine{3895     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3896     \}}
\DoxyCodeLine{3897 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{3898     \{}
\DoxyCodeLine{3899     arma\_ignore(U);}
\DoxyCodeLine{3900     arma\_ignore(S);}
\DoxyCodeLine{3901     arma\_ignore(V);}
\DoxyCodeLine{3902     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{3903     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}svd(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{3904     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3905     \}}
\DoxyCodeLine{3906 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{3907   \}}
\DoxyCodeLine{3908 }
\DoxyCodeLine{3909 }
\DoxyCodeLine{3910 }
\DoxyCodeLine{3911 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{3912 \textcolor{keyword}{inline}}
\DoxyCodeLine{3913 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{3914 auxlib::svd\_dc\_econ(\mbox{\hyperlink{classMat}{Mat<eT>}}\& U, \mbox{\hyperlink{classCol}{Col<eT>}}\& S, \mbox{\hyperlink{classMat}{Mat<eT>}}\& V, \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}})}
\DoxyCodeLine{3915   \{}
\DoxyCodeLine{3916   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{3917   }
\DoxyCodeLine{3918 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{3919     \{}
\DoxyCodeLine{3920     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{3921     }
\DoxyCodeLine{3922     \textcolor{keywordtype}{char} jobz = \textcolor{charliteral}{'S'};}
\DoxyCodeLine{3923     }
\DoxyCodeLine{3924     blas\_int m         = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{3925     blas\_int n         = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{3926     blas\_int min\_mn    = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(m,n);}
\DoxyCodeLine{3927     blas\_int max\_mn    = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(m,n);}
\DoxyCodeLine{3928     blas\_int lda       = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{3929     blas\_int ldu       = m;}
\DoxyCodeLine{3930     blas\_int ldvt      = min\_mn;}
\DoxyCodeLine{3931     blas\_int lwork1    = 3*min\_mn*min\_mn + (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})( max\_mn, 4*min\_mn*min\_mn + 4*min\_mn );  \textcolor{comment}{// as per LAPACK 3.2 docs}}
\DoxyCodeLine{3932     blas\_int lwork2    = 4*min\_mn*min\_mn + 6*min\_mn + max\_mn;  \textcolor{comment}{// as per LAPACK 3.4 docs; LAPACK 3.8 requires 4*min\_mn*min\_mn + 7*min\_mn}}
\DoxyCodeLine{3933     blas\_int lwork\_min = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(lwork1, lwork2);  \textcolor{comment}{// due to differences between LAPACK 3.2 and 3.4}}
\DoxyCodeLine{3934     blas\_int info      = 0;}
\DoxyCodeLine{3935     }
\DoxyCodeLine{3936     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty())}
\DoxyCodeLine{3937       \{}
\DoxyCodeLine{3938       U.eye();}
\DoxyCodeLine{3939       S.reset();}
\DoxyCodeLine{3940       V.eye( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(n), \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(min\_mn) );}
\DoxyCodeLine{3941       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3942       \}}
\DoxyCodeLine{3943     }
\DoxyCodeLine{3944     S.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(min\_mn) );}
\DoxyCodeLine{3945     }
\DoxyCodeLine{3946     U.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(m), \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(min\_mn) );}
\DoxyCodeLine{3947     }
\DoxyCodeLine{3948     V.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(min\_mn), \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(n) );}
\DoxyCodeLine{3949     }
\DoxyCodeLine{3950     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} iwork( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(8*min\_mn) );}
\DoxyCodeLine{3951     }
\DoxyCodeLine{3952     blas\_int lwork\_proposed = 0;}
\DoxyCodeLine{3953     }
\DoxyCodeLine{3954     \textcolor{keywordflow}{if}((m*n) >= 1024)}
\DoxyCodeLine{3955       \{}
\DoxyCodeLine{3956       eT        work\_query[2];}
\DoxyCodeLine{3957       blas\_int lwork\_query = blas\_int(-\/1);}
\DoxyCodeLine{3958       }
\DoxyCodeLine{3959       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::gesdd()"{}});}
\DoxyCodeLine{3960       lapack::gesdd<eT>(\&jobz, \&m, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, S.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), U.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldu, V.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldvt, \&work\_query[0], \&lwork\_query, iwork.memptr(), \&info);}
\DoxyCodeLine{3961       }
\DoxyCodeLine{3962       \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{3963       }
\DoxyCodeLine{3964       lwork\_proposed = \textcolor{keyword}{static\_cast<}blas\_int\textcolor{keyword}{>}(work\_query[0]);}
\DoxyCodeLine{3965       \}}
\DoxyCodeLine{3966     }
\DoxyCodeLine{3967     blas\_int lwork\_final = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(lwork\_proposed, lwork\_min);}
\DoxyCodeLine{3968     }
\DoxyCodeLine{3969     \mbox{\hyperlink{classpodarray}{podarray<eT>}} work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork\_final) );}
\DoxyCodeLine{3970     }
\DoxyCodeLine{3971     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::gesdd()"{}});}
\DoxyCodeLine{3972     lapack::gesdd<eT>(\&jobz, \&m, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, S.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), U.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldu, V.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldvt, work.memptr(), \&lwork\_final, iwork.memptr(), \&info);}
\DoxyCodeLine{3973     }
\DoxyCodeLine{3974     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{3975     }
\DoxyCodeLine{3976     op\_strans::apply\_mat\_inplace(V);}
\DoxyCodeLine{3977     }
\DoxyCodeLine{3978     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3979     \}}
\DoxyCodeLine{3980 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{3981     \{}
\DoxyCodeLine{3982     arma\_ignore(U);}
\DoxyCodeLine{3983     arma\_ignore(S);}
\DoxyCodeLine{3984     arma\_ignore(V);}
\DoxyCodeLine{3985     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{3986     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}svd(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{3987     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3988     \}}
\DoxyCodeLine{3989 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{3990   \}}
\DoxyCodeLine{3991 }
\DoxyCodeLine{3992 }
\DoxyCodeLine{3993 }
\DoxyCodeLine{3994 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3995 \textcolor{keyword}{inline}}
\DoxyCodeLine{3996 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{3997 auxlib::svd\_dc\_econ(\mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& U, \mbox{\hyperlink{classCol}{Col<T>}}\& S, \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& V, \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& \mbox{\hyperlink{structA}{A}})}
\DoxyCodeLine{3998   \{}
\DoxyCodeLine{3999   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{4000   }
\DoxyCodeLine{4001 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{4002     \{}
\DoxyCodeLine{4003     \textcolor{keyword}{typedef} std::complex<T> eT;}
\DoxyCodeLine{4004     }
\DoxyCodeLine{4005     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{4006     }
\DoxyCodeLine{4007     \textcolor{keywordtype}{char} jobz = \textcolor{charliteral}{'S'};}
\DoxyCodeLine{4008     }
\DoxyCodeLine{4009     blas\_int m         = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4010     blas\_int n         = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{4011     blas\_int min\_mn    = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(m,n);}
\DoxyCodeLine{4012     blas\_int max\_mn    = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(m,n);}
\DoxyCodeLine{4013     blas\_int lda       = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4014     blas\_int ldu       = m;}
\DoxyCodeLine{4015     blas\_int ldvt      = min\_mn;}
\DoxyCodeLine{4016     blas\_int lwork\_min = min\_mn*min\_mn + 2*min\_mn + max\_mn;  \textcolor{comment}{// as per LAPACK 3.2 docs}}
\DoxyCodeLine{4017     blas\_int lrwork    = min\_mn * ((\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(5*min\_mn+7, 2*max\_mn + 2*min\_mn+1));  \textcolor{comment}{// LAPACK 3.8 uses 5*min\_mn+5 instead of 5*min\_mn+7}}
\DoxyCodeLine{4018     blas\_int info      = 0;}
\DoxyCodeLine{4019     }
\DoxyCodeLine{4020     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty())}
\DoxyCodeLine{4021       \{}
\DoxyCodeLine{4022       U.eye();}
\DoxyCodeLine{4023       S.reset();}
\DoxyCodeLine{4024       V.eye( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(n), \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(min\_mn) );}
\DoxyCodeLine{4025       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{4026       \}}
\DoxyCodeLine{4027     }
\DoxyCodeLine{4028     S.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(min\_mn) );}
\DoxyCodeLine{4029     }
\DoxyCodeLine{4030     U.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(m), \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(min\_mn) );}
\DoxyCodeLine{4031     }
\DoxyCodeLine{4032     V.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(min\_mn), \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(n) );}
\DoxyCodeLine{4033     }
\DoxyCodeLine{4034     \mbox{\hyperlink{classpodarray}{podarray<T>}}        rwork( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lrwork  ) );}
\DoxyCodeLine{4035     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} iwork( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(8*min\_mn) );}
\DoxyCodeLine{4036     }
\DoxyCodeLine{4037     blas\_int lwork\_proposed = 0;}
\DoxyCodeLine{4038     }
\DoxyCodeLine{4039     \textcolor{keywordflow}{if}((m*n) >= 1024)}
\DoxyCodeLine{4040       \{}
\DoxyCodeLine{4041       eT        work\_query[2];}
\DoxyCodeLine{4042       blas\_int lwork\_query = blas\_int(-\/1);}
\DoxyCodeLine{4043       }
\DoxyCodeLine{4044       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::cx\_gesdd()"{}});}
\DoxyCodeLine{4045       lapack::cx\_gesdd<T>(\&jobz, \&m, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, S.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), U.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldu, V.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldvt, \&work\_query[0], \&lwork\_query, rwork.memptr(), iwork.memptr(), \&info);}
\DoxyCodeLine{4046       }
\DoxyCodeLine{4047       \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{4048       }
\DoxyCodeLine{4049       lwork\_proposed = \textcolor{keyword}{static\_cast<}blas\_int\textcolor{keyword}{>}( \mbox{\hyperlink{classaccess_a9687cee4d2be0fe591998d6f5c6d0849}{access::tmp\_real}}(work\_query[0]) );}
\DoxyCodeLine{4050       \}}
\DoxyCodeLine{4051     }
\DoxyCodeLine{4052     blas\_int lwork\_final = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(lwork\_proposed, lwork\_min);}
\DoxyCodeLine{4053     }
\DoxyCodeLine{4054     \mbox{\hyperlink{classpodarray}{podarray<eT>}} work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork\_final) );}
\DoxyCodeLine{4055     }
\DoxyCodeLine{4056     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::cx\_gesdd()"{}});}
\DoxyCodeLine{4057     lapack::cx\_gesdd<T>(\&jobz, \&m, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, S.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), U.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldu, V.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldvt, work.memptr(), \&lwork\_final, rwork.memptr(), iwork.memptr(), \&info);}
\DoxyCodeLine{4058     }
\DoxyCodeLine{4059     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{4060     }
\DoxyCodeLine{4061     op\_htrans::apply\_mat\_inplace(V);}
\DoxyCodeLine{4062     }
\DoxyCodeLine{4063     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{4064     \}}
\DoxyCodeLine{4065 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{4066     \{}
\DoxyCodeLine{4067     arma\_ignore(U);}
\DoxyCodeLine{4068     arma\_ignore(S);}
\DoxyCodeLine{4069     arma\_ignore(V);}
\DoxyCodeLine{4070     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{4071     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}svd(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{4072     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{4073     \}}
\DoxyCodeLine{4074 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{4075   \}}
\DoxyCodeLine{4076 }
\DoxyCodeLine{4077 }
\DoxyCodeLine{4078 }
\DoxyCodeLine{4080 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{4081 arma\_cold}
\DoxyCodeLine{4082 \textcolor{keyword}{inline}}
\DoxyCodeLine{4083 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{4084 \mbox{\hyperlink{group__auxlib_gaa6f6fa63e5763cf3877cdb3d8f4188b0}{auxlib::solve\_square\_tiny}}(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::elem\_type,T1>}}\& B\_expr)}
\DoxyCodeLine{4085   \{}
\DoxyCodeLine{4086   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{4087   }
\DoxyCodeLine{4088   \textcolor{comment}{// NOTE: assuming A has size <= 4x4}}
\DoxyCodeLine{4089   }
\DoxyCodeLine{4090   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{4091   }
\DoxyCodeLine{4092   \textcolor{keyword}{const} uword A\_n\_rows = \mbox{\hyperlink{structA}{A}}.n\_rows;}
\DoxyCodeLine{4093   }
\DoxyCodeLine{4094   \mbox{\hyperlink{classMat}{Mat<eT>}} A\_inv(A\_n\_rows, A\_n\_rows, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{4095   }
\DoxyCodeLine{4096   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} status = op\_inv::apply\_tiny\_noalias(A\_inv, \mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{4097   }
\DoxyCodeLine{4098   \textcolor{keywordflow}{if}(status == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{4099   }
\DoxyCodeLine{4100   \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} UB(B\_expr.get\_ref());}
\DoxyCodeLine{4101   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structB}{B}}     = UB.M;}
\DoxyCodeLine{4102   }
\DoxyCodeLine{4103   \textcolor{keyword}{const} uword B\_n\_rows = \mbox{\hyperlink{structB}{B}}.n\_rows;}
\DoxyCodeLine{4104   \textcolor{keyword}{const} uword B\_n\_cols = \mbox{\hyperlink{structB}{B}}.n\_cols;}
\DoxyCodeLine{4105   }
\DoxyCodeLine{4106   arma\_debug\_check( (A\_n\_rows != B\_n\_rows), \textcolor{stringliteral}{"{}solve(): number of rows in the given matrices must be the same"{}} );}
\DoxyCodeLine{4107   }
\DoxyCodeLine{4108   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty() || \mbox{\hyperlink{structB}{B}}.is\_empty())}
\DoxyCodeLine{4109     \{}
\DoxyCodeLine{4110     out.zeros(\mbox{\hyperlink{structA}{A}}.n\_cols, B\_n\_cols);}
\DoxyCodeLine{4111     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{4112     \}}
\DoxyCodeLine{4113   }
\DoxyCodeLine{4114   \textcolor{keywordflow}{if}(UB.is\_alias(out))}
\DoxyCodeLine{4115     \{}
\DoxyCodeLine{4116     \mbox{\hyperlink{classMat}{Mat<eT>}} tmp(A\_n\_rows, B\_n\_cols, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{4117     }
\DoxyCodeLine{4118     \mbox{\hyperlink{classgemm__emul}{gemm\_emul<false,false,false,false>::apply}}(tmp, A\_inv, \mbox{\hyperlink{structB}{B}});}
\DoxyCodeLine{4119     }
\DoxyCodeLine{4120     out.\mbox{\hyperlink{group__Mat_gaff06a75771f96605f7cc4f8c6b3fceb7}{steal\_mem}}(tmp);}
\DoxyCodeLine{4121     \}}
\DoxyCodeLine{4122   \textcolor{keywordflow}{else}}
\DoxyCodeLine{4123     \{}
\DoxyCodeLine{4124     out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(A\_n\_rows, B\_n\_cols);}
\DoxyCodeLine{4125     }
\DoxyCodeLine{4126     \mbox{\hyperlink{classgemm__emul}{gemm\_emul<false,false,false,false>::apply}}(out, A\_inv, \mbox{\hyperlink{structB}{B}});}
\DoxyCodeLine{4127     \}}
\DoxyCodeLine{4128   }
\DoxyCodeLine{4129   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{4130   \}}
\DoxyCodeLine{4131 }
\DoxyCodeLine{4132 }
\DoxyCodeLine{4133 }
\DoxyCodeLine{4135 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{4136 \textcolor{keyword}{inline}}
\DoxyCodeLine{4137 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{4138 \mbox{\hyperlink{group__auxlib_ga530089e89e43155f3bf6e709bbe775dd}{auxlib::solve\_square\_fast}}(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::elem\_type,T1>}}\& B\_expr)}
\DoxyCodeLine{4139   \{}
\DoxyCodeLine{4140   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{4141   }
\DoxyCodeLine{4142   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{4143   }
\DoxyCodeLine{4144   \textcolor{keyword}{const} uword A\_n\_rows = \mbox{\hyperlink{structA}{A}}.n\_rows;}
\DoxyCodeLine{4145   }
\DoxyCodeLine{4146   \textcolor{keywordflow}{if}((A\_n\_rows <= 4) \&\& \mbox{\hyperlink{structis__cx}{is\_cx<eT>::no}})}
\DoxyCodeLine{4147     \{}
\DoxyCodeLine{4148     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} status = \mbox{\hyperlink{group__auxlib_gaa6f6fa63e5763cf3877cdb3d8f4188b0}{auxlib::solve\_square\_tiny}}(out, \mbox{\hyperlink{structA}{A}}, B\_expr.get\_ref());}
\DoxyCodeLine{4149     }
\DoxyCodeLine{4150     \textcolor{keywordflow}{if}(status)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{4151     \}}
\DoxyCodeLine{4152   }
\DoxyCodeLine{4153   out = B\_expr.get\_ref();}
\DoxyCodeLine{4154   }
\DoxyCodeLine{4155   \textcolor{keyword}{const} uword B\_n\_rows = out.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}};}
\DoxyCodeLine{4156   \textcolor{keyword}{const} uword B\_n\_cols = out.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}};}
\DoxyCodeLine{4157     }
\DoxyCodeLine{4158   arma\_debug\_check( (A\_n\_rows != B\_n\_rows), \textcolor{stringliteral}{"{}solve(): number of rows in the given matrices must be the same"{}} );}
\DoxyCodeLine{4159     }
\DoxyCodeLine{4160   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty() || out.\mbox{\hyperlink{group__Mat_ga3008049216e02308ff665862f451a7ff}{is\_empty}}())}
\DoxyCodeLine{4161     \{}
\DoxyCodeLine{4162     out.zeros(\mbox{\hyperlink{structA}{A}}.n\_cols, B\_n\_cols);}
\DoxyCodeLine{4163     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{4164     \}}
\DoxyCodeLine{4165   }
\DoxyCodeLine{4166 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_ATLAS)}}
\DoxyCodeLine{4167     \{}
\DoxyCodeLine{4168     arma\_debug\_assert\_atlas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{4169     }
\DoxyCodeLine{4170     \mbox{\hyperlink{classpodarray}{podarray<int>}} ipiv(A\_n\_rows + 2);  \textcolor{comment}{// +2 for paranoia: old versions of Atlas might be trashing memory}}
\DoxyCodeLine{4171     }
\DoxyCodeLine{4172     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}atlas::clapack\_gesv()"{}});}
\DoxyCodeLine{4173     \textcolor{keywordtype}{int} info = atlas::clapack\_gesv<eT>(atlas::CblasColMajor, A\_n\_rows, B\_n\_cols, \mbox{\hyperlink{structA}{A}}.memptr(), A\_n\_rows, ipiv.memptr(), out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), A\_n\_rows);}
\DoxyCodeLine{4174     }
\DoxyCodeLine{4175     \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{4176     \}}
\DoxyCodeLine{4177 \textcolor{preprocessor}{  \#elif defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{4178     \{}
\DoxyCodeLine{4179     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{4180     }
\DoxyCodeLine{4181     blas\_int n    = blas\_int(A\_n\_rows);  \textcolor{comment}{// assuming A is square}}
\DoxyCodeLine{4182     blas\_int lda  = blas\_int(A\_n\_rows);}
\DoxyCodeLine{4183     blas\_int ldb  = blas\_int(B\_n\_rows);}
\DoxyCodeLine{4184     blas\_int nrhs = blas\_int(B\_n\_cols);}
\DoxyCodeLine{4185     blas\_int info = blas\_int(0);}
\DoxyCodeLine{4186     }
\DoxyCodeLine{4187     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} ipiv(A\_n\_rows + 2);  \textcolor{comment}{// +2 for paranoia: some versions of Lapack might be trashing memory}}
\DoxyCodeLine{4188     }
\DoxyCodeLine{4189     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::gesv()"{}});}
\DoxyCodeLine{4190     lapack::gesv<eT>(\&n, \&nrhs, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, ipiv.memptr(), out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldb, \&info);}
\DoxyCodeLine{4191     }
\DoxyCodeLine{4192     \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{4193     \}}
\DoxyCodeLine{4194 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{4195     \{}
\DoxyCodeLine{4196     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}solve(): use of ATLAS or LAPACK must be enabled"{}});}
\DoxyCodeLine{4197     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{4198     \}}
\DoxyCodeLine{4199 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{4200   \}}
\DoxyCodeLine{4201 }
\DoxyCodeLine{4202 }
\DoxyCodeLine{4203 }
\DoxyCodeLine{4205 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{4206 \textcolor{keyword}{inline}}
\DoxyCodeLine{4207 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{4208 \mbox{\hyperlink{group__auxlib_ga16be749fd9b7ac92dd2f437f9e45fdf9}{auxlib::solve\_square\_rcond}}(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{typename} T1::pod\_type\& out\_rcond, \mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::elem\_type,T1>}}\& B\_expr, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_ugly)}
\DoxyCodeLine{4209   \{}
\DoxyCodeLine{4210   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{4211   }
\DoxyCodeLine{4212 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{4213     \{}
\DoxyCodeLine{4214     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{4215     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type   T;}
\DoxyCodeLine{4216     }
\DoxyCodeLine{4217     out\_rcond = T(0);}
\DoxyCodeLine{4218     }
\DoxyCodeLine{4219     out = B\_expr.get\_ref();}
\DoxyCodeLine{4220     }
\DoxyCodeLine{4221     \textcolor{keyword}{const} uword B\_n\_rows = out.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}};}
\DoxyCodeLine{4222     \textcolor{keyword}{const} uword B\_n\_cols = out.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}};}
\DoxyCodeLine{4223       }
\DoxyCodeLine{4224     arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.n\_rows != B\_n\_rows), \textcolor{stringliteral}{"{}solve(): number of rows in the given matrices must be the same"{}} );}
\DoxyCodeLine{4225       }
\DoxyCodeLine{4226     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty() || out.\mbox{\hyperlink{group__Mat_ga3008049216e02308ff665862f451a7ff}{is\_empty}}())}
\DoxyCodeLine{4227       \{}
\DoxyCodeLine{4228       out.zeros(\mbox{\hyperlink{structA}{A}}.n\_cols, B\_n\_cols);}
\DoxyCodeLine{4229       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{4230       \}}
\DoxyCodeLine{4231     }
\DoxyCodeLine{4232     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{4233     }
\DoxyCodeLine{4234     \textcolor{keywordtype}{char}     norm\_id  = \textcolor{charliteral}{'1'};}
\DoxyCodeLine{4235     \textcolor{keywordtype}{char}     trans    = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{4236     blas\_int n        = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);  \textcolor{comment}{// assuming A is square}}
\DoxyCodeLine{4237     blas\_int lda      = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4238     blas\_int ldb      = blas\_int(B\_n\_rows);}
\DoxyCodeLine{4239     blas\_int nrhs     = blas\_int(B\_n\_cols);}
\DoxyCodeLine{4240     blas\_int info     = blas\_int(0);}
\DoxyCodeLine{4241     T        norm\_val = T(0);}
\DoxyCodeLine{4242     }
\DoxyCodeLine{4243     \mbox{\hyperlink{classpodarray}{podarray<T>}}        junk(1);}
\DoxyCodeLine{4244     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} ipiv(\mbox{\hyperlink{structA}{A}}.n\_rows + 2);  \textcolor{comment}{// +2 for paranoia}}
\DoxyCodeLine{4245     }
\DoxyCodeLine{4246     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::lange()"{}});}
\DoxyCodeLine{4247     norm\_val = lapack::lange<eT>(\&norm\_id, \&n, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, junk.memptr());}
\DoxyCodeLine{4248     }
\DoxyCodeLine{4249     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::getrf()"{}});}
\DoxyCodeLine{4250     lapack::getrf<eT>(\&n, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&n, ipiv.memptr(), \&info);}
\DoxyCodeLine{4251     }
\DoxyCodeLine{4252     \textcolor{keywordflow}{if}(info != blas\_int(0))  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{4253     }
\DoxyCodeLine{4254     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::getrs()"{}});}
\DoxyCodeLine{4255     lapack::getrs<eT>(\&trans, \&n, \&nrhs, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, ipiv.memptr(), out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldb, \&info);}
\DoxyCodeLine{4256     }
\DoxyCodeLine{4257     \textcolor{keywordflow}{if}(info != blas\_int(0))  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{4258     }
\DoxyCodeLine{4259     out\_rcond = auxlib::lu\_rcond<T>(\mbox{\hyperlink{structA}{A}}, norm\_val);}
\DoxyCodeLine{4260     }
\DoxyCodeLine{4261     \textcolor{keywordflow}{if}( (allow\_ugly == \textcolor{keyword}{false}) \&\& (out\_rcond < auxlib::epsilon\_lapack(\mbox{\hyperlink{structA}{A}})) )  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{4262     }
\DoxyCodeLine{4263     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{4264     \}}
\DoxyCodeLine{4265 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{4266     \{}
\DoxyCodeLine{4267     arma\_ignore(out);}
\DoxyCodeLine{4268     arma\_ignore(out\_rcond);}
\DoxyCodeLine{4269     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{4270     arma\_ignore(B\_expr);}
\DoxyCodeLine{4271     arma\_ignore(allow\_ugly);}
\DoxyCodeLine{4272     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}solve(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{4273     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{4274     \}}
\DoxyCodeLine{4275 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{4276   \}}
\DoxyCodeLine{4277 }
\DoxyCodeLine{4278 }
\DoxyCodeLine{4279 }
\DoxyCodeLine{4281 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{4282 \textcolor{keyword}{inline}}
\DoxyCodeLine{4283 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{4284 \mbox{\hyperlink{group__auxlib_gab1d24ba6a7f6a7aad1b5bcf4d75bd1bf}{auxlib::solve\_square\_refine}}(\mbox{\hyperlink{classMat}{Mat<typename T1::pod\_type>}}\& out, \textcolor{keyword}{typename} T1::pod\_type\& out\_rcond, \mbox{\hyperlink{classMat}{Mat<typename T1::pod\_type>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::pod\_type,T1>}}\& B\_expr, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} equilibrate, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_ugly)}
\DoxyCodeLine{4285   \{}
\DoxyCodeLine{4286   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{4287   }
\DoxyCodeLine{4288 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{4289     \{}
\DoxyCodeLine{4290     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type eT;}
\DoxyCodeLine{4291     }
\DoxyCodeLine{4292     \textcolor{comment}{// Mat<eT> B = B\_expr.get\_ref();  // B is overwritten by lapack::gesvx() if equilibrate is enabled}}
\DoxyCodeLine{4293     }
\DoxyCodeLine{4294     \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} UB(B\_expr.get\_ref());  \textcolor{comment}{// deliberately not declaring as const}}
\DoxyCodeLine{4295     }
\DoxyCodeLine{4296     \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& UB\_M\_as\_Mat = UB.M;  \textcolor{comment}{// so we don't confuse the ?: operator below}}
\DoxyCodeLine{4297     }
\DoxyCodeLine{4298     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_copy = ((equilibrate \&\& UB.is\_const) || UB.is\_alias(out));}
\DoxyCodeLine{4299     }
\DoxyCodeLine{4300     \mbox{\hyperlink{classMat}{Mat<eT>}} B\_tmp;  \textcolor{keywordflow}{if}(use\_copy)  \{ B\_tmp = UB\_M\_as\_Mat; \}}
\DoxyCodeLine{4301     }
\DoxyCodeLine{4302     \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structB}{B}} = (use\_copy) ? B\_tmp : UB\_M\_as\_Mat;}
\DoxyCodeLine{4303     }
\DoxyCodeLine{4304     arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.n\_rows != \mbox{\hyperlink{structB}{B}}.n\_rows), \textcolor{stringliteral}{"{}solve(): number of rows in the given matrices must be the same"{}} );}
\DoxyCodeLine{4305       }
\DoxyCodeLine{4306     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty() || \mbox{\hyperlink{structB}{B}}.is\_empty())}
\DoxyCodeLine{4307       \{}
\DoxyCodeLine{4308       out.zeros(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{4309       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{4310       \}}
\DoxyCodeLine{4311     }
\DoxyCodeLine{4312     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}},\mbox{\hyperlink{structB}{B}});}
\DoxyCodeLine{4313     }
\DoxyCodeLine{4314     out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{4315     }
\DoxyCodeLine{4316     \textcolor{keywordtype}{char}     fact  = (equilibrate) ? \textcolor{charliteral}{'E'} : \textcolor{charliteral}{'N'}; }
\DoxyCodeLine{4317     \textcolor{keywordtype}{char}     trans = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{4318     \textcolor{keywordtype}{char}     equed = char(0);}
\DoxyCodeLine{4319     blas\_int n     = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4320     blas\_int nrhs  = blas\_int(\mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{4321     blas\_int lda   = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4322     blas\_int ldaf  = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4323     blas\_int ldb   = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4324     blas\_int ldx   = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4325     blas\_int info  = blas\_int(0);}
\DoxyCodeLine{4326     eT       rcond = eT(0);}
\DoxyCodeLine{4327     }
\DoxyCodeLine{4328     \mbox{\hyperlink{classMat}{Mat<eT>}} AF(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{4329     }
\DoxyCodeLine{4330     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}}  IPIV(  \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4331     \mbox{\hyperlink{classpodarray}{podarray<eT>}}           R(  \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4332     \mbox{\hyperlink{classpodarray}{podarray<eT>}}           C(  \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4333     \mbox{\hyperlink{classpodarray}{podarray<eT>}}        FERR(  \mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{4334     \mbox{\hyperlink{classpodarray}{podarray<eT>}}        BERR(  \mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{4335     \mbox{\hyperlink{classpodarray}{podarray<eT>}}        WORK(4*\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4336     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} IWORK(  \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4337     }
\DoxyCodeLine{4338     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::gesvx()"{}});}
\DoxyCodeLine{4339     lapack::gesvx}
\DoxyCodeLine{4340       (}
\DoxyCodeLine{4341       \&fact, \&trans, \&n, \&nrhs,}
\DoxyCodeLine{4342       \mbox{\hyperlink{structA}{A}}.memptr(), \&lda,}
\DoxyCodeLine{4343       AF.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldaf,}
\DoxyCodeLine{4344       IPIV.memptr(),}
\DoxyCodeLine{4345       \&equed,}
\DoxyCodeLine{4346       R.memptr(),}
\DoxyCodeLine{4347       C.memptr(),}
\DoxyCodeLine{4348       \textcolor{keyword}{const\_cast<}eT*\textcolor{keyword}{>}(\mbox{\hyperlink{structB}{B}}.memptr()), \&ldb,}
\DoxyCodeLine{4349       out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldx,}
\DoxyCodeLine{4350       \&rcond,}
\DoxyCodeLine{4351       FERR.memptr(),}
\DoxyCodeLine{4352       BERR.memptr(),}
\DoxyCodeLine{4353       WORK.memptr(),}
\DoxyCodeLine{4354       IWORK.memptr(),}
\DoxyCodeLine{4355       \&info}
\DoxyCodeLine{4356       );}
\DoxyCodeLine{4357     }
\DoxyCodeLine{4358     \textcolor{comment}{// NOTE: using const\_cast<eT*>(B.memptr()) to allow B to be overwritten for equilibration;}}
\DoxyCodeLine{4359     \textcolor{comment}{// NOTE: B is created as a copy of B\_expr if equilibration is enabled; otherwise B is a reference to B\_expr}}
\DoxyCodeLine{4360     }
\DoxyCodeLine{4361     out\_rcond = rcond;}
\DoxyCodeLine{4362     }
\DoxyCodeLine{4363     \textcolor{keywordflow}{return} (allow\_ugly) ? ((info == 0) || (info == (n+1))) : (info == 0);}
\DoxyCodeLine{4364     \}}
\DoxyCodeLine{4365 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{4366     \{}
\DoxyCodeLine{4367     arma\_ignore(out);}
\DoxyCodeLine{4368     arma\_ignore(out\_rcond);}
\DoxyCodeLine{4369     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{4370     arma\_ignore(B\_expr);}
\DoxyCodeLine{4371     arma\_ignore(equilibrate);}
\DoxyCodeLine{4372     arma\_ignore(allow\_ugly);}
\DoxyCodeLine{4373     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}solve(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{4374     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{4375     \}}
\DoxyCodeLine{4376 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{4377   \}}
\DoxyCodeLine{4378 }
\DoxyCodeLine{4379 }
\DoxyCodeLine{4380 }
\DoxyCodeLine{4382 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{4383 \textcolor{keyword}{inline}}
\DoxyCodeLine{4384 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{4385 \mbox{\hyperlink{group__auxlib_gab1d24ba6a7f6a7aad1b5bcf4d75bd1bf}{auxlib::solve\_square\_refine}}(\mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\& out, \textcolor{keyword}{typename} T1::pod\_type\& out\_rcond, \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base}}<std::complex<typename T1::pod\_type>,T1>\& B\_expr, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} equilibrate, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_ugly)}
\DoxyCodeLine{4386   \{}
\DoxyCodeLine{4387   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{4388   }
\DoxyCodeLine{4389 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{4390     \{}
\DoxyCodeLine{4391     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type     T;}
\DoxyCodeLine{4392     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<T> eT;}
\DoxyCodeLine{4393     }
\DoxyCodeLine{4394     \textcolor{comment}{// Mat<eT> B = B\_expr.get\_ref();  // B is overwritten by lapack::cx\_gesvx() if equilibrate is enabled}}
\DoxyCodeLine{4395     }
\DoxyCodeLine{4396     \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} UB(B\_expr.get\_ref());  \textcolor{comment}{// deliberately not declaring as const}}
\DoxyCodeLine{4397     }
\DoxyCodeLine{4398     \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& UB\_M\_as\_Mat = UB.M;  \textcolor{comment}{// so we don't confuse the ?: operator below}}
\DoxyCodeLine{4399     }
\DoxyCodeLine{4400     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_copy = ((equilibrate \&\& UB.is\_const) || UB.is\_alias(out));}
\DoxyCodeLine{4401     }
\DoxyCodeLine{4402     \mbox{\hyperlink{classMat}{Mat<eT>}} B\_tmp;  \textcolor{keywordflow}{if}(use\_copy)  \{ B\_tmp = UB\_M\_as\_Mat; \}}
\DoxyCodeLine{4403     }
\DoxyCodeLine{4404     \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structB}{B}} = (use\_copy) ? B\_tmp : UB\_M\_as\_Mat;}
\DoxyCodeLine{4405     }
\DoxyCodeLine{4406     arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.n\_rows != \mbox{\hyperlink{structB}{B}}.n\_rows), \textcolor{stringliteral}{"{}solve(): number of rows in the given matrices must be the same"{}} );}
\DoxyCodeLine{4407       }
\DoxyCodeLine{4408     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty() || \mbox{\hyperlink{structB}{B}}.is\_empty())}
\DoxyCodeLine{4409       \{}
\DoxyCodeLine{4410       out.zeros(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{4411       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{4412       \}}
\DoxyCodeLine{4413     }
\DoxyCodeLine{4414     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}},\mbox{\hyperlink{structB}{B}});}
\DoxyCodeLine{4415     }
\DoxyCodeLine{4416     out.set\_size(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{4417     }
\DoxyCodeLine{4418     \textcolor{keywordtype}{char}     fact  = (equilibrate) ? \textcolor{charliteral}{'E'} : \textcolor{charliteral}{'N'}; }
\DoxyCodeLine{4419     \textcolor{keywordtype}{char}     trans = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{4420     \textcolor{keywordtype}{char}     equed = char(0);}
\DoxyCodeLine{4421     blas\_int n     = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4422     blas\_int nrhs  = blas\_int(\mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{4423     blas\_int lda   = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4424     blas\_int ldaf  = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4425     blas\_int ldb   = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4426     blas\_int ldx   = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4427     blas\_int info  = blas\_int(0);}
\DoxyCodeLine{4428     T        rcond = T(0);}
\DoxyCodeLine{4429     }
\DoxyCodeLine{4430     \mbox{\hyperlink{classMat}{Mat<eT>}} AF(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{4431     }
\DoxyCodeLine{4432     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}}  IPIV(  \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4433     \mbox{\hyperlink{classpodarray}{podarray< T>}}           R(  \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4434     \mbox{\hyperlink{classpodarray}{podarray< T>}}           C(  \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4435     \mbox{\hyperlink{classpodarray}{podarray< T>}}        FERR(  \mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{4436     \mbox{\hyperlink{classpodarray}{podarray< T>}}        BERR(  \mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{4437     \mbox{\hyperlink{classpodarray}{podarray<eT>}}        WORK(2*\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4438     \mbox{\hyperlink{classpodarray}{podarray< T>}}       RWORK(2*\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4439     }
\DoxyCodeLine{4440     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::cx\_gesvx()"{}});}
\DoxyCodeLine{4441     lapack::cx\_gesvx}
\DoxyCodeLine{4442       (}
\DoxyCodeLine{4443       \&fact, \&trans, \&n, \&nrhs,}
\DoxyCodeLine{4444       \mbox{\hyperlink{structA}{A}}.memptr(), \&lda,}
\DoxyCodeLine{4445       AF.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldaf,}
\DoxyCodeLine{4446       IPIV.memptr(),}
\DoxyCodeLine{4447       \&equed,}
\DoxyCodeLine{4448       R.memptr(),}
\DoxyCodeLine{4449       C.memptr(),}
\DoxyCodeLine{4450       \textcolor{keyword}{const\_cast<}eT*\textcolor{keyword}{>}(\mbox{\hyperlink{structB}{B}}.memptr()), \&ldb,}
\DoxyCodeLine{4451       out.memptr(), \&ldx,}
\DoxyCodeLine{4452       \&rcond,}
\DoxyCodeLine{4453       FERR.memptr(),}
\DoxyCodeLine{4454       BERR.memptr(),}
\DoxyCodeLine{4455       WORK.memptr(),}
\DoxyCodeLine{4456       RWORK.memptr(),}
\DoxyCodeLine{4457       \&info}
\DoxyCodeLine{4458       );}
\DoxyCodeLine{4459     }
\DoxyCodeLine{4460     \textcolor{comment}{// NOTE: using const\_cast<eT*>(B.memptr()) to allow B to be overwritten for equilibration;}}
\DoxyCodeLine{4461     \textcolor{comment}{// NOTE: B is created as a copy of B\_expr if equilibration is enabled; otherwise B is a reference to B\_expr}}
\DoxyCodeLine{4462     }
\DoxyCodeLine{4463     out\_rcond = rcond;}
\DoxyCodeLine{4464     }
\DoxyCodeLine{4465     \textcolor{keywordflow}{return} (allow\_ugly) ? ((info == 0) || (info == (n+1))) : (info == 0);}
\DoxyCodeLine{4466     \}}
\DoxyCodeLine{4467 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{4468     \{}
\DoxyCodeLine{4469     arma\_ignore(out);}
\DoxyCodeLine{4470     arma\_ignore(out\_rcond);}
\DoxyCodeLine{4471     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{4472     arma\_ignore(B\_expr);}
\DoxyCodeLine{4473     arma\_ignore(equilibrate);}
\DoxyCodeLine{4474     arma\_ignore(allow\_ugly);}
\DoxyCodeLine{4475     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}solve(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{4476     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{4477     \}}
\DoxyCodeLine{4478 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{4479   \}}
\DoxyCodeLine{4480 }
\DoxyCodeLine{4481 }
\DoxyCodeLine{4482 }
\DoxyCodeLine{4483 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{4484 \textcolor{keyword}{inline}}
\DoxyCodeLine{4485 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{4486 auxlib::solve\_sympd\_fast(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::elem\_type,T1>}}\& B\_expr)}
\DoxyCodeLine{4487   \{}
\DoxyCodeLine{4488   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{4489   }
\DoxyCodeLine{4490 \textcolor{preprocessor}{  \#if defined(ARMA\_CRIPPLED\_LAPACK)}}
\DoxyCodeLine{4491     \{}
\DoxyCodeLine{4492     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}auxlib::solve\_sympd\_fast(): redirecting to auxlib::solve\_square\_fast() due to crippled LAPACK"{}});}
\DoxyCodeLine{4493     }
\DoxyCodeLine{4494     \textcolor{keywordflow}{return} \mbox{\hyperlink{group__auxlib_ga530089e89e43155f3bf6e709bbe775dd}{auxlib::solve\_square\_fast}}(out, \mbox{\hyperlink{structA}{A}}, B\_expr);}
\DoxyCodeLine{4495     \}}
\DoxyCodeLine{4496 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{4497     \{}
\DoxyCodeLine{4498     \textcolor{keywordflow}{return} auxlib::solve\_sympd\_fast\_common(out, \mbox{\hyperlink{structA}{A}}, B\_expr);}
\DoxyCodeLine{4499     \}}
\DoxyCodeLine{4500 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{4501   \}}
\DoxyCodeLine{4502 }
\DoxyCodeLine{4503 }
\DoxyCodeLine{4504 }
\DoxyCodeLine{4505 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{4506 \textcolor{keyword}{inline}}
\DoxyCodeLine{4507 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{4508 auxlib::solve\_sympd\_fast\_common(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::elem\_type,T1>}}\& B\_expr)}
\DoxyCodeLine{4509   \{}
\DoxyCodeLine{4510   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{4511   }
\DoxyCodeLine{4512   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{4513   }
\DoxyCodeLine{4514   \textcolor{keyword}{const} uword A\_n\_rows = \mbox{\hyperlink{structA}{A}}.n\_rows;}
\DoxyCodeLine{4515   }
\DoxyCodeLine{4516   \textcolor{keywordflow}{if}((A\_n\_rows <= 4) \&\& \mbox{\hyperlink{structis__cx}{is\_cx<eT>::no}})}
\DoxyCodeLine{4517     \{}
\DoxyCodeLine{4518     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} status = \mbox{\hyperlink{group__auxlib_gaa6f6fa63e5763cf3877cdb3d8f4188b0}{auxlib::solve\_square\_tiny}}(out, \mbox{\hyperlink{structA}{A}}, B\_expr.get\_ref());}
\DoxyCodeLine{4519     }
\DoxyCodeLine{4520     \textcolor{keywordflow}{if}(status)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{4521     \}}
\DoxyCodeLine{4522   }
\DoxyCodeLine{4523   out = B\_expr.get\_ref();}
\DoxyCodeLine{4524   }
\DoxyCodeLine{4525   \textcolor{keyword}{const} uword B\_n\_rows = out.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}};}
\DoxyCodeLine{4526   \textcolor{keyword}{const} uword B\_n\_cols = out.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}};}
\DoxyCodeLine{4527   }
\DoxyCodeLine{4528   arma\_debug\_check( (A\_n\_rows != B\_n\_rows), \textcolor{stringliteral}{"{}solve(): number of rows in the given matrices must be the same"{}} );}
\DoxyCodeLine{4529   }
\DoxyCodeLine{4530   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty() || out.\mbox{\hyperlink{group__Mat_ga3008049216e02308ff665862f451a7ff}{is\_empty}}())}
\DoxyCodeLine{4531     \{}
\DoxyCodeLine{4532     out.zeros(\mbox{\hyperlink{structA}{A}}.n\_cols, B\_n\_cols);}
\DoxyCodeLine{4533     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{4534     \}}
\DoxyCodeLine{4535   }
\DoxyCodeLine{4536 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_ATLAS)}}
\DoxyCodeLine{4537     \{}
\DoxyCodeLine{4538     arma\_debug\_assert\_atlas\_size(\mbox{\hyperlink{structA}{A}}, out);}
\DoxyCodeLine{4539     }
\DoxyCodeLine{4540     \textcolor{keywordtype}{int} info = 0;}
\DoxyCodeLine{4541     }
\DoxyCodeLine{4542     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}atlas::clapack\_posv()"{}});}
\DoxyCodeLine{4543     info = atlas::clapack\_posv<eT>(atlas::CblasColMajor, atlas::CblasLower, A\_n\_rows, B\_n\_cols, \mbox{\hyperlink{structA}{A}}.memptr(), A\_n\_rows, out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), B\_n\_rows);}
\DoxyCodeLine{4544     }
\DoxyCodeLine{4545     \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{4546     \}}
\DoxyCodeLine{4547 \textcolor{preprocessor}{  \#elif defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{4548     \{}
\DoxyCodeLine{4549     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}}, out);}
\DoxyCodeLine{4550     }
\DoxyCodeLine{4551     \textcolor{keywordtype}{char}     uplo = \textcolor{charliteral}{'L'};}
\DoxyCodeLine{4552     blas\_int n    = blas\_int(A\_n\_rows);  \textcolor{comment}{// assuming A is square}}
\DoxyCodeLine{4553     blas\_int nrhs = blas\_int(B\_n\_cols);}
\DoxyCodeLine{4554     blas\_int lda  = blas\_int(A\_n\_rows);}
\DoxyCodeLine{4555     blas\_int ldb  = blas\_int(B\_n\_rows);}
\DoxyCodeLine{4556     blas\_int info = blas\_int(0);}
\DoxyCodeLine{4557     }
\DoxyCodeLine{4558     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::posv()"{}});}
\DoxyCodeLine{4559     lapack::posv<eT>(\&uplo, \&n, \&nrhs, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldb, \&info);}
\DoxyCodeLine{4560     }
\DoxyCodeLine{4561     \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{4562     \}}
\DoxyCodeLine{4563 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{4564     \{}
\DoxyCodeLine{4565     arma\_ignore(out);}
\DoxyCodeLine{4566     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{4567     arma\_ignore(B\_expr);}
\DoxyCodeLine{4568     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}solve(): use of ATLAS or LAPACK must be enabled"{}});}
\DoxyCodeLine{4569     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{4570     \}}
\DoxyCodeLine{4571 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{4572   \}}
\DoxyCodeLine{4573 }
\DoxyCodeLine{4574 }
\DoxyCodeLine{4575 }
\DoxyCodeLine{4577 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{4578 \textcolor{keyword}{inline}}
\DoxyCodeLine{4579 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{4580 \mbox{\hyperlink{group__auxlib_ga62ce89610f71efecc71e6512e32b810a}{auxlib::solve\_sympd\_rcond}}(\mbox{\hyperlink{classMat}{Mat<typename T1::pod\_type>}}\& out, \textcolor{keyword}{typename} T1::pod\_type\& out\_rcond, \mbox{\hyperlink{classMat}{Mat<typename T1::pod\_type>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::pod\_type,T1>}}\& B\_expr, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_ugly)}
\DoxyCodeLine{4581   \{}
\DoxyCodeLine{4582   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{4583   }
\DoxyCodeLine{4584 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{4585     \{}
\DoxyCodeLine{4586     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{4587     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type   T;}
\DoxyCodeLine{4588     }
\DoxyCodeLine{4589     out\_rcond = T(0);}
\DoxyCodeLine{4590     }
\DoxyCodeLine{4591     out = B\_expr.get\_ref();}
\DoxyCodeLine{4592     }
\DoxyCodeLine{4593     \textcolor{keyword}{const} uword B\_n\_rows = out.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}};}
\DoxyCodeLine{4594     \textcolor{keyword}{const} uword B\_n\_cols = out.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}};}
\DoxyCodeLine{4595     }
\DoxyCodeLine{4596     arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.n\_rows != B\_n\_rows), \textcolor{stringliteral}{"{}solve(): number of rows in the given matrices must be the same"{}} );}
\DoxyCodeLine{4597     }
\DoxyCodeLine{4598     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty() || out.\mbox{\hyperlink{group__Mat_ga3008049216e02308ff665862f451a7ff}{is\_empty}}())}
\DoxyCodeLine{4599       \{}
\DoxyCodeLine{4600       out.zeros(\mbox{\hyperlink{structA}{A}}.n\_cols, B\_n\_cols);}
\DoxyCodeLine{4601       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{4602       \}}
\DoxyCodeLine{4603     }
\DoxyCodeLine{4604     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}}, out);}
\DoxyCodeLine{4605     }
\DoxyCodeLine{4606     \textcolor{keywordtype}{char}     norm\_id  = \textcolor{charliteral}{'1'};}
\DoxyCodeLine{4607     \textcolor{keywordtype}{char}     uplo     = \textcolor{charliteral}{'L'};}
\DoxyCodeLine{4608     blas\_int n        = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);  \textcolor{comment}{// assuming A is square}}
\DoxyCodeLine{4609     blas\_int nrhs     = blas\_int(B\_n\_cols);}
\DoxyCodeLine{4610     blas\_int info     = blas\_int(0);}
\DoxyCodeLine{4611     T        norm\_val = T(0);}
\DoxyCodeLine{4612     }
\DoxyCodeLine{4613     \mbox{\hyperlink{classpodarray}{podarray<T>}} work(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4614     }
\DoxyCodeLine{4615     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::lansy()"{}});}
\DoxyCodeLine{4616     norm\_val = lapack::lansy(\&norm\_id, \&uplo, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&n, work.memptr());}
\DoxyCodeLine{4617     }
\DoxyCodeLine{4618     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::potrf()"{}});}
\DoxyCodeLine{4619     lapack::potrf<eT>(\&uplo, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&n, \&info);}
\DoxyCodeLine{4620     }
\DoxyCodeLine{4621     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{4622     }
\DoxyCodeLine{4623     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::potrs()"{}});}
\DoxyCodeLine{4624     lapack::potrs<eT>(\&uplo, \&n, \&nrhs, \mbox{\hyperlink{structA}{A}}.memptr(), \&n, out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&n, \&info);}
\DoxyCodeLine{4625     }
\DoxyCodeLine{4626     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{4627     }
\DoxyCodeLine{4628     out\_rcond = auxlib::lu\_rcond\_sympd<T>(\mbox{\hyperlink{structA}{A}}, norm\_val);}
\DoxyCodeLine{4629     }
\DoxyCodeLine{4630     \textcolor{keywordflow}{if}( (allow\_ugly == \textcolor{keyword}{false}) \&\& (out\_rcond < auxlib::epsilon\_lapack(\mbox{\hyperlink{structA}{A}})) )  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{4631     }
\DoxyCodeLine{4632     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{4633     \}}
\DoxyCodeLine{4634 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{4635     \{}
\DoxyCodeLine{4636     arma\_ignore(out);}
\DoxyCodeLine{4637     arma\_ignore(out\_rcond);}
\DoxyCodeLine{4638     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{4639     arma\_ignore(B\_expr);}
\DoxyCodeLine{4640     arma\_ignore(allow\_ugly);}
\DoxyCodeLine{4641     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}solve(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{4642     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{4643     \}}
\DoxyCodeLine{4644 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{4645   \}}
\DoxyCodeLine{4646 }
\DoxyCodeLine{4647 }
\DoxyCodeLine{4648 }
\DoxyCodeLine{4650 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{4651 \textcolor{keyword}{inline}}
\DoxyCodeLine{4652 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{4653 \mbox{\hyperlink{group__auxlib_ga62ce89610f71efecc71e6512e32b810a}{auxlib::solve\_sympd\_rcond}}(\mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\& out, \textcolor{keyword}{typename} T1::pod\_type\& out\_rcond, \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base}}< std::complex<typename T1::pod\_type>,T1>\& B\_expr, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_ugly)}
\DoxyCodeLine{4654   \{}
\DoxyCodeLine{4655   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{4656   }
\DoxyCodeLine{4657 \textcolor{preprocessor}{  \#if defined(ARMA\_CRIPPLED\_LAPACK)}}
\DoxyCodeLine{4658     \{}
\DoxyCodeLine{4659     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}auxlib::solve\_sympd\_rcond(): redirecting to auxlib::solve\_square\_rcond() due to crippled LAPACK"{}});}
\DoxyCodeLine{4660     }
\DoxyCodeLine{4661     \textcolor{keywordflow}{return} \mbox{\hyperlink{group__auxlib_ga16be749fd9b7ac92dd2f437f9e45fdf9}{auxlib::solve\_square\_rcond}}(out, out\_rcond, \mbox{\hyperlink{structA}{A}}, B\_expr, allow\_ugly);}
\DoxyCodeLine{4662     \}}
\DoxyCodeLine{4663 \textcolor{preprocessor}{  \#elif defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{4664     \{}
\DoxyCodeLine{4665     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type     T;}
\DoxyCodeLine{4666     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<T> eT;}
\DoxyCodeLine{4667     }
\DoxyCodeLine{4668     out\_rcond = T(0);}
\DoxyCodeLine{4669     }
\DoxyCodeLine{4670     out = B\_expr.get\_ref();}
\DoxyCodeLine{4671     }
\DoxyCodeLine{4672     \textcolor{keyword}{const} uword B\_n\_rows = out.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}};}
\DoxyCodeLine{4673     \textcolor{keyword}{const} uword B\_n\_cols = out.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}};}
\DoxyCodeLine{4674     }
\DoxyCodeLine{4675     arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.n\_rows != B\_n\_rows), \textcolor{stringliteral}{"{}solve(): number of rows in the given matrices must be the same"{}} );}
\DoxyCodeLine{4676     }
\DoxyCodeLine{4677     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty() || out.\mbox{\hyperlink{group__Mat_ga3008049216e02308ff665862f451a7ff}{is\_empty}}())}
\DoxyCodeLine{4678       \{}
\DoxyCodeLine{4679       out.zeros(\mbox{\hyperlink{structA}{A}}.n\_cols, B\_n\_cols);}
\DoxyCodeLine{4680       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{4681       \}}
\DoxyCodeLine{4682     }
\DoxyCodeLine{4683     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}}, out);}
\DoxyCodeLine{4684     }
\DoxyCodeLine{4685     \textcolor{keywordtype}{char}     norm\_id  = \textcolor{charliteral}{'1'};}
\DoxyCodeLine{4686     \textcolor{keywordtype}{char}     uplo     = \textcolor{charliteral}{'L'};}
\DoxyCodeLine{4687     blas\_int n        = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);  \textcolor{comment}{// assuming A is square}}
\DoxyCodeLine{4688     blas\_int nrhs     = blas\_int(B\_n\_cols);}
\DoxyCodeLine{4689     blas\_int info     = blas\_int(0);}
\DoxyCodeLine{4690     T        norm\_val = T(0);}
\DoxyCodeLine{4691     }
\DoxyCodeLine{4692     \mbox{\hyperlink{classpodarray}{podarray<T>}} work(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4693     }
\DoxyCodeLine{4694     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::lanhe()"{}});}
\DoxyCodeLine{4695     norm\_val = lapack::lanhe(\&norm\_id, \&uplo, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&n, work.memptr());}
\DoxyCodeLine{4696     }
\DoxyCodeLine{4697     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::potrf()"{}});}
\DoxyCodeLine{4698     lapack::potrf<eT>(\&uplo, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&n, \&info);}
\DoxyCodeLine{4699     }
\DoxyCodeLine{4700     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{4701     }
\DoxyCodeLine{4702     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::potrs()"{}});}
\DoxyCodeLine{4703     lapack::potrs<eT>(\&uplo, \&n, \&nrhs, \mbox{\hyperlink{structA}{A}}.memptr(), \&n, out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&n, \&info);}
\DoxyCodeLine{4704     }
\DoxyCodeLine{4705     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{4706     }
\DoxyCodeLine{4707     out\_rcond = auxlib::lu\_rcond\_sympd<T>(\mbox{\hyperlink{structA}{A}}, norm\_val);}
\DoxyCodeLine{4708     }
\DoxyCodeLine{4709     \textcolor{keywordflow}{if}( (allow\_ugly == \textcolor{keyword}{false}) \&\& (out\_rcond < auxlib::epsilon\_lapack(\mbox{\hyperlink{structA}{A}})) )  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{4710     }
\DoxyCodeLine{4711     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{4712     \}}
\DoxyCodeLine{4713 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{4714     \{}
\DoxyCodeLine{4715     arma\_ignore(out);}
\DoxyCodeLine{4716     arma\_ignore(out\_rcond);}
\DoxyCodeLine{4717     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{4718     arma\_ignore(B\_expr);}
\DoxyCodeLine{4719     arma\_ignore(allow\_ugly);}
\DoxyCodeLine{4720     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}solve(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{4721     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{4722     \}}
\DoxyCodeLine{4723 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{4724   \}}
\DoxyCodeLine{4725 }
\DoxyCodeLine{4726 }
\DoxyCodeLine{4727 }
\DoxyCodeLine{4729 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{4730 \textcolor{keyword}{inline}}
\DoxyCodeLine{4731 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{4732 \mbox{\hyperlink{group__auxlib_gab44e1fb14a3c2bb6aaedbc3782ce6839}{auxlib::solve\_sympd\_refine}}(\mbox{\hyperlink{classMat}{Mat<typename T1::pod\_type>}}\& out, \textcolor{keyword}{typename} T1::pod\_type\& out\_rcond, \mbox{\hyperlink{classMat}{Mat<typename T1::pod\_type>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::pod\_type,T1>}}\& B\_expr, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} equilibrate, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_ugly)}
\DoxyCodeLine{4733   \{}
\DoxyCodeLine{4734   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{4735   }
\DoxyCodeLine{4736 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{4737     \{}
\DoxyCodeLine{4738     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type eT;}
\DoxyCodeLine{4739     }
\DoxyCodeLine{4740     \textcolor{comment}{// Mat<eT> B = B\_expr.get\_ref();  // B is overwritten by lapack::posvx() if equilibrate is enabled}}
\DoxyCodeLine{4741     }
\DoxyCodeLine{4742     \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} UB(B\_expr.get\_ref());  \textcolor{comment}{// deliberately not declaring as const}}
\DoxyCodeLine{4743     }
\DoxyCodeLine{4744     \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& UB\_M\_as\_Mat = UB.M;  \textcolor{comment}{// so we don't confuse the ?: operator below}}
\DoxyCodeLine{4745     }
\DoxyCodeLine{4746     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_copy = ((equilibrate \&\& UB.is\_const) || UB.is\_alias(out));}
\DoxyCodeLine{4747     }
\DoxyCodeLine{4748     \mbox{\hyperlink{classMat}{Mat<eT>}} B\_tmp;  \textcolor{keywordflow}{if}(use\_copy)  \{ B\_tmp = UB\_M\_as\_Mat; \}}
\DoxyCodeLine{4749     }
\DoxyCodeLine{4750     \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structB}{B}} = (use\_copy) ? B\_tmp : UB\_M\_as\_Mat;}
\DoxyCodeLine{4751     }
\DoxyCodeLine{4752     arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.n\_rows != \mbox{\hyperlink{structB}{B}}.n\_rows), \textcolor{stringliteral}{"{}solve(): number of rows in the given matrices must be the same"{}} );}
\DoxyCodeLine{4753     }
\DoxyCodeLine{4754     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty() || \mbox{\hyperlink{structB}{B}}.is\_empty())}
\DoxyCodeLine{4755       \{}
\DoxyCodeLine{4756       out.zeros(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{4757       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{4758       \}}
\DoxyCodeLine{4759     }
\DoxyCodeLine{4760     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}},\mbox{\hyperlink{structB}{B}});}
\DoxyCodeLine{4761     }
\DoxyCodeLine{4762     out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{4763     }
\DoxyCodeLine{4764     \textcolor{keywordtype}{char}     fact  = (equilibrate) ? \textcolor{charliteral}{'E'} : \textcolor{charliteral}{'N'}; }
\DoxyCodeLine{4765     \textcolor{keywordtype}{char}     uplo  = \textcolor{charliteral}{'L'};}
\DoxyCodeLine{4766     \textcolor{keywordtype}{char}     equed = char(0);}
\DoxyCodeLine{4767     blas\_int n     = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4768     blas\_int nrhs  = blas\_int(\mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{4769     blas\_int lda   = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4770     blas\_int ldaf  = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4771     blas\_int ldb   = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4772     blas\_int ldx   = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4773     blas\_int info  = blas\_int(0);}
\DoxyCodeLine{4774     eT       rcond = eT(0);}
\DoxyCodeLine{4775     }
\DoxyCodeLine{4776     \mbox{\hyperlink{classMat}{Mat<eT>}} AF(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{4777     }
\DoxyCodeLine{4778     \mbox{\hyperlink{classpodarray}{podarray<eT>}}           S(  \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4779     \mbox{\hyperlink{classpodarray}{podarray<eT>}}        FERR(  \mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{4780     \mbox{\hyperlink{classpodarray}{podarray<eT>}}        BERR(  \mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{4781     \mbox{\hyperlink{classpodarray}{podarray<eT>}}        WORK(3*\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4782     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} IWORK(  \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4783     }
\DoxyCodeLine{4784     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::posvx()"{}});}
\DoxyCodeLine{4785     lapack::posvx(\&fact, \&uplo, \&n, \&nrhs, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, AF.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldaf, \&equed, S.memptr(), \textcolor{keyword}{const\_cast<}eT*\textcolor{keyword}{>}(\mbox{\hyperlink{structB}{B}}.memptr()), \&ldb, out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldx, \&rcond, FERR.memptr(), BERR.memptr(), WORK.memptr(), IWORK.memptr(), \&info);}
\DoxyCodeLine{4786     }
\DoxyCodeLine{4787     \textcolor{comment}{// NOTE: using const\_cast<eT*>(B.memptr()) to allow B to be overwritten for equilibration;}}
\DoxyCodeLine{4788     \textcolor{comment}{// NOTE: B is created as a copy of B\_expr if equilibration is enabled; otherwise B is a reference to B\_expr}}
\DoxyCodeLine{4789     }
\DoxyCodeLine{4790     out\_rcond = rcond;}
\DoxyCodeLine{4791     }
\DoxyCodeLine{4792     \textcolor{keywordflow}{return} (allow\_ugly) ? ((info == 0) || (info == (n+1))) : (info == 0);}
\DoxyCodeLine{4793     \}}
\DoxyCodeLine{4794 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{4795     \{}
\DoxyCodeLine{4796     arma\_ignore(out);}
\DoxyCodeLine{4797     arma\_ignore(out\_rcond);}
\DoxyCodeLine{4798     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{4799     arma\_ignore(B\_expr);}
\DoxyCodeLine{4800     arma\_ignore(equilibrate);}
\DoxyCodeLine{4801     arma\_ignore(allow\_ugly);}
\DoxyCodeLine{4802     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}solve(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{4803     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{4804     \}}
\DoxyCodeLine{4805 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{4806   \}}
\DoxyCodeLine{4807 }
\DoxyCodeLine{4808 }
\DoxyCodeLine{4809 }
\DoxyCodeLine{4811 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{4812 \textcolor{keyword}{inline}}
\DoxyCodeLine{4813 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{4814 \mbox{\hyperlink{group__auxlib_gab44e1fb14a3c2bb6aaedbc3782ce6839}{auxlib::solve\_sympd\_refine}}(\mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\& out, \textcolor{keyword}{typename} T1::pod\_type\& out\_rcond, \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base}}<std::complex<typename T1::pod\_type>,T1>\& B\_expr, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} equilibrate, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_ugly)}
\DoxyCodeLine{4815   \{}
\DoxyCodeLine{4816   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{4817   }
\DoxyCodeLine{4818 \textcolor{preprocessor}{  \#if defined(ARMA\_CRIPPLED\_LAPACK)}}
\DoxyCodeLine{4819     \{}
\DoxyCodeLine{4820     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}auxlib::solve\_sympd\_refine(): redirecting to auxlib::solve\_square\_refine() due to crippled LAPACK"{}});}
\DoxyCodeLine{4821     }
\DoxyCodeLine{4822     \textcolor{keywordflow}{return} \mbox{\hyperlink{group__auxlib_gab1d24ba6a7f6a7aad1b5bcf4d75bd1bf}{auxlib::solve\_square\_refine}}(out, out\_rcond, \mbox{\hyperlink{structA}{A}}, B\_expr, equilibrate, allow\_ugly);}
\DoxyCodeLine{4823     \}}
\DoxyCodeLine{4824 \textcolor{preprocessor}{  \#elif defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{4825     \{}
\DoxyCodeLine{4826     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type     T;}
\DoxyCodeLine{4827     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<T> eT;}
\DoxyCodeLine{4828     }
\DoxyCodeLine{4829     \textcolor{comment}{// Mat<eT> B = B\_expr.get\_ref();  // B is overwritten by lapack::cx\_posvx() if equilibrate is enabled}}
\DoxyCodeLine{4830     }
\DoxyCodeLine{4831     \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} UB(B\_expr.get\_ref());  \textcolor{comment}{// deliberately not declaring as const}}
\DoxyCodeLine{4832     }
\DoxyCodeLine{4833     \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& UB\_M\_as\_Mat = UB.M;  \textcolor{comment}{// so we don't confuse the ?: operator below}}
\DoxyCodeLine{4834     }
\DoxyCodeLine{4835     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_copy = ((equilibrate \&\& UB.is\_const) || UB.is\_alias(out));}
\DoxyCodeLine{4836     }
\DoxyCodeLine{4837     \mbox{\hyperlink{classMat}{Mat<eT>}} B\_tmp;  \textcolor{keywordflow}{if}(use\_copy)  \{ B\_tmp = UB\_M\_as\_Mat; \}}
\DoxyCodeLine{4838     }
\DoxyCodeLine{4839     \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structB}{B}} = (use\_copy) ? B\_tmp : UB\_M\_as\_Mat;}
\DoxyCodeLine{4840     }
\DoxyCodeLine{4841     arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.n\_rows != \mbox{\hyperlink{structB}{B}}.n\_rows), \textcolor{stringliteral}{"{}solve(): number of rows in the given matrices must be the same"{}} );}
\DoxyCodeLine{4842       }
\DoxyCodeLine{4843     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty() || \mbox{\hyperlink{structB}{B}}.is\_empty())}
\DoxyCodeLine{4844       \{}
\DoxyCodeLine{4845       out.zeros(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{4846       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{4847       \}}
\DoxyCodeLine{4848     }
\DoxyCodeLine{4849     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}},\mbox{\hyperlink{structB}{B}});}
\DoxyCodeLine{4850     }
\DoxyCodeLine{4851     out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{4852     }
\DoxyCodeLine{4853     \textcolor{keywordtype}{char}     fact  = (equilibrate) ? \textcolor{charliteral}{'E'} : \textcolor{charliteral}{'N'}; }
\DoxyCodeLine{4854     \textcolor{keywordtype}{char}     uplo  = \textcolor{charliteral}{'L'};}
\DoxyCodeLine{4855     \textcolor{keywordtype}{char}     equed = char(0);}
\DoxyCodeLine{4856     blas\_int n     = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4857     blas\_int nrhs  = blas\_int(\mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{4858     blas\_int lda   = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4859     blas\_int ldaf  = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4860     blas\_int ldb   = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4861     blas\_int ldx   = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4862     blas\_int info  = blas\_int(0);}
\DoxyCodeLine{4863     T        rcond = T(0);}
\DoxyCodeLine{4864     }
\DoxyCodeLine{4865     \mbox{\hyperlink{classMat}{Mat<eT>}} AF(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{4866     }
\DoxyCodeLine{4867     \mbox{\hyperlink{classpodarray}{podarray< T>}}           S(  \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4868     \mbox{\hyperlink{classpodarray}{podarray< T>}}        FERR(  \mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{4869     \mbox{\hyperlink{classpodarray}{podarray< T>}}        BERR(  \mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{4870     \mbox{\hyperlink{classpodarray}{podarray<eT>}}        WORK(2*\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4871     \mbox{\hyperlink{classpodarray}{podarray< T>}}       RWORK(  \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4872     }
\DoxyCodeLine{4873     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::cx\_posvx()"{}});}
\DoxyCodeLine{4874     lapack::cx\_posvx(\&fact, \&uplo, \&n, \&nrhs, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, AF.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldaf, \&equed, S.memptr(), \textcolor{keyword}{const\_cast<}eT*\textcolor{keyword}{>}(\mbox{\hyperlink{structB}{B}}.memptr()), \&ldb, out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldx, \&rcond, FERR.memptr(), BERR.memptr(), WORK.memptr(), RWORK.memptr(), \&info);}
\DoxyCodeLine{4875     }
\DoxyCodeLine{4876     \textcolor{comment}{// NOTE: using const\_cast<eT*>(B.memptr()) to allow B to be overwritten for equilibration;}}
\DoxyCodeLine{4877     \textcolor{comment}{// NOTE: B is created as a copy of B\_expr if equilibration is enabled; otherwise B is a reference to B\_expr}}
\DoxyCodeLine{4878     }
\DoxyCodeLine{4879     out\_rcond = rcond;}
\DoxyCodeLine{4880     }
\DoxyCodeLine{4881     \textcolor{keywordflow}{return} (allow\_ugly) ? ((info == 0) || (info == (n+1))) : (info == 0);}
\DoxyCodeLine{4882     \}}
\DoxyCodeLine{4883 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{4884     \{}
\DoxyCodeLine{4885     arma\_ignore(out);}
\DoxyCodeLine{4886     arma\_ignore(out\_rcond);}
\DoxyCodeLine{4887     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{4888     arma\_ignore(B\_expr);}
\DoxyCodeLine{4889     arma\_ignore(equilibrate);}
\DoxyCodeLine{4890     arma\_ignore(allow\_ugly);}
\DoxyCodeLine{4891     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}solve(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{4892     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{4893     \}}
\DoxyCodeLine{4894 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{4895   \}}
\DoxyCodeLine{4896 }
\DoxyCodeLine{4897 }
\DoxyCodeLine{4898 }
\DoxyCodeLine{4900 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{4901 \textcolor{keyword}{inline}}
\DoxyCodeLine{4902 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{4903 \mbox{\hyperlink{group__auxlib_ga05e7ac9cd99f556f2fb38f5edfece9e0}{auxlib::solve\_rect\_fast}}(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::elem\_type,T1>}}\& B\_expr)}
\DoxyCodeLine{4904   \{}
\DoxyCodeLine{4905   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{4906   }
\DoxyCodeLine{4907 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{4908     \{}
\DoxyCodeLine{4909     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{4910     }
\DoxyCodeLine{4911     \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap}{unwrap<T1>}}   U(B\_expr.get\_ref());}
\DoxyCodeLine{4912     \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structB}{B}} = U.M;}
\DoxyCodeLine{4913     }
\DoxyCodeLine{4914     arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.n\_rows != \mbox{\hyperlink{structB}{B}}.n\_rows), \textcolor{stringliteral}{"{}solve(): number of rows in the given matrices must be the same"{}} );}
\DoxyCodeLine{4915     }
\DoxyCodeLine{4916     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty() || \mbox{\hyperlink{structB}{B}}.is\_empty())}
\DoxyCodeLine{4917       \{}
\DoxyCodeLine{4918       out.zeros(\mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{4919       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{4920       \}}
\DoxyCodeLine{4921     }
\DoxyCodeLine{4922     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}},\mbox{\hyperlink{structB}{B}});}
\DoxyCodeLine{4923     }
\DoxyCodeLine{4924     \mbox{\hyperlink{classMat}{Mat<eT>}} tmp( (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_cols), \mbox{\hyperlink{structB}{B}}.n\_cols, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}() );}
\DoxyCodeLine{4925     }
\DoxyCodeLine{4926     \textcolor{keywordflow}{if}(arma::size(tmp) == arma::size(\mbox{\hyperlink{structB}{B}}))}
\DoxyCodeLine{4927       \{}
\DoxyCodeLine{4928       tmp = \mbox{\hyperlink{structB}{B}};}
\DoxyCodeLine{4929       \}}
\DoxyCodeLine{4930     \textcolor{keywordflow}{else}}
\DoxyCodeLine{4931       \{}
\DoxyCodeLine{4932       tmp.zeros();}
\DoxyCodeLine{4933       tmp(0,0, arma::size(\mbox{\hyperlink{structB}{B}})) = \mbox{\hyperlink{structB}{B}};}
\DoxyCodeLine{4934       \}}
\DoxyCodeLine{4935     }
\DoxyCodeLine{4936     \textcolor{keywordtype}{char}      trans     = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{4937     blas\_int  m         = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4938     blas\_int  n         = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{4939     blas\_int  lda       = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{4940     blas\_int  ldb       = blas\_int(tmp.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{4941     blas\_int  nrhs      = blas\_int(\mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{4942     blas\_int  min\_mn    = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(m,n);}
\DoxyCodeLine{4943     blas\_int  lwork\_min = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(blas\_int(1), min\_mn + (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(min\_mn, nrhs));}
\DoxyCodeLine{4944     blas\_int  info      = 0;}
\DoxyCodeLine{4945     }
\DoxyCodeLine{4946     blas\_int lwork\_proposed = 0;}
\DoxyCodeLine{4947     }
\DoxyCodeLine{4948     \textcolor{keywordflow}{if}((m*n) >= 1024)}
\DoxyCodeLine{4949       \{}
\DoxyCodeLine{4950       eT        work\_query[2];}
\DoxyCodeLine{4951       blas\_int lwork\_query = -\/1;}
\DoxyCodeLine{4952       }
\DoxyCodeLine{4953       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::gels()"{}});}
\DoxyCodeLine{4954       lapack::gels<eT>( \&trans, \&m, \&n, \&nrhs, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, tmp.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldb, \&work\_query[0], \&lwork\_query, \&info );}
\DoxyCodeLine{4955       }
\DoxyCodeLine{4956       \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{4957       }
\DoxyCodeLine{4958       lwork\_proposed = \textcolor{keyword}{static\_cast<}blas\_int\textcolor{keyword}{>}( \mbox{\hyperlink{classaccess_a9687cee4d2be0fe591998d6f5c6d0849}{access::tmp\_real}}(work\_query[0]) );}
\DoxyCodeLine{4959       \}}
\DoxyCodeLine{4960     }
\DoxyCodeLine{4961     blas\_int lwork\_final = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(lwork\_proposed, lwork\_min);}
\DoxyCodeLine{4962     }
\DoxyCodeLine{4963     \mbox{\hyperlink{classpodarray}{podarray<eT>}} work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork\_final) );}
\DoxyCodeLine{4964     }
\DoxyCodeLine{4965     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::gels()"{}});}
\DoxyCodeLine{4966     lapack::gels<eT>( \&trans, \&m, \&n, \&nrhs, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, tmp.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldb, work.memptr(), \&lwork\_final, \&info );}
\DoxyCodeLine{4967     }
\DoxyCodeLine{4968     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{4969     }
\DoxyCodeLine{4970     \textcolor{keywordflow}{if}(tmp.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}} == \mbox{\hyperlink{structA}{A}}.n\_cols)}
\DoxyCodeLine{4971       \{}
\DoxyCodeLine{4972       out.\mbox{\hyperlink{group__Mat_gaff06a75771f96605f7cc4f8c6b3fceb7}{steal\_mem}}(tmp);}
\DoxyCodeLine{4973       \}}
\DoxyCodeLine{4974     \textcolor{keywordflow}{else}}
\DoxyCodeLine{4975       \{}
\DoxyCodeLine{4976       out = tmp.head\_rows(\mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{4977       \}}
\DoxyCodeLine{4978     }
\DoxyCodeLine{4979     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{4980     \}}
\DoxyCodeLine{4981 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{4982     \{}
\DoxyCodeLine{4983     arma\_ignore(out);}
\DoxyCodeLine{4984     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{4985     arma\_ignore(B\_expr);}
\DoxyCodeLine{4986     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}solve(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{4987     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{4988     \}}
\DoxyCodeLine{4989 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{4990   \}}
\DoxyCodeLine{4991 }
\DoxyCodeLine{4992 }
\DoxyCodeLine{4993 }
\DoxyCodeLine{4995 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{4996 \textcolor{keyword}{inline}}
\DoxyCodeLine{4997 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{4998 \mbox{\hyperlink{group__auxlib_ga676eba94edde2d8118168a4a99eec8f3}{auxlib::solve\_rect\_rcond}}(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{typename} T1::pod\_type\& out\_rcond, \mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::elem\_type,T1>}}\& B\_expr, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_ugly)}
\DoxyCodeLine{4999   \{}
\DoxyCodeLine{5000   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{5001   }
\DoxyCodeLine{5002 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{5003     \{}
\DoxyCodeLine{5004     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{5005     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type   T;}
\DoxyCodeLine{5006     }
\DoxyCodeLine{5007     out\_rcond = T(0);}
\DoxyCodeLine{5008     }
\DoxyCodeLine{5009     \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap}{unwrap<T1>}}   U(B\_expr.get\_ref());}
\DoxyCodeLine{5010     \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structB}{B}} = U.M;}
\DoxyCodeLine{5011     }
\DoxyCodeLine{5012     arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.n\_rows != \mbox{\hyperlink{structB}{B}}.n\_rows), \textcolor{stringliteral}{"{}solve(): number of rows in the given matrices must be the same"{}} );}
\DoxyCodeLine{5013     }
\DoxyCodeLine{5014     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty() || \mbox{\hyperlink{structB}{B}}.is\_empty())}
\DoxyCodeLine{5015       \{}
\DoxyCodeLine{5016       out.zeros(\mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{5017       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{5018       \}}
\DoxyCodeLine{5019     }
\DoxyCodeLine{5020     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}},\mbox{\hyperlink{structB}{B}});}
\DoxyCodeLine{5021     }
\DoxyCodeLine{5022     \mbox{\hyperlink{classMat}{Mat<eT>}} tmp( (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_cols), \mbox{\hyperlink{structB}{B}}.n\_cols, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}() );}
\DoxyCodeLine{5023     }
\DoxyCodeLine{5024     \textcolor{keywordflow}{if}(arma::size(tmp) == arma::size(\mbox{\hyperlink{structB}{B}}))}
\DoxyCodeLine{5025       \{}
\DoxyCodeLine{5026       tmp = \mbox{\hyperlink{structB}{B}};}
\DoxyCodeLine{5027       \}}
\DoxyCodeLine{5028     \textcolor{keywordflow}{else}}
\DoxyCodeLine{5029       \{}
\DoxyCodeLine{5030       tmp.zeros();}
\DoxyCodeLine{5031       tmp(0,0, arma::size(\mbox{\hyperlink{structB}{B}})) = \mbox{\hyperlink{structB}{B}};}
\DoxyCodeLine{5032       \}}
\DoxyCodeLine{5033     }
\DoxyCodeLine{5034     \textcolor{keywordtype}{char}      trans     = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{5035     blas\_int  m         = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{5036     blas\_int  n         = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{5037     blas\_int  lda       = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{5038     blas\_int  ldb       = blas\_int(tmp.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{5039     blas\_int  nrhs      = blas\_int(\mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{5040     blas\_int  min\_mn    = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(m,n);}
\DoxyCodeLine{5041     blas\_int  lwork\_min = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(blas\_int(1), min\_mn + (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(min\_mn, nrhs));}
\DoxyCodeLine{5042     blas\_int  info      = 0;}
\DoxyCodeLine{5043     }
\DoxyCodeLine{5044     blas\_int lwork\_proposed = 0;}
\DoxyCodeLine{5045     }
\DoxyCodeLine{5046     \textcolor{keywordflow}{if}((m*n) >= 1024)}
\DoxyCodeLine{5047       \{}
\DoxyCodeLine{5048       eT        work\_query[2];}
\DoxyCodeLine{5049       blas\_int lwork\_query = -\/1;}
\DoxyCodeLine{5050       }
\DoxyCodeLine{5051       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::gels()"{}});}
\DoxyCodeLine{5052       lapack::gels<eT>( \&trans, \&m, \&n, \&nrhs, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, tmp.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldb, \&work\_query[0], \&lwork\_query, \&info );}
\DoxyCodeLine{5053       }
\DoxyCodeLine{5054       \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{5055       }
\DoxyCodeLine{5056       lwork\_proposed = \textcolor{keyword}{static\_cast<}blas\_int\textcolor{keyword}{>}( \mbox{\hyperlink{classaccess_a9687cee4d2be0fe591998d6f5c6d0849}{access::tmp\_real}}(work\_query[0]) );}
\DoxyCodeLine{5057       \}}
\DoxyCodeLine{5058     }
\DoxyCodeLine{5059     blas\_int lwork\_final = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(lwork\_proposed, lwork\_min);}
\DoxyCodeLine{5060     }
\DoxyCodeLine{5061     \mbox{\hyperlink{classpodarray}{podarray<eT>}} work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork\_final) );}
\DoxyCodeLine{5062     }
\DoxyCodeLine{5063     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::gels()"{}});}
\DoxyCodeLine{5064     lapack::gels<eT>( \&trans, \&m, \&n, \&nrhs, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, tmp.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldb, work.memptr(), \&lwork\_final, \&info );}
\DoxyCodeLine{5065     }
\DoxyCodeLine{5066     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{5067     }
\DoxyCodeLine{5068     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.n\_rows >= \mbox{\hyperlink{structA}{A}}.n\_cols)}
\DoxyCodeLine{5069       \{}
\DoxyCodeLine{5070       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}estimating rcond via R"{}});}
\DoxyCodeLine{5071       }
\DoxyCodeLine{5072       \textcolor{comment}{// xGELS  docs: for M >= N, A contains details of its QR decomposition as returned by xGEQRF}}
\DoxyCodeLine{5073       \textcolor{comment}{// xGEQRF docs: elements on and above the diagonal contain the min(M,N)-\/by-\/N upper trapezoidal matrix R}}
\DoxyCodeLine{5074       }
\DoxyCodeLine{5075       \mbox{\hyperlink{classMat}{Mat<eT>}} R(\mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structarma__zeros__indicator}{arma\_zeros\_indicator}}());}
\DoxyCodeLine{5076       }
\DoxyCodeLine{5077       \textcolor{keywordflow}{for}(uword col=0; col < \mbox{\hyperlink{structA}{A}}.n\_cols; ++col)}
\DoxyCodeLine{5078         \{}
\DoxyCodeLine{5079         \textcolor{keywordflow}{for}(uword row=0; row <= col; ++row)}
\DoxyCodeLine{5080           \{}
\DoxyCodeLine{5081           R.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(row,col) = \mbox{\hyperlink{structA}{A}}.at(row,col);}
\DoxyCodeLine{5082           \}}
\DoxyCodeLine{5083         \}}
\DoxyCodeLine{5084       }
\DoxyCodeLine{5085       \textcolor{comment}{// determine quality of solution}}
\DoxyCodeLine{5086       out\_rcond = auxlib::rcond\_trimat(R, 0);   \textcolor{comment}{// 0: upper triangular; 1: lower triangular}}
\DoxyCodeLine{5087       }
\DoxyCodeLine{5088       \textcolor{keywordflow}{if}( (allow\_ugly == \textcolor{keyword}{false}) \&\& (out\_rcond < auxlib::epsilon\_lapack(\mbox{\hyperlink{structA}{A}})) )  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{5089       \}}
\DoxyCodeLine{5090     \textcolor{keywordflow}{else}}
\DoxyCodeLine{5091     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.n\_rows < \mbox{\hyperlink{structA}{A}}.n\_cols)}
\DoxyCodeLine{5092       \{}
\DoxyCodeLine{5093       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}estimating rcond via L"{}});}
\DoxyCodeLine{5094       }
\DoxyCodeLine{5095       \textcolor{comment}{// xGELS  docs: for M < N, A contains details of its LQ decomposition as returned by xGELQF}}
\DoxyCodeLine{5096       \textcolor{comment}{// xGELQF docs: elements on and below the diagonal contain the M-\/by-\/min(M,N) lower trapezoidal matrix L}}
\DoxyCodeLine{5097       }
\DoxyCodeLine{5098       \mbox{\hyperlink{classMat}{Mat<eT>}} L(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structarma__zeros__indicator}{arma\_zeros\_indicator}}());}
\DoxyCodeLine{5099       }
\DoxyCodeLine{5100       \textcolor{keywordflow}{for}(uword col=0; col < \mbox{\hyperlink{structA}{A}}.n\_rows; ++col)}
\DoxyCodeLine{5101         \{}
\DoxyCodeLine{5102         \textcolor{keywordflow}{for}(uword row=col; row < \mbox{\hyperlink{structA}{A}}.n\_rows; ++row)}
\DoxyCodeLine{5103           \{}
\DoxyCodeLine{5104           L.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(row,col) = \mbox{\hyperlink{structA}{A}}.at(row,col);}
\DoxyCodeLine{5105           \}}
\DoxyCodeLine{5106         \}}
\DoxyCodeLine{5107       }
\DoxyCodeLine{5108       \textcolor{comment}{// determine quality of solution}}
\DoxyCodeLine{5109       out\_rcond = auxlib::rcond\_trimat(L, 1);   \textcolor{comment}{// 0: upper triangular; 1: lower triangular}}
\DoxyCodeLine{5110       }
\DoxyCodeLine{5111       \textcolor{keywordflow}{if}( (allow\_ugly == \textcolor{keyword}{false}) \&\& (out\_rcond < auxlib::epsilon\_lapack(\mbox{\hyperlink{structA}{A}})) )  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{5112       \}}
\DoxyCodeLine{5113     }
\DoxyCodeLine{5114     \textcolor{keywordflow}{if}(tmp.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}} == \mbox{\hyperlink{structA}{A}}.n\_cols)}
\DoxyCodeLine{5115       \{}
\DoxyCodeLine{5116       out.\mbox{\hyperlink{group__Mat_gaff06a75771f96605f7cc4f8c6b3fceb7}{steal\_mem}}(tmp);}
\DoxyCodeLine{5117       \}}
\DoxyCodeLine{5118     \textcolor{keywordflow}{else}}
\DoxyCodeLine{5119       \{}
\DoxyCodeLine{5120       out = tmp.head\_rows(\mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{5121       \}}
\DoxyCodeLine{5122     }
\DoxyCodeLine{5123     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{5124     \}}
\DoxyCodeLine{5125 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{5126     \{}
\DoxyCodeLine{5127     arma\_ignore(out);}
\DoxyCodeLine{5128     arma\_ignore(out\_rcond);}
\DoxyCodeLine{5129     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{5130     arma\_ignore(B\_expr);}
\DoxyCodeLine{5131     arma\_ignore(allow\_ugly);}
\DoxyCodeLine{5132     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}solve(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{5133     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{5134     \}}
\DoxyCodeLine{5135 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{5136   \}}
\DoxyCodeLine{5137 }
\DoxyCodeLine{5138 }
\DoxyCodeLine{5139 }
\DoxyCodeLine{5140 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{5141 \textcolor{keyword}{inline}}
\DoxyCodeLine{5142 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{5143 auxlib::solve\_approx\_svd(\mbox{\hyperlink{classMat}{Mat<typename T1::pod\_type>}}\& out, \mbox{\hyperlink{classMat}{Mat<typename T1::pod\_type>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::pod\_type,T1>}}\& B\_expr)}
\DoxyCodeLine{5144   \{}
\DoxyCodeLine{5145   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{5146   }
\DoxyCodeLine{5147 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{5148     \{}
\DoxyCodeLine{5149     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type eT;}
\DoxyCodeLine{5150     }
\DoxyCodeLine{5151     \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap}{unwrap<T1>}}   U(B\_expr.get\_ref());}
\DoxyCodeLine{5152     \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structB}{B}} = U.M;}
\DoxyCodeLine{5153     }
\DoxyCodeLine{5154     arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.n\_rows != \mbox{\hyperlink{structB}{B}}.n\_rows), \textcolor{stringliteral}{"{}solve(): number of rows in the given matrices must be the same"{}} );}
\DoxyCodeLine{5155     }
\DoxyCodeLine{5156     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty() || \mbox{\hyperlink{structB}{B}}.is\_empty())}
\DoxyCodeLine{5157       \{}
\DoxyCodeLine{5158       out.zeros(\mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{5159       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{5160       \}}
\DoxyCodeLine{5161     }
\DoxyCodeLine{5162     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}},\mbox{\hyperlink{structB}{B}});}
\DoxyCodeLine{5163     }
\DoxyCodeLine{5164     \mbox{\hyperlink{classMat}{Mat<eT>}} tmp( (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_cols), \mbox{\hyperlink{structB}{B}}.n\_cols, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}() );}
\DoxyCodeLine{5165     }
\DoxyCodeLine{5166     \textcolor{keywordflow}{if}(arma::size(tmp) == arma::size(\mbox{\hyperlink{structB}{B}}))}
\DoxyCodeLine{5167       \{}
\DoxyCodeLine{5168       tmp = \mbox{\hyperlink{structB}{B}};}
\DoxyCodeLine{5169       \}}
\DoxyCodeLine{5170     \textcolor{keywordflow}{else}}
\DoxyCodeLine{5171       \{}
\DoxyCodeLine{5172       tmp.zeros();}
\DoxyCodeLine{5173       tmp(0,0, arma::size(\mbox{\hyperlink{structB}{B}})) = \mbox{\hyperlink{structB}{B}};}
\DoxyCodeLine{5174       \}}
\DoxyCodeLine{5175     }
\DoxyCodeLine{5176     blas\_int m      = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{5177     blas\_int n      = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{5178     blas\_int min\_mn = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(m, n);}
\DoxyCodeLine{5179     blas\_int nrhs   = blas\_int(\mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{5180     blas\_int lda    = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{5181     blas\_int ldb    = blas\_int(tmp.n\_rows);}
\DoxyCodeLine{5182     eT       rcond  = eT(-\/1);  \textcolor{comment}{// -\/1 means "{}use machine precision"{}}}
\DoxyCodeLine{5183     blas\_int rank   = blas\_int(0);}
\DoxyCodeLine{5184     blas\_int info   = blas\_int(0);}
\DoxyCodeLine{5185     }
\DoxyCodeLine{5186     \mbox{\hyperlink{classpodarray}{podarray<eT>}} S( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(min\_mn) );}
\DoxyCodeLine{5187     }
\DoxyCodeLine{5188     \textcolor{comment}{// NOTE: with LAPACK 3.8, can use the workspace query to also obtain liwork,}}
\DoxyCodeLine{5189     \textcolor{comment}{// NOTE: which makes the call to lapack::laenv() redundant}}
\DoxyCodeLine{5190     }
\DoxyCodeLine{5191     blas\_int ispec = blas\_int(9);}
\DoxyCodeLine{5192     }
\DoxyCodeLine{5193     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* const\_name = (\mbox{\hyperlink{structis__float}{is\_float<eT>::value}}) ? \textcolor{stringliteral}{"{}SGELSD"{}} : \textcolor{stringliteral}{"{}DGELSD"{}};}
\DoxyCodeLine{5194     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* const\_opts = \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{5195     }
\DoxyCodeLine{5196     \textcolor{keywordtype}{char}* \mbox{\hyperlink{structname}{name}} = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(const\_name);}
\DoxyCodeLine{5197     \textcolor{keywordtype}{char}* opts = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(const\_opts);}
\DoxyCodeLine{5198     }
\DoxyCodeLine{5199     blas\_int n1 = m;}
\DoxyCodeLine{5200     blas\_int n2 = n;}
\DoxyCodeLine{5201     blas\_int n3 = nrhs;}
\DoxyCodeLine{5202     blas\_int n4 = lda;}
\DoxyCodeLine{5203     }
\DoxyCodeLine{5204     blas\_int laenv\_result = (arma\_config::hidden\_args) ? blas\_int(lapack::laenv(\&ispec, \mbox{\hyperlink{structname}{name}}, opts, \&n1, \&n2, \&n3, \&n4, 6, 1)) : blas\_int(0);}
\DoxyCodeLine{5205     }
\DoxyCodeLine{5206     blas\_int smlsiz    = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})( blas\_int(25), laenv\_result );}
\DoxyCodeLine{5207     blas\_int smlsiz\_p1 = blas\_int(1) + smlsiz;}
\DoxyCodeLine{5208     }
\DoxyCodeLine{5209     blas\_int nlvl   = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})( blas\_int(0), blas\_int(1) + blas\_int( std::log(\textcolor{keywordtype}{double}(min\_mn) / \textcolor{keywordtype}{double}(smlsiz\_p1))/\textcolor{keywordtype}{double}(0.69314718055994530942) ) );}
\DoxyCodeLine{5210     blas\_int liwork = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})( blas\_int(1), (blas\_int(3)*min\_mn*nlvl + blas\_int(11)*min\_mn) );}
\DoxyCodeLine{5211     }
\DoxyCodeLine{5212     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} iwork( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(liwork) );}
\DoxyCodeLine{5213     }
\DoxyCodeLine{5214     blas\_int lwork\_min = blas\_int(12)*min\_mn + blas\_int(2)*min\_mn*smlsiz + blas\_int(8)*min\_mn*nlvl + min\_mn*nrhs + smlsiz\_p1*smlsiz\_p1;}
\DoxyCodeLine{5215     }
\DoxyCodeLine{5216     eT        work\_query[2];}
\DoxyCodeLine{5217     blas\_int lwork\_query = blas\_int(-\/1);}
\DoxyCodeLine{5218     }
\DoxyCodeLine{5219     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::gelsd()"{}});}
\DoxyCodeLine{5220     lapack::gelsd(\&m, \&n, \&nrhs, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, tmp.memptr(), \&ldb, S.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&rcond, \&rank, \&work\_query[0], \&lwork\_query, iwork.memptr(), \&info);}
\DoxyCodeLine{5221     }
\DoxyCodeLine{5222     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{5223     }
\DoxyCodeLine{5224     \textcolor{comment}{// NOTE: in LAPACK 3.8, iwork[0] returns the minimum liwork}}
\DoxyCodeLine{5225     }
\DoxyCodeLine{5226     blas\_int lwork\_proposed = \textcolor{keyword}{static\_cast<}blas\_int\textcolor{keyword}{>}( \mbox{\hyperlink{classaccess_a9687cee4d2be0fe591998d6f5c6d0849}{access::tmp\_real}}(work\_query[0]) );}
\DoxyCodeLine{5227     blas\_int lwork\_final    = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(lwork\_proposed, lwork\_min);}
\DoxyCodeLine{5228     }
\DoxyCodeLine{5229     \mbox{\hyperlink{classpodarray}{podarray<eT>}} work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork\_final) );}
\DoxyCodeLine{5230     }
\DoxyCodeLine{5231     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::gelsd()"{}});}
\DoxyCodeLine{5232     lapack::gelsd(\&m, \&n, \&nrhs, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, tmp.memptr(), \&ldb, S.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&rcond, \&rank, work.memptr(), \&lwork\_final, iwork.memptr(), \&info);}
\DoxyCodeLine{5233     }
\DoxyCodeLine{5234     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{5235     }
\DoxyCodeLine{5236     \textcolor{keywordflow}{if}(tmp.n\_rows == \mbox{\hyperlink{structA}{A}}.n\_cols)}
\DoxyCodeLine{5237       \{}
\DoxyCodeLine{5238       out.\mbox{\hyperlink{group__Mat_gaff06a75771f96605f7cc4f8c6b3fceb7}{steal\_mem}}(tmp);}
\DoxyCodeLine{5239       \}}
\DoxyCodeLine{5240     \textcolor{keywordflow}{else}}
\DoxyCodeLine{5241       \{}
\DoxyCodeLine{5242       out = tmp.head\_rows(\mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{5243       \}}
\DoxyCodeLine{5244     }
\DoxyCodeLine{5245     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{5246     \}}
\DoxyCodeLine{5247 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{5248     \{}
\DoxyCodeLine{5249     arma\_ignore(out);}
\DoxyCodeLine{5250     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{5251     arma\_ignore(B\_expr);}
\DoxyCodeLine{5252     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}solve(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{5253     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{5254     \}}
\DoxyCodeLine{5255 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{5256   \}}
\DoxyCodeLine{5257 }
\DoxyCodeLine{5258 }
\DoxyCodeLine{5259 }
\DoxyCodeLine{5260 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{5261 \textcolor{keyword}{inline}}
\DoxyCodeLine{5262 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{5263 auxlib::solve\_approx\_svd(\mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\& out, \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base}}<std::complex<typename T1::pod\_type>,T1>\& B\_expr)}
\DoxyCodeLine{5264   \{}
\DoxyCodeLine{5265   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{5266   }
\DoxyCodeLine{5267 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{5268     \{}
\DoxyCodeLine{5269     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type     T;}
\DoxyCodeLine{5270     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<T> eT;}
\DoxyCodeLine{5271     }
\DoxyCodeLine{5272     \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap}{unwrap<T1>}}   U(B\_expr.get\_ref());}
\DoxyCodeLine{5273     \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structB}{B}} = U.M;}
\DoxyCodeLine{5274     }
\DoxyCodeLine{5275     arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.n\_rows != \mbox{\hyperlink{structB}{B}}.n\_rows), \textcolor{stringliteral}{"{}solve(): number of rows in the given matrices must be the same"{}} );}
\DoxyCodeLine{5276     }
\DoxyCodeLine{5277     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty() || \mbox{\hyperlink{structB}{B}}.is\_empty())}
\DoxyCodeLine{5278       \{}
\DoxyCodeLine{5279       out.zeros(\mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{5280       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{5281       \}}
\DoxyCodeLine{5282     }
\DoxyCodeLine{5283     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}},\mbox{\hyperlink{structB}{B}});}
\DoxyCodeLine{5284     }
\DoxyCodeLine{5285     \mbox{\hyperlink{classMat}{Mat<eT>}} tmp( (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_cols), \mbox{\hyperlink{structB}{B}}.n\_cols, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}() );}
\DoxyCodeLine{5286     }
\DoxyCodeLine{5287     \textcolor{keywordflow}{if}(arma::size(tmp) == arma::size(\mbox{\hyperlink{structB}{B}}))}
\DoxyCodeLine{5288       \{}
\DoxyCodeLine{5289       tmp = \mbox{\hyperlink{structB}{B}};}
\DoxyCodeLine{5290       \}}
\DoxyCodeLine{5291     \textcolor{keywordflow}{else}}
\DoxyCodeLine{5292       \{}
\DoxyCodeLine{5293       tmp.zeros();}
\DoxyCodeLine{5294       tmp(0,0, arma::size(\mbox{\hyperlink{structB}{B}})) = \mbox{\hyperlink{structB}{B}};}
\DoxyCodeLine{5295       \}}
\DoxyCodeLine{5296     }
\DoxyCodeLine{5297     blas\_int m      = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{5298     blas\_int n      = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{5299     blas\_int min\_mn = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(m, n);}
\DoxyCodeLine{5300     blas\_int nrhs   = blas\_int(\mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{5301     blas\_int lda    = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{5302     blas\_int ldb    = blas\_int(tmp.n\_rows);}
\DoxyCodeLine{5303     T        rcond  = T(-\/1);  \textcolor{comment}{// -\/1 means "{}use machine precision"{}}}
\DoxyCodeLine{5304     blas\_int rank   = blas\_int(0);}
\DoxyCodeLine{5305     blas\_int info   = blas\_int(0);}
\DoxyCodeLine{5306     }
\DoxyCodeLine{5307     \mbox{\hyperlink{classpodarray}{podarray<T>}} S( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(min\_mn) );}
\DoxyCodeLine{5308     }
\DoxyCodeLine{5309     blas\_int ispec = blas\_int(9);}
\DoxyCodeLine{5310     }
\DoxyCodeLine{5311     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* const\_name = (\mbox{\hyperlink{structis__float}{is\_float<T>::value}}) ? \textcolor{stringliteral}{"{}CGELSD"{}} : \textcolor{stringliteral}{"{}ZGELSD"{}};}
\DoxyCodeLine{5312     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* const\_opts = \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{5313     }
\DoxyCodeLine{5314     \textcolor{keywordtype}{char}* \mbox{\hyperlink{structname}{name}} = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(const\_name);}
\DoxyCodeLine{5315     \textcolor{keywordtype}{char}* opts = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(const\_opts);}
\DoxyCodeLine{5316     }
\DoxyCodeLine{5317     blas\_int n1 = m;}
\DoxyCodeLine{5318     blas\_int n2 = n;}
\DoxyCodeLine{5319     blas\_int n3 = nrhs;}
\DoxyCodeLine{5320     blas\_int n4 = lda;}
\DoxyCodeLine{5321     }
\DoxyCodeLine{5322     blas\_int laenv\_result = (arma\_config::hidden\_args) ? blas\_int(lapack::laenv(\&ispec, \mbox{\hyperlink{structname}{name}}, opts, \&n1, \&n2, \&n3, \&n4, 6, 1)) : blas\_int(0);}
\DoxyCodeLine{5323     }
\DoxyCodeLine{5324     blas\_int smlsiz    = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})( blas\_int(25), laenv\_result );}
\DoxyCodeLine{5325     blas\_int smlsiz\_p1 = blas\_int(1) + smlsiz;}
\DoxyCodeLine{5326     }
\DoxyCodeLine{5327     blas\_int nlvl = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})( blas\_int(0), blas\_int(1) + blas\_int( std::log(\textcolor{keywordtype}{double}(min\_mn) / \textcolor{keywordtype}{double}(smlsiz\_p1))/\textcolor{keywordtype}{double}(0.69314718055994530942) ) );}
\DoxyCodeLine{5328     }
\DoxyCodeLine{5329     blas\_int lrwork = (m >= n)}
\DoxyCodeLine{5330       ? blas\_int(10)*n + blas\_int(2)*n*smlsiz + blas\_int(8)*n*nlvl + blas\_int(3)*smlsiz*nrhs + (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})( (smlsiz\_p1)*(smlsiz\_p1), n*(blas\_int(1)+nrhs) + blas\_int(2)*nrhs )}
\DoxyCodeLine{5331       : blas\_int(10)*m + blas\_int(2)*m*smlsiz + blas\_int(8)*m*nlvl + blas\_int(3)*smlsiz*nrhs + (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})( (smlsiz\_p1)*(smlsiz\_p1), n*(blas\_int(1)+nrhs) + blas\_int(2)*nrhs );}
\DoxyCodeLine{5332     }
\DoxyCodeLine{5333     blas\_int liwork = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})( blas\_int(1), (blas\_int(3)*blas\_int(min\_mn)*nlvl + blas\_int(11)*blas\_int(min\_mn)) );}
\DoxyCodeLine{5334     }
\DoxyCodeLine{5335     \mbox{\hyperlink{classpodarray}{podarray<T>}}        rwork( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lrwork) );}
\DoxyCodeLine{5336     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} iwork( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(liwork) );}
\DoxyCodeLine{5337     }
\DoxyCodeLine{5338     blas\_int lwork\_min = 2*min\_mn + min\_mn*nrhs;}
\DoxyCodeLine{5339     }
\DoxyCodeLine{5340     eT        work\_query[2];}
\DoxyCodeLine{5341     blas\_int lwork\_query = blas\_int(-\/1);}
\DoxyCodeLine{5342     }
\DoxyCodeLine{5343     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::cx\_gelsd()"{}});}
\DoxyCodeLine{5344     lapack::cx\_gelsd(\&m, \&n, \&nrhs, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, tmp.memptr(), \&ldb, S.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&rcond, \&rank, \&work\_query[0], \&lwork\_query, rwork.memptr(), iwork.memptr(), \&info);}
\DoxyCodeLine{5345     }
\DoxyCodeLine{5346     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{5347     }
\DoxyCodeLine{5348     blas\_int lwork\_proposed = \textcolor{keyword}{static\_cast<}blas\_int\textcolor{keyword}{>}( \mbox{\hyperlink{classaccess_a9687cee4d2be0fe591998d6f5c6d0849}{access::tmp\_real}}( work\_query[0]) );}
\DoxyCodeLine{5349     blas\_int lwork\_final    = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(lwork\_proposed, lwork\_min);}
\DoxyCodeLine{5350     }
\DoxyCodeLine{5351     \mbox{\hyperlink{classpodarray}{podarray<eT>}} work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork\_final) );}
\DoxyCodeLine{5352     }
\DoxyCodeLine{5353     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::cx\_gelsd()"{}});}
\DoxyCodeLine{5354     lapack::cx\_gelsd(\&m, \&n, \&nrhs, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, tmp.memptr(), \&ldb, S.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&rcond, \&rank, work.memptr(), \&lwork\_final, rwork.memptr(), iwork.memptr(), \&info);}
\DoxyCodeLine{5355     }
\DoxyCodeLine{5356     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{5357     }
\DoxyCodeLine{5358     \textcolor{keywordflow}{if}(tmp.n\_rows == \mbox{\hyperlink{structA}{A}}.n\_cols)}
\DoxyCodeLine{5359       \{}
\DoxyCodeLine{5360       out.\mbox{\hyperlink{group__Mat_gaff06a75771f96605f7cc4f8c6b3fceb7}{steal\_mem}}(tmp);}
\DoxyCodeLine{5361       \}}
\DoxyCodeLine{5362     \textcolor{keywordflow}{else}}
\DoxyCodeLine{5363       \{}
\DoxyCodeLine{5364       out = tmp.head\_rows(\mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{5365       \}}
\DoxyCodeLine{5366     }
\DoxyCodeLine{5367     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{5368     \}}
\DoxyCodeLine{5369 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{5370     \{}
\DoxyCodeLine{5371     arma\_ignore(out);}
\DoxyCodeLine{5372     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{5373     arma\_ignore(B\_expr);}
\DoxyCodeLine{5374     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}solve(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{5375     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{5376     \}}
\DoxyCodeLine{5377 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{5378   \}}
\DoxyCodeLine{5379 }
\DoxyCodeLine{5380 }
\DoxyCodeLine{5381 }
\DoxyCodeLine{5382 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{5383 \textcolor{keyword}{inline}}
\DoxyCodeLine{5384 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{5385 auxlib::solve\_trimat\_fast(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::elem\_type,T1>}}\& B\_expr, \textcolor{keyword}{const} uword layout)}
\DoxyCodeLine{5386   \{}
\DoxyCodeLine{5387   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{5388   }
\DoxyCodeLine{5389 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{5390     \{}
\DoxyCodeLine{5391     out = B\_expr.get\_ref();}
\DoxyCodeLine{5392     }
\DoxyCodeLine{5393     \textcolor{keyword}{const} uword B\_n\_rows = out.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}};}
\DoxyCodeLine{5394     \textcolor{keyword}{const} uword B\_n\_cols = out.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}};}
\DoxyCodeLine{5395     }
\DoxyCodeLine{5396     arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.n\_rows != B\_n\_rows), \textcolor{stringliteral}{"{}solve(): number of rows in the given matrices must be the same"{}} );}
\DoxyCodeLine{5397     }
\DoxyCodeLine{5398     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty() || out.\mbox{\hyperlink{group__Mat_ga3008049216e02308ff665862f451a7ff}{is\_empty}}())}
\DoxyCodeLine{5399       \{}
\DoxyCodeLine{5400       out.zeros(\mbox{\hyperlink{structA}{A}}.n\_cols, B\_n\_cols);}
\DoxyCodeLine{5401       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{5402       \}}
\DoxyCodeLine{5403     }
\DoxyCodeLine{5404     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}},out);}
\DoxyCodeLine{5405     }
\DoxyCodeLine{5406     \textcolor{keywordtype}{char}     uplo  = (layout == 0) ? \textcolor{charliteral}{'U'} : \textcolor{charliteral}{'L'};}
\DoxyCodeLine{5407     \textcolor{keywordtype}{char}     trans = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{5408     \textcolor{keywordtype}{char}     diag  = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{5409     blas\_int n     = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{5410     blas\_int nrhs  = blas\_int(B\_n\_cols);}
\DoxyCodeLine{5411     blas\_int info  = 0;}
\DoxyCodeLine{5412     }
\DoxyCodeLine{5413     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::trtrs()"{}});}
\DoxyCodeLine{5414     lapack::trtrs(\&uplo, \&trans, \&diag, \&n, \&nrhs, \mbox{\hyperlink{structA}{A}}.memptr(), \&n, out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&n, \&info);}
\DoxyCodeLine{5415     }
\DoxyCodeLine{5416     \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{5417     \}}
\DoxyCodeLine{5418 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{5419     \{}
\DoxyCodeLine{5420     arma\_ignore(out);}
\DoxyCodeLine{5421     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{5422     arma\_ignore(B\_expr);}
\DoxyCodeLine{5423     arma\_ignore(layout);}
\DoxyCodeLine{5424     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}solve(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{5425     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{5426     \}}
\DoxyCodeLine{5427 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{5428   \}}
\DoxyCodeLine{5429 }
\DoxyCodeLine{5430 }
\DoxyCodeLine{5431 }
\DoxyCodeLine{5432 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{5433 \textcolor{keyword}{inline}}
\DoxyCodeLine{5434 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{5435 auxlib::solve\_trimat\_rcond(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{typename} T1::pod\_type\& out\_rcond, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::elem\_type,T1>}}\& B\_expr, \textcolor{keyword}{const} uword layout, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_ugly)}
\DoxyCodeLine{5436   \{}
\DoxyCodeLine{5437   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{5438   }
\DoxyCodeLine{5439 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{5440     \{}
\DoxyCodeLine{5441     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type T;}
\DoxyCodeLine{5442     }
\DoxyCodeLine{5443     out\_rcond = T(0);}
\DoxyCodeLine{5444     }
\DoxyCodeLine{5445     out = B\_expr.get\_ref();}
\DoxyCodeLine{5446     }
\DoxyCodeLine{5447     \textcolor{keyword}{const} uword B\_n\_rows = out.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}};}
\DoxyCodeLine{5448     \textcolor{keyword}{const} uword B\_n\_cols = out.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}};}
\DoxyCodeLine{5449     }
\DoxyCodeLine{5450     arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.n\_rows != B\_n\_rows), \textcolor{stringliteral}{"{}solve(): number of rows in the given matrices must be the same"{}} );}
\DoxyCodeLine{5451     }
\DoxyCodeLine{5452     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty() || out.\mbox{\hyperlink{group__Mat_ga3008049216e02308ff665862f451a7ff}{is\_empty}}())}
\DoxyCodeLine{5453       \{}
\DoxyCodeLine{5454       out.zeros(\mbox{\hyperlink{structA}{A}}.n\_cols, B\_n\_cols);}
\DoxyCodeLine{5455       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{5456       \}}
\DoxyCodeLine{5457     }
\DoxyCodeLine{5458     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}},out);}
\DoxyCodeLine{5459     }
\DoxyCodeLine{5460     \textcolor{keywordtype}{char}     uplo  = (layout == 0) ? \textcolor{charliteral}{'U'} : \textcolor{charliteral}{'L'};}
\DoxyCodeLine{5461     \textcolor{keywordtype}{char}     trans = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{5462     \textcolor{keywordtype}{char}     diag  = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{5463     blas\_int n     = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{5464     blas\_int nrhs  = blas\_int(B\_n\_cols);}
\DoxyCodeLine{5465     blas\_int info  = 0;}
\DoxyCodeLine{5466     }
\DoxyCodeLine{5467     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::trtrs()"{}});}
\DoxyCodeLine{5468     lapack::trtrs(\&uplo, \&trans, \&diag, \&n, \&nrhs, \mbox{\hyperlink{structA}{A}}.memptr(), \&n, out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&n, \&info);}
\DoxyCodeLine{5469     }
\DoxyCodeLine{5470     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{5471     }
\DoxyCodeLine{5472     \textcolor{comment}{// determine quality of solution}}
\DoxyCodeLine{5473     out\_rcond = auxlib::rcond\_trimat(\mbox{\hyperlink{structA}{A}}, layout);}
\DoxyCodeLine{5474     }
\DoxyCodeLine{5475     \textcolor{keywordflow}{if}( (allow\_ugly == \textcolor{keyword}{false}) \&\& (out\_rcond < auxlib::epsilon\_lapack(\mbox{\hyperlink{structA}{A}})) )  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{5476     }
\DoxyCodeLine{5477     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{5478     \}}
\DoxyCodeLine{5479 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{5480     \{}
\DoxyCodeLine{5481     arma\_ignore(out);}
\DoxyCodeLine{5482     arma\_ignore(out\_rcond);}
\DoxyCodeLine{5483     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{5484     arma\_ignore(B\_expr);}
\DoxyCodeLine{5485     arma\_ignore(layout);}
\DoxyCodeLine{5486     arma\_ignore(allow\_ugly);}
\DoxyCodeLine{5487     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}solve(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{5488     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{5489     \}}
\DoxyCodeLine{5490 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{5491   \}}
\DoxyCodeLine{5492 }
\DoxyCodeLine{5493 }
\DoxyCodeLine{5494 }
\DoxyCodeLine{5496 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{5497 \textcolor{keyword}{inline}}
\DoxyCodeLine{5498 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{5499 \mbox{\hyperlink{group__auxlib_gab6113ebff3bb4633d77d574813c981e6}{auxlib::solve\_band\_fast}}(\mbox{\hyperlink{classMat}{Mat<typename T1::pod\_type>}}\& out, \mbox{\hyperlink{classMat}{Mat<typename T1::pod\_type>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} uword KL, \textcolor{keyword}{const} uword KU, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::pod\_type,T1>}}\& B\_expr)}
\DoxyCodeLine{5500   \{}
\DoxyCodeLine{5501   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{5502   }
\DoxyCodeLine{5503   \textcolor{keywordflow}{return} \mbox{\hyperlink{group__auxlib_ga285eb5be770a4d4ec1159070d1e9487b}{auxlib::solve\_band\_fast\_common}}(out, \mbox{\hyperlink{structA}{A}}, KL, KU, B\_expr);}
\DoxyCodeLine{5504   \}}
\DoxyCodeLine{5505 }
\DoxyCodeLine{5506 }
\DoxyCodeLine{5507 }
\DoxyCodeLine{5509 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{5510 \textcolor{keyword}{inline}}
\DoxyCodeLine{5511 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{5512 \mbox{\hyperlink{group__auxlib_gab6113ebff3bb4633d77d574813c981e6}{auxlib::solve\_band\_fast}}(\mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\& out, \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} uword KL, \textcolor{keyword}{const} uword KU, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base}}< std::complex<typename T1::pod\_type>,T1>\& B\_expr)}
\DoxyCodeLine{5513   \{}
\DoxyCodeLine{5514   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{5515   }
\DoxyCodeLine{5516 \textcolor{preprocessor}{  \#if defined(ARMA\_CRIPPLED\_LAPACK)}}
\DoxyCodeLine{5517     \{}
\DoxyCodeLine{5518     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}auxlib::solve\_band\_fast(): redirecting to auxlib::solve\_square\_fast() due to crippled LAPACK"{}});}
\DoxyCodeLine{5519     }
\DoxyCodeLine{5520     arma\_ignore(KL);}
\DoxyCodeLine{5521     arma\_ignore(KU);}
\DoxyCodeLine{5522     }
\DoxyCodeLine{5523     \textcolor{keywordflow}{return} \mbox{\hyperlink{group__auxlib_ga530089e89e43155f3bf6e709bbe775dd}{auxlib::solve\_square\_fast}}(out, \mbox{\hyperlink{structA}{A}}, B\_expr);}
\DoxyCodeLine{5524     \}}
\DoxyCodeLine{5525 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{5526     \{}
\DoxyCodeLine{5527     \textcolor{keywordflow}{return} \mbox{\hyperlink{group__auxlib_ga285eb5be770a4d4ec1159070d1e9487b}{auxlib::solve\_band\_fast\_common}}(out, \mbox{\hyperlink{structA}{A}}, KL, KU, B\_expr);}
\DoxyCodeLine{5528     \}}
\DoxyCodeLine{5529 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{5530   \}}
\DoxyCodeLine{5531 }
\DoxyCodeLine{5532 }
\DoxyCodeLine{5533 }
\DoxyCodeLine{5535 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{5536 \textcolor{keyword}{inline}}
\DoxyCodeLine{5537 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{5538 \mbox{\hyperlink{group__auxlib_ga285eb5be770a4d4ec1159070d1e9487b}{auxlib::solve\_band\_fast\_common}}(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} uword KL, \textcolor{keyword}{const} uword KU, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::elem\_type,T1>}}\& B\_expr)}
\DoxyCodeLine{5539   \{}
\DoxyCodeLine{5540   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{5541   }
\DoxyCodeLine{5542 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{5543     \{}
\DoxyCodeLine{5544     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{5545     }
\DoxyCodeLine{5546     out = B\_expr.get\_ref();}
\DoxyCodeLine{5547     }
\DoxyCodeLine{5548     \textcolor{keyword}{const} uword B\_n\_rows = out.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}};}
\DoxyCodeLine{5549     \textcolor{keyword}{const} uword B\_n\_cols = out.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}};}
\DoxyCodeLine{5550     }
\DoxyCodeLine{5551     arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.n\_rows != B\_n\_rows), \textcolor{stringliteral}{"{}solve(): number of rows in the given matrices must be the same"{}} );}
\DoxyCodeLine{5552     }
\DoxyCodeLine{5553     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty() || out.\mbox{\hyperlink{group__Mat_ga3008049216e02308ff665862f451a7ff}{is\_empty}}())}
\DoxyCodeLine{5554       \{}
\DoxyCodeLine{5555       out.zeros(\mbox{\hyperlink{structA}{A}}.n\_rows, B\_n\_cols);}
\DoxyCodeLine{5556       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{5557       \}}
\DoxyCodeLine{5558     }
\DoxyCodeLine{5559     \textcolor{comment}{// for gbsv, matrix AB size: 2*KL+KU+1 x N; band representation of A stored in rows KL+1 to 2*KL+KU+1  (note: fortran counts from 1)}}
\DoxyCodeLine{5560     }
\DoxyCodeLine{5561     \mbox{\hyperlink{classMat}{Mat<eT>}} AB;}
\DoxyCodeLine{5562     band\_helper::compress(AB, \mbox{\hyperlink{structA}{A}}, KL, KU, \textcolor{keyword}{true});}
\DoxyCodeLine{5563     }
\DoxyCodeLine{5564     \textcolor{keyword}{const} uword N = AB.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}};  \textcolor{comment}{// order of the original square matrix A}}
\DoxyCodeLine{5565     }
\DoxyCodeLine{5566     arma\_debug\_assert\_blas\_size(AB,out);}
\DoxyCodeLine{5567     }
\DoxyCodeLine{5568     blas\_int n    = blas\_int(N);}
\DoxyCodeLine{5569     blas\_int kl   = blas\_int(KL);}
\DoxyCodeLine{5570     blas\_int ku   = blas\_int(KU);}
\DoxyCodeLine{5571     blas\_int nrhs = blas\_int(B\_n\_cols);}
\DoxyCodeLine{5572     blas\_int ldab = blas\_int(AB.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{5573     blas\_int ldb  = blas\_int(B\_n\_rows);}
\DoxyCodeLine{5574     blas\_int info = blas\_int(0);}
\DoxyCodeLine{5575     }
\DoxyCodeLine{5576     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} ipiv(N + 2);  \textcolor{comment}{// +2 for paranoia}}
\DoxyCodeLine{5577     }
\DoxyCodeLine{5578     \textcolor{comment}{// NOTE: AB is overwritten}}
\DoxyCodeLine{5579     }
\DoxyCodeLine{5580     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::gbsv()"{}});}
\DoxyCodeLine{5581     lapack::gbsv<eT>(\&n, \&kl, \&ku, \&nrhs, AB.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldab, ipiv.memptr(), out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldb, \&info);}
\DoxyCodeLine{5582     }
\DoxyCodeLine{5583     \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{5584     \}}
\DoxyCodeLine{5585 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{5586     \{}
\DoxyCodeLine{5587     arma\_ignore(out);}
\DoxyCodeLine{5588     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{5589     arma\_ignore(KL);}
\DoxyCodeLine{5590     arma\_ignore(KU);}
\DoxyCodeLine{5591     arma\_ignore(B\_expr);}
\DoxyCodeLine{5592     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}solve(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{5593     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{5594     \}}
\DoxyCodeLine{5595 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{5596   \}}
\DoxyCodeLine{5597 }
\DoxyCodeLine{5598 }
\DoxyCodeLine{5599 }
\DoxyCodeLine{5601 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{5602 \textcolor{keyword}{inline}}
\DoxyCodeLine{5603 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{5604 \mbox{\hyperlink{group__auxlib_ga9c2bcb80543054b93973eb61857a3a35}{auxlib::solve\_band\_rcond}}(\mbox{\hyperlink{classMat}{Mat<typename T1::pod\_type>}}\& out, \textcolor{keyword}{typename} T1::pod\_type\& out\_rcond, \mbox{\hyperlink{classMat}{Mat<typename T1::pod\_type>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} uword KL, \textcolor{keyword}{const} uword KU, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::pod\_type,T1>}}\& B\_expr, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_ugly)}
\DoxyCodeLine{5605   \{}
\DoxyCodeLine{5606   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{5607   }
\DoxyCodeLine{5608   \textcolor{keywordflow}{return} \mbox{\hyperlink{group__auxlib_ga53fcaccc31c1a35dafb39fe03bfda705}{auxlib::solve\_band\_rcond\_common}}(out, out\_rcond, \mbox{\hyperlink{structA}{A}}, KL, KU, B\_expr, allow\_ugly);}
\DoxyCodeLine{5609   \}}
\DoxyCodeLine{5610 }
\DoxyCodeLine{5611 }
\DoxyCodeLine{5612 }
\DoxyCodeLine{5614 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{5615 \textcolor{keyword}{inline}}
\DoxyCodeLine{5616 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{5617 \mbox{\hyperlink{group__auxlib_ga9c2bcb80543054b93973eb61857a3a35}{auxlib::solve\_band\_rcond}}(\mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\& out, \textcolor{keyword}{typename} T1::pod\_type\& out\_rcond, \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} uword KL, \textcolor{keyword}{const} uword KU, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base}}< std::complex<typename T1::pod\_type>,T1>\& B\_expr, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_ugly)}
\DoxyCodeLine{5618   \{}
\DoxyCodeLine{5619   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{5620   }
\DoxyCodeLine{5621 \textcolor{preprocessor}{  \#if defined(ARMA\_CRIPPLED\_LAPACK)}}
\DoxyCodeLine{5622     \{}
\DoxyCodeLine{5623     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}auxlib::solve\_band\_rcond(): redirecting to auxlib::solve\_square\_rcond() due to crippled LAPACK"{}});}
\DoxyCodeLine{5624     }
\DoxyCodeLine{5625     arma\_ignore(KL);}
\DoxyCodeLine{5626     arma\_ignore(KU);}
\DoxyCodeLine{5627     }
\DoxyCodeLine{5628     \textcolor{keywordflow}{return} \mbox{\hyperlink{group__auxlib_ga16be749fd9b7ac92dd2f437f9e45fdf9}{auxlib::solve\_square\_rcond}}(out, out\_rcond, \mbox{\hyperlink{structA}{A}}, B\_expr, allow\_ugly);}
\DoxyCodeLine{5629     \}}
\DoxyCodeLine{5630 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{5631     \{}
\DoxyCodeLine{5632     \textcolor{keywordflow}{return} \mbox{\hyperlink{group__auxlib_ga53fcaccc31c1a35dafb39fe03bfda705}{auxlib::solve\_band\_rcond\_common}}(out, out\_rcond, \mbox{\hyperlink{structA}{A}}, KL, KU, B\_expr, allow\_ugly);}
\DoxyCodeLine{5633     \}}
\DoxyCodeLine{5634 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{5635   \}}
\DoxyCodeLine{5636 }
\DoxyCodeLine{5637 }
\DoxyCodeLine{5638 }
\DoxyCodeLine{5640 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{5641 \textcolor{keyword}{inline}}
\DoxyCodeLine{5642 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{5643 \mbox{\hyperlink{group__auxlib_ga53fcaccc31c1a35dafb39fe03bfda705}{auxlib::solve\_band\_rcond\_common}}(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{typename} T1::pod\_type\& out\_rcond, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} uword KL, \textcolor{keyword}{const} uword KU, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::elem\_type,T1>}}\& B\_expr, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_ugly)}
\DoxyCodeLine{5644   \{}
\DoxyCodeLine{5645   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{5646   }
\DoxyCodeLine{5647 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{5648     \{}
\DoxyCodeLine{5649     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{5650     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type   T;}
\DoxyCodeLine{5651     }
\DoxyCodeLine{5652     out\_rcond = T(0);}
\DoxyCodeLine{5653     }
\DoxyCodeLine{5654     out = B\_expr.get\_ref();}
\DoxyCodeLine{5655     }
\DoxyCodeLine{5656     \textcolor{keyword}{const} uword B\_n\_rows = out.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}};}
\DoxyCodeLine{5657     \textcolor{keyword}{const} uword B\_n\_cols = out.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}};}
\DoxyCodeLine{5658     }
\DoxyCodeLine{5659     arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.n\_rows != B\_n\_rows), \textcolor{stringliteral}{"{}solve(): number of rows in the given matrices must be the same"{}} );}
\DoxyCodeLine{5660     }
\DoxyCodeLine{5661     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty() || out.\mbox{\hyperlink{group__Mat_ga3008049216e02308ff665862f451a7ff}{is\_empty}}())}
\DoxyCodeLine{5662       \{}
\DoxyCodeLine{5663       out.zeros(\mbox{\hyperlink{structA}{A}}.n\_rows, B\_n\_cols);}
\DoxyCodeLine{5664       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{5665       \}}
\DoxyCodeLine{5666     }
\DoxyCodeLine{5667     \textcolor{comment}{// for gbtrf, matrix AB size: 2*KL+KU+1 x N; band representation of A stored in rows KL+1 to 2*KL+KU+1  (note: fortran counts from 1)}}
\DoxyCodeLine{5668     }
\DoxyCodeLine{5669     \mbox{\hyperlink{classMat}{Mat<eT>}} AB;}
\DoxyCodeLine{5670     band\_helper::compress(AB, \mbox{\hyperlink{structA}{A}}, KL, KU, \textcolor{keyword}{true});}
\DoxyCodeLine{5671     }
\DoxyCodeLine{5672     \textcolor{keyword}{const} uword N = AB.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}};  \textcolor{comment}{// order of the original square matrix A}}
\DoxyCodeLine{5673     }
\DoxyCodeLine{5674     arma\_debug\_assert\_blas\_size(AB,out);}
\DoxyCodeLine{5675     }
\DoxyCodeLine{5676     \textcolor{keywordtype}{char}     norm\_id  = \textcolor{charliteral}{'1'};}
\DoxyCodeLine{5677     \textcolor{keywordtype}{char}     trans    = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{5678     blas\_int n        = blas\_int(N);  \textcolor{comment}{// assuming square matrix}}
\DoxyCodeLine{5679     blas\_int kl       = blas\_int(KL);}
\DoxyCodeLine{5680     blas\_int ku       = blas\_int(KU);}
\DoxyCodeLine{5681     blas\_int nrhs     = blas\_int(B\_n\_cols);}
\DoxyCodeLine{5682     blas\_int ldab     = blas\_int(AB.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{5683     blas\_int ldb      = blas\_int(B\_n\_rows);}
\DoxyCodeLine{5684     blas\_int info     = blas\_int(0);}
\DoxyCodeLine{5685     T        norm\_val = T(0);}
\DoxyCodeLine{5686     }
\DoxyCodeLine{5687     \mbox{\hyperlink{classpodarray}{podarray<T>}}        junk(1);}
\DoxyCodeLine{5688     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} ipiv(N + 2);  \textcolor{comment}{// +2 for paranoia}}
\DoxyCodeLine{5689     }
\DoxyCodeLine{5690     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::langb()"{}});}
\DoxyCodeLine{5691     norm\_val = lapack::langb<eT>(\&norm\_id, \&n, \&kl, \&ku, AB.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldab, junk.memptr());}
\DoxyCodeLine{5692     }
\DoxyCodeLine{5693     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::gbtrf()"{}});}
\DoxyCodeLine{5694     lapack::gbtrf<eT>(\&n, \&n, \&kl, \&ku, AB.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldab, ipiv.memptr(), \&info);}
\DoxyCodeLine{5695     }
\DoxyCodeLine{5696     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{5697     }
\DoxyCodeLine{5698     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::gbtrs()"{}});}
\DoxyCodeLine{5699     lapack::gbtrs<eT>(\&trans, \&n, \&kl, \&ku, \&nrhs, AB.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldab, ipiv.memptr(), out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldb, \&info);}
\DoxyCodeLine{5700     }
\DoxyCodeLine{5701     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{5702     }
\DoxyCodeLine{5703     out\_rcond = auxlib::lu\_rcond\_band<T>(AB, KL, KU, ipiv, norm\_val);}
\DoxyCodeLine{5704     }
\DoxyCodeLine{5705     \textcolor{keywordflow}{if}( (allow\_ugly == \textcolor{keyword}{false}) \&\& (out\_rcond < auxlib::epsilon\_lapack(AB)) )  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{5706     }
\DoxyCodeLine{5707     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{5708     \}}
\DoxyCodeLine{5709 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{5710     \{}
\DoxyCodeLine{5711     arma\_ignore(out);}
\DoxyCodeLine{5712     arma\_ignore(out\_rcond);}
\DoxyCodeLine{5713     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{5714     arma\_ignore(KL);}
\DoxyCodeLine{5715     arma\_ignore(KU);}
\DoxyCodeLine{5716     arma\_ignore(B\_expr);}
\DoxyCodeLine{5717     arma\_ignore(allow\_ugly);}
\DoxyCodeLine{5718     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}solve(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{5719     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{5720     \}}
\DoxyCodeLine{5721 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{5722   \}}
\DoxyCodeLine{5723 }
\DoxyCodeLine{5724 }
\DoxyCodeLine{5725 }
\DoxyCodeLine{5727 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{5728 \textcolor{keyword}{inline}}
\DoxyCodeLine{5729 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{5730 \mbox{\hyperlink{group__auxlib_ga00042cee38300d1df5196cbb8247ab34}{auxlib::solve\_band\_refine}}(\mbox{\hyperlink{classMat}{Mat<typename T1::pod\_type>}}\& out, \textcolor{keyword}{typename} T1::pod\_type\& out\_rcond, \mbox{\hyperlink{classMat}{Mat<typename T1::pod\_type>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} uword KL, \textcolor{keyword}{const} uword KU, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::pod\_type,T1>}}\& B\_expr, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} equilibrate, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_ugly)}
\DoxyCodeLine{5731   \{}
\DoxyCodeLine{5732   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{5733   }
\DoxyCodeLine{5734 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{5735     \{}
\DoxyCodeLine{5736     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type eT;}
\DoxyCodeLine{5737     }
\DoxyCodeLine{5738     \mbox{\hyperlink{classMat}{Mat<eT>}} \mbox{\hyperlink{structB}{B}} = B\_expr.get\_ref();  \textcolor{comment}{// B is overwritten}}
\DoxyCodeLine{5739     }
\DoxyCodeLine{5740     arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.n\_rows != \mbox{\hyperlink{structB}{B}}.n\_rows), \textcolor{stringliteral}{"{}solve(): number of rows in the given matrices must be the same"{}} );}
\DoxyCodeLine{5741       }
\DoxyCodeLine{5742     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty() || \mbox{\hyperlink{structB}{B}}.is\_empty())}
\DoxyCodeLine{5743       \{}
\DoxyCodeLine{5744       out.zeros(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{5745       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{5746       \}}
\DoxyCodeLine{5747     }
\DoxyCodeLine{5748     \textcolor{comment}{// for gbsvx, matrix AB size: KL+KU+1 x N; band representation of A stored in rows 1 to KL+KU+1  (note: fortran counts from 1)}}
\DoxyCodeLine{5749     }
\DoxyCodeLine{5750     \mbox{\hyperlink{classMat}{Mat<eT>}} AB;}
\DoxyCodeLine{5751     band\_helper::compress(AB, \mbox{\hyperlink{structA}{A}}, KL, KU, \textcolor{keyword}{false});}
\DoxyCodeLine{5752     }
\DoxyCodeLine{5753     \textcolor{keyword}{const} uword N = AB.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}};}
\DoxyCodeLine{5754     }
\DoxyCodeLine{5755     arma\_debug\_assert\_blas\_size(AB,\mbox{\hyperlink{structB}{B}});}
\DoxyCodeLine{5756     }
\DoxyCodeLine{5757     out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(N, \mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{5758     }
\DoxyCodeLine{5759     \mbox{\hyperlink{classMat}{Mat<eT>}} AFB(2*KL+KU+1, N, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{5760     }
\DoxyCodeLine{5761     \textcolor{keywordtype}{char}     fact  = (equilibrate) ? \textcolor{charliteral}{'E'} : \textcolor{charliteral}{'N'}; }
\DoxyCodeLine{5762     \textcolor{keywordtype}{char}     trans = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{5763     \textcolor{keywordtype}{char}     equed = char(0);}
\DoxyCodeLine{5764     blas\_int n     = blas\_int(N);}
\DoxyCodeLine{5765     blas\_int kl    = blas\_int(KL);}
\DoxyCodeLine{5766     blas\_int ku    = blas\_int(KU);}
\DoxyCodeLine{5767     blas\_int nrhs  = blas\_int(\mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{5768     blas\_int ldab  = blas\_int(AB.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{5769     blas\_int ldafb = blas\_int(AFB.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{5770     blas\_int ldb   = blas\_int(\mbox{\hyperlink{structB}{B}}.n\_rows);}
\DoxyCodeLine{5771     blas\_int ldx   = blas\_int(N);}
\DoxyCodeLine{5772     blas\_int info  = blas\_int(0);}
\DoxyCodeLine{5773     eT       rcond = eT(0);}
\DoxyCodeLine{5774     }
\DoxyCodeLine{5775     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}}  IPIV(  N);}
\DoxyCodeLine{5776     \mbox{\hyperlink{classpodarray}{podarray<eT>}}           R(  N);}
\DoxyCodeLine{5777     \mbox{\hyperlink{classpodarray}{podarray<eT>}}           C(  N);}
\DoxyCodeLine{5778     \mbox{\hyperlink{classpodarray}{podarray<eT>}}        FERR(  \mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{5779     \mbox{\hyperlink{classpodarray}{podarray<eT>}}        BERR(  \mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{5780     \mbox{\hyperlink{classpodarray}{podarray<eT>}}        WORK(3*N);}
\DoxyCodeLine{5781     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} IWORK(  N);}
\DoxyCodeLine{5782     }
\DoxyCodeLine{5783     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::gbsvx()"{}});}
\DoxyCodeLine{5784     lapack::gbsvx}
\DoxyCodeLine{5785       (}
\DoxyCodeLine{5786       \&fact, \&trans, \&n, \&kl, \&ku, \&nrhs, }
\DoxyCodeLine{5787       AB.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldab,}
\DoxyCodeLine{5788       AFB.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldafb,}
\DoxyCodeLine{5789       IPIV.memptr(),}
\DoxyCodeLine{5790       \&equed,}
\DoxyCodeLine{5791       R.memptr(),}
\DoxyCodeLine{5792       C.memptr(),}
\DoxyCodeLine{5793       \mbox{\hyperlink{structB}{B}}.memptr(), \&ldb,}
\DoxyCodeLine{5794       out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldx,}
\DoxyCodeLine{5795       \&rcond,}
\DoxyCodeLine{5796       FERR.memptr(),}
\DoxyCodeLine{5797       BERR.memptr(),}
\DoxyCodeLine{5798       WORK.memptr(),}
\DoxyCodeLine{5799       IWORK.memptr(),}
\DoxyCodeLine{5800       \&info}
\DoxyCodeLine{5801       );}
\DoxyCodeLine{5802     }
\DoxyCodeLine{5803     out\_rcond = rcond;}
\DoxyCodeLine{5804     }
\DoxyCodeLine{5805     \textcolor{keywordflow}{return} (allow\_ugly) ? ((info == 0) || (info == (n+1))) : (info == 0);}
\DoxyCodeLine{5806     \}}
\DoxyCodeLine{5807 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{5808     \{}
\DoxyCodeLine{5809     arma\_ignore(out);}
\DoxyCodeLine{5810     arma\_ignore(out\_rcond);}
\DoxyCodeLine{5811     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{5812     arma\_ignore(KL);}
\DoxyCodeLine{5813     arma\_ignore(KU);}
\DoxyCodeLine{5814     arma\_ignore(B\_expr);}
\DoxyCodeLine{5815     arma\_ignore(equilibrate);}
\DoxyCodeLine{5816     arma\_ignore(allow\_ugly);}
\DoxyCodeLine{5817     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}solve(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{5818     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{5819     \}}
\DoxyCodeLine{5820 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{5821   \}}
\DoxyCodeLine{5822 }
\DoxyCodeLine{5823 }
\DoxyCodeLine{5824 }
\DoxyCodeLine{5826 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{5827 \textcolor{keyword}{inline}}
\DoxyCodeLine{5828 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{5829 \mbox{\hyperlink{group__auxlib_ga00042cee38300d1df5196cbb8247ab34}{auxlib::solve\_band\_refine}}(\mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\& out, \textcolor{keyword}{typename} T1::pod\_type\& out\_rcond, \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} uword KL, \textcolor{keyword}{const} uword KU, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base}}<std::complex<typename T1::pod\_type>,T1>\& B\_expr, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} equilibrate, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_ugly)}
\DoxyCodeLine{5830   \{}
\DoxyCodeLine{5831   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{5832   }
\DoxyCodeLine{5833 \textcolor{preprocessor}{  \#if defined(ARMA\_CRIPPLED\_LAPACK)}}
\DoxyCodeLine{5834     \{}
\DoxyCodeLine{5835     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}auxlib::solve\_band\_refine(): redirecting to auxlib::solve\_square\_refine() due to crippled LAPACK"{}});}
\DoxyCodeLine{5836     }
\DoxyCodeLine{5837     arma\_ignore(KL);}
\DoxyCodeLine{5838     arma\_ignore(KU);}
\DoxyCodeLine{5839     }
\DoxyCodeLine{5840     \textcolor{keywordflow}{return} \mbox{\hyperlink{group__auxlib_gab1d24ba6a7f6a7aad1b5bcf4d75bd1bf}{auxlib::solve\_square\_refine}}(out, out\_rcond, \mbox{\hyperlink{structA}{A}}, B\_expr, equilibrate, allow\_ugly);}
\DoxyCodeLine{5841     \}}
\DoxyCodeLine{5842 \textcolor{preprocessor}{  \#elif defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{5843     \{}
\DoxyCodeLine{5844     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type     T;}
\DoxyCodeLine{5845     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<T> eT;}
\DoxyCodeLine{5846     }
\DoxyCodeLine{5847     \mbox{\hyperlink{classMat}{Mat<eT>}} \mbox{\hyperlink{structB}{B}} = B\_expr.get\_ref();  \textcolor{comment}{// B is overwritten}}
\DoxyCodeLine{5848     }
\DoxyCodeLine{5849     arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.n\_rows != \mbox{\hyperlink{structB}{B}}.n\_rows), \textcolor{stringliteral}{"{}solve(): number of rows in the given matrices must be the same"{}} );}
\DoxyCodeLine{5850       }
\DoxyCodeLine{5851     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty() || \mbox{\hyperlink{structB}{B}}.is\_empty())}
\DoxyCodeLine{5852       \{}
\DoxyCodeLine{5853       out.zeros(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{5854       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{5855       \}}
\DoxyCodeLine{5856     }
\DoxyCodeLine{5857     \textcolor{comment}{// for gbsvx, matrix AB size: KL+KU+1 x N; band representation of A stored in rows 1 to KL+KU+1  (note: fortran counts from 1)}}
\DoxyCodeLine{5858     }
\DoxyCodeLine{5859     \mbox{\hyperlink{classMat}{Mat<eT>}} AB;}
\DoxyCodeLine{5860     band\_helper::compress(AB, \mbox{\hyperlink{structA}{A}}, KL, KU, \textcolor{keyword}{false});}
\DoxyCodeLine{5861     }
\DoxyCodeLine{5862     \textcolor{keyword}{const} uword N = AB.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}};}
\DoxyCodeLine{5863     }
\DoxyCodeLine{5864     arma\_debug\_assert\_blas\_size(AB,\mbox{\hyperlink{structB}{B}});}
\DoxyCodeLine{5865     }
\DoxyCodeLine{5866     out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(N, \mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{5867     }
\DoxyCodeLine{5868     \mbox{\hyperlink{classMat}{Mat<eT>}} AFB(2*KL+KU+1, N, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{5869     }
\DoxyCodeLine{5870     \textcolor{keywordtype}{char}     fact  = (equilibrate) ? \textcolor{charliteral}{'E'} : \textcolor{charliteral}{'N'}; }
\DoxyCodeLine{5871     \textcolor{keywordtype}{char}     trans = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{5872     \textcolor{keywordtype}{char}     equed = char(0);}
\DoxyCodeLine{5873     blas\_int n     = blas\_int(N);}
\DoxyCodeLine{5874     blas\_int kl    = blas\_int(KL);}
\DoxyCodeLine{5875     blas\_int ku    = blas\_int(KU);}
\DoxyCodeLine{5876     blas\_int nrhs  = blas\_int(\mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{5877     blas\_int ldab  = blas\_int(AB.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{5878     blas\_int ldafb = blas\_int(AFB.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{5879     blas\_int ldb   = blas\_int(\mbox{\hyperlink{structB}{B}}.n\_rows);}
\DoxyCodeLine{5880     blas\_int ldx   = blas\_int(N);}
\DoxyCodeLine{5881     blas\_int info  = blas\_int(0);}
\DoxyCodeLine{5882     T        rcond = T(0);}
\DoxyCodeLine{5883     }
\DoxyCodeLine{5884     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}}  IPIV(  N);}
\DoxyCodeLine{5885     \mbox{\hyperlink{classpodarray}{podarray< T>}}           R(  N);}
\DoxyCodeLine{5886     \mbox{\hyperlink{classpodarray}{podarray< T>}}           C(  N);}
\DoxyCodeLine{5887     \mbox{\hyperlink{classpodarray}{podarray< T>}}        FERR(  \mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{5888     \mbox{\hyperlink{classpodarray}{podarray< T>}}        BERR(  \mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{5889     \mbox{\hyperlink{classpodarray}{podarray<eT>}}        WORK(2*N);}
\DoxyCodeLine{5890     \mbox{\hyperlink{classpodarray}{podarray< T>}}       RWORK(  N);  \textcolor{comment}{// NOTE: according to lapack 3.6.1 docs, the size of RWORK in zgbsvx is different to RWORK in dgesvx }}
\DoxyCodeLine{5891     }
\DoxyCodeLine{5892     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::cx\_gbsvx()"{}});}
\DoxyCodeLine{5893     lapack::cx\_gbsvx}
\DoxyCodeLine{5894       (}
\DoxyCodeLine{5895       \&fact, \&trans, \&n, \&kl, \&ku, \&nrhs,}
\DoxyCodeLine{5896       AB.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldab,}
\DoxyCodeLine{5897       AFB.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldafb,}
\DoxyCodeLine{5898       IPIV.memptr(),}
\DoxyCodeLine{5899       \&equed,}
\DoxyCodeLine{5900       R.memptr(),}
\DoxyCodeLine{5901       C.memptr(),}
\DoxyCodeLine{5902       \mbox{\hyperlink{structB}{B}}.memptr(), \&ldb,}
\DoxyCodeLine{5903       out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldx,}
\DoxyCodeLine{5904       \&rcond,}
\DoxyCodeLine{5905       FERR.memptr(),}
\DoxyCodeLine{5906       BERR.memptr(),}
\DoxyCodeLine{5907       WORK.memptr(),}
\DoxyCodeLine{5908       RWORK.memptr(),}
\DoxyCodeLine{5909       \&info}
\DoxyCodeLine{5910       );}
\DoxyCodeLine{5911     }
\DoxyCodeLine{5912     out\_rcond = rcond;}
\DoxyCodeLine{5913     }
\DoxyCodeLine{5914     \textcolor{keywordflow}{return} (allow\_ugly) ? ((info == 0) || (info == (n+1))) : (info == 0);}
\DoxyCodeLine{5915     \}}
\DoxyCodeLine{5916 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{5917     \{}
\DoxyCodeLine{5918     arma\_ignore(out);}
\DoxyCodeLine{5919     arma\_ignore(out\_rcond);}
\DoxyCodeLine{5920     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{5921     arma\_ignore(KL);}
\DoxyCodeLine{5922     arma\_ignore(KU);}
\DoxyCodeLine{5923     arma\_ignore(B\_expr);}
\DoxyCodeLine{5924     arma\_ignore(equilibrate);}
\DoxyCodeLine{5925     arma\_ignore(allow\_ugly);}
\DoxyCodeLine{5926     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}solve(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{5927     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{5928     \}}
\DoxyCodeLine{5929 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{5930   \}}
\DoxyCodeLine{5931 }
\DoxyCodeLine{5932 }
\DoxyCodeLine{5933 }
\DoxyCodeLine{5935 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{5936 \textcolor{keyword}{inline}}
\DoxyCodeLine{5937 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{5938 \mbox{\hyperlink{group__auxlib_ga463326aa06a967b1dab4c17bc0a350b5}{auxlib::solve\_tridiag\_fast}}(\mbox{\hyperlink{classMat}{Mat<typename T1::pod\_type>}}\& out, \mbox{\hyperlink{classMat}{Mat<typename T1::pod\_type>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::pod\_type,T1>}}\& B\_expr)}
\DoxyCodeLine{5939   \{}
\DoxyCodeLine{5940   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{5941   }
\DoxyCodeLine{5942   \textcolor{keywordflow}{return} \mbox{\hyperlink{group__auxlib_gaf2c6a0acba990cccadd740118f7855c9}{auxlib::solve\_tridiag\_fast\_common}}(out, \mbox{\hyperlink{structA}{A}}, B\_expr);}
\DoxyCodeLine{5943   \}}
\DoxyCodeLine{5944 }
\DoxyCodeLine{5945 }
\DoxyCodeLine{5946 }
\DoxyCodeLine{5948 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{5949 \textcolor{keyword}{inline}}
\DoxyCodeLine{5950 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{5951 \mbox{\hyperlink{group__auxlib_ga463326aa06a967b1dab4c17bc0a350b5}{auxlib::solve\_tridiag\_fast}}(\mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\& out, \mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::pod\_type> >\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base}}< std::complex<typename T1::pod\_type>,T1>\& B\_expr)}
\DoxyCodeLine{5952   \{}
\DoxyCodeLine{5953   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{5954   }
\DoxyCodeLine{5955 \textcolor{preprocessor}{  \#if defined(ARMA\_CRIPPLED\_LAPACK)}}
\DoxyCodeLine{5956     \{}
\DoxyCodeLine{5957     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}auxlib::solve\_tridiag\_fast(): redirecting to auxlib::solve\_square\_fast() due to crippled LAPACK"{}});}
\DoxyCodeLine{5958     }
\DoxyCodeLine{5959     \textcolor{keywordflow}{return} \mbox{\hyperlink{group__auxlib_ga530089e89e43155f3bf6e709bbe775dd}{auxlib::solve\_square\_fast}}(out, \mbox{\hyperlink{structA}{A}}, B\_expr);}
\DoxyCodeLine{5960     \}}
\DoxyCodeLine{5961 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{5962     \{}
\DoxyCodeLine{5963     \textcolor{keywordflow}{return} \mbox{\hyperlink{group__auxlib_gaf2c6a0acba990cccadd740118f7855c9}{auxlib::solve\_tridiag\_fast\_common}}(out, \mbox{\hyperlink{structA}{A}}, B\_expr);}
\DoxyCodeLine{5964     \}}
\DoxyCodeLine{5965 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{5966   \}}
\DoxyCodeLine{5967 }
\DoxyCodeLine{5968 }
\DoxyCodeLine{5969 }
\DoxyCodeLine{5971 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{5972 \textcolor{keyword}{inline}}
\DoxyCodeLine{5973 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{5974 \mbox{\hyperlink{group__auxlib_gaf2c6a0acba990cccadd740118f7855c9}{auxlib::solve\_tridiag\_fast\_common}}(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::elem\_type,T1>}}\& B\_expr)}
\DoxyCodeLine{5975   \{}
\DoxyCodeLine{5976   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{5977   }
\DoxyCodeLine{5978 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{5979     \{}
\DoxyCodeLine{5980     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{5981     }
\DoxyCodeLine{5982     out = B\_expr.get\_ref();}
\DoxyCodeLine{5983     }
\DoxyCodeLine{5984     \textcolor{keyword}{const} uword B\_n\_rows = out.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}};}
\DoxyCodeLine{5985     \textcolor{keyword}{const} uword B\_n\_cols = out.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}};}
\DoxyCodeLine{5986     }
\DoxyCodeLine{5987     arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.n\_rows != B\_n\_rows), \textcolor{stringliteral}{"{}solve(): number of rows in the given matrices must be the same"{}} );}
\DoxyCodeLine{5988     }
\DoxyCodeLine{5989     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty() || out.\mbox{\hyperlink{group__Mat_ga3008049216e02308ff665862f451a7ff}{is\_empty}}())}
\DoxyCodeLine{5990       \{}
\DoxyCodeLine{5991       out.zeros(\mbox{\hyperlink{structA}{A}}.n\_rows, B\_n\_cols);}
\DoxyCodeLine{5992       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{5993       \}}
\DoxyCodeLine{5994     }
\DoxyCodeLine{5995     \mbox{\hyperlink{classMat}{Mat<eT>}} tridiag;}
\DoxyCodeLine{5996     band\_helper::extract\_tridiag(tridiag, \mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{5997     }
\DoxyCodeLine{5998     arma\_debug\_assert\_blas\_size(tridiag, out);}
\DoxyCodeLine{5999     }
\DoxyCodeLine{6000     blas\_int n    = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6001     blas\_int nrhs = blas\_int(B\_n\_cols);}
\DoxyCodeLine{6002     blas\_int ldb  = blas\_int(B\_n\_rows);}
\DoxyCodeLine{6003     blas\_int info = blas\_int(0);}
\DoxyCodeLine{6004     }
\DoxyCodeLine{6005     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::gtsv()"{}});}
\DoxyCodeLine{6006     lapack::gtsv<eT>(\&n, \&nrhs, tridiag.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(0), tridiag.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(1), tridiag.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(2), out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldb, \&info);}
\DoxyCodeLine{6007     }
\DoxyCodeLine{6008     \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{6009     \}}
\DoxyCodeLine{6010 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{6011     \{}
\DoxyCodeLine{6012     arma\_ignore(out);}
\DoxyCodeLine{6013     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{6014     arma\_ignore(B\_expr);}
\DoxyCodeLine{6015     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}solve(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{6016     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{6017     \}}
\DoxyCodeLine{6018 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{6019   \}}
\DoxyCodeLine{6020 }
\DoxyCodeLine{6021 }
\DoxyCodeLine{6022 }
\DoxyCodeLine{6023 \textcolor{comment}{//}}
\DoxyCodeLine{6024 \textcolor{comment}{// Schur decomposition}}
\DoxyCodeLine{6025 }
\DoxyCodeLine{6026 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{6027 \textcolor{keyword}{inline}}
\DoxyCodeLine{6028 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{6029 auxlib::schur(\mbox{\hyperlink{classMat}{Mat<eT>}}\& U, \mbox{\hyperlink{classMat}{Mat<eT>}}\& S, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<eT,T1>}}\& X, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} calc\_U)}
\DoxyCodeLine{6030   \{}
\DoxyCodeLine{6031   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{6032   }
\DoxyCodeLine{6033 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{6034     \{}
\DoxyCodeLine{6035     S = X.get\_ref();}
\DoxyCodeLine{6036     }
\DoxyCodeLine{6037     arma\_debug\_check( (S.\mbox{\hyperlink{group__Mat_ga1f860b22491beb19251642270d04d8f1}{is\_square}}() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}schur(): given matrix must be square sized"{}} );}
\DoxyCodeLine{6038     }
\DoxyCodeLine{6039     \textcolor{keywordflow}{if}(S.\mbox{\hyperlink{group__Mat_ga3008049216e02308ff665862f451a7ff}{is\_empty}}())}
\DoxyCodeLine{6040       \{}
\DoxyCodeLine{6041       U.reset();}
\DoxyCodeLine{6042       S.reset();}
\DoxyCodeLine{6043       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{6044       \}}
\DoxyCodeLine{6045     }
\DoxyCodeLine{6046     arma\_debug\_assert\_blas\_size(S);}
\DoxyCodeLine{6047     }
\DoxyCodeLine{6048     \textcolor{keyword}{const} uword S\_n\_rows = S.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}};}
\DoxyCodeLine{6049     }
\DoxyCodeLine{6050     \textcolor{keywordflow}{if}(calc\_U) \{ U.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(S\_n\_rows, S\_n\_rows); \} \textcolor{keywordflow}{else} \{ U.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(1,1); \}}
\DoxyCodeLine{6051     }
\DoxyCodeLine{6052     \textcolor{keywordtype}{char}      jobvs  = calc\_U ? \textcolor{charliteral}{'V'} : \textcolor{charliteral}{'N'};}
\DoxyCodeLine{6053     \textcolor{keywordtype}{char}      sort   = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{6054     \textcolor{keywordtype}{void}*     select = 0;}
\DoxyCodeLine{6055     blas\_int  n      = blas\_int(S\_n\_rows);}
\DoxyCodeLine{6056     blas\_int  sdim   = 0;}
\DoxyCodeLine{6057     blas\_int  ldvs   = calc\_U ? n : blas\_int(1);}
\DoxyCodeLine{6058     blas\_int  lwork  = 64*n;  \textcolor{comment}{// lwork\_min = (std::max)(blas\_int(1), 3*n)}}
\DoxyCodeLine{6059     blas\_int  info   = 0;}
\DoxyCodeLine{6060     }
\DoxyCodeLine{6061     \mbox{\hyperlink{classpodarray}{podarray<eT>}} wr(S\_n\_rows);}
\DoxyCodeLine{6062     \mbox{\hyperlink{classpodarray}{podarray<eT>}} wi(S\_n\_rows);}
\DoxyCodeLine{6063     }
\DoxyCodeLine{6064     \mbox{\hyperlink{classpodarray}{podarray<eT>}}        work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork) );}
\DoxyCodeLine{6065     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} bwork(S\_n\_rows);}
\DoxyCodeLine{6066     }
\DoxyCodeLine{6067     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::gees()"{}});}
\DoxyCodeLine{6068     lapack::gees(\&jobvs, \&sort, select, \&n, S.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&n, \&sdim, wr.memptr(), wi.memptr(), U.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldvs, work.memptr(), \&lwork, bwork.memptr(), \&info);}
\DoxyCodeLine{6069     }
\DoxyCodeLine{6070     \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{6071     \}}
\DoxyCodeLine{6072 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{6073     \{}
\DoxyCodeLine{6074     arma\_ignore(U);}
\DoxyCodeLine{6075     arma\_ignore(S);}
\DoxyCodeLine{6076     arma\_ignore(X);}
\DoxyCodeLine{6077     arma\_ignore(calc\_U);}
\DoxyCodeLine{6078     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}schur(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{6079     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{6080     \}}
\DoxyCodeLine{6081 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{6082   \}}
\DoxyCodeLine{6083 }
\DoxyCodeLine{6084 }
\DoxyCodeLine{6085 }
\DoxyCodeLine{6086 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{6087 \textcolor{keyword}{inline}}
\DoxyCodeLine{6088 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{6089 auxlib::schur(\mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& U, \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& S, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base}}<std::complex<T>,T1>\& X, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} calc\_U)}
\DoxyCodeLine{6090   \{}
\DoxyCodeLine{6091   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{6092   }
\DoxyCodeLine{6093   S = X.get\_ref();}
\DoxyCodeLine{6094   }
\DoxyCodeLine{6095   arma\_debug\_check( (S.\mbox{\hyperlink{group__Mat_ga1f860b22491beb19251642270d04d8f1}{is\_square}}() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}schur(): given matrix must be square sized"{}} );}
\DoxyCodeLine{6096   }
\DoxyCodeLine{6097   \textcolor{keywordflow}{return} auxlib::schur(U,S,calc\_U);}
\DoxyCodeLine{6098   \}}
\DoxyCodeLine{6099 }
\DoxyCodeLine{6100 }
\DoxyCodeLine{6101 }
\DoxyCodeLine{6102 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6103 \textcolor{keyword}{inline}}
\DoxyCodeLine{6104 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{6105 auxlib::schur(\mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& U, \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& S, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} calc\_U)}
\DoxyCodeLine{6106   \{}
\DoxyCodeLine{6107   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{6108   }
\DoxyCodeLine{6109 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{6110     \{}
\DoxyCodeLine{6111     \textcolor{keyword}{typedef} std::complex<T> eT;}
\DoxyCodeLine{6112     }
\DoxyCodeLine{6113     \textcolor{keywordflow}{if}(S.\mbox{\hyperlink{group__Mat_ga3008049216e02308ff665862f451a7ff}{is\_empty}}())}
\DoxyCodeLine{6114       \{}
\DoxyCodeLine{6115       U.reset();}
\DoxyCodeLine{6116       S.reset();}
\DoxyCodeLine{6117       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{6118       \}}
\DoxyCodeLine{6119     }
\DoxyCodeLine{6120     arma\_debug\_assert\_blas\_size(S);}
\DoxyCodeLine{6121     }
\DoxyCodeLine{6122     \textcolor{keyword}{const} uword S\_n\_rows = S.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}};}
\DoxyCodeLine{6123     }
\DoxyCodeLine{6124     \textcolor{keywordflow}{if}(calc\_U) \{ U.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(S\_n\_rows, S\_n\_rows); \} \textcolor{keywordflow}{else} \{ U.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(1,1); \}}
\DoxyCodeLine{6125     }
\DoxyCodeLine{6126     \textcolor{keywordtype}{char}      jobvs  = calc\_U ? \textcolor{charliteral}{'V'} : \textcolor{charliteral}{'N'};}
\DoxyCodeLine{6127     \textcolor{keywordtype}{char}      sort   = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{6128     \textcolor{keywordtype}{void}*     select = 0;}
\DoxyCodeLine{6129     blas\_int  n      = blas\_int(S\_n\_rows);}
\DoxyCodeLine{6130     blas\_int  sdim   = 0;}
\DoxyCodeLine{6131     blas\_int  ldvs   = calc\_U ? n : blas\_int(1);}
\DoxyCodeLine{6132     blas\_int  lwork  = 64*n;  \textcolor{comment}{// lwork\_min = (std::max)(blas\_int(1), 2*n)}}
\DoxyCodeLine{6133     blas\_int  info   = 0;}
\DoxyCodeLine{6134     }
\DoxyCodeLine{6135     \mbox{\hyperlink{classpodarray}{podarray<eT>}}           w(S\_n\_rows);}
\DoxyCodeLine{6136     \mbox{\hyperlink{classpodarray}{podarray<eT>}}        work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork) );}
\DoxyCodeLine{6137     \mbox{\hyperlink{classpodarray}{podarray< T>}}       rwork(S\_n\_rows);}
\DoxyCodeLine{6138     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} bwork(S\_n\_rows);}
\DoxyCodeLine{6139     }
\DoxyCodeLine{6140     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::cx\_gees()"{}});}
\DoxyCodeLine{6141     lapack::cx\_gees(\&jobvs, \&sort, select, \&n, S.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&n, \&sdim, w.memptr(), U.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldvs, work.memptr(), \&lwork, rwork.memptr(), bwork.memptr(), \&info);}
\DoxyCodeLine{6142     }
\DoxyCodeLine{6143     \textcolor{keywordflow}{return} (info == 0);}
\DoxyCodeLine{6144     \}}
\DoxyCodeLine{6145 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{6146     \{}
\DoxyCodeLine{6147     arma\_ignore(U);}
\DoxyCodeLine{6148     arma\_ignore(S);}
\DoxyCodeLine{6149     arma\_ignore(calc\_U);}
\DoxyCodeLine{6150     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}schur(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{6151     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{6152     \}}
\DoxyCodeLine{6153 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{6154   \}}
\DoxyCodeLine{6155 }
\DoxyCodeLine{6156 }
\DoxyCodeLine{6157 }
\DoxyCodeLine{6158 \textcolor{comment}{//}}
\DoxyCodeLine{6159 \textcolor{comment}{// solve the Sylvester equation AX + XB = C}}
\DoxyCodeLine{6160 }
\DoxyCodeLine{6161 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{6162 \textcolor{keyword}{inline}}
\DoxyCodeLine{6163 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{6164 auxlib::syl(\mbox{\hyperlink{classMat}{Mat<eT>}}\& X, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structB}{B}}, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& C)}
\DoxyCodeLine{6165   \{}
\DoxyCodeLine{6166   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{6167   }
\DoxyCodeLine{6168 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{6169     \{}
\DoxyCodeLine{6170     arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.is\_square() == \textcolor{keyword}{false}) || (\mbox{\hyperlink{structB}{B}}.is\_square() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}syl(): given matrices must be square sized"{}} );}
\DoxyCodeLine{6171       }
\DoxyCodeLine{6172     arma\_debug\_check( (C.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}} != \mbox{\hyperlink{structA}{A}}.n\_rows) || (C.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}} != \mbox{\hyperlink{structB}{B}}.n\_cols), \textcolor{stringliteral}{"{}syl(): matrices are not conformant"{}} );}
\DoxyCodeLine{6173     }
\DoxyCodeLine{6174     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty() || \mbox{\hyperlink{structB}{B}}.is\_empty() || C.\mbox{\hyperlink{group__Mat_ga3008049216e02308ff665862f451a7ff}{is\_empty}}())  \{ X.reset(); \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{6175     }
\DoxyCodeLine{6176     \mbox{\hyperlink{classMat}{Mat<eT>}} Z1, Z2, T1, T2;}
\DoxyCodeLine{6177     }
\DoxyCodeLine{6178     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} status\_sd1 = auxlib::schur(Z1, T1, \mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{6179     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} status\_sd2 = auxlib::schur(Z2, T2, \mbox{\hyperlink{structB}{B}});}
\DoxyCodeLine{6180     }
\DoxyCodeLine{6181     \textcolor{keywordflow}{if}( (status\_sd1 == \textcolor{keyword}{false}) || (status\_sd2 == \textcolor{keyword}{false}) )  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{6182     }
\DoxyCodeLine{6183     \textcolor{keywordtype}{char}     trana = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{6184     \textcolor{keywordtype}{char}     tranb = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{6185     blas\_int  isgn = +1;}
\DoxyCodeLine{6186     blas\_int     m = blas\_int(T1.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{6187     blas\_int     n = blas\_int(T2.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}});}
\DoxyCodeLine{6188     }
\DoxyCodeLine{6189     eT       scale = eT(0);}
\DoxyCodeLine{6190     blas\_int  info = 0;}
\DoxyCodeLine{6191     }
\DoxyCodeLine{6192     \mbox{\hyperlink{classMat}{Mat<eT>}} Y = trans(Z1) * C * Z2;}
\DoxyCodeLine{6193     }
\DoxyCodeLine{6194     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::trsyl()"{}});}
\DoxyCodeLine{6195     lapack::trsyl<eT>(\&trana, \&tranb, \&isgn, \&m, \&n, T1.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&m, T2.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&n, Y.memptr(), \&m, \&scale, \&info);}
\DoxyCodeLine{6196     }
\DoxyCodeLine{6197     \textcolor{keywordflow}{if}(info < 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{6198     }
\DoxyCodeLine{6199     \textcolor{comment}{//Y /= scale;}}
\DoxyCodeLine{6200     Y /= (-\/scale);}
\DoxyCodeLine{6201     }
\DoxyCodeLine{6202     X = Z1 * Y * trans(Z2);}
\DoxyCodeLine{6203     }
\DoxyCodeLine{6204     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{6205     \}}
\DoxyCodeLine{6206 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{6207     \{}
\DoxyCodeLine{6208     arma\_ignore(X);}
\DoxyCodeLine{6209     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{6210     arma\_ignore(\mbox{\hyperlink{structB}{B}});}
\DoxyCodeLine{6211     arma\_ignore(C);}
\DoxyCodeLine{6212     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}syl(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{6213     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{6214     \}}
\DoxyCodeLine{6215 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{6216   \}}
\DoxyCodeLine{6217   }
\DoxyCodeLine{6218   }
\DoxyCodeLine{6219 }
\DoxyCodeLine{6220 \textcolor{comment}{//}}
\DoxyCodeLine{6221 \textcolor{comment}{// QZ decomposition of general square real matrix pair}}
\DoxyCodeLine{6222 }
\DoxyCodeLine{6223 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{6224 \textcolor{keyword}{inline}}
\DoxyCodeLine{6225 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{6226 auxlib::qz(\mbox{\hyperlink{classMat}{Mat<T>}}\& \mbox{\hyperlink{structA}{A}}, \mbox{\hyperlink{classMat}{Mat<T>}}\& \mbox{\hyperlink{structB}{B}}, \mbox{\hyperlink{classMat}{Mat<T>}}\& vsl, \mbox{\hyperlink{classMat}{Mat<T>}}\& vsr, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<T,T1>}}\& X\_expr, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<T,T2>}}\& Y\_expr, \textcolor{keyword}{const} \textcolor{keywordtype}{char} mode)}
\DoxyCodeLine{6227   \{}
\DoxyCodeLine{6228   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{6229   }
\DoxyCodeLine{6230 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{6231     \{}
\DoxyCodeLine{6232     \mbox{\hyperlink{structA}{A}} = X\_expr.get\_ref();}
\DoxyCodeLine{6233     \mbox{\hyperlink{structB}{B}} = Y\_expr.get\_ref();}
\DoxyCodeLine{6234     }
\DoxyCodeLine{6235     arma\_debug\_check( ((\mbox{\hyperlink{structA}{A}}.is\_square() == \textcolor{keyword}{false}) || (\mbox{\hyperlink{structB}{B}}.is\_square() == \textcolor{keyword}{false})), \textcolor{stringliteral}{"{}qz(): given matrices must be square sized"{}} );}
\DoxyCodeLine{6236     }
\DoxyCodeLine{6237     arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.n\_rows != \mbox{\hyperlink{structB}{B}}.n\_rows), \textcolor{stringliteral}{"{}qz(): given matrices must have the same size"{}} );}
\DoxyCodeLine{6238     }
\DoxyCodeLine{6239     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty())}
\DoxyCodeLine{6240       \{}
\DoxyCodeLine{6241         \mbox{\hyperlink{structA}{A}}.reset();}
\DoxyCodeLine{6242         \mbox{\hyperlink{structB}{B}}.reset();}
\DoxyCodeLine{6243       vsl.reset();}
\DoxyCodeLine{6244       vsr.reset();}
\DoxyCodeLine{6245       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{6246       \}}
\DoxyCodeLine{6247     }
\DoxyCodeLine{6248     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{6249     }
\DoxyCodeLine{6250     vsl.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6251     vsr.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6252     }
\DoxyCodeLine{6253     \textcolor{keywordtype}{char}     jobvsl  = \textcolor{charliteral}{'V'};}
\DoxyCodeLine{6254     \textcolor{keywordtype}{char}     jobvsr  = \textcolor{charliteral}{'V'};}
\DoxyCodeLine{6255     \textcolor{keywordtype}{char}     eigsort = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{6256     \textcolor{keywordtype}{void}*    selctg  = 0;}
\DoxyCodeLine{6257     blas\_int N       = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6258     blas\_int sdim    = 0;}
\DoxyCodeLine{6259     blas\_int lwork   = 64*N+16;  \textcolor{comment}{// lwork\_min = (std::max)(blas\_int(1),8*N+16)}}
\DoxyCodeLine{6260     blas\_int info    = 0;}
\DoxyCodeLine{6261     }
\DoxyCodeLine{6262          \textcolor{keywordflow}{if}(mode == \textcolor{charliteral}{'l'})  \{ eigsort = \textcolor{charliteral}{'S'}; selctg = qz\_helper::ptr\_cast(\&(qz\_helper::select\_lhp<T>)); \}}
\DoxyCodeLine{6263     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(mode == \textcolor{charliteral}{'r'})  \{ eigsort = \textcolor{charliteral}{'S'}; selctg = qz\_helper::ptr\_cast(\&(qz\_helper::select\_rhp<T>)); \}}
\DoxyCodeLine{6264     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(mode == \textcolor{charliteral}{'i'})  \{ eigsort = \textcolor{charliteral}{'S'}; selctg = qz\_helper::ptr\_cast(\&(qz\_helper::select\_iuc<T>)); \}}
\DoxyCodeLine{6265     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(mode == \textcolor{charliteral}{'o'})  \{ eigsort = \textcolor{charliteral}{'S'}; selctg = qz\_helper::ptr\_cast(\&(qz\_helper::select\_ouc<T>)); \}}
\DoxyCodeLine{6266     }
\DoxyCodeLine{6267     \mbox{\hyperlink{classpodarray}{podarray<T>}} alphar(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6268     \mbox{\hyperlink{classpodarray}{podarray<T>}} alphai(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6269     \mbox{\hyperlink{classpodarray}{podarray<T>}}   beta(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6270     }
\DoxyCodeLine{6271     \mbox{\hyperlink{classpodarray}{podarray<T>}}         work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork) );}
\DoxyCodeLine{6272     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} bwork( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(N)     );}
\DoxyCodeLine{6273     }
\DoxyCodeLine{6274     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::gges()"{}});}
\DoxyCodeLine{6275     }
\DoxyCodeLine{6276     lapack::gges}
\DoxyCodeLine{6277       (}
\DoxyCodeLine{6278       \&jobvsl, \&jobvsr, \&eigsort, selctg, \&N,}
\DoxyCodeLine{6279       \mbox{\hyperlink{structA}{A}}.memptr(), \&N, \mbox{\hyperlink{structB}{B}}.memptr(), \&N, \&sdim,}
\DoxyCodeLine{6280       alphar.memptr(), alphai.memptr(), beta.memptr(),}
\DoxyCodeLine{6281       vsl.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&N, vsr.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&N,}
\DoxyCodeLine{6282       work.memptr(), \&lwork, bwork.memptr(),}
\DoxyCodeLine{6283       \&info}
\DoxyCodeLine{6284       );}
\DoxyCodeLine{6285     }
\DoxyCodeLine{6286     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{6287     }
\DoxyCodeLine{6288     op\_strans::apply\_mat\_inplace(vsl);}
\DoxyCodeLine{6289     }
\DoxyCodeLine{6290     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{6291     \}}
\DoxyCodeLine{6292 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{6293     \{}
\DoxyCodeLine{6294     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{6295     arma\_ignore(\mbox{\hyperlink{structB}{B}});}
\DoxyCodeLine{6296     arma\_ignore(vsl);}
\DoxyCodeLine{6297     arma\_ignore(vsr);}
\DoxyCodeLine{6298     arma\_ignore(X\_expr);}
\DoxyCodeLine{6299     arma\_ignore(Y\_expr);}
\DoxyCodeLine{6300     arma\_ignore(mode);}
\DoxyCodeLine{6301     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}qz(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{6302     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{6303     \}}
\DoxyCodeLine{6304 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{6305   \}}
\DoxyCodeLine{6306 }
\DoxyCodeLine{6307 }
\DoxyCodeLine{6308 }
\DoxyCodeLine{6309 \textcolor{comment}{//}}
\DoxyCodeLine{6310 \textcolor{comment}{// QZ decomposition of general square complex matrix pair}}
\DoxyCodeLine{6311 }
\DoxyCodeLine{6312 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{6313 \textcolor{keyword}{inline}}
\DoxyCodeLine{6314 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{6315 auxlib::qz(\mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& \mbox{\hyperlink{structA}{A}}, \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& \mbox{\hyperlink{structB}{B}}, \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& vsl, \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& vsr, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base}}< std::complex<T>, T1 >\& X\_expr, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base}}< std::complex<T>, T2 >\& Y\_expr, \textcolor{keyword}{const} \textcolor{keywordtype}{char} mode)}
\DoxyCodeLine{6316   \{}
\DoxyCodeLine{6317   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{6318   }
\DoxyCodeLine{6319 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{6320     \{}
\DoxyCodeLine{6321     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<T> eT;}
\DoxyCodeLine{6322     }
\DoxyCodeLine{6323     \mbox{\hyperlink{structA}{A}} = X\_expr.get\_ref();}
\DoxyCodeLine{6324     \mbox{\hyperlink{structB}{B}} = Y\_expr.get\_ref();}
\DoxyCodeLine{6325     }
\DoxyCodeLine{6326     arma\_debug\_check( ((\mbox{\hyperlink{structA}{A}}.is\_square() == \textcolor{keyword}{false}) || (\mbox{\hyperlink{structB}{B}}.is\_square() == \textcolor{keyword}{false})), \textcolor{stringliteral}{"{}qz(): given matrices must be square sized"{}} );}
\DoxyCodeLine{6327     }
\DoxyCodeLine{6328     arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.n\_rows != \mbox{\hyperlink{structB}{B}}.n\_rows), \textcolor{stringliteral}{"{}qz(): given matrices must have the same size"{}} );}
\DoxyCodeLine{6329     }
\DoxyCodeLine{6330     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty())}
\DoxyCodeLine{6331       \{}
\DoxyCodeLine{6332         \mbox{\hyperlink{structA}{A}}.reset();}
\DoxyCodeLine{6333         \mbox{\hyperlink{structB}{B}}.reset();}
\DoxyCodeLine{6334       vsl.reset();}
\DoxyCodeLine{6335       vsr.reset();}
\DoxyCodeLine{6336       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{6337       \}}
\DoxyCodeLine{6338     }
\DoxyCodeLine{6339     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{6340     }
\DoxyCodeLine{6341     vsl.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6342     vsr.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6343     }
\DoxyCodeLine{6344     \textcolor{keywordtype}{char}     jobvsl  = \textcolor{charliteral}{'V'};}
\DoxyCodeLine{6345     \textcolor{keywordtype}{char}     jobvsr  = \textcolor{charliteral}{'V'};}
\DoxyCodeLine{6346     \textcolor{keywordtype}{char}     eigsort = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{6347     \textcolor{keywordtype}{void}*    selctg  = 0;}
\DoxyCodeLine{6348     blas\_int N       = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6349     blas\_int sdim    = 0;}
\DoxyCodeLine{6350     blas\_int lwork   = 64*N;  \textcolor{comment}{// lwork\_min = (std::max)(blas\_int(1),2*N)}}
\DoxyCodeLine{6351     blas\_int info    = 0;}
\DoxyCodeLine{6352     }
\DoxyCodeLine{6353          \textcolor{keywordflow}{if}(mode == \textcolor{charliteral}{'l'})  \{ eigsort = \textcolor{charliteral}{'S'}; selctg = qz\_helper::ptr\_cast(\&(qz\_helper::cx\_select\_lhp<T>)); \}}
\DoxyCodeLine{6354     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(mode == \textcolor{charliteral}{'r'})  \{ eigsort = \textcolor{charliteral}{'S'}; selctg = qz\_helper::ptr\_cast(\&(qz\_helper::cx\_select\_rhp<T>)); \}}
\DoxyCodeLine{6355     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(mode == \textcolor{charliteral}{'i'})  \{ eigsort = \textcolor{charliteral}{'S'}; selctg = qz\_helper::ptr\_cast(\&(qz\_helper::cx\_select\_iuc<T>)); \}}
\DoxyCodeLine{6356     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(mode == \textcolor{charliteral}{'o'})  \{ eigsort = \textcolor{charliteral}{'S'}; selctg = qz\_helper::ptr\_cast(\&(qz\_helper::cx\_select\_ouc<T>)); \}}
\DoxyCodeLine{6357     }
\DoxyCodeLine{6358     \mbox{\hyperlink{classpodarray}{podarray<eT>}} alpha(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6359     \mbox{\hyperlink{classpodarray}{podarray<eT>}}  beta(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6360     }
\DoxyCodeLine{6361     \mbox{\hyperlink{classpodarray}{podarray<eT>}}        work( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(lwork) );}
\DoxyCodeLine{6362     \mbox{\hyperlink{classpodarray}{podarray< T>}}       rwork( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(8*N)   );}
\DoxyCodeLine{6363     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} bwork( \textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(N)     );}
\DoxyCodeLine{6364     }
\DoxyCodeLine{6365     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::cx\_gges()"{}});}
\DoxyCodeLine{6366     }
\DoxyCodeLine{6367     lapack::cx\_gges}
\DoxyCodeLine{6368       (}
\DoxyCodeLine{6369       \&jobvsl, \&jobvsr, \&eigsort, selctg, \&N,}
\DoxyCodeLine{6370       \mbox{\hyperlink{structA}{A}}.memptr(), \&N, \mbox{\hyperlink{structB}{B}}.memptr(), \&N, \&sdim,}
\DoxyCodeLine{6371       alpha.memptr(), beta.memptr(),}
\DoxyCodeLine{6372       vsl.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&N, vsr.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&N,}
\DoxyCodeLine{6373       work.memptr(), \&lwork, rwork.memptr(), bwork.memptr(),}
\DoxyCodeLine{6374       \&info}
\DoxyCodeLine{6375       );}
\DoxyCodeLine{6376     }
\DoxyCodeLine{6377     \textcolor{keywordflow}{if}(info != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{6378     }
\DoxyCodeLine{6379     op\_htrans::apply\_mat\_inplace(vsl);}
\DoxyCodeLine{6380     }
\DoxyCodeLine{6381     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{6382     \}}
\DoxyCodeLine{6383 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{6384     \{}
\DoxyCodeLine{6385     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{6386     arma\_ignore(\mbox{\hyperlink{structB}{B}});}
\DoxyCodeLine{6387     arma\_ignore(vsl);}
\DoxyCodeLine{6388     arma\_ignore(vsr);}
\DoxyCodeLine{6389     arma\_ignore(X\_expr);}
\DoxyCodeLine{6390     arma\_ignore(Y\_expr);}
\DoxyCodeLine{6391     arma\_ignore(mode);}
\DoxyCodeLine{6392     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}qz(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{6393     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{6394     \}}
\DoxyCodeLine{6395 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{6396   \}}
\DoxyCodeLine{6397 }
\DoxyCodeLine{6398 }
\DoxyCodeLine{6399 }
\DoxyCodeLine{6400 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{6401 \textcolor{keyword}{inline}}
\DoxyCodeLine{6402 eT}
\DoxyCodeLine{6403 auxlib::rcond(\mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}})}
\DoxyCodeLine{6404   \{}
\DoxyCodeLine{6405 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{6406     \{}
\DoxyCodeLine{6407     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{6408     }
\DoxyCodeLine{6409     \textcolor{keywordtype}{char}     norm\_id  = \textcolor{charliteral}{'1'};}
\DoxyCodeLine{6410     blas\_int m        = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6411     blas\_int n        = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);  \textcolor{comment}{// assuming square matrix}}
\DoxyCodeLine{6412     blas\_int lda      = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6413     eT       norm\_val = eT(0);}
\DoxyCodeLine{6414     eT       rcond    = eT(0);}
\DoxyCodeLine{6415     blas\_int info     = blas\_int(0);}
\DoxyCodeLine{6416     }
\DoxyCodeLine{6417     \mbox{\hyperlink{classpodarray}{podarray<eT>}}        work(4*\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6418     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} iwork(  \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6419     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} ipiv( (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_cols) );}
\DoxyCodeLine{6420     }
\DoxyCodeLine{6421     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::lange()"{}});}
\DoxyCodeLine{6422     norm\_val = lapack::lange(\&norm\_id, \&m, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, work.memptr());}
\DoxyCodeLine{6423     }
\DoxyCodeLine{6424     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::getrf()"{}});}
\DoxyCodeLine{6425     lapack::getrf(\&m, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, ipiv.memptr(), \&info);}
\DoxyCodeLine{6426     }
\DoxyCodeLine{6427     \textcolor{keywordflow}{if}(info != blas\_int(0))  \{ \textcolor{keywordflow}{return} eT(0); \}}
\DoxyCodeLine{6428     }
\DoxyCodeLine{6429     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::gecon()"{}});}
\DoxyCodeLine{6430     lapack::gecon(\&norm\_id, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, \&norm\_val, \&rcond, work.memptr(), iwork.memptr(), \&info);}
\DoxyCodeLine{6431     }
\DoxyCodeLine{6432     \textcolor{keywordflow}{if}(info != blas\_int(0))  \{ \textcolor{keywordflow}{return} eT(0); \}}
\DoxyCodeLine{6433     }
\DoxyCodeLine{6434     \textcolor{keywordflow}{return} rcond;}
\DoxyCodeLine{6435     \}}
\DoxyCodeLine{6436 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{6437     \{}
\DoxyCodeLine{6438     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{6439     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}rcond(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{6440     \textcolor{keywordflow}{return} eT(0);}
\DoxyCodeLine{6441     \}}
\DoxyCodeLine{6442 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{6443   \}}
\DoxyCodeLine{6444 }
\DoxyCodeLine{6445 }
\DoxyCodeLine{6446 }
\DoxyCodeLine{6447 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6448 \textcolor{keyword}{inline}}
\DoxyCodeLine{6449 T}
\DoxyCodeLine{6450 auxlib::rcond(\mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& \mbox{\hyperlink{structA}{A}})}
\DoxyCodeLine{6451   \{}
\DoxyCodeLine{6452 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{6453     \{}
\DoxyCodeLine{6454     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<T> eT;}
\DoxyCodeLine{6455     }
\DoxyCodeLine{6456     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{6457     }
\DoxyCodeLine{6458     \textcolor{keywordtype}{char}     norm\_id  = \textcolor{charliteral}{'1'};}
\DoxyCodeLine{6459     blas\_int m        = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6460     blas\_int n        = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);  \textcolor{comment}{// assuming square matrix}}
\DoxyCodeLine{6461     blas\_int lda      = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6462     T        norm\_val = T(0);}
\DoxyCodeLine{6463     T        rcond    = T(0);}
\DoxyCodeLine{6464     blas\_int info     = blas\_int(0);}
\DoxyCodeLine{6465     }
\DoxyCodeLine{6466     \mbox{\hyperlink{classpodarray}{podarray< T>}}        junk(1);}
\DoxyCodeLine{6467     \mbox{\hyperlink{classpodarray}{podarray<eT>}}        work(2*\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6468     \mbox{\hyperlink{classpodarray}{podarray< T>}}       rwork(2*\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6469     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} ipiv( (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_cols) );}
\DoxyCodeLine{6470     }
\DoxyCodeLine{6471     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::lange()"{}});}
\DoxyCodeLine{6472     norm\_val = lapack::lange(\&norm\_id, \&m, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, junk.memptr());}
\DoxyCodeLine{6473     }
\DoxyCodeLine{6474     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::getrf()"{}});}
\DoxyCodeLine{6475     lapack::getrf(\&m, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, ipiv.memptr(), \&info);}
\DoxyCodeLine{6476     }
\DoxyCodeLine{6477     \textcolor{keywordflow}{if}(info != blas\_int(0))  \{ \textcolor{keywordflow}{return} T(0); \}}
\DoxyCodeLine{6478     }
\DoxyCodeLine{6479     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::cx\_gecon()"{}});}
\DoxyCodeLine{6480     lapack::cx\_gecon(\&norm\_id, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, \&norm\_val, \&rcond, work.memptr(), rwork.memptr(), \&info);}
\DoxyCodeLine{6481     }
\DoxyCodeLine{6482     \textcolor{keywordflow}{if}(info != blas\_int(0))  \{ \textcolor{keywordflow}{return} T(0); \}}
\DoxyCodeLine{6483     }
\DoxyCodeLine{6484     \textcolor{keywordflow}{return} rcond;}
\DoxyCodeLine{6485     \}}
\DoxyCodeLine{6486 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{6487     \{}
\DoxyCodeLine{6488     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{6489     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}rcond(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{6490     \textcolor{keywordflow}{return} T(0);}
\DoxyCodeLine{6491     \}}
\DoxyCodeLine{6492 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{6493   \}}
\DoxyCodeLine{6494 }
\DoxyCodeLine{6495 }
\DoxyCodeLine{6496 }
\DoxyCodeLine{6497 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{6498 \textcolor{keyword}{inline}}
\DoxyCodeLine{6499 eT}
\DoxyCodeLine{6500 auxlib::rcond\_sympd(\mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keywordtype}{bool}\& calc\_ok)}
\DoxyCodeLine{6501   \{}
\DoxyCodeLine{6502 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{6503     \{}
\DoxyCodeLine{6504     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{6505     }
\DoxyCodeLine{6506     calc\_ok = \textcolor{keyword}{false};}
\DoxyCodeLine{6507     }
\DoxyCodeLine{6508     \textcolor{keywordtype}{char}     norm\_id  = \textcolor{charliteral}{'1'};}
\DoxyCodeLine{6509     \textcolor{keywordtype}{char}     uplo     = \textcolor{charliteral}{'L'};}
\DoxyCodeLine{6510     blas\_int n        = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);  \textcolor{comment}{// assuming square matrix}}
\DoxyCodeLine{6511     blas\_int lda      = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6512     eT       norm\_val = eT(0);}
\DoxyCodeLine{6513     eT       rcond    = eT(0);}
\DoxyCodeLine{6514     blas\_int info     = blas\_int(0);}
\DoxyCodeLine{6515     }
\DoxyCodeLine{6516     \mbox{\hyperlink{classpodarray}{podarray<eT>}}        work(3*\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6517     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} iwork(  \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6518     }
\DoxyCodeLine{6519     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::lansy()"{}});}
\DoxyCodeLine{6520     norm\_val = lapack::lansy(\&norm\_id, \&uplo, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, work.memptr());}
\DoxyCodeLine{6521     }
\DoxyCodeLine{6522     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::potrf()"{}});}
\DoxyCodeLine{6523     lapack::potrf(\&uplo, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, \&info);}
\DoxyCodeLine{6524     }
\DoxyCodeLine{6525     \textcolor{keywordflow}{if}(info != blas\_int(0))  \{ \textcolor{keywordflow}{return} eT(0); \}}
\DoxyCodeLine{6526     }
\DoxyCodeLine{6527     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::pocon()"{}});}
\DoxyCodeLine{6528     lapack::pocon(\&uplo, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, \&norm\_val, \&rcond, work.memptr(), iwork.memptr(), \&info);}
\DoxyCodeLine{6529     }
\DoxyCodeLine{6530     \textcolor{keywordflow}{if}(info != blas\_int(0))  \{ \textcolor{keywordflow}{return} eT(0); \}}
\DoxyCodeLine{6531     }
\DoxyCodeLine{6532     calc\_ok = \textcolor{keyword}{true};}
\DoxyCodeLine{6533     }
\DoxyCodeLine{6534     \textcolor{keywordflow}{return} rcond;}
\DoxyCodeLine{6535     \}}
\DoxyCodeLine{6536 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{6537     \{}
\DoxyCodeLine{6538     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{6539     calc\_ok = \textcolor{keyword}{false};}
\DoxyCodeLine{6540     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}rcond(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{6541     \textcolor{keywordflow}{return} eT(0);}
\DoxyCodeLine{6542     \}}
\DoxyCodeLine{6543 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{6544   \}}
\DoxyCodeLine{6545 }
\DoxyCodeLine{6546 }
\DoxyCodeLine{6547 }
\DoxyCodeLine{6548 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6549 \textcolor{keyword}{inline}}
\DoxyCodeLine{6550 T}
\DoxyCodeLine{6551 auxlib::rcond\_sympd(\mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& \mbox{\hyperlink{structA}{A}}, \textcolor{keywordtype}{bool}\& calc\_ok)}
\DoxyCodeLine{6552   \{}
\DoxyCodeLine{6553 \textcolor{preprocessor}{  \#if defined(ARMA\_CRIPPLED\_LAPACK)}}
\DoxyCodeLine{6554     \{}
\DoxyCodeLine{6555     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}auxlib::rcond\_sympd(): redirecting to auxlib::rcond() due to crippled LAPACK"{}});}
\DoxyCodeLine{6556     }
\DoxyCodeLine{6557     calc\_ok = \textcolor{keyword}{true};}
\DoxyCodeLine{6558     }
\DoxyCodeLine{6559     \textcolor{keywordflow}{return} auxlib::rcond(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{6560     \}}
\DoxyCodeLine{6561 \textcolor{preprocessor}{  \#elif defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{6562     \{}
\DoxyCodeLine{6563     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<T> eT;}
\DoxyCodeLine{6564     }
\DoxyCodeLine{6565     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{6566     }
\DoxyCodeLine{6567     calc\_ok = \textcolor{keyword}{false};}
\DoxyCodeLine{6568     }
\DoxyCodeLine{6569     \textcolor{keywordtype}{char}     norm\_id  = \textcolor{charliteral}{'1'};}
\DoxyCodeLine{6570     \textcolor{keywordtype}{char}     uplo     = \textcolor{charliteral}{'L'};}
\DoxyCodeLine{6571     blas\_int n        = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);  \textcolor{comment}{// assuming square matrix}}
\DoxyCodeLine{6572     blas\_int lda      = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6573     T        norm\_val = T(0);}
\DoxyCodeLine{6574     T        rcond    = T(0);}
\DoxyCodeLine{6575     blas\_int info     = blas\_int(0);}
\DoxyCodeLine{6576     }
\DoxyCodeLine{6577     \mbox{\hyperlink{classpodarray}{podarray<eT>}}  work(2*\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6578     \mbox{\hyperlink{classpodarray}{podarray< T>}} rwork(  \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6579     }
\DoxyCodeLine{6580     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::lanhe()"{}});}
\DoxyCodeLine{6581     norm\_val = lapack::lanhe(\&norm\_id, \&uplo, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, rwork.memptr());}
\DoxyCodeLine{6582     }
\DoxyCodeLine{6583     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::potrf()"{}});}
\DoxyCodeLine{6584     lapack::potrf(\&uplo, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, \&info);}
\DoxyCodeLine{6585     }
\DoxyCodeLine{6586     \textcolor{keywordflow}{if}(info != blas\_int(0))  \{ \textcolor{keywordflow}{return} T(0); \}}
\DoxyCodeLine{6587     }
\DoxyCodeLine{6588     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::cx\_pocon()"{}});}
\DoxyCodeLine{6589     lapack::cx\_pocon(\&uplo, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, \&norm\_val, \&rcond, work.memptr(), rwork.memptr(), \&info);}
\DoxyCodeLine{6590     }
\DoxyCodeLine{6591     \textcolor{keywordflow}{if}(info != blas\_int(0))  \{ \textcolor{keywordflow}{return} T(0); \}}
\DoxyCodeLine{6592     }
\DoxyCodeLine{6593     calc\_ok = \textcolor{keyword}{true};}
\DoxyCodeLine{6594     }
\DoxyCodeLine{6595     \textcolor{keywordflow}{return} rcond;}
\DoxyCodeLine{6596     \}}
\DoxyCodeLine{6597 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{6598     \{}
\DoxyCodeLine{6599     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{6600     calc\_ok = \textcolor{keyword}{false};}
\DoxyCodeLine{6601     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}rcond(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{6602     \textcolor{keywordflow}{return} T(0);}
\DoxyCodeLine{6603     \}}
\DoxyCodeLine{6604 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{6605   \}}
\DoxyCodeLine{6606 }
\DoxyCodeLine{6607 }
\DoxyCodeLine{6608 }
\DoxyCodeLine{6609 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{6610 \textcolor{keyword}{inline}}
\DoxyCodeLine{6611 eT}
\DoxyCodeLine{6612 auxlib::rcond\_trimat(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} uword layout)}
\DoxyCodeLine{6613   \{}
\DoxyCodeLine{6614 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{6615     \{}
\DoxyCodeLine{6616     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{6617     }
\DoxyCodeLine{6618     \textcolor{keywordtype}{char}     norm\_id = \textcolor{charliteral}{'1'};}
\DoxyCodeLine{6619     \textcolor{keywordtype}{char}     uplo    = (layout == 0) ? \textcolor{charliteral}{'U'} : \textcolor{charliteral}{'L'};}
\DoxyCodeLine{6620     \textcolor{keywordtype}{char}     diag    = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{6621     blas\_int n       = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);  \textcolor{comment}{// assuming square matrix}}
\DoxyCodeLine{6622     eT       rcond   = eT(0);}
\DoxyCodeLine{6623     blas\_int info    = blas\_int(0);}
\DoxyCodeLine{6624     }
\DoxyCodeLine{6625     \mbox{\hyperlink{classpodarray}{podarray<eT>}}        work(3*\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6626     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} iwork(  \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6627     }
\DoxyCodeLine{6628     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::trcon()"{}});}
\DoxyCodeLine{6629     lapack::trcon(\&norm\_id, \&uplo, \&diag, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&n, \&rcond, work.memptr(), iwork.memptr(), \&info);}
\DoxyCodeLine{6630     }
\DoxyCodeLine{6631     \textcolor{keywordflow}{if}(info != blas\_int(0))  \{ \textcolor{keywordflow}{return} eT(0); \}}
\DoxyCodeLine{6632     }
\DoxyCodeLine{6633     \textcolor{keywordflow}{return} rcond;}
\DoxyCodeLine{6634     \}}
\DoxyCodeLine{6635 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{6636     \{}
\DoxyCodeLine{6637     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{6638     arma\_ignore(layout);}
\DoxyCodeLine{6639     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}rcond(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{6640     \textcolor{keywordflow}{return} eT(0);}
\DoxyCodeLine{6641     \}}
\DoxyCodeLine{6642 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{6643   \}}
\DoxyCodeLine{6644 }
\DoxyCodeLine{6645 }
\DoxyCodeLine{6646 }
\DoxyCodeLine{6647 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6648 \textcolor{keyword}{inline}}
\DoxyCodeLine{6649 T}
\DoxyCodeLine{6650 auxlib::rcond\_trimat(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} uword layout)}
\DoxyCodeLine{6651   \{}
\DoxyCodeLine{6652 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{6653     \{}
\DoxyCodeLine{6654     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<T> eT;}
\DoxyCodeLine{6655     }
\DoxyCodeLine{6656     arma\_debug\_assert\_blas\_size(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{6657     }
\DoxyCodeLine{6658     \textcolor{keywordtype}{char}     norm\_id = \textcolor{charliteral}{'1'};}
\DoxyCodeLine{6659     \textcolor{keywordtype}{char}     uplo    = (layout == 0) ? \textcolor{charliteral}{'U'} : \textcolor{charliteral}{'L'};}
\DoxyCodeLine{6660     \textcolor{keywordtype}{char}     diag    = \textcolor{charliteral}{'N'};}
\DoxyCodeLine{6661     blas\_int n       = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);  \textcolor{comment}{// assuming square matrix}}
\DoxyCodeLine{6662     T        rcond   = T(0);}
\DoxyCodeLine{6663     blas\_int info    = blas\_int(0);}
\DoxyCodeLine{6664     }
\DoxyCodeLine{6665     \mbox{\hyperlink{classpodarray}{podarray<eT>}}  work(2*\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6666     \mbox{\hyperlink{classpodarray}{podarray< T>}} rwork(  \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6667     }
\DoxyCodeLine{6668     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::cx\_trcon()"{}});}
\DoxyCodeLine{6669     lapack::cx\_trcon(\&norm\_id, \&uplo, \&diag, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&n, \&rcond, work.memptr(), rwork.memptr(), \&info);}
\DoxyCodeLine{6670     }
\DoxyCodeLine{6671     \textcolor{keywordflow}{if}(info != blas\_int(0))  \{ \textcolor{keywordflow}{return} T(0); \}}
\DoxyCodeLine{6672     }
\DoxyCodeLine{6673     \textcolor{keywordflow}{return} rcond;}
\DoxyCodeLine{6674     \}}
\DoxyCodeLine{6675 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{6676     \{}
\DoxyCodeLine{6677     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{6678     arma\_ignore(layout);}
\DoxyCodeLine{6679     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}rcond(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{6680     \textcolor{keywordflow}{return} T(0);}
\DoxyCodeLine{6681     \}}
\DoxyCodeLine{6682 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{6683   \}}
\DoxyCodeLine{6684 }
\DoxyCodeLine{6685 }
\DoxyCodeLine{6686 }
\DoxyCodeLine{6687 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{6688 \textcolor{keyword}{inline}}
\DoxyCodeLine{6689 eT}
\DoxyCodeLine{6690 auxlib::lu\_rcond(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} eT norm\_val)}
\DoxyCodeLine{6691   \{}
\DoxyCodeLine{6692 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{6693     \{}
\DoxyCodeLine{6694     \textcolor{keywordtype}{char}     norm\_id = \textcolor{charliteral}{'1'};}
\DoxyCodeLine{6695     blas\_int n       = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);  \textcolor{comment}{// assuming square matrix}}
\DoxyCodeLine{6696     blas\_int lda     = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6697     eT       rcond   = eT(0);}
\DoxyCodeLine{6698     blas\_int info    = blas\_int(0);}
\DoxyCodeLine{6699     }
\DoxyCodeLine{6700     \mbox{\hyperlink{classpodarray}{podarray<eT>}}        work(4*\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6701     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} iwork(  \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6702     }
\DoxyCodeLine{6703     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::gecon()"{}});}
\DoxyCodeLine{6704     lapack::gecon(\&norm\_id, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, \&norm\_val, \&rcond, work.memptr(), iwork.memptr(), \&info);}
\DoxyCodeLine{6705     }
\DoxyCodeLine{6706     \textcolor{keywordflow}{if}(info != blas\_int(0))  \{ \textcolor{keywordflow}{return} eT(0); \}}
\DoxyCodeLine{6707     }
\DoxyCodeLine{6708     \textcolor{keywordflow}{return} rcond;}
\DoxyCodeLine{6709     \}}
\DoxyCodeLine{6710 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{6711     \{}
\DoxyCodeLine{6712     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{6713     arma\_ignore(norm\_val);}
\DoxyCodeLine{6714     \textcolor{keywordflow}{return} eT(0);}
\DoxyCodeLine{6715     \}}
\DoxyCodeLine{6716 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{6717   \}}
\DoxyCodeLine{6718 }
\DoxyCodeLine{6719 }
\DoxyCodeLine{6720 }
\DoxyCodeLine{6721 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6722 \textcolor{keyword}{inline}}
\DoxyCodeLine{6723 T}
\DoxyCodeLine{6724 auxlib::lu\_rcond(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} T norm\_val)}
\DoxyCodeLine{6725   \{}
\DoxyCodeLine{6726 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{6727     \{}
\DoxyCodeLine{6728     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<T> eT;}
\DoxyCodeLine{6729     }
\DoxyCodeLine{6730     \textcolor{keywordtype}{char}     norm\_id = \textcolor{charliteral}{'1'};}
\DoxyCodeLine{6731     blas\_int n       = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);  \textcolor{comment}{// assuming square matrix}}
\DoxyCodeLine{6732     blas\_int lda     = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6733     T        rcond   = T(0);}
\DoxyCodeLine{6734     blas\_int info    = blas\_int(0);}
\DoxyCodeLine{6735     }
\DoxyCodeLine{6736     \mbox{\hyperlink{classpodarray}{podarray<eT>}}  work(2*\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6737     \mbox{\hyperlink{classpodarray}{podarray< T>}} rwork(2*\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6738     }
\DoxyCodeLine{6739     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::cx\_gecon()"{}});}
\DoxyCodeLine{6740     lapack::cx\_gecon(\&norm\_id, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&lda, \&norm\_val, \&rcond, work.memptr(), rwork.memptr(), \&info);}
\DoxyCodeLine{6741     }
\DoxyCodeLine{6742     \textcolor{keywordflow}{if}(info != blas\_int(0))  \{ \textcolor{keywordflow}{return} T(0); \}}
\DoxyCodeLine{6743     }
\DoxyCodeLine{6744     \textcolor{keywordflow}{return} rcond;}
\DoxyCodeLine{6745     \}}
\DoxyCodeLine{6746 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{6747     \{}
\DoxyCodeLine{6748     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{6749     arma\_ignore(norm\_val);}
\DoxyCodeLine{6750     \textcolor{keywordflow}{return} T(0);}
\DoxyCodeLine{6751     \}}
\DoxyCodeLine{6752 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{6753   \}}
\DoxyCodeLine{6754 }
\DoxyCodeLine{6755 }
\DoxyCodeLine{6756 }
\DoxyCodeLine{6757 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{6758 \textcolor{keyword}{inline}}
\DoxyCodeLine{6759 eT}
\DoxyCodeLine{6760 auxlib::lu\_rcond\_sympd(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} eT norm\_val)}
\DoxyCodeLine{6761   \{}
\DoxyCodeLine{6762 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{6763     \{}
\DoxyCodeLine{6764     \textcolor{keywordtype}{char}     uplo  = \textcolor{charliteral}{'L'};}
\DoxyCodeLine{6765     blas\_int n     = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);  \textcolor{comment}{// assuming square matrix}}
\DoxyCodeLine{6766     eT       rcond = eT(0);}
\DoxyCodeLine{6767     blas\_int info  = blas\_int(0);}
\DoxyCodeLine{6768     }
\DoxyCodeLine{6769     \mbox{\hyperlink{classpodarray}{podarray<eT>}}        work(3*\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6770     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} iwork(  \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6771     }
\DoxyCodeLine{6772     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::pocon()"{}});}
\DoxyCodeLine{6773     lapack::pocon(\&uplo, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&n, \&norm\_val, \&rcond, work.memptr(), iwork.memptr(), \&info);}
\DoxyCodeLine{6774     }
\DoxyCodeLine{6775     \textcolor{keywordflow}{if}(info != blas\_int(0))  \{ \textcolor{keywordflow}{return} eT(0); \}}
\DoxyCodeLine{6776     }
\DoxyCodeLine{6777     \textcolor{keywordflow}{return} rcond;}
\DoxyCodeLine{6778     \}}
\DoxyCodeLine{6779 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{6780     \{}
\DoxyCodeLine{6781     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{6782     arma\_ignore(norm\_val);}
\DoxyCodeLine{6783     \textcolor{keywordflow}{return} eT(0);}
\DoxyCodeLine{6784     \}}
\DoxyCodeLine{6785 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{6786   \}}
\DoxyCodeLine{6787 }
\DoxyCodeLine{6788 }
\DoxyCodeLine{6789 }
\DoxyCodeLine{6790 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6791 \textcolor{keyword}{inline}}
\DoxyCodeLine{6792 T}
\DoxyCodeLine{6793 auxlib::lu\_rcond\_sympd(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} T norm\_val)}
\DoxyCodeLine{6794   \{}
\DoxyCodeLine{6795 \textcolor{preprocessor}{  \#if defined(ARMA\_CRIPPLED\_LAPACK)}}
\DoxyCodeLine{6796     \{}
\DoxyCodeLine{6797     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{6798     arma\_ignore(norm\_val);}
\DoxyCodeLine{6799     \textcolor{keywordflow}{return} T(0);}
\DoxyCodeLine{6800     \}}
\DoxyCodeLine{6801 \textcolor{preprocessor}{  \#elif defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{6802     \{}
\DoxyCodeLine{6803     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<T> eT;}
\DoxyCodeLine{6804     }
\DoxyCodeLine{6805     \textcolor{keywordtype}{char}     uplo  = \textcolor{charliteral}{'L'};}
\DoxyCodeLine{6806     blas\_int n     = blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows);  \textcolor{comment}{// assuming square matrix}}
\DoxyCodeLine{6807     T        rcond = T(0);}
\DoxyCodeLine{6808     blas\_int info  = blas\_int(0);}
\DoxyCodeLine{6809     }
\DoxyCodeLine{6810     \mbox{\hyperlink{classpodarray}{podarray<eT>}}  work(2*\mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6811     \mbox{\hyperlink{classpodarray}{podarray< T>}} rwork(  \mbox{\hyperlink{structA}{A}}.n\_rows);}
\DoxyCodeLine{6812     }
\DoxyCodeLine{6813     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::cx\_pocon()"{}});}
\DoxyCodeLine{6814     lapack::cx\_pocon(\&uplo, \&n, \mbox{\hyperlink{structA}{A}}.memptr(), \&n, \&norm\_val, \&rcond, work.memptr(), rwork.memptr(), \&info);}
\DoxyCodeLine{6815     }
\DoxyCodeLine{6816     \textcolor{keywordflow}{if}(info != blas\_int(0))  \{ \textcolor{keywordflow}{return} T(0); \}}
\DoxyCodeLine{6817     }
\DoxyCodeLine{6818     \textcolor{keywordflow}{return} rcond;}
\DoxyCodeLine{6819     \}}
\DoxyCodeLine{6820 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{6821     \{}
\DoxyCodeLine{6822     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{6823     arma\_ignore(norm\_val);}
\DoxyCodeLine{6824     \textcolor{keywordflow}{return} T(0);}
\DoxyCodeLine{6825     \}}
\DoxyCodeLine{6826 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{6827   \}}
\DoxyCodeLine{6828 }
\DoxyCodeLine{6829 }
\DoxyCodeLine{6830 }
\DoxyCodeLine{6831 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{6832 \textcolor{keyword}{inline}}
\DoxyCodeLine{6833 eT}
\DoxyCodeLine{6834 auxlib::lu\_rcond\_band(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& AB, \textcolor{keyword}{const} uword KL, \textcolor{keyword}{const} uword KU, \textcolor{keyword}{const} \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}}\& ipiv, \textcolor{keyword}{const} eT norm\_val)}
\DoxyCodeLine{6835   \{}
\DoxyCodeLine{6836 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{6837     \{}
\DoxyCodeLine{6838     \textcolor{keyword}{const} uword N = AB.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}};  \textcolor{comment}{// order of the original square matrix A}}
\DoxyCodeLine{6839     }
\DoxyCodeLine{6840     \textcolor{keywordtype}{char}     norm\_id = \textcolor{charliteral}{'1'};}
\DoxyCodeLine{6841     blas\_int n       = blas\_int(N);}
\DoxyCodeLine{6842     blas\_int kl      = blas\_int(KL);}
\DoxyCodeLine{6843     blas\_int ku      = blas\_int(KU);}
\DoxyCodeLine{6844     blas\_int ldab    = blas\_int(AB.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{6845     eT       rcond   = eT(0);}
\DoxyCodeLine{6846     blas\_int info    = blas\_int(0);}
\DoxyCodeLine{6847     }
\DoxyCodeLine{6848     \mbox{\hyperlink{classpodarray}{podarray<eT>}}        work(3*N);}
\DoxyCodeLine{6849     \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}} iwork(  N);}
\DoxyCodeLine{6850     }
\DoxyCodeLine{6851     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::gbcon()"{}});}
\DoxyCodeLine{6852     lapack::gbcon<eT>(\&norm\_id, \&n, \&kl, \&ku, AB.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldab, ipiv.memptr(), \&norm\_val, \&rcond, work.memptr(), iwork.memptr(), \&info);}
\DoxyCodeLine{6853     }
\DoxyCodeLine{6854     \textcolor{keywordflow}{if}(info != blas\_int(0))  \{ \textcolor{keywordflow}{return} eT(0); \}}
\DoxyCodeLine{6855     }
\DoxyCodeLine{6856     \textcolor{keywordflow}{return} rcond;}
\DoxyCodeLine{6857     \}}
\DoxyCodeLine{6858 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{6859     \{}
\DoxyCodeLine{6860     arma\_ignore(AB);}
\DoxyCodeLine{6861     arma\_ignore(KL);}
\DoxyCodeLine{6862     arma\_ignore(KU);}
\DoxyCodeLine{6863     arma\_ignore(ipiv);}
\DoxyCodeLine{6864     arma\_ignore(norm\_val);}
\DoxyCodeLine{6865     \textcolor{keywordflow}{return} eT(0);}
\DoxyCodeLine{6866     \}}
\DoxyCodeLine{6867 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{6868   \}}
\DoxyCodeLine{6869 }
\DoxyCodeLine{6870 }
\DoxyCodeLine{6871 }
\DoxyCodeLine{6872 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6873 \textcolor{keyword}{inline}}
\DoxyCodeLine{6874 T}
\DoxyCodeLine{6875 auxlib::lu\_rcond\_band(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& AB, \textcolor{keyword}{const} uword KL, \textcolor{keyword}{const} uword KU, \textcolor{keyword}{const} \mbox{\hyperlink{classpodarray}{podarray<blas\_int>}}\& ipiv, \textcolor{keyword}{const} T norm\_val)}
\DoxyCodeLine{6876   \{}
\DoxyCodeLine{6877 \textcolor{preprocessor}{  \#if defined(ARMA\_CRIPPLED\_LAPACK)}}
\DoxyCodeLine{6878     \{}
\DoxyCodeLine{6879     arma\_ignore(AB);}
\DoxyCodeLine{6880     arma\_ignore(KL);}
\DoxyCodeLine{6881     arma\_ignore(KU);}
\DoxyCodeLine{6882     arma\_ignore(ipiv);}
\DoxyCodeLine{6883     arma\_ignore(norm\_val);}
\DoxyCodeLine{6884     \textcolor{keywordflow}{return} T(0);}
\DoxyCodeLine{6885     \}}
\DoxyCodeLine{6886 \textcolor{preprocessor}{  \#elif defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{6887     \{}
\DoxyCodeLine{6888     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<T> eT;}
\DoxyCodeLine{6889     }
\DoxyCodeLine{6890     \textcolor{keyword}{const} uword N = AB.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}};  \textcolor{comment}{// order of the original square matrix A}}
\DoxyCodeLine{6891     }
\DoxyCodeLine{6892     \textcolor{keywordtype}{char}     norm\_id = \textcolor{charliteral}{'1'};}
\DoxyCodeLine{6893     blas\_int n       = blas\_int(N);}
\DoxyCodeLine{6894     blas\_int kl      = blas\_int(KL);}
\DoxyCodeLine{6895     blas\_int ku      = blas\_int(KU);}
\DoxyCodeLine{6896     blas\_int ldab    = blas\_int(AB.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{6897     T        rcond   = T(0);}
\DoxyCodeLine{6898     blas\_int info    = blas\_int(0);}
\DoxyCodeLine{6899     }
\DoxyCodeLine{6900     \mbox{\hyperlink{classpodarray}{podarray<eT>}}  work(2*N);}
\DoxyCodeLine{6901     \mbox{\hyperlink{classpodarray}{podarray< T>}} rwork(  N);}
\DoxyCodeLine{6902     }
\DoxyCodeLine{6903     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}lapack::cx\_gbcon()"{}});}
\DoxyCodeLine{6904     lapack::cx\_gbcon<T>(\&norm\_id, \&n, \&kl, \&ku, AB.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), \&ldab, ipiv.memptr(), \&norm\_val, \&rcond, work.memptr(), rwork.memptr(), \&info);}
\DoxyCodeLine{6905     }
\DoxyCodeLine{6906     \textcolor{keywordflow}{if}(info != blas\_int(0))  \{ \textcolor{keywordflow}{return} T(0); \}}
\DoxyCodeLine{6907     }
\DoxyCodeLine{6908     \textcolor{keywordflow}{return} rcond;}
\DoxyCodeLine{6909     \}}
\DoxyCodeLine{6910 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{6911     \{}
\DoxyCodeLine{6912     arma\_ignore(AB);}
\DoxyCodeLine{6913     arma\_ignore(KL);}
\DoxyCodeLine{6914     arma\_ignore(KU);}
\DoxyCodeLine{6915     arma\_ignore(ipiv);}
\DoxyCodeLine{6916     arma\_ignore(norm\_val);}
\DoxyCodeLine{6917     \textcolor{keywordflow}{return} T(0);}
\DoxyCodeLine{6918     \}}
\DoxyCodeLine{6919 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{6920   \}}
\DoxyCodeLine{6921 }
\DoxyCodeLine{6922 }
\DoxyCodeLine{6923 }
\DoxyCodeLine{6924 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{6925 \textcolor{keyword}{inline}}
\DoxyCodeLine{6926 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{6927 auxlib::crippled\_lapack(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::elem\_type, T1>}}\&)}
\DoxyCodeLine{6928   \{}
\DoxyCodeLine{6929 \textcolor{preprocessor}{  \#if defined(ARMA\_CRIPPLED\_LAPACK)}}
\DoxyCodeLine{6930     \{}
\DoxyCodeLine{6931     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}auxlib::crippled\_lapack(): true"{}});}
\DoxyCodeLine{6932     }
\DoxyCodeLine{6933     \textcolor{keywordflow}{return} (\mbox{\hyperlink{structis__cx}{is\_cx<typename T1::elem\_type>::yes}});}
\DoxyCodeLine{6934     \}}
\DoxyCodeLine{6935 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{6936     \{}
\DoxyCodeLine{6937     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{6938     \}}
\DoxyCodeLine{6939 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{6940   \}}
\DoxyCodeLine{6941 }
\DoxyCodeLine{6942 }
\DoxyCodeLine{6943 }
\DoxyCodeLine{6944 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{6945 \textcolor{keyword}{inline}}
\DoxyCodeLine{6946 \textcolor{keyword}{typename} T1::pod\_type}
\DoxyCodeLine{6947 auxlib::epsilon\_lapack(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::elem\_type, T1>}}\&)}
\DoxyCodeLine{6948   \{}
\DoxyCodeLine{6949   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type T;}
\DoxyCodeLine{6950   }
\DoxyCodeLine{6951   \textcolor{keywordflow}{return} T(0.5)*std::numeric\_limits<T>::epsilon();}
\DoxyCodeLine{6952   }
\DoxyCodeLine{6953   \textcolor{comment}{// value reverse engineered from dgesvx.f and dlamch.f}}
\DoxyCodeLine{6954   \textcolor{comment}{// http://www.netlib.org/lapack/explore-\/html/da/d21/dgesvx\_8f.html}}
\DoxyCodeLine{6955   \textcolor{comment}{// http://www.netlib.org/lapack/explore-\/html/d5/dd4/dlamch\_8f.html}}
\DoxyCodeLine{6956   \textcolor{comment}{//}}
\DoxyCodeLine{6957   \textcolor{comment}{// Fortran epsilon(X) function:}}
\DoxyCodeLine{6958   \textcolor{comment}{// https://gcc.gnu.org/onlinedocs/gfortran/EPSILON.html}}
\DoxyCodeLine{6959   \textcolor{comment}{// "{}EPSILON(X) returns the smallest number E of the same kind as X such that 1 + E > 1"{}}}
\DoxyCodeLine{6960   \textcolor{comment}{// }}
\DoxyCodeLine{6961   \textcolor{comment}{// C++ std::numeric\_limits<T>::epsilon() function:}}
\DoxyCodeLine{6962   \textcolor{comment}{// https://en.cppreference.com/w/cpp/types/numeric\_limits/epsilon}}
\DoxyCodeLine{6963   \textcolor{comment}{// "{}the difference between 1.0 and the next value representable by the floating-\/point type T"{}}}
\DoxyCodeLine{6964   \textcolor{comment}{// }}
\DoxyCodeLine{6965   \textcolor{comment}{// extract from dgesvx.f:}}
\DoxyCodeLine{6966   \textcolor{comment}{// }}
\DoxyCodeLine{6967   \textcolor{comment}{//   IF( rcond.LT.dlamch( 'Epsilon' ) )}}
\DoxyCodeLine{6968   \textcolor{comment}{//     info = n + 1}}
\DoxyCodeLine{6969   \textcolor{comment}{//   RETURN}}
\DoxyCodeLine{6970   \textcolor{comment}{// }}
\DoxyCodeLine{6971   \textcolor{comment}{// extract from dlamch.f:}}
\DoxyCodeLine{6972   \textcolor{comment}{//   }}
\DoxyCodeLine{6973   \textcolor{comment}{//   * rnd = 1.0 when rounding occurs in addition, 0.0 otherwise}}
\DoxyCodeLine{6974   \textcolor{comment}{//   ...}}
\DoxyCodeLine{6975   \textcolor{comment}{//   *  Assume rounding, not chopping. Always}}
\DoxyCodeLine{6976   \textcolor{comment}{//   }}
\DoxyCodeLine{6977   \textcolor{comment}{//   rnd = one}}
\DoxyCodeLine{6978   \textcolor{comment}{//   }}
\DoxyCodeLine{6979   \textcolor{comment}{//   IF( one.EQ.rnd ) THEN}}
\DoxyCodeLine{6980   \textcolor{comment}{//     eps = epsilon(zero) * 0.5}}
\DoxyCodeLine{6981   \textcolor{comment}{//   ELSE}}
\DoxyCodeLine{6982   \textcolor{comment}{//     eps = epsilon(zero)}}
\DoxyCodeLine{6983   \textcolor{comment}{//   END IF}}
\DoxyCodeLine{6984   \textcolor{comment}{//   ...}}
\DoxyCodeLine{6985   \textcolor{comment}{//   IF( lsame( cmach, 'E' ) ) THEN}}
\DoxyCodeLine{6986   \textcolor{comment}{//     rmach = eps}}
\DoxyCodeLine{6987   \textcolor{comment}{//   ...}}
\DoxyCodeLine{6988   \textcolor{comment}{//   END IF}}
\DoxyCodeLine{6989   \textcolor{comment}{//   ...}}
\DoxyCodeLine{6990   \textcolor{comment}{//   dlamch = rmach}}
\DoxyCodeLine{6991   \textcolor{comment}{//   RETURN}}
\DoxyCodeLine{6992   \}}
\DoxyCodeLine{6993 }
\DoxyCodeLine{6994 }
\DoxyCodeLine{6995 }
\DoxyCodeLine{6996 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{6997 \textcolor{keyword}{inline}}
\DoxyCodeLine{6998 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{6999 auxlib::rudimentary\_sym\_check(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X)}
\DoxyCodeLine{7000   \{}
\DoxyCodeLine{7001   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{7002   }
\DoxyCodeLine{7003   \textcolor{keyword}{const} uword N   = X.n\_rows;}
\DoxyCodeLine{7004   \textcolor{keyword}{const} uword Nm2 = N-\/2;}
\DoxyCodeLine{7005   }
\DoxyCodeLine{7006   \textcolor{keywordflow}{if}(N != X.n\_cols)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{7007   \textcolor{keywordflow}{if}(N <= uword(1))  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true};  \}}
\DoxyCodeLine{7008   }
\DoxyCodeLine{7009   \textcolor{keyword}{const} eT* X\_mem = X.memptr();}
\DoxyCodeLine{7010   }
\DoxyCodeLine{7011   \textcolor{keyword}{const} eT* X\_offsetA = \&(X\_mem[Nm2  ]);}
\DoxyCodeLine{7012   \textcolor{keyword}{const} eT* X\_offsetB = \&(X\_mem[Nm2*N]);}
\DoxyCodeLine{7013   }
\DoxyCodeLine{7014   \textcolor{keyword}{const} eT A1 = *(X\_offsetA  ); }
\DoxyCodeLine{7015   \textcolor{keyword}{const} eT A2 = *(X\_offsetA+1);  \textcolor{comment}{// bottom-\/left corner (ie. last value in first column)}}
\DoxyCodeLine{7016   \textcolor{keyword}{const} eT B1 = *(X\_offsetB  );  }
\DoxyCodeLine{7017   \textcolor{keyword}{const} eT B2 = *(X\_offsetB+N);  \textcolor{comment}{// top-\/right   corner (ie. first value in last column)}}
\DoxyCodeLine{7018   }
\DoxyCodeLine{7019   \textcolor{keyword}{const} eT \mbox{\hyperlink{classC1}{C1}} = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(std::abs(A1), std::abs(B1));}
\DoxyCodeLine{7020   \textcolor{keyword}{const} eT \mbox{\hyperlink{classC2}{C2}} = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(std::abs(A2), std::abs(B2));}
\DoxyCodeLine{7021   }
\DoxyCodeLine{7022   \textcolor{keyword}{const} eT delta1 = std::abs(A1 -\/ B1);}
\DoxyCodeLine{7023   \textcolor{keyword}{const} eT delta2 = std::abs(A2 -\/ B2);}
\DoxyCodeLine{7024   }
\DoxyCodeLine{7025   \textcolor{keyword}{const} eT tol = eT(10000)*std::numeric\_limits<eT>::epsilon();  \textcolor{comment}{// allow some leeway}}
\DoxyCodeLine{7026   }
\DoxyCodeLine{7027   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} okay1 = ( (delta1 <= tol) || (delta1 <= (\mbox{\hyperlink{classC1}{C1}} * tol)) );}
\DoxyCodeLine{7028   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} okay2 = ( (delta2 <= tol) || (delta2 <= (\mbox{\hyperlink{classC2}{C2}} * tol)) );}
\DoxyCodeLine{7029   }
\DoxyCodeLine{7030   \textcolor{keywordflow}{return} (okay1 \&\& okay2);}
\DoxyCodeLine{7031   \}}
\DoxyCodeLine{7032 }
\DoxyCodeLine{7033 }
\DoxyCodeLine{7034 }
\DoxyCodeLine{7035 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{7036 \textcolor{keyword}{inline}}
\DoxyCodeLine{7037 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{7038 auxlib::rudimentary\_sym\_check(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& X)}
\DoxyCodeLine{7039   \{}
\DoxyCodeLine{7040   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{7041   }
\DoxyCodeLine{7042   \textcolor{comment}{// NOTE: the function name is a misnomer, as it checks for hermitian complex matrices;}}
\DoxyCodeLine{7043   \textcolor{comment}{// NOTE: for simplicity of use, the function name is the same as for real matrices}}
\DoxyCodeLine{7044   }
\DoxyCodeLine{7045   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<T> eT;}
\DoxyCodeLine{7046   }
\DoxyCodeLine{7047   \textcolor{keyword}{const} uword N   = X.n\_rows;}
\DoxyCodeLine{7048   \textcolor{keyword}{const} uword Nm1 = N-\/1;}
\DoxyCodeLine{7049   }
\DoxyCodeLine{7050   \textcolor{keywordflow}{if}(N != X.n\_cols)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{7051   \textcolor{keywordflow}{if}(N == uword(0))  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true};  \}}
\DoxyCodeLine{7052   }
\DoxyCodeLine{7053   \textcolor{keyword}{const} eT* X\_mem = X.memptr();}
\DoxyCodeLine{7054   }
\DoxyCodeLine{7055   \textcolor{keyword}{const} T tol = T(10000)*std::numeric\_limits<T>::epsilon();  \textcolor{comment}{// allow some leeway}}
\DoxyCodeLine{7056   }
\DoxyCodeLine{7057   \textcolor{keywordflow}{if}(std::abs(X\_mem[0].imag()) > tol)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{7058   }
\DoxyCodeLine{7059   \textcolor{keyword}{const} eT\& \mbox{\hyperlink{structA}{A}} = X\_mem[Nm1  ];  \textcolor{comment}{// bottom-\/left corner (ie. last value in first column)}}
\DoxyCodeLine{7060   \textcolor{keyword}{const} eT\& \mbox{\hyperlink{structB}{B}} = X\_mem[Nm1*N];  \textcolor{comment}{// top-\/right   corner (ie. first value in last column)}}
\DoxyCodeLine{7061   }
\DoxyCodeLine{7062   \textcolor{keyword}{const} T C\_real = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(std::abs(\mbox{\hyperlink{structA}{A}}.real()), std::abs(\mbox{\hyperlink{structB}{B}}.real()));}
\DoxyCodeLine{7063   \textcolor{keyword}{const} T C\_imag = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(std::abs(\mbox{\hyperlink{structA}{A}}.imag()), std::abs(\mbox{\hyperlink{structB}{B}}.imag()));}
\DoxyCodeLine{7064   }
\DoxyCodeLine{7065   \textcolor{keyword}{const} T delta\_real = std::abs(\mbox{\hyperlink{structA}{A}}.real() -\/ \mbox{\hyperlink{structB}{B}}.real());}
\DoxyCodeLine{7066   \textcolor{keyword}{const} T delta\_imag = std::abs(\mbox{\hyperlink{structA}{A}}.imag() + \mbox{\hyperlink{structB}{B}}.imag());  \textcolor{comment}{// take into account the conjugate}}
\DoxyCodeLine{7067   }
\DoxyCodeLine{7068   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} okay\_real = ( (delta\_real <= tol) || (delta\_real <= (C\_real * tol)) );}
\DoxyCodeLine{7069   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} okay\_imag = ( (delta\_imag <= tol) || (delta\_imag <= (C\_imag * tol)) );}
\DoxyCodeLine{7070   }
\DoxyCodeLine{7071   \textcolor{keywordflow}{return} (okay\_real \&\& okay\_imag);}
\DoxyCodeLine{7072   \}}
\DoxyCodeLine{7073 }
\DoxyCodeLine{7074 }
\DoxyCodeLine{7075 }
\DoxyCodeLine{7076 \textcolor{comment}{//}}
\DoxyCodeLine{7077 }
\DoxyCodeLine{7078 }
\DoxyCodeLine{7079 }
\DoxyCodeLine{7080 \textcolor{keyword}{namespace }qz\_helper}
\DoxyCodeLine{7081 \{}
\DoxyCodeLine{7082 }
\DoxyCodeLine{7083 \textcolor{comment}{// sgges() and dgges() require an external function with three arguments:}}
\DoxyCodeLine{7084 \textcolor{comment}{// select(alpha\_real, alpha\_imag, beta)}}
\DoxyCodeLine{7085 \textcolor{comment}{// where the eigenvalue is defined as complex(alpha\_real, alpha\_imag) / beta}}
\DoxyCodeLine{7086 }
\DoxyCodeLine{7087 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{7088 \textcolor{keyword}{inline}}
\DoxyCodeLine{7089 blas\_int}
\DoxyCodeLine{7090 select\_lhp(\textcolor{keyword}{const} T* x\_ptr, \textcolor{keyword}{const} T* y\_ptr, \textcolor{keyword}{const} T* z\_ptr)}
\DoxyCodeLine{7091   \{}
\DoxyCodeLine{7092   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{7093   }
\DoxyCodeLine{7094   \textcolor{comment}{// cout << "{}select\_lhp(): (*x\_ptr) = "{} << (*x\_ptr) << endl;}}
\DoxyCodeLine{7095   \textcolor{comment}{// cout << "{}select\_lhp(): (*y\_ptr) = "{} << (*y\_ptr) << endl;}}
\DoxyCodeLine{7096   \textcolor{comment}{// cout << "{}select\_lhp(): (*z\_ptr) = "{} << (*z\_ptr) << endl;}}
\DoxyCodeLine{7097   }
\DoxyCodeLine{7098   arma\_ignore(y\_ptr);  \textcolor{comment}{// ignore imaginary part}}
\DoxyCodeLine{7099   }
\DoxyCodeLine{7100   \textcolor{keyword}{const} T x = (*x\_ptr);}
\DoxyCodeLine{7101   \textcolor{keyword}{const} T z = (*z\_ptr);}
\DoxyCodeLine{7102   }
\DoxyCodeLine{7103   \textcolor{keywordflow}{if}(z == T(0))  \{ \textcolor{keywordflow}{return} blas\_int(0); \}  \textcolor{comment}{// consider an infinite eig value not to lie in either lhp or rhp}}
\DoxyCodeLine{7104   }
\DoxyCodeLine{7105   \textcolor{keywordflow}{return} ((x/z) < T(0)) ? blas\_int(1) : blas\_int(0);}
\DoxyCodeLine{7106   \}}
\DoxyCodeLine{7107 }
\DoxyCodeLine{7108 }
\DoxyCodeLine{7109 }
\DoxyCodeLine{7110 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{7111 \textcolor{keyword}{inline}}
\DoxyCodeLine{7112 blas\_int}
\DoxyCodeLine{7113 select\_rhp(\textcolor{keyword}{const} T* x\_ptr, \textcolor{keyword}{const} T* y\_ptr, \textcolor{keyword}{const} T* z\_ptr)}
\DoxyCodeLine{7114   \{}
\DoxyCodeLine{7115   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{7116   }
\DoxyCodeLine{7117   \textcolor{comment}{// cout << "{}select\_rhp(): (*x\_ptr) = "{} << (*x\_ptr) << endl;}}
\DoxyCodeLine{7118   \textcolor{comment}{// cout << "{}select\_rhp(): (*y\_ptr) = "{} << (*y\_ptr) << endl;}}
\DoxyCodeLine{7119   \textcolor{comment}{// cout << "{}select\_rhp(): (*z\_ptr) = "{} << (*z\_ptr) << endl;}}
\DoxyCodeLine{7120   }
\DoxyCodeLine{7121   arma\_ignore(y\_ptr);  \textcolor{comment}{// ignore imaginary part}}
\DoxyCodeLine{7122   }
\DoxyCodeLine{7123   \textcolor{keyword}{const} T x = (*x\_ptr);}
\DoxyCodeLine{7124   \textcolor{keyword}{const} T z = (*z\_ptr);}
\DoxyCodeLine{7125   }
\DoxyCodeLine{7126   \textcolor{keywordflow}{if}(z == T(0))  \{ \textcolor{keywordflow}{return} blas\_int(0); \}  \textcolor{comment}{// consider an infinite eig value not to lie in either lhp or rhp}}
\DoxyCodeLine{7127   }
\DoxyCodeLine{7128   \textcolor{keywordflow}{return} ((x/z) > T(0)) ? blas\_int(1) : blas\_int(0);}
\DoxyCodeLine{7129   \}}
\DoxyCodeLine{7130 }
\DoxyCodeLine{7131 }
\DoxyCodeLine{7132 }
\DoxyCodeLine{7133 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{7134 \textcolor{keyword}{inline}}
\DoxyCodeLine{7135 blas\_int}
\DoxyCodeLine{7136 select\_iuc(\textcolor{keyword}{const} T* x\_ptr, \textcolor{keyword}{const} T* y\_ptr, \textcolor{keyword}{const} T* z\_ptr)}
\DoxyCodeLine{7137   \{}
\DoxyCodeLine{7138   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{7139   }
\DoxyCodeLine{7140   \textcolor{comment}{// cout << "{}select\_iuc(): (*x\_ptr) = "{} << (*x\_ptr) << endl;}}
\DoxyCodeLine{7141   \textcolor{comment}{// cout << "{}select\_iuc(): (*y\_ptr) = "{} << (*y\_ptr) << endl;}}
\DoxyCodeLine{7142   \textcolor{comment}{// cout << "{}select\_iuc(): (*z\_ptr) = "{} << (*z\_ptr) << endl;}}
\DoxyCodeLine{7143   }
\DoxyCodeLine{7144   \textcolor{keyword}{const} T x = (*x\_ptr);}
\DoxyCodeLine{7145   \textcolor{keyword}{const} T y = (*y\_ptr);}
\DoxyCodeLine{7146   \textcolor{keyword}{const} T z = (*z\_ptr);}
\DoxyCodeLine{7147   }
\DoxyCodeLine{7148   \textcolor{keywordflow}{if}(z == T(0))  \{ \textcolor{keywordflow}{return} blas\_int(0); \}  \textcolor{comment}{// consider an infinite eig value to be outside of the unit circle }}
\DoxyCodeLine{7149   }
\DoxyCodeLine{7150   \textcolor{comment}{//return (std::abs(std::complex<T>(x,y) / z) < T(1)) ? blas\_int(1) : blas\_int(0);}}
\DoxyCodeLine{7151   \textcolor{keywordflow}{return} (std::sqrt(x*x + y*y) < std::abs(z)) ? blas\_int(1) : blas\_int(0);}
\DoxyCodeLine{7152   \}}
\DoxyCodeLine{7153 }
\DoxyCodeLine{7154 }
\DoxyCodeLine{7155 }
\DoxyCodeLine{7156 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{7157 \textcolor{keyword}{inline}}
\DoxyCodeLine{7158 blas\_int}
\DoxyCodeLine{7159 select\_ouc(\textcolor{keyword}{const} T* x\_ptr, \textcolor{keyword}{const} T* y\_ptr, \textcolor{keyword}{const} T* z\_ptr)}
\DoxyCodeLine{7160   \{}
\DoxyCodeLine{7161   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{7162   }
\DoxyCodeLine{7163   \textcolor{comment}{// cout << "{}select\_ouc(): (*x\_ptr) = "{} << (*x\_ptr) << endl;}}
\DoxyCodeLine{7164   \textcolor{comment}{// cout << "{}select\_ouc(): (*y\_ptr) = "{} << (*y\_ptr) << endl;}}
\DoxyCodeLine{7165   \textcolor{comment}{// cout << "{}select\_ouc(): (*z\_ptr) = "{} << (*z\_ptr) << endl;}}
\DoxyCodeLine{7166   }
\DoxyCodeLine{7167   \textcolor{keyword}{const} T x = (*x\_ptr);}
\DoxyCodeLine{7168   \textcolor{keyword}{const} T y = (*y\_ptr);}
\DoxyCodeLine{7169   \textcolor{keyword}{const} T z = (*z\_ptr);}
\DoxyCodeLine{7170   }
\DoxyCodeLine{7171   \textcolor{keywordflow}{if}(z == T(0))}
\DoxyCodeLine{7172     \{}
\DoxyCodeLine{7173     \textcolor{keywordflow}{return} (x == T(0)) ? blas\_int(0) : blas\_int(1);  \textcolor{comment}{// consider an infinite eig value to be outside of the unit circle }}
\DoxyCodeLine{7174     \}}
\DoxyCodeLine{7175   }
\DoxyCodeLine{7176   \textcolor{comment}{//return (std::abs(std::complex<T>(x,y) / z) > T(1)) ? blas\_int(1) : blas\_int(0);}}
\DoxyCodeLine{7177   \textcolor{keywordflow}{return} (std::sqrt(x*x + y*y) > std::abs(z)) ? blas\_int(1) : blas\_int(0);}
\DoxyCodeLine{7178   \}}
\DoxyCodeLine{7179 }
\DoxyCodeLine{7180 }
\DoxyCodeLine{7181 }
\DoxyCodeLine{7182 \textcolor{comment}{// cgges() and zgges() require an external function with two arguments:}}
\DoxyCodeLine{7183 \textcolor{comment}{// select(alpha, beta)}}
\DoxyCodeLine{7184 \textcolor{comment}{// where the complex eigenvalue is defined as (alpha / beta)}}
\DoxyCodeLine{7185 }
\DoxyCodeLine{7186 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{7187 \textcolor{keyword}{inline}}
\DoxyCodeLine{7188 blas\_int}
\DoxyCodeLine{7189 cx\_select\_lhp(\textcolor{keyword}{const} std::complex<T>* x\_ptr, \textcolor{keyword}{const} std::complex<T>* y\_ptr)}
\DoxyCodeLine{7190   \{}
\DoxyCodeLine{7191   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{7192   }
\DoxyCodeLine{7193   \textcolor{comment}{// cout << "{}cx\_select\_lhp(): (*x\_ptr) = "{} << (*x\_ptr) << endl;}}
\DoxyCodeLine{7194   \textcolor{comment}{// cout << "{}cx\_select\_lhp(): (*y\_ptr) = "{} << (*y\_ptr) << endl;}}
\DoxyCodeLine{7195   }
\DoxyCodeLine{7196   \textcolor{keyword}{const} std::complex<T>\& x = (*x\_ptr);}
\DoxyCodeLine{7197   \textcolor{keyword}{const} std::complex<T>\& y = (*y\_ptr);}
\DoxyCodeLine{7198   }
\DoxyCodeLine{7199   \textcolor{keywordflow}{if}( (y.real() == T(0)) \&\& (y.imag() == T(0)) )  \{ \textcolor{keywordflow}{return} blas\_int(0); \}  \textcolor{comment}{// consider an infinite eig value not to lie in either lhp or rhp}}
\DoxyCodeLine{7200   }
\DoxyCodeLine{7201   \textcolor{keywordflow}{return} (std::real(x / y) < T(0)) ? blas\_int(1) : blas\_int(0);}
\DoxyCodeLine{7202   \}}
\DoxyCodeLine{7203 }
\DoxyCodeLine{7204 }
\DoxyCodeLine{7205 }
\DoxyCodeLine{7206 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{7207 \textcolor{keyword}{inline}}
\DoxyCodeLine{7208 blas\_int}
\DoxyCodeLine{7209 cx\_select\_rhp(\textcolor{keyword}{const} std::complex<T>* x\_ptr, \textcolor{keyword}{const} std::complex<T>* y\_ptr)}
\DoxyCodeLine{7210   \{}
\DoxyCodeLine{7211   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{7212   }
\DoxyCodeLine{7213   \textcolor{comment}{// cout << "{}cx\_select\_rhp(): (*x\_ptr) = "{} << (*x\_ptr) << endl;}}
\DoxyCodeLine{7214   \textcolor{comment}{// cout << "{}cx\_select\_rhp(): (*y\_ptr) = "{} << (*y\_ptr) << endl;}}
\DoxyCodeLine{7215   }
\DoxyCodeLine{7216   \textcolor{keyword}{const} std::complex<T>\& x = (*x\_ptr);}
\DoxyCodeLine{7217   \textcolor{keyword}{const} std::complex<T>\& y = (*y\_ptr);}
\DoxyCodeLine{7218   }
\DoxyCodeLine{7219   \textcolor{keywordflow}{if}( (y.real() == T(0)) \&\& (y.imag() == T(0)) )  \{ \textcolor{keywordflow}{return} blas\_int(0); \}  \textcolor{comment}{// consider an infinite eig value not to lie in either lhp or rhp}}
\DoxyCodeLine{7220   }
\DoxyCodeLine{7221   \textcolor{keywordflow}{return} (std::real(x / y) > T(0)) ? blas\_int(1) : blas\_int(0);}
\DoxyCodeLine{7222   \}}
\DoxyCodeLine{7223 }
\DoxyCodeLine{7224 }
\DoxyCodeLine{7225 }
\DoxyCodeLine{7226 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{7227 \textcolor{keyword}{inline}}
\DoxyCodeLine{7228 blas\_int}
\DoxyCodeLine{7229 cx\_select\_iuc(\textcolor{keyword}{const} std::complex<T>* x\_ptr, \textcolor{keyword}{const} std::complex<T>* y\_ptr)}
\DoxyCodeLine{7230   \{}
\DoxyCodeLine{7231   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{7232   }
\DoxyCodeLine{7233   \textcolor{comment}{// cout << "{}cx\_select\_iuc(): (*x\_ptr) = "{} << (*x\_ptr) << endl;}}
\DoxyCodeLine{7234   \textcolor{comment}{// cout << "{}cx\_select\_iuc(): (*y\_ptr) = "{} << (*y\_ptr) << endl;}}
\DoxyCodeLine{7235   }
\DoxyCodeLine{7236   \textcolor{keyword}{const} std::complex<T>\& x = (*x\_ptr);}
\DoxyCodeLine{7237   \textcolor{keyword}{const} std::complex<T>\& y = (*y\_ptr);}
\DoxyCodeLine{7238   }
\DoxyCodeLine{7239   \textcolor{keywordflow}{if}( (y.real() == T(0)) \&\& (y.imag() == T(0)) )  \{ \textcolor{keywordflow}{return} blas\_int(0); \}  \textcolor{comment}{// consider an infinite eig value to be outside of the unit circle}}
\DoxyCodeLine{7240   }
\DoxyCodeLine{7241   \textcolor{keywordflow}{return} (std::abs(x / y) < T(1)) ? blas\_int(1) : blas\_int(0);}
\DoxyCodeLine{7242   \}}
\DoxyCodeLine{7243 }
\DoxyCodeLine{7244 }
\DoxyCodeLine{7245 }
\DoxyCodeLine{7246 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{7247 \textcolor{keyword}{inline}}
\DoxyCodeLine{7248 blas\_int}
\DoxyCodeLine{7249 cx\_select\_ouc(\textcolor{keyword}{const} std::complex<T>* x\_ptr, \textcolor{keyword}{const} std::complex<T>* y\_ptr)}
\DoxyCodeLine{7250   \{}
\DoxyCodeLine{7251   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{7252   }
\DoxyCodeLine{7253   \textcolor{comment}{// cout << "{}cx\_select\_ouc(): (*x\_ptr) = "{} << (*x\_ptr) << endl;}}
\DoxyCodeLine{7254   \textcolor{comment}{// cout << "{}cx\_select\_ouc(): (*y\_ptr) = "{} << (*y\_ptr) << endl;}}
\DoxyCodeLine{7255   }
\DoxyCodeLine{7256   \textcolor{keyword}{const} std::complex<T>\& x = (*x\_ptr);}
\DoxyCodeLine{7257   \textcolor{keyword}{const} std::complex<T>\& y = (*y\_ptr);}
\DoxyCodeLine{7258   }
\DoxyCodeLine{7259   \textcolor{keywordflow}{if}( (y.real() == T(0)) \&\& (y.imag() == T(0)) )}
\DoxyCodeLine{7260     \{}
\DoxyCodeLine{7261     \textcolor{keywordflow}{return} ((x.real() == T(0)) \&\& (x.imag() == T(0))) ? blas\_int(0) : blas\_int(1);  \textcolor{comment}{// consider an infinite eig value to be outside of the unit circle}}
\DoxyCodeLine{7262     \}}
\DoxyCodeLine{7263   }
\DoxyCodeLine{7264   \textcolor{keywordflow}{return} (std::abs(x / y) > T(1)) ? blas\_int(1) : blas\_int(0);}
\DoxyCodeLine{7265   \}}
\DoxyCodeLine{7266 }
\DoxyCodeLine{7267 }
\DoxyCodeLine{7268 }
\DoxyCodeLine{7269 \textcolor{comment}{// need to do shenanigans with pointers due to:}}
\DoxyCodeLine{7270 \textcolor{comment}{// -\/ we're using LAPACK ?gges() defined to expect pointer-\/to-\/function to be passed as pointer-\/to-\/object}}
\DoxyCodeLine{7271 \textcolor{comment}{// -\/ explicit casting between pointer-\/to-\/function and pointer-\/to-\/object is a non-\/standard extension in C}}
\DoxyCodeLine{7272 \textcolor{comment}{// -\/ the extension is essentially mandatory on POSIX systems}}
\DoxyCodeLine{7273 \textcolor{comment}{// -\/ some compilers will complain about the extension in pedantic mode}}
\DoxyCodeLine{7274 }
\DoxyCodeLine{7275 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{7276 \textcolor{keyword}{inline}}
\DoxyCodeLine{7277 void\_ptr}
\DoxyCodeLine{7278 ptr\_cast(blas\_int (*\mbox{\hyperlink{classfunction}{function}})(\textcolor{keyword}{const} T*, \textcolor{keyword}{const} T*, \textcolor{keyword}{const} T*))}
\DoxyCodeLine{7279   \{}
\DoxyCodeLine{7280   \textcolor{keyword}{union }converter}
\DoxyCodeLine{7281     \{}
\DoxyCodeLine{7282     blas\_int (*fn)(\textcolor{keyword}{const} T*, \textcolor{keyword}{const} T*, \textcolor{keyword}{const} T*);}
\DoxyCodeLine{7283     void\_ptr obj;}
\DoxyCodeLine{7284     \};}
\DoxyCodeLine{7285   }
\DoxyCodeLine{7286   converter tmp;}
\DoxyCodeLine{7287   }
\DoxyCodeLine{7288   tmp.obj = 0;}
\DoxyCodeLine{7289   tmp.fn  = \mbox{\hyperlink{classfunction}{function}};}
\DoxyCodeLine{7290   }
\DoxyCodeLine{7291   \textcolor{keywordflow}{return} tmp.obj;}
\DoxyCodeLine{7292   \}}
\DoxyCodeLine{7293 }
\DoxyCodeLine{7294 }
\DoxyCodeLine{7295 }
\DoxyCodeLine{7296 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{7297 \textcolor{keyword}{inline}}
\DoxyCodeLine{7298 void\_ptr}
\DoxyCodeLine{7299 ptr\_cast(blas\_int (*\mbox{\hyperlink{classfunction}{function}})(\textcolor{keyword}{const} std::complex<T>*, \textcolor{keyword}{const} std::complex<T>*))}
\DoxyCodeLine{7300   \{}
\DoxyCodeLine{7301   \textcolor{keyword}{union }converter}
\DoxyCodeLine{7302     \{}
\DoxyCodeLine{7303     blas\_int (*fn)(\textcolor{keyword}{const} std::complex<T>*, \textcolor{keyword}{const} std::complex<T>*);}
\DoxyCodeLine{7304     void\_ptr obj;}
\DoxyCodeLine{7305     \};}
\DoxyCodeLine{7306   }
\DoxyCodeLine{7307   converter tmp;}
\DoxyCodeLine{7308   }
\DoxyCodeLine{7309   tmp.obj = 0;}
\DoxyCodeLine{7310   tmp.fn  = \mbox{\hyperlink{classfunction}{function}};}
\DoxyCodeLine{7311   }
\DoxyCodeLine{7312   \textcolor{keywordflow}{return} tmp.obj;}
\DoxyCodeLine{7313   \}}
\DoxyCodeLine{7314 }
\DoxyCodeLine{7315 }
\DoxyCodeLine{7316 }
\DoxyCodeLine{7317 \}  \textcolor{comment}{// end of namespace qz\_helper}}
\DoxyCodeLine{7318 }
\DoxyCodeLine{7319 }

\end{DoxyCode}
