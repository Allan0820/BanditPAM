\hypertarget{operator__times_8hpp_source}{}\doxysection{operator\+\_\+times.\+hpp}
\label{operator__times_8hpp_source}\index{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/operator\_times.hpp@{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/operator\_times.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008-\/2016 Conrad Sanderson (http://conradsanderson.id.au)}}
\DoxyCodeLine{2 \textcolor{comment}{// Copyright 2008-\/2016 National ICT Australia (NICTA)}}
\DoxyCodeLine{3 \textcolor{comment}{// }}
\DoxyCodeLine{4 \textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{5 \textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{6 \textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{7 \textcolor{comment}{// http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{8 \textcolor{comment}{// }}
\DoxyCodeLine{9 \textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{10 \textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{11 \textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{12 \textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{13 \textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{14 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{19 }
\DoxyCodeLine{20 }
\DoxyCodeLine{21 }
\DoxyCodeLine{23 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{24 arma\_inline}
\DoxyCodeLine{25 \textcolor{keyword}{typename} \mbox{\hyperlink{structenable__if2}{enable\_if2< is\_arma\_type<T1>::value}}, \textcolor{keyword}{const} \mbox{\hyperlink{classeOp}{eOp<T1, eop\_scalar\_times>}} >::result}
\DoxyCodeLine{26 \textcolor{keyword}{operator}*}
\DoxyCodeLine{27 (\textcolor{keyword}{const} T1\& X, \textcolor{keyword}{const} \textcolor{keyword}{typename} T1::elem\_type k)}
\DoxyCodeLine{28   \{}
\DoxyCodeLine{29   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{30   }
\DoxyCodeLine{31   \textcolor{keywordflow}{return} \mbox{\hyperlink{classeOp}{eOp<T1, eop\_scalar\_times>}}(X,k);}
\DoxyCodeLine{32   \}}
\DoxyCodeLine{33 }
\DoxyCodeLine{34 }
\DoxyCodeLine{35 }
\DoxyCodeLine{37 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{38 arma\_inline}
\DoxyCodeLine{39 \textcolor{keyword}{typename} \mbox{\hyperlink{structenable__if2}{enable\_if2< is\_arma\_type<T1>::value}}, \textcolor{keyword}{const} \mbox{\hyperlink{classeOp}{eOp<T1, eop\_scalar\_times>}} >::result}
\DoxyCodeLine{40 \textcolor{keyword}{operator}*}
\DoxyCodeLine{41 (\textcolor{keyword}{const} \textcolor{keyword}{typename} T1::elem\_type k, \textcolor{keyword}{const} T1\& X)}
\DoxyCodeLine{42   \{}
\DoxyCodeLine{43   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{44   }
\DoxyCodeLine{45   \textcolor{keywordflow}{return} \mbox{\hyperlink{classeOp}{eOp<T1, eop\_scalar\_times>}}(X,k);  \textcolor{comment}{// NOTE: order is swapped}}
\DoxyCodeLine{46   \}}
\DoxyCodeLine{47 }
\DoxyCodeLine{48 }
\DoxyCodeLine{49 }
\DoxyCodeLine{51 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{52 arma\_inline}
\DoxyCodeLine{53 \textcolor{keyword}{typename}}
\DoxyCodeLine{54 \mbox{\hyperlink{structenable__if2}{enable\_if2}}}
\DoxyCodeLine{55   <}
\DoxyCodeLine{56   (\mbox{\hyperlink{structis__arma__type}{is\_arma\_type<T1>::value}} \&\& \mbox{\hyperlink{structis__cx}{is\_cx<typename T1::elem\_type>::no}}),}
\DoxyCodeLine{57   \textcolor{keyword}{const} \mbox{\hyperlink{classmtOp}{mtOp}}<\textcolor{keyword}{typename} std::complex<typename T1::pod\_type>, T1, \mbox{\hyperlink{classop__cx__scalar__times}{op\_cx\_scalar\_times}}>}
\DoxyCodeLine{58   >::result}
\DoxyCodeLine{59 \textcolor{keyword}{operator}*}
\DoxyCodeLine{60   (}
\DoxyCodeLine{61   \textcolor{keyword}{const} T1\&                                  X,}
\DoxyCodeLine{62   \textcolor{keyword}{const} std::complex<typename T1::pod\_type>\& k}
\DoxyCodeLine{63   )}
\DoxyCodeLine{64   \{}
\DoxyCodeLine{65   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{66   }
\DoxyCodeLine{67   \textcolor{keywordflow}{return} \mbox{\hyperlink{classmtOp}{mtOp<typename std::complex<typename T1::pod\_type>}}, T1, \mbox{\hyperlink{classop__cx__scalar__times}{op\_cx\_scalar\_times}}>(\textcolor{charliteral}{'j'}, X, k);}
\DoxyCodeLine{68   \}}
\DoxyCodeLine{69 }
\DoxyCodeLine{70 }
\DoxyCodeLine{71 }
\DoxyCodeLine{73 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{74 arma\_inline}
\DoxyCodeLine{75 \textcolor{keyword}{typename}}
\DoxyCodeLine{76 \mbox{\hyperlink{structenable__if2}{enable\_if2}}}
\DoxyCodeLine{77   <}
\DoxyCodeLine{78   (\mbox{\hyperlink{structis__arma__type}{is\_arma\_type<T1>::value}} \&\& \mbox{\hyperlink{structis__cx}{is\_cx<typename T1::elem\_type>::no}}),}
\DoxyCodeLine{79   \textcolor{keyword}{const} \mbox{\hyperlink{classmtOp}{mtOp}}<\textcolor{keyword}{typename} std::complex<typename T1::pod\_type>, T1, \mbox{\hyperlink{classop__cx__scalar__times}{op\_cx\_scalar\_times}}>}
\DoxyCodeLine{80   >::result}
\DoxyCodeLine{81 \textcolor{keyword}{operator}*}
\DoxyCodeLine{82   (}
\DoxyCodeLine{83   \textcolor{keyword}{const} std::complex<typename T1::pod\_type>\& k,}
\DoxyCodeLine{84   \textcolor{keyword}{const} T1\&                                  X}
\DoxyCodeLine{85   )}
\DoxyCodeLine{86   \{}
\DoxyCodeLine{87   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{88   }
\DoxyCodeLine{89   \textcolor{keywordflow}{return} \mbox{\hyperlink{classmtOp}{mtOp<typename std::complex<typename T1::pod\_type>}}, T1, \mbox{\hyperlink{classop__cx__scalar__times}{op\_cx\_scalar\_times}}>(\textcolor{charliteral}{'j'}, X, k);}
\DoxyCodeLine{90   \}}
\DoxyCodeLine{91 }
\DoxyCodeLine{92 }
\DoxyCodeLine{93 }
\DoxyCodeLine{95 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{96 arma\_inline}
\DoxyCodeLine{97 \textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T1, op\_htrans2>}}}
\DoxyCodeLine{98 \textcolor{keyword}{operator}*}
\DoxyCodeLine{99 (\textcolor{keyword}{const} \textcolor{keyword}{typename} T1::elem\_type k, \textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T1, op\_htrans>}}\& X)}
\DoxyCodeLine{100   \{}
\DoxyCodeLine{101   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{102   }
\DoxyCodeLine{103   \textcolor{keywordflow}{return} \mbox{\hyperlink{classOp}{Op<T1, op\_htrans2>}}(X.m, k);}
\DoxyCodeLine{104   \}}
\DoxyCodeLine{105 }
\DoxyCodeLine{106 }
\DoxyCodeLine{107 }
\DoxyCodeLine{109 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{110 arma\_inline}
\DoxyCodeLine{111 \textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T1, op\_htrans2>}}}
\DoxyCodeLine{112 \textcolor{keyword}{operator}*}
\DoxyCodeLine{113 (\textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T1, op\_htrans>}}\& X, \textcolor{keyword}{const} \textcolor{keyword}{typename} T1::elem\_type k)}
\DoxyCodeLine{114   \{}
\DoxyCodeLine{115   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{116   }
\DoxyCodeLine{117   \textcolor{keywordflow}{return} \mbox{\hyperlink{classOp}{Op<T1, op\_htrans2>}}(X.m, k);}
\DoxyCodeLine{118   \}}
\DoxyCodeLine{119 }
\DoxyCodeLine{120 }
\DoxyCodeLine{121 }
\DoxyCodeLine{123 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{124 arma\_inline}
\DoxyCodeLine{125 \textcolor{keyword}{typename}}
\DoxyCodeLine{126 \mbox{\hyperlink{structenable__if2}{enable\_if2}}}
\DoxyCodeLine{127   <}
\DoxyCodeLine{128   (\mbox{\hyperlink{structis__arma__type}{is\_arma\_type<T1>::value}} \&\& \mbox{\hyperlink{structis__same__type}{is\_same\_type<typename T1::elem\_type, typename T2::elem\_type>::value}}),}
\DoxyCodeLine{129   \textcolor{keyword}{const} \mbox{\hyperlink{classGlue}{Glue}}<T1, \mbox{\hyperlink{classOp}{Op<T2, op\_diagmat>}}, \mbox{\hyperlink{classglue__times__diag}{glue\_times\_diag}}>}
\DoxyCodeLine{130   >::result}
\DoxyCodeLine{131 \textcolor{keyword}{operator}*}
\DoxyCodeLine{132 (\textcolor{keyword}{const} T1\& X, \textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T2, op\_diagmat>}}\& Y)}
\DoxyCodeLine{133   \{}
\DoxyCodeLine{134   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{135   }
\DoxyCodeLine{136   \textcolor{keywordflow}{return} \mbox{\hyperlink{classGlue}{Glue<T1, Op<T2, op\_diagmat>}}, \mbox{\hyperlink{classglue__times__diag}{glue\_times\_diag}}>(X, Y);}
\DoxyCodeLine{137   \}}
\DoxyCodeLine{138 }
\DoxyCodeLine{139 }
\DoxyCodeLine{140 }
\DoxyCodeLine{142 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{143 arma\_inline}
\DoxyCodeLine{144 \textcolor{keyword}{typename}}
\DoxyCodeLine{145 \mbox{\hyperlink{structenable__if2}{enable\_if2}}}
\DoxyCodeLine{146   <}
\DoxyCodeLine{147   (\mbox{\hyperlink{structis__arma__type}{is\_arma\_type<T2>::value}} \&\& \mbox{\hyperlink{structis__same__type}{is\_same\_type<typename T1::elem\_type, typename T2::elem\_type>::value}}),}
\DoxyCodeLine{148   \textcolor{keyword}{const} \mbox{\hyperlink{classGlue}{Glue}}<\mbox{\hyperlink{classOp}{Op<T1, op\_diagmat>}}, T2, \mbox{\hyperlink{classglue__times__diag}{glue\_times\_diag}}>}
\DoxyCodeLine{149   >::result}
\DoxyCodeLine{150 \textcolor{keyword}{operator}*}
\DoxyCodeLine{151 (\textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T1, op\_diagmat>}}\& X, \textcolor{keyword}{const} T2\& Y)}
\DoxyCodeLine{152   \{}
\DoxyCodeLine{153   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{154   }
\DoxyCodeLine{155   \textcolor{keywordflow}{return} \mbox{\hyperlink{classGlue}{Glue<Op<T1, op\_diagmat>}}, T2, \mbox{\hyperlink{classglue__times__diag}{glue\_times\_diag}}>(X, Y);}
\DoxyCodeLine{156   \}}
\DoxyCodeLine{157 }
\DoxyCodeLine{158 }
\DoxyCodeLine{159 }
\DoxyCodeLine{161 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{162 \textcolor{keyword}{inline}}
\DoxyCodeLine{163 \mbox{\hyperlink{classMat}{Mat< typename promote\_type<typename T1::elem\_type, typename T2::elem\_type>::result}} >}
\DoxyCodeLine{164 \textcolor{keyword}{operator}*}
\DoxyCodeLine{165 (\textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T1, op\_diagmat>}}\& X, \textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T2, op\_diagmat>}}\& Y)}
\DoxyCodeLine{166   \{}
\DoxyCodeLine{167   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{168   }
\DoxyCodeLine{169   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT1;}
\DoxyCodeLine{170   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T2::elem\_type eT2;}
\DoxyCodeLine{171   }
\DoxyCodeLine{172   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} promote\_type<eT1,eT2>::result out\_eT;}
\DoxyCodeLine{173   }
\DoxyCodeLine{174   \mbox{\hyperlink{structpromote__type}{promote\_type<eT1,eT2>::check}}();}
\DoxyCodeLine{175   }
\DoxyCodeLine{176   \textcolor{keyword}{const} \mbox{\hyperlink{classdiagmat__proxy}{diagmat\_proxy<T1>}} \mbox{\hyperlink{structA}{A}}(X.m);}
\DoxyCodeLine{177   \textcolor{keyword}{const} \mbox{\hyperlink{classdiagmat__proxy}{diagmat\_proxy<T2>}} \mbox{\hyperlink{structB}{B}}(Y.m);}
\DoxyCodeLine{178   }
\DoxyCodeLine{179   arma\_debug\_assert\_mul\_size(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structB}{B}}.n\_rows, \mbox{\hyperlink{structB}{B}}.n\_cols, \textcolor{stringliteral}{"{}matrix multiplication"{}});}
\DoxyCodeLine{180   }
\DoxyCodeLine{181   \mbox{\hyperlink{classMat}{Mat<out\_eT>}} out(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structB}{B}}.n\_cols, \mbox{\hyperlink{structarma__zeros__indicator}{arma\_zeros\_indicator}}());}
\DoxyCodeLine{182   }
\DoxyCodeLine{183   \textcolor{keyword}{const} uword A\_length = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{184   \textcolor{keyword}{const} uword B\_length = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(\mbox{\hyperlink{structB}{B}}.n\_rows, \mbox{\hyperlink{structB}{B}}.n\_cols);}
\DoxyCodeLine{185   }
\DoxyCodeLine{186   \textcolor{keyword}{const} uword N = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(A\_length, B\_length);}
\DoxyCodeLine{187   }
\DoxyCodeLine{188   \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)}
\DoxyCodeLine{189     \{}
\DoxyCodeLine{190     out.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,i) = \mbox{\hyperlink{structupgrade__val}{upgrade\_val<eT1,eT2>::apply}}( \mbox{\hyperlink{structA}{A}}[i] ) * \mbox{\hyperlink{structupgrade__val}{upgrade\_val<eT1,eT2>::apply}}( \mbox{\hyperlink{structB}{B}}[i] );}
\DoxyCodeLine{191     \}}
\DoxyCodeLine{192   }
\DoxyCodeLine{193   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{194   \}}
\DoxyCodeLine{195 }
\DoxyCodeLine{196 }
\DoxyCodeLine{197 }
\DoxyCodeLine{199 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{200 arma\_inline}
\DoxyCodeLine{201 \textcolor{keyword}{typename}}
\DoxyCodeLine{202 \mbox{\hyperlink{structenable__if2}{enable\_if2}}}
\DoxyCodeLine{203   <}
\DoxyCodeLine{204   \mbox{\hyperlink{structis__arma__type}{is\_arma\_type<T1>::value}} \&\& \mbox{\hyperlink{structis__arma__type}{is\_arma\_type<T2>::value}} \&\& \mbox{\hyperlink{structis__same__type}{is\_same\_type<typename T1::elem\_type, typename T2::elem\_type>::value}},}
\DoxyCodeLine{205   \textcolor{keyword}{const} \mbox{\hyperlink{classGlue}{Glue<T1, T2, glue\_times>}}}
\DoxyCodeLine{206   >::result}
\DoxyCodeLine{207 \textcolor{keyword}{operator}*}
\DoxyCodeLine{208 (\textcolor{keyword}{const} T1\& X, \textcolor{keyword}{const} T2\& Y)}
\DoxyCodeLine{209   \{}
\DoxyCodeLine{210   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{211   }
\DoxyCodeLine{212   \textcolor{keywordflow}{return} \mbox{\hyperlink{classGlue}{Glue<T1, T2, glue\_times>}}(X, Y);}
\DoxyCodeLine{213   \}}
\DoxyCodeLine{214 }
\DoxyCodeLine{215 }
\DoxyCodeLine{216 }
\DoxyCodeLine{218 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{219 \textcolor{keyword}{inline}}
\DoxyCodeLine{220 \textcolor{keyword}{typename}}
\DoxyCodeLine{221 \mbox{\hyperlink{structenable__if2}{enable\_if2}}}
\DoxyCodeLine{222   <}
\DoxyCodeLine{223   (\mbox{\hyperlink{structis__arma__type}{is\_arma\_type<T1>::value}} \&\& \mbox{\hyperlink{structis__arma__type}{is\_arma\_type<T2>::value}} \&\& (\mbox{\hyperlink{structis__same__type}{is\_same\_type<typename T1::elem\_type, typename T2::elem\_type>::no}})),}
\DoxyCodeLine{224   \textcolor{keyword}{const} \mbox{\hyperlink{classmtGlue}{mtGlue< typename promote\_type<typename T1::elem\_type, typename T2::elem\_type>::result}}, T1, T2, \mbox{\hyperlink{classglue__mixed__times}{glue\_mixed\_times}} >}
\DoxyCodeLine{225   >::result}
\DoxyCodeLine{226 \textcolor{keyword}{operator}*}
\DoxyCodeLine{227   (}
\DoxyCodeLine{228   \textcolor{keyword}{const} T1\& X,}
\DoxyCodeLine{229   \textcolor{keyword}{const} T2\& Y}
\DoxyCodeLine{230   )}
\DoxyCodeLine{231   \{}
\DoxyCodeLine{232   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{233   }
\DoxyCodeLine{234   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT1;}
\DoxyCodeLine{235   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T2::elem\_type eT2;}
\DoxyCodeLine{236   }
\DoxyCodeLine{237   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} promote\_type<eT1,eT2>::result out\_eT;}
\DoxyCodeLine{238   }
\DoxyCodeLine{239   \mbox{\hyperlink{structpromote__type}{promote\_type<eT1,eT2>::check}}();}
\DoxyCodeLine{240   }
\DoxyCodeLine{241   \textcolor{keywordflow}{return} \mbox{\hyperlink{classmtGlue}{mtGlue<out\_eT, T1, T2, glue\_mixed\_times>}}( X, Y );}
\DoxyCodeLine{242   \}}
\DoxyCodeLine{243 }
\DoxyCodeLine{244 }
\DoxyCodeLine{245 }
\DoxyCodeLine{247 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{248 \textcolor{keyword}{inline}}
\DoxyCodeLine{249 \textcolor{keyword}{typename}}
\DoxyCodeLine{250 \mbox{\hyperlink{structenable__if2}{enable\_if2}}}
\DoxyCodeLine{251   <}
\DoxyCodeLine{252   \mbox{\hyperlink{structis__arma__sparse__type}{is\_arma\_sparse\_type<T1>::value}},}
\DoxyCodeLine{253   \mbox{\hyperlink{classSpOp}{SpOp<T1,spop\_scalar\_times>}}}
\DoxyCodeLine{254   >::result}
\DoxyCodeLine{255 \textcolor{keyword}{operator}*}
\DoxyCodeLine{256   (}
\DoxyCodeLine{257   \textcolor{keyword}{const} T1\& X,}
\DoxyCodeLine{258   \textcolor{keyword}{const} \textcolor{keyword}{typename} T1::elem\_type k}
\DoxyCodeLine{259   )}
\DoxyCodeLine{260   \{}
\DoxyCodeLine{261   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{262   }
\DoxyCodeLine{263   \textcolor{keywordflow}{return} \mbox{\hyperlink{classSpOp}{SpOp<T1,spop\_scalar\_times>}}(X, k);}
\DoxyCodeLine{264   \}}
\DoxyCodeLine{265 }
\DoxyCodeLine{266 }
\DoxyCodeLine{267 }
\DoxyCodeLine{268 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{269 \textcolor{keyword}{inline}}
\DoxyCodeLine{270 \textcolor{keyword}{typename}}
\DoxyCodeLine{271 \mbox{\hyperlink{structenable__if2}{enable\_if2}}}
\DoxyCodeLine{272   <}
\DoxyCodeLine{273   \mbox{\hyperlink{structis__arma__sparse__type}{is\_arma\_sparse\_type<T1>::value}},}
\DoxyCodeLine{274   \mbox{\hyperlink{classSpOp}{SpOp<T1,spop\_scalar\_times>}}}
\DoxyCodeLine{275   >::result}
\DoxyCodeLine{276 \textcolor{keyword}{operator}*}
\DoxyCodeLine{277   (}
\DoxyCodeLine{278   \textcolor{keyword}{const} \textcolor{keyword}{typename} T1::elem\_type k,}
\DoxyCodeLine{279   \textcolor{keyword}{const} T1\& X}
\DoxyCodeLine{280   )}
\DoxyCodeLine{281   \{}
\DoxyCodeLine{282   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{283   }
\DoxyCodeLine{284   \textcolor{keywordflow}{return} \mbox{\hyperlink{classSpOp}{SpOp<T1,spop\_scalar\_times>}}(X, k);}
\DoxyCodeLine{285   \}}
\DoxyCodeLine{286 }
\DoxyCodeLine{287 }
\DoxyCodeLine{288 }
\DoxyCodeLine{290 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{291 arma\_inline}
\DoxyCodeLine{292 \textcolor{keyword}{typename}}
\DoxyCodeLine{293 \mbox{\hyperlink{structenable__if2}{enable\_if2}}}
\DoxyCodeLine{294   <}
\DoxyCodeLine{295   (\mbox{\hyperlink{structis__arma__sparse__type}{is\_arma\_sparse\_type<T1>::value}} \&\& \mbox{\hyperlink{structis__cx}{is\_cx<typename T1::elem\_type>::no}}),}
\DoxyCodeLine{296   \textcolor{keyword}{const} \mbox{\hyperlink{classmtSpOp}{mtSpOp}}<\textcolor{keyword}{typename} std::complex<typename T1::pod\_type>, T1, \mbox{\hyperlink{classspop__cx__scalar__times}{spop\_cx\_scalar\_times}}>}
\DoxyCodeLine{297   >::result}
\DoxyCodeLine{298 \textcolor{keyword}{operator}*}
\DoxyCodeLine{299   (}
\DoxyCodeLine{300   \textcolor{keyword}{const} T1\&                                  X,}
\DoxyCodeLine{301   \textcolor{keyword}{const} std::complex<typename T1::pod\_type>\& k}
\DoxyCodeLine{302   )}
\DoxyCodeLine{303   \{}
\DoxyCodeLine{304   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{305   }
\DoxyCodeLine{306   \textcolor{keywordflow}{return} \mbox{\hyperlink{classmtSpOp}{mtSpOp<typename std::complex<typename T1::pod\_type>}}, T1, \mbox{\hyperlink{classspop__cx__scalar__times}{spop\_cx\_scalar\_times}}>(\textcolor{charliteral}{'j'}, X, k);}
\DoxyCodeLine{307   \}}
\DoxyCodeLine{308 }
\DoxyCodeLine{309 }
\DoxyCodeLine{310 }
\DoxyCodeLine{312 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{313 arma\_inline}
\DoxyCodeLine{314 \textcolor{keyword}{typename}}
\DoxyCodeLine{315 \mbox{\hyperlink{structenable__if2}{enable\_if2}}}
\DoxyCodeLine{316   <}
\DoxyCodeLine{317   (\mbox{\hyperlink{structis__arma__sparse__type}{is\_arma\_sparse\_type<T1>::value}} \&\& \mbox{\hyperlink{structis__cx}{is\_cx<typename T1::elem\_type>::no}}),}
\DoxyCodeLine{318   \textcolor{keyword}{const} \mbox{\hyperlink{classmtSpOp}{mtSpOp}}<\textcolor{keyword}{typename} std::complex<typename T1::pod\_type>, T1, \mbox{\hyperlink{classspop__cx__scalar__times}{spop\_cx\_scalar\_times}}>}
\DoxyCodeLine{319   >::result}
\DoxyCodeLine{320 \textcolor{keyword}{operator}*}
\DoxyCodeLine{321   (}
\DoxyCodeLine{322   \textcolor{keyword}{const} std::complex<typename T1::pod\_type>\& k,}
\DoxyCodeLine{323   \textcolor{keyword}{const} T1\&                                  X}
\DoxyCodeLine{324   )}
\DoxyCodeLine{325   \{}
\DoxyCodeLine{326   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{327   }
\DoxyCodeLine{328   \textcolor{keywordflow}{return} \mbox{\hyperlink{classmtSpOp}{mtSpOp<typename std::complex<typename T1::pod\_type>}}, T1, \mbox{\hyperlink{classspop__cx__scalar__times}{spop\_cx\_scalar\_times}}>(\textcolor{charliteral}{'j'}, X, k);}
\DoxyCodeLine{329   \}}
\DoxyCodeLine{330 }
\DoxyCodeLine{331 }
\DoxyCodeLine{332 }
\DoxyCodeLine{334 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{335 \textcolor{keyword}{inline}}
\DoxyCodeLine{336 \textcolor{keyword}{typename}}
\DoxyCodeLine{337 \mbox{\hyperlink{structenable__if2}{enable\_if2}}}
\DoxyCodeLine{338   <}
\DoxyCodeLine{339   (\mbox{\hyperlink{structis__arma__sparse__type}{is\_arma\_sparse\_type<T1>::value}} \&\& \mbox{\hyperlink{structis__arma__sparse__type}{is\_arma\_sparse\_type<T2>::value}} \&\& \mbox{\hyperlink{structis__same__type}{is\_same\_type<typename T1::elem\_type, typename T2::elem\_type>::value}}),}
\DoxyCodeLine{340   \textcolor{keyword}{const} \mbox{\hyperlink{classSpGlue}{SpGlue<T1,T2,spglue\_times>}}}
\DoxyCodeLine{341   >::result}
\DoxyCodeLine{342 \textcolor{keyword}{operator}*}
\DoxyCodeLine{343   (}
\DoxyCodeLine{344   \textcolor{keyword}{const} T1\& x,}
\DoxyCodeLine{345   \textcolor{keyword}{const} T2\& y}
\DoxyCodeLine{346   )}
\DoxyCodeLine{347   \{}
\DoxyCodeLine{348   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{349 }
\DoxyCodeLine{350   \textcolor{keywordflow}{return} \mbox{\hyperlink{classSpGlue}{SpGlue<T1,T2,spglue\_times>}}(x, y);}
\DoxyCodeLine{351   \}}
\DoxyCodeLine{352 }
\DoxyCodeLine{353 }
\DoxyCodeLine{354 }
\DoxyCodeLine{356 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{357 \textcolor{keyword}{inline}}
\DoxyCodeLine{358 \textcolor{keyword}{typename}}
\DoxyCodeLine{359 \mbox{\hyperlink{structenable__if2}{enable\_if2}}}
\DoxyCodeLine{360   <}
\DoxyCodeLine{361   (\mbox{\hyperlink{structis__arma__sparse__type}{is\_arma\_sparse\_type<T1>::value}} \&\& \mbox{\hyperlink{structis__arma__type}{is\_arma\_type<T2>::value}} \&\& \mbox{\hyperlink{structis__same__type}{is\_same\_type<typename T1::elem\_type, typename T2::elem\_type>::value}}),}
\DoxyCodeLine{362   \mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}}
\DoxyCodeLine{363   >::result}
\DoxyCodeLine{364 \textcolor{keyword}{operator}*}
\DoxyCodeLine{365   (}
\DoxyCodeLine{366   \textcolor{keyword}{const} T1\& x,}
\DoxyCodeLine{367   \textcolor{keyword}{const} T2\& y}
\DoxyCodeLine{368   )}
\DoxyCodeLine{369   \{}
\DoxyCodeLine{370   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{371   }
\DoxyCodeLine{372   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{373   }
\DoxyCodeLine{374   \mbox{\hyperlink{classMat}{Mat<eT>}} result;}
\DoxyCodeLine{375   }
\DoxyCodeLine{376   spglue\_times\_misc::sparse\_times\_dense(result, x, y);}
\DoxyCodeLine{377   }
\DoxyCodeLine{378   \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{379   \}}
\DoxyCodeLine{380 }
\DoxyCodeLine{381 }
\DoxyCodeLine{382 }
\DoxyCodeLine{384 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{385 \textcolor{keyword}{inline}}
\DoxyCodeLine{386 \textcolor{keyword}{typename}}
\DoxyCodeLine{387 \mbox{\hyperlink{structenable__if2}{enable\_if2}}}
\DoxyCodeLine{388   <}
\DoxyCodeLine{389   (\mbox{\hyperlink{structis__arma__type}{is\_arma\_type<T1>::value}} \&\& \mbox{\hyperlink{structis__arma__sparse__type}{is\_arma\_sparse\_type<T2>::value}} \&\& \mbox{\hyperlink{structis__same__type}{is\_same\_type<typename T1::elem\_type, typename T2::elem\_type>::value}}),}
\DoxyCodeLine{390   \mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}}
\DoxyCodeLine{391   >::result}
\DoxyCodeLine{392 \textcolor{keyword}{operator}*}
\DoxyCodeLine{393   (}
\DoxyCodeLine{394   \textcolor{keyword}{const} T1\& x,}
\DoxyCodeLine{395   \textcolor{keyword}{const} T2\& y}
\DoxyCodeLine{396   )}
\DoxyCodeLine{397   \{}
\DoxyCodeLine{398   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{399   }
\DoxyCodeLine{400   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{401   }
\DoxyCodeLine{402   \mbox{\hyperlink{classMat}{Mat<eT>}} result;}
\DoxyCodeLine{403   }
\DoxyCodeLine{404   spglue\_times\_misc::dense\_times\_sparse(result, x, y);}
\DoxyCodeLine{405   }
\DoxyCodeLine{406   \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{407   \}}
\DoxyCodeLine{408 }
\DoxyCodeLine{409 }
\DoxyCodeLine{410 }
\DoxyCodeLine{412 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{413 \textcolor{keyword}{inline}}
\DoxyCodeLine{414 \textcolor{keyword}{typename}}
\DoxyCodeLine{415 \mbox{\hyperlink{structenable__if2}{enable\_if2}}}
\DoxyCodeLine{416   <}
\DoxyCodeLine{417   (\mbox{\hyperlink{structis__arma__sparse__type}{is\_arma\_sparse\_type<T1>::value}} \&\& \mbox{\hyperlink{structis__arma__sparse__type}{is\_arma\_sparse\_type<T2>::value}} \&\& (\mbox{\hyperlink{structis__same__type}{is\_same\_type<typename T1::elem\_type, typename T2::elem\_type>::no}})),}
\DoxyCodeLine{418   \textcolor{keyword}{const} \mbox{\hyperlink{classmtSpGlue}{mtSpGlue< typename promote\_type<typename T1::elem\_type, typename T2::elem\_type>::result}}, T1, T2, \mbox{\hyperlink{classspglue__times__mixed}{spglue\_times\_mixed}} >}
\DoxyCodeLine{419   >::result}
\DoxyCodeLine{420 \textcolor{keyword}{operator}*}
\DoxyCodeLine{421   (}
\DoxyCodeLine{422   \textcolor{keyword}{const} T1\& X,}
\DoxyCodeLine{423   \textcolor{keyword}{const} T2\& Y}
\DoxyCodeLine{424   )}
\DoxyCodeLine{425   \{}
\DoxyCodeLine{426   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{427   }
\DoxyCodeLine{428   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT1;}
\DoxyCodeLine{429   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T2::elem\_type eT2;}
\DoxyCodeLine{430   }
\DoxyCodeLine{431   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} promote\_type<eT1,eT2>::result out\_eT;}
\DoxyCodeLine{432   }
\DoxyCodeLine{433   \mbox{\hyperlink{structpromote__type}{promote\_type<eT1,eT2>::check}}();}
\DoxyCodeLine{434   }
\DoxyCodeLine{435   \textcolor{keywordflow}{return} \mbox{\hyperlink{classmtSpGlue}{mtSpGlue<out\_eT, T1, T2, spglue\_times\_mixed>}}( X, Y );}
\DoxyCodeLine{436   \}}
\DoxyCodeLine{437 }
\DoxyCodeLine{438 }
\DoxyCodeLine{439 }
\DoxyCodeLine{441 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{442 \textcolor{keyword}{inline}}
\DoxyCodeLine{443 \textcolor{keyword}{typename}}
\DoxyCodeLine{444 \mbox{\hyperlink{structenable__if2}{enable\_if2}}}
\DoxyCodeLine{445   <}
\DoxyCodeLine{446   (\mbox{\hyperlink{structis__arma__sparse__type}{is\_arma\_sparse\_type<T1>::value}} \&\& \mbox{\hyperlink{structis__arma__type}{is\_arma\_type<T2>::value}} \&\& \mbox{\hyperlink{structis__same__type}{is\_same\_type<typename T1::elem\_type, typename T2::elem\_type>::no}}),}
\DoxyCodeLine{447   \mbox{\hyperlink{classMat}{Mat}}< \textcolor{keyword}{typename} promote\_type<typename T1::elem\_type, typename T2::elem\_type>::result >}
\DoxyCodeLine{448   >::result}
\DoxyCodeLine{449 \textcolor{keyword}{operator}*}
\DoxyCodeLine{450   (}
\DoxyCodeLine{451   \textcolor{keyword}{const} T1\& X,}
\DoxyCodeLine{452   \textcolor{keyword}{const} T2\& Y}
\DoxyCodeLine{453   )}
\DoxyCodeLine{454   \{}
\DoxyCodeLine{455   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{456   }
\DoxyCodeLine{457   \mbox{\hyperlink{classMat}{Mat< typename promote\_type<typename T1::elem\_type, typename T2::elem\_type>::result}} > out;}
\DoxyCodeLine{458   }
\DoxyCodeLine{459   spglue\_times\_mixed::sparse\_times\_dense(out, X, Y);}
\DoxyCodeLine{460   }
\DoxyCodeLine{461   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{462   \}}
\DoxyCodeLine{463 }
\DoxyCodeLine{464 }
\DoxyCodeLine{465 }
\DoxyCodeLine{467 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{468 \textcolor{keyword}{inline}}
\DoxyCodeLine{469 \textcolor{keyword}{typename}}
\DoxyCodeLine{470 \mbox{\hyperlink{structenable__if2}{enable\_if2}}}
\DoxyCodeLine{471   <}
\DoxyCodeLine{472   (\mbox{\hyperlink{structis__arma__type}{is\_arma\_type<T1>::value}} \&\& \mbox{\hyperlink{structis__arma__sparse__type}{is\_arma\_sparse\_type<T2>::value}} \&\& \mbox{\hyperlink{structis__same__type}{is\_same\_type<typename T1::elem\_type, typename T2::elem\_type>::no}}),}
\DoxyCodeLine{473   \mbox{\hyperlink{classMat}{Mat}}< \textcolor{keyword}{typename} promote\_type<typename T1::elem\_type, typename T2::elem\_type>::result >}
\DoxyCodeLine{474   >::result}
\DoxyCodeLine{475 \textcolor{keyword}{operator}*}
\DoxyCodeLine{476   (}
\DoxyCodeLine{477   \textcolor{keyword}{const} T1\& X,}
\DoxyCodeLine{478   \textcolor{keyword}{const} T2\& Y}
\DoxyCodeLine{479   )}
\DoxyCodeLine{480   \{}
\DoxyCodeLine{481   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{482   }
\DoxyCodeLine{483   \mbox{\hyperlink{classMat}{Mat< typename promote\_type<typename T1::elem\_type, typename T2::elem\_type>::result}} > out;}
\DoxyCodeLine{484   }
\DoxyCodeLine{485   spglue\_times\_mixed::dense\_times\_sparse(out, X, Y);}
\DoxyCodeLine{486   }
\DoxyCodeLine{487   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{488   \}}
\DoxyCodeLine{489 }
\DoxyCodeLine{490 }
\DoxyCodeLine{491 }

\end{DoxyCode}
