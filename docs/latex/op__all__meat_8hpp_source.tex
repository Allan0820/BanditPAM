\hypertarget{op__all__meat_8hpp_source}{}\doxysection{op\+\_\+all\+\_\+meat.\+hpp}
\label{op__all__meat_8hpp_source}\index{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/op\_all\_meat.hpp@{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/op\_all\_meat.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008-\/2016 Conrad Sanderson (http://conradsanderson.id.au)}}
\DoxyCodeLine{2 \textcolor{comment}{// Copyright 2008-\/2016 National ICT Australia (NICTA)}}
\DoxyCodeLine{3 \textcolor{comment}{// }}
\DoxyCodeLine{4 \textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{5 \textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{6 \textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{7 \textcolor{comment}{// http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{8 \textcolor{comment}{// }}
\DoxyCodeLine{9 \textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{10 \textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{11 \textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{12 \textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{13 \textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{14 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{17 }
\DoxyCodeLine{20 }
\DoxyCodeLine{21 }
\DoxyCodeLine{22 }
\DoxyCodeLine{23 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{24 \textcolor{keyword}{inline}}
\DoxyCodeLine{25 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{26 op\_all::all\_vec\_helper(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::elem\_type, T1>}}\& X)}
\DoxyCodeLine{27   \{}
\DoxyCodeLine{28   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{29   }
\DoxyCodeLine{30   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{31   }
\DoxyCodeLine{32   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} P(X.get\_ref());}
\DoxyCodeLine{33   }
\DoxyCodeLine{34   \textcolor{keyword}{const} uword n\_elem = P.get\_n\_elem();}
\DoxyCodeLine{35   }
\DoxyCodeLine{36   uword count = 0;}
\DoxyCodeLine{37   }
\DoxyCodeLine{38   \textcolor{keywordflow}{if}(\mbox{\hyperlink{classProxy}{Proxy<T1>::use\_at}} == \textcolor{keyword}{false})}
\DoxyCodeLine{39     \{}
\DoxyCodeLine{40     \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::ea\_type}} Pea = P.get\_ea();}
\DoxyCodeLine{41     }
\DoxyCodeLine{42     \textcolor{keywordflow}{for}(uword i=0; i<n\_elem; ++i)}
\DoxyCodeLine{43       \{}
\DoxyCodeLine{44       count += (Pea[i] != eT(0)) ? uword(1) : uword(0);}
\DoxyCodeLine{45       \}}
\DoxyCodeLine{46     \}}
\DoxyCodeLine{47   \textcolor{keywordflow}{else}}
\DoxyCodeLine{48     \{}
\DoxyCodeLine{49     \textcolor{keyword}{const} uword n\_rows = P.get\_n\_rows();}
\DoxyCodeLine{50     \textcolor{keyword}{const} uword n\_cols = P.get\_n\_cols();}
\DoxyCodeLine{51     }
\DoxyCodeLine{52     \textcolor{keywordflow}{for}(uword col=0; col < n\_cols; ++col)}
\DoxyCodeLine{53     \textcolor{keywordflow}{for}(uword row=0; row < n\_rows; ++row)}
\DoxyCodeLine{54       \{}
\DoxyCodeLine{55       count += (P.at(row,col) != eT(0)) ? uword(1) : uword(0);}
\DoxyCodeLine{56       \}}
\DoxyCodeLine{57     \}}
\DoxyCodeLine{58   }
\DoxyCodeLine{59   \textcolor{comment}{// NOTE: for empty vectors it makes more sense to return false, but we need to return true for compatibility with Octave}}
\DoxyCodeLine{60   \textcolor{keywordflow}{return} (n\_elem == count);}
\DoxyCodeLine{61   \}}
\DoxyCodeLine{62 }
\DoxyCodeLine{63 }
\DoxyCodeLine{64 }
\DoxyCodeLine{65 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{66 \textcolor{keyword}{inline}}
\DoxyCodeLine{67 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{68 op\_all::all\_vec\_helper(\textcolor{keyword}{const} \mbox{\hyperlink{classsubview}{subview<eT>}}\& X)}
\DoxyCodeLine{69   \{}
\DoxyCodeLine{70   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{71   }
\DoxyCodeLine{72   \textcolor{keyword}{const} uword X\_n\_rows = X.n\_rows;}
\DoxyCodeLine{73   \textcolor{keyword}{const} uword X\_n\_cols = X.n\_cols;}
\DoxyCodeLine{74   }
\DoxyCodeLine{75   uword count = 0;}
\DoxyCodeLine{76   }
\DoxyCodeLine{77   \textcolor{keywordflow}{if}(X\_n\_rows == 1)}
\DoxyCodeLine{78     \{}
\DoxyCodeLine{79     \textcolor{keywordflow}{for}(uword col=0; col < X\_n\_cols; ++col)}
\DoxyCodeLine{80       \{}
\DoxyCodeLine{81       count += (X.at(0,col) != eT(0)) ? uword(1) : uword(0);}
\DoxyCodeLine{82       \}}
\DoxyCodeLine{83     \}}
\DoxyCodeLine{84   \textcolor{keywordflow}{else}}
\DoxyCodeLine{85     \{}
\DoxyCodeLine{86     \textcolor{keywordflow}{for}(uword col=0; col < X\_n\_cols; ++col)}
\DoxyCodeLine{87       \{}
\DoxyCodeLine{88       \textcolor{keyword}{const} eT* X\_colmem = X.colptr(col);}
\DoxyCodeLine{89       }
\DoxyCodeLine{90       \textcolor{keywordflow}{for}(uword row=0; row < X\_n\_rows; ++row)}
\DoxyCodeLine{91         \{}
\DoxyCodeLine{92         count += (X\_colmem[row] != eT(0)) ? uword(1) : uword(0);}
\DoxyCodeLine{93         \}}
\DoxyCodeLine{94       \}}
\DoxyCodeLine{95     \}}
\DoxyCodeLine{96   }
\DoxyCodeLine{97   \textcolor{keywordflow}{return} (X.n\_elem == count);}
\DoxyCodeLine{98   \}}
\DoxyCodeLine{99 }
\DoxyCodeLine{100 }
\DoxyCodeLine{101 }
\DoxyCodeLine{102 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{103 \textcolor{keyword}{inline}}
\DoxyCodeLine{104 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{105 op\_all::all\_vec\_helper(\textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T1, op\_vectorise\_col>}}\& X)}
\DoxyCodeLine{106   \{}
\DoxyCodeLine{107   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{108   }
\DoxyCodeLine{109   \textcolor{keywordflow}{return} op\_all::all\_vec\_helper(X.m);}
\DoxyCodeLine{110   \}}
\DoxyCodeLine{111 }
\DoxyCodeLine{112 }
\DoxyCodeLine{113 }
\DoxyCodeLine{114 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} op\_type>}
\DoxyCodeLine{115 \textcolor{keyword}{inline}}
\DoxyCodeLine{116 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{117 op\_all::all\_vec\_helper}
\DoxyCodeLine{118   (}
\DoxyCodeLine{119   \textcolor{keyword}{const} \mbox{\hyperlink{classmtOp}{mtOp<uword, T1, op\_type>}}\& X,}
\DoxyCodeLine{120   \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__op__rel__only}{arma\_op\_rel\_only<op\_type>::result}}*           junk1,}
\DoxyCodeLine{121   \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<typename T1::elem\_type>::result* junk2}
\DoxyCodeLine{122   )}
\DoxyCodeLine{123   \{}
\DoxyCodeLine{124   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{125   arma\_ignore(junk1);}
\DoxyCodeLine{126   arma\_ignore(junk2);}
\DoxyCodeLine{127   }
\DoxyCodeLine{128   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{129   }
\DoxyCodeLine{130   \textcolor{keyword}{const} eT val = X.aux;}
\DoxyCodeLine{131   }
\DoxyCodeLine{132   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} P(X.m);}
\DoxyCodeLine{133   }
\DoxyCodeLine{134   \textcolor{keyword}{const} uword n\_elem = P.get\_n\_elem();}
\DoxyCodeLine{135   }
\DoxyCodeLine{136   uword count = 0;}
\DoxyCodeLine{137   }
\DoxyCodeLine{138   \textcolor{keywordflow}{if}(\mbox{\hyperlink{classProxy}{Proxy<T1>::use\_at}} == \textcolor{keyword}{false})}
\DoxyCodeLine{139     \{}
\DoxyCodeLine{140     \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::ea\_type}} Pea = P.get\_ea();}
\DoxyCodeLine{141     }
\DoxyCodeLine{142     \textcolor{keywordflow}{for}(uword i=0; i < n\_elem; ++i)}
\DoxyCodeLine{143       \{}
\DoxyCodeLine{144       \textcolor{keyword}{const} eT tmp = Pea[i];}
\DoxyCodeLine{145       }
\DoxyCodeLine{146            \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_lt\_pre   >::yes}})  \{ count += (val <  tmp) ? uword(1) : uword(0); \}}
\DoxyCodeLine{147       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_lt\_post  >::yes}})  \{ count += (tmp <  val) ? uword(1) : uword(0); \}}
\DoxyCodeLine{148       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_gt\_pre   >::yes}})  \{ count += (val >  tmp) ? uword(1) : uword(0); \}}
\DoxyCodeLine{149       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_gt\_post  >::yes}})  \{ count += (tmp >  val) ? uword(1) : uword(0); \}}
\DoxyCodeLine{150       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_lteq\_pre >::yes}})  \{ count += (val <= tmp) ? uword(1) : uword(0); \}}
\DoxyCodeLine{151       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_lteq\_post>::yes}})  \{ count += (tmp <= val) ? uword(1) : uword(0); \}}
\DoxyCodeLine{152       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_gteq\_pre >::yes}})  \{ count += (val >= tmp) ? uword(1) : uword(0); \}}
\DoxyCodeLine{153       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_gteq\_post>::yes}})  \{ count += (tmp >= val) ? uword(1) : uword(0); \}}
\DoxyCodeLine{154       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_eq       >::yes}})  \{ count += (tmp == val) ? uword(1) : uword(0); \}}
\DoxyCodeLine{155       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_noteq    >::yes}})  \{ count += (tmp != val) ? uword(1) : uword(0); \}}
\DoxyCodeLine{156       \}}
\DoxyCodeLine{157     \}}
\DoxyCodeLine{158   \textcolor{keywordflow}{else}}
\DoxyCodeLine{159     \{}
\DoxyCodeLine{160     \textcolor{keyword}{const} uword n\_rows = P.get\_n\_rows();}
\DoxyCodeLine{161     \textcolor{keyword}{const} uword n\_cols = P.get\_n\_cols();}
\DoxyCodeLine{162     }
\DoxyCodeLine{163     \textcolor{keywordflow}{for}(uword col=0; col < n\_cols; ++col)}
\DoxyCodeLine{164     \textcolor{keywordflow}{for}(uword row=0; row < n\_rows; ++row)}
\DoxyCodeLine{165       \{}
\DoxyCodeLine{166       \textcolor{keyword}{const} eT tmp = P.at(row,col);}
\DoxyCodeLine{167       }
\DoxyCodeLine{168            \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_lt\_pre   >::yes}})  \{ \textcolor{keywordflow}{if}(val <  tmp) \{ ++count; \} \}}
\DoxyCodeLine{169       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_lt\_post  >::yes}})  \{ \textcolor{keywordflow}{if}(tmp <  val) \{ ++count; \} \}}
\DoxyCodeLine{170       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_gt\_pre   >::yes}})  \{ \textcolor{keywordflow}{if}(val >  tmp) \{ ++count; \} \}}
\DoxyCodeLine{171       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_gt\_post  >::yes}})  \{ \textcolor{keywordflow}{if}(tmp >  val) \{ ++count; \} \}}
\DoxyCodeLine{172       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_lteq\_pre >::yes}})  \{ \textcolor{keywordflow}{if}(val <= tmp) \{ ++count; \} \}}
\DoxyCodeLine{173       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_lteq\_post>::yes}})  \{ \textcolor{keywordflow}{if}(tmp <= val) \{ ++count; \} \}}
\DoxyCodeLine{174       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_gteq\_pre >::yes}})  \{ \textcolor{keywordflow}{if}(val >= tmp) \{ ++count; \} \}}
\DoxyCodeLine{175       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_gteq\_post>::yes}})  \{ \textcolor{keywordflow}{if}(tmp >= val) \{ ++count; \} \}}
\DoxyCodeLine{176       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_eq       >::yes}})  \{ \textcolor{keywordflow}{if}(tmp == val) \{ ++count; \} \}}
\DoxyCodeLine{177       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_noteq    >::yes}})  \{ \textcolor{keywordflow}{if}(tmp != val) \{ ++count; \} \}}
\DoxyCodeLine{178       \}}
\DoxyCodeLine{179     \}}
\DoxyCodeLine{180   }
\DoxyCodeLine{181   \textcolor{keywordflow}{return} (n\_elem == count);}
\DoxyCodeLine{182   \}}
\DoxyCodeLine{183 }
\DoxyCodeLine{184 }
\DoxyCodeLine{185 }
\DoxyCodeLine{186 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2, \textcolor{keyword}{typename} glue\_type>}
\DoxyCodeLine{187 \textcolor{keyword}{inline}}
\DoxyCodeLine{188 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{189 op\_all::all\_vec\_helper}
\DoxyCodeLine{190   (}
\DoxyCodeLine{191   \textcolor{keyword}{const} \mbox{\hyperlink{classmtGlue}{mtGlue<uword, T1, T2, glue\_type>}}\& X,}
\DoxyCodeLine{192   \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__glue__rel__only}{arma\_glue\_rel\_only<glue\_type>::result}}*       junk1,}
\DoxyCodeLine{193   \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<typename T1::elem\_type>::result* junk2,}
\DoxyCodeLine{194   \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<typename T2::elem\_type>::result* junk3}
\DoxyCodeLine{195   )}
\DoxyCodeLine{196   \{}
\DoxyCodeLine{197   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{198   arma\_ignore(junk1);}
\DoxyCodeLine{199   arma\_ignore(junk2);}
\DoxyCodeLine{200   arma\_ignore(junk3);}
\DoxyCodeLine{201   }
\DoxyCodeLine{202   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT1;}
\DoxyCodeLine{203   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T2::elem\_type eT2;}
\DoxyCodeLine{204   }
\DoxyCodeLine{205   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::ea\_type}} ea\_type1;}
\DoxyCodeLine{206   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T2>::ea\_type}} ea\_type2;}
\DoxyCodeLine{207   }
\DoxyCodeLine{208   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} \mbox{\hyperlink{structA}{A}}(X.A);}
\DoxyCodeLine{209   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T2>}} \mbox{\hyperlink{structB}{B}}(X.B);}
\DoxyCodeLine{210   }
\DoxyCodeLine{211   arma\_debug\_assert\_same\_size(\mbox{\hyperlink{structA}{A}}, \mbox{\hyperlink{structB}{B}}, \textcolor{stringliteral}{"{}relational operator"{}});}
\DoxyCodeLine{212   }
\DoxyCodeLine{213   \textcolor{keyword}{const} uword n\_elem = \mbox{\hyperlink{structA}{A}}.get\_n\_elem();}
\DoxyCodeLine{214   }
\DoxyCodeLine{215   uword count = 0;}
\DoxyCodeLine{216   }
\DoxyCodeLine{217   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_at = (\mbox{\hyperlink{classProxy}{Proxy<T1>::use\_at}} || \mbox{\hyperlink{classProxy}{Proxy<T2>::use\_at}});}
\DoxyCodeLine{218   }
\DoxyCodeLine{219   \textcolor{keywordflow}{if}(use\_at == \textcolor{keyword}{false})}
\DoxyCodeLine{220     \{}
\DoxyCodeLine{221     ea\_type1 PA = \mbox{\hyperlink{structA}{A}}.get\_ea();}
\DoxyCodeLine{222     ea\_type2 PB = \mbox{\hyperlink{structB}{B}}.get\_ea();}
\DoxyCodeLine{223     }
\DoxyCodeLine{224     \textcolor{keywordflow}{for}(uword i=0; i<n\_elem; ++i)}
\DoxyCodeLine{225       \{}
\DoxyCodeLine{226       \textcolor{keyword}{const} eT1 tmp1 = PA[i];}
\DoxyCodeLine{227       \textcolor{keyword}{const} eT2 tmp2 = PB[i];}
\DoxyCodeLine{228       }
\DoxyCodeLine{229            \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_lt    >::yes}})  \{ count += (tmp1 <  tmp2) ? uword(1) : uword(0); \}}
\DoxyCodeLine{230       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_gt    >::yes}})  \{ count += (tmp1 >  tmp2) ? uword(1) : uword(0); \}}
\DoxyCodeLine{231       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_lteq  >::yes}})  \{ count += (tmp1 <= tmp2) ? uword(1) : uword(0); \}}
\DoxyCodeLine{232       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_gteq  >::yes}})  \{ count += (tmp1 >= tmp2) ? uword(1) : uword(0); \}}
\DoxyCodeLine{233       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_eq    >::yes}})  \{ count += (tmp1 == tmp2) ? uword(1) : uword(0); \}}
\DoxyCodeLine{234       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_noteq >::yes}})  \{ count += (tmp1 != tmp2) ? uword(1) : uword(0); \}}
\DoxyCodeLine{235       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_and   >::yes}})  \{ count += (tmp1 \&\& tmp2) ? uword(1) : uword(0); \}}
\DoxyCodeLine{236       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_or    >::yes}})  \{ count += (tmp1 || tmp2) ? uword(1) : uword(0); \}}
\DoxyCodeLine{237       \}}
\DoxyCodeLine{238     \}}
\DoxyCodeLine{239   \textcolor{keywordflow}{else}}
\DoxyCodeLine{240     \{}
\DoxyCodeLine{241     \textcolor{keyword}{const} uword n\_rows = \mbox{\hyperlink{structA}{A}}.get\_n\_rows();}
\DoxyCodeLine{242     \textcolor{keyword}{const} uword n\_cols = \mbox{\hyperlink{structA}{A}}.get\_n\_cols();}
\DoxyCodeLine{243     }
\DoxyCodeLine{244     \textcolor{keywordflow}{for}(uword col=0; col < n\_cols; ++col)}
\DoxyCodeLine{245     \textcolor{keywordflow}{for}(uword row=0; row < n\_rows; ++row)}
\DoxyCodeLine{246       \{}
\DoxyCodeLine{247       \textcolor{keyword}{const} eT1 tmp1 = \mbox{\hyperlink{structA}{A}}.at(row,col);}
\DoxyCodeLine{248       \textcolor{keyword}{const} eT2 tmp2 = \mbox{\hyperlink{structB}{B}}.at(row,col);}
\DoxyCodeLine{249       }
\DoxyCodeLine{250            \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_lt    >::yes}})  \{ \textcolor{keywordflow}{if}(tmp1 <  tmp2) \{ ++count; \} \}}
\DoxyCodeLine{251       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_gt    >::yes}})  \{ \textcolor{keywordflow}{if}(tmp1 >  tmp2) \{ ++count; \} \}}
\DoxyCodeLine{252       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_lteq  >::yes}})  \{ \textcolor{keywordflow}{if}(tmp1 <= tmp2) \{ ++count; \} \}}
\DoxyCodeLine{253       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_gteq  >::yes}})  \{ \textcolor{keywordflow}{if}(tmp1 >= tmp2) \{ ++count; \} \}}
\DoxyCodeLine{254       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_eq    >::yes}})  \{ \textcolor{keywordflow}{if}(tmp1 == tmp2) \{ ++count; \} \}}
\DoxyCodeLine{255       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_noteq >::yes}})  \{ \textcolor{keywordflow}{if}(tmp1 != tmp2) \{ ++count; \} \}}
\DoxyCodeLine{256       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_and   >::yes}})  \{ \textcolor{keywordflow}{if}(tmp1 \&\& tmp2) \{ ++count; \} \}}
\DoxyCodeLine{257       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_or    >::yes}})  \{ \textcolor{keywordflow}{if}(tmp1 || tmp2) \{ ++count; \} \}}
\DoxyCodeLine{258       \}}
\DoxyCodeLine{259     \}}
\DoxyCodeLine{260   }
\DoxyCodeLine{261   \textcolor{keywordflow}{return} (n\_elem == count);}
\DoxyCodeLine{262   \}}
\DoxyCodeLine{263 }
\DoxyCodeLine{264 }
\DoxyCodeLine{265 }
\DoxyCodeLine{266 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{267 \textcolor{keyword}{inline}}
\DoxyCodeLine{268 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{269 op\_all::all\_vec(T1\& X)}
\DoxyCodeLine{270   \{}
\DoxyCodeLine{271   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{272   }
\DoxyCodeLine{273   \textcolor{keywordflow}{return} op\_all::all\_vec\_helper(X);}
\DoxyCodeLine{274   \}}
\DoxyCodeLine{275 }
\DoxyCodeLine{276 }
\DoxyCodeLine{277 }
\DoxyCodeLine{278 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{279 \textcolor{keyword}{inline}}
\DoxyCodeLine{280 \textcolor{keywordtype}{void}}
\DoxyCodeLine{281 op\_all::apply\_helper(\mbox{\hyperlink{classMat}{Mat<uword>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}}\& P, \textcolor{keyword}{const} uword dim)}
\DoxyCodeLine{282   \{}
\DoxyCodeLine{283   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{284   }
\DoxyCodeLine{285   \textcolor{keyword}{const} uword n\_rows = P.get\_n\_rows();}
\DoxyCodeLine{286   \textcolor{keyword}{const} uword n\_cols = P.get\_n\_cols();}
\DoxyCodeLine{287   }
\DoxyCodeLine{288   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::elem\_type}} eT;}
\DoxyCodeLine{289   }
\DoxyCodeLine{290   \textcolor{keywordflow}{if}(dim == 0)  \textcolor{comment}{// traverse rows (ie. process each column)}}
\DoxyCodeLine{291     \{}
\DoxyCodeLine{292     out.zeros(1, n\_cols);}
\DoxyCodeLine{293     }
\DoxyCodeLine{294     \textcolor{keywordflow}{if}(out.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}} == 0)  \{ \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{295     }
\DoxyCodeLine{296     uword* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{297     }
\DoxyCodeLine{298     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__Mat}{is\_Mat}}<\textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::stored\_type}}>::value)}
\DoxyCodeLine{299       \{}
\DoxyCodeLine{300       \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap}{unwrap<typename Proxy<T1>::stored\_type}}> U(P.Q);}
\DoxyCodeLine{301       }
\DoxyCodeLine{302       \textcolor{keywordflow}{for}(uword col=0; col < n\_cols; ++col)}
\DoxyCodeLine{303         \{}
\DoxyCodeLine{304         \textcolor{keyword}{const} eT* colmem = U.M.colptr(col);}
\DoxyCodeLine{305         }
\DoxyCodeLine{306         uword count = 0;}
\DoxyCodeLine{307         }
\DoxyCodeLine{308         \textcolor{keywordflow}{for}(uword row=0; row < n\_rows; ++row)}
\DoxyCodeLine{309           \{}
\DoxyCodeLine{310           count += (colmem[row] != eT(0)) ? uword(1) : uword(0);}
\DoxyCodeLine{311           \}}
\DoxyCodeLine{312         }
\DoxyCodeLine{313         out\_mem[col] = (n\_rows == count) ? uword(1) : uword(0); }
\DoxyCodeLine{314         \}}
\DoxyCodeLine{315       \}}
\DoxyCodeLine{316     \textcolor{keywordflow}{else}}
\DoxyCodeLine{317       \{}
\DoxyCodeLine{318       \textcolor{keywordflow}{for}(uword col=0; col < n\_cols; ++col)}
\DoxyCodeLine{319         \{}
\DoxyCodeLine{320         uword count = 0;}
\DoxyCodeLine{321         }
\DoxyCodeLine{322         \textcolor{keywordflow}{for}(uword row=0; row < n\_rows; ++row)}
\DoxyCodeLine{323           \{}
\DoxyCodeLine{324           \textcolor{keywordflow}{if}(P.at(row,col) != eT(0))  \{ ++count; \}}
\DoxyCodeLine{325           \}}
\DoxyCodeLine{326         }
\DoxyCodeLine{327         out\_mem[col] = (n\_rows == count) ? uword(1) : uword(0); }
\DoxyCodeLine{328         \}}
\DoxyCodeLine{329       \}}
\DoxyCodeLine{330     \}}
\DoxyCodeLine{331   \textcolor{keywordflow}{else}}
\DoxyCodeLine{332     \{}
\DoxyCodeLine{333     out.zeros(n\_rows, 1);}
\DoxyCodeLine{334     }
\DoxyCodeLine{335     uword* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{336     }
\DoxyCodeLine{337     \textcolor{comment}{// internal dual use of 'out': keep the counts for each row}}
\DoxyCodeLine{338     }
\DoxyCodeLine{339     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__Mat}{is\_Mat}}<\textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::stored\_type}}>::value)}
\DoxyCodeLine{340       \{}
\DoxyCodeLine{341       \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap}{unwrap<typename Proxy<T1>::stored\_type}}> U(P.Q);}
\DoxyCodeLine{342       }
\DoxyCodeLine{343       \textcolor{keywordflow}{for}(uword col=0; col < n\_cols; ++col)}
\DoxyCodeLine{344         \{}
\DoxyCodeLine{345         \textcolor{keyword}{const} eT* colmem = U.M.colptr(col);}
\DoxyCodeLine{346         }
\DoxyCodeLine{347         \textcolor{keywordflow}{for}(uword row=0; row < n\_rows; ++row)}
\DoxyCodeLine{348           \{}
\DoxyCodeLine{349           out\_mem[row] += (colmem[row] != eT(0)) ? uword(1) : uword(0);}
\DoxyCodeLine{350           \}}
\DoxyCodeLine{351         \}}
\DoxyCodeLine{352       \}}
\DoxyCodeLine{353     \textcolor{keywordflow}{else}}
\DoxyCodeLine{354       \{}
\DoxyCodeLine{355       \textcolor{keywordflow}{for}(uword col=0; col < n\_cols; ++col)}
\DoxyCodeLine{356         \{}
\DoxyCodeLine{357         \textcolor{keywordflow}{for}(uword row=0; row < n\_rows; ++row)}
\DoxyCodeLine{358           \{}
\DoxyCodeLine{359           \textcolor{keywordflow}{if}(P.at(row,col) != eT(0))  \{ ++out\_mem[row]; \}}
\DoxyCodeLine{360           \}}
\DoxyCodeLine{361         \}}
\DoxyCodeLine{362       \}}
\DoxyCodeLine{363     }
\DoxyCodeLine{364     }
\DoxyCodeLine{365     \textcolor{comment}{// see what the counts tell us}}
\DoxyCodeLine{366     }
\DoxyCodeLine{367     \textcolor{keywordflow}{for}(uword row=0; row < n\_rows; ++row)}
\DoxyCodeLine{368       \{}
\DoxyCodeLine{369       out\_mem[row] = (n\_cols == out\_mem[row]) ? uword(1) : uword(0);}
\DoxyCodeLine{370       \}}
\DoxyCodeLine{371     }
\DoxyCodeLine{372     \}}
\DoxyCodeLine{373   \}}
\DoxyCodeLine{374 }
\DoxyCodeLine{375 }
\DoxyCodeLine{376 }
\DoxyCodeLine{377 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{378 \textcolor{keyword}{inline}}
\DoxyCodeLine{379 \textcolor{keywordtype}{void}}
\DoxyCodeLine{380 op\_all::apply(\mbox{\hyperlink{classMat}{Mat<uword>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classmtOp}{mtOp<uword, T1, op\_all>}}\& X)}
\DoxyCodeLine{381   \{}
\DoxyCodeLine{382   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{383   }
\DoxyCodeLine{384   \textcolor{keyword}{const} uword dim = X.aux\_uword\_a;}
\DoxyCodeLine{385   }
\DoxyCodeLine{386   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} P(X.m);}
\DoxyCodeLine{387   }
\DoxyCodeLine{388   \textcolor{keywordflow}{if}(P.is\_alias(out) == \textcolor{keyword}{false})}
\DoxyCodeLine{389     \{}
\DoxyCodeLine{390     op\_all::apply\_helper(out, P, dim);}
\DoxyCodeLine{391     \}}
\DoxyCodeLine{392   \textcolor{keywordflow}{else}}
\DoxyCodeLine{393     \{}
\DoxyCodeLine{394     \mbox{\hyperlink{classMat}{Mat<uword>}} out2;}
\DoxyCodeLine{395     }
\DoxyCodeLine{396     op\_all::apply\_helper(out2, P, dim);}
\DoxyCodeLine{397     }
\DoxyCodeLine{398     out.\mbox{\hyperlink{group__Mat_gaff06a75771f96605f7cc4f8c6b3fceb7}{steal\_mem}}(out2);}
\DoxyCodeLine{399     \}}
\DoxyCodeLine{400   \}}
\DoxyCodeLine{401 }
\DoxyCodeLine{402 }
\DoxyCodeLine{403 }

\end{DoxyCode}
