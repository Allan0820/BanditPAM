\hypertarget{glue__histc__meat_8hpp_source}{}\doxysection{glue\+\_\+histc\+\_\+meat.\+hpp}
\label{glue__histc__meat_8hpp_source}\index{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/glue\_histc\_meat.hpp@{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/glue\_histc\_meat.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008-\/2016 Conrad Sanderson (http://conradsanderson.id.au)}}
\DoxyCodeLine{2 \textcolor{comment}{// Copyright 2008-\/2016 National ICT Australia (NICTA)}}
\DoxyCodeLine{3 \textcolor{comment}{// }}
\DoxyCodeLine{4 \textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{5 \textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{6 \textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{7 \textcolor{comment}{// http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{8 \textcolor{comment}{// }}
\DoxyCodeLine{9 \textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{10 \textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{11 \textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{12 \textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{13 \textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{14 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{19 }
\DoxyCodeLine{20 }
\DoxyCodeLine{21 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{22 \textcolor{keyword}{inline}}
\DoxyCodeLine{23 \textcolor{keywordtype}{void}}
\DoxyCodeLine{24 glue\_histc::apply\_noalias(\mbox{\hyperlink{classMat}{Mat<uword>}}\& C, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structB}{B}}, \textcolor{keyword}{const} uword dim)}
\DoxyCodeLine{25   \{}
\DoxyCodeLine{26   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{27   }
\DoxyCodeLine{28   arma\_debug\_check( ((\mbox{\hyperlink{structB}{B}}.is\_vec() == \textcolor{keyword}{false}) \&\& (\mbox{\hyperlink{structB}{B}}.is\_empty() == \textcolor{keyword}{false})), \textcolor{stringliteral}{"{}histc(): parameter 'edges' must be a vector"{}} );}
\DoxyCodeLine{29   }
\DoxyCodeLine{30   \textcolor{keyword}{const} uword A\_n\_rows = \mbox{\hyperlink{structA}{A}}.n\_rows;}
\DoxyCodeLine{31   \textcolor{keyword}{const} uword A\_n\_cols = \mbox{\hyperlink{structA}{A}}.n\_cols;}
\DoxyCodeLine{32   }
\DoxyCodeLine{33   \textcolor{keyword}{const} uword B\_n\_elem = \mbox{\hyperlink{structB}{B}}.n\_elem;}
\DoxyCodeLine{34   }
\DoxyCodeLine{35   \textcolor{keywordflow}{if}( B\_n\_elem == uword(0) )  \{ C.reset(); \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{36   }
\DoxyCodeLine{37   arma\_debug\_check}
\DoxyCodeLine{38     (}
\DoxyCodeLine{39     ((\mbox{\hyperlink{classCol}{Col<eT>}}(\textcolor{keyword}{const\_cast<}eT*\textcolor{keyword}{>}(\mbox{\hyperlink{structB}{B}}.memptr()), B\_n\_elem, \textcolor{keyword}{false}, \textcolor{keyword}{false})).is\_sorted(\textcolor{stringliteral}{"{}strictascend"{}}) == \textcolor{keyword}{false}),}
\DoxyCodeLine{40     \textcolor{stringliteral}{"{}hist(): given 'edges' vector does not contain monotonically increasing values"{}}}
\DoxyCodeLine{41     );}
\DoxyCodeLine{42   }
\DoxyCodeLine{43   \textcolor{keyword}{const} eT*   B\_mem       = \mbox{\hyperlink{structB}{B}}.memptr();}
\DoxyCodeLine{44   \textcolor{keyword}{const} uword B\_n\_elem\_m1 = B\_n\_elem -\/ 1;}
\DoxyCodeLine{45   }
\DoxyCodeLine{46   \textcolor{keywordflow}{if}(dim == uword(0))}
\DoxyCodeLine{47     \{}
\DoxyCodeLine{48     C.zeros(B\_n\_elem, A\_n\_cols);}
\DoxyCodeLine{49     }
\DoxyCodeLine{50     \textcolor{keywordflow}{for}(uword col=0; col < A\_n\_cols; ++col)}
\DoxyCodeLine{51       \{}
\DoxyCodeLine{52       \textcolor{keyword}{const} eT*    A\_coldata = \mbox{\hyperlink{structA}{A}}.colptr(col);}
\DoxyCodeLine{53             uword* C\_coldata = C.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(col);}
\DoxyCodeLine{54       }
\DoxyCodeLine{55       \textcolor{keywordflow}{for}(uword row=0; row < A\_n\_rows; ++row)}
\DoxyCodeLine{56         \{}
\DoxyCodeLine{57         \textcolor{keyword}{const} eT x = A\_coldata[row];}
\DoxyCodeLine{58         }
\DoxyCodeLine{59         \textcolor{keywordflow}{for}(uword i=0; i < B\_n\_elem\_m1; ++i)}
\DoxyCodeLine{60           \{}
\DoxyCodeLine{61                \textcolor{keywordflow}{if}( (B\_mem[i]           <= x) \&\& (x < B\_mem[i+1]) )  \{ C\_coldata[i]++;           \textcolor{keywordflow}{break}; \}}
\DoxyCodeLine{62           \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(  B\_mem[B\_n\_elem\_m1] == x                      )  \{ C\_coldata[B\_n\_elem\_m1]++; \textcolor{keywordflow}{break}; \}    \textcolor{comment}{// for compatibility with Matlab}}
\DoxyCodeLine{63           \}}
\DoxyCodeLine{64         \}}
\DoxyCodeLine{65       \}}
\DoxyCodeLine{66     \}}
\DoxyCodeLine{67   \textcolor{keywordflow}{else}}
\DoxyCodeLine{68   \textcolor{keywordflow}{if}(dim == uword(1))}
\DoxyCodeLine{69     \{}
\DoxyCodeLine{70     C.zeros(A\_n\_rows, B\_n\_elem);}
\DoxyCodeLine{71     }
\DoxyCodeLine{72     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.n\_rows == 1)}
\DoxyCodeLine{73       \{}
\DoxyCodeLine{74       \textcolor{keyword}{const} uword  A\_n\_elem = \mbox{\hyperlink{structA}{A}}.n\_elem;}
\DoxyCodeLine{75       \textcolor{keyword}{const} eT*    A\_mem    = \mbox{\hyperlink{structA}{A}}.memptr();}
\DoxyCodeLine{76             uword* C\_mem    = C.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{77       }
\DoxyCodeLine{78       \textcolor{keywordflow}{for}(uword j=0; j < A\_n\_elem; ++j)}
\DoxyCodeLine{79         \{}
\DoxyCodeLine{80         \textcolor{keyword}{const} eT x = A\_mem[j];}
\DoxyCodeLine{81         }
\DoxyCodeLine{82         \textcolor{keywordflow}{for}(uword i=0; i < B\_n\_elem\_m1; ++i)}
\DoxyCodeLine{83           \{}
\DoxyCodeLine{84                \textcolor{keywordflow}{if}( (B\_mem[i]           <= x) \&\& (x < B\_mem[i+1]) )  \{ C\_mem[i]++;           \textcolor{keywordflow}{break}; \}}
\DoxyCodeLine{85           \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(  B\_mem[B\_n\_elem\_m1] == x                      )  \{ C\_mem[B\_n\_elem\_m1]++; \textcolor{keywordflow}{break}; \}    \textcolor{comment}{// for compatibility with Matlab}}
\DoxyCodeLine{86           \}}
\DoxyCodeLine{87         \}}
\DoxyCodeLine{88       \}}
\DoxyCodeLine{89     \textcolor{keywordflow}{else}}
\DoxyCodeLine{90       \{}
\DoxyCodeLine{91       \textcolor{keywordflow}{for}(uword row=0; row < A\_n\_rows; ++row)}
\DoxyCodeLine{92       \textcolor{keywordflow}{for}(uword col=0; col < A\_n\_cols; ++col)}
\DoxyCodeLine{93         \{}
\DoxyCodeLine{94         \textcolor{keyword}{const} eT x = \mbox{\hyperlink{structA}{A}}.at(row,col);}
\DoxyCodeLine{95         }
\DoxyCodeLine{96         \textcolor{keywordflow}{for}(uword i=0; i < B\_n\_elem\_m1; ++i)}
\DoxyCodeLine{97           \{}
\DoxyCodeLine{98                \textcolor{keywordflow}{if}( (B\_mem[i]            <= x) \&\& (x < B\_mem[i+1]) )  \{ C.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(row,i)++;           \textcolor{keywordflow}{break}; \}}
\DoxyCodeLine{99           \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(  B\_mem[B\_n\_elem\_m1]  == x                      )  \{ C.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(row,B\_n\_elem\_m1)++; \textcolor{keywordflow}{break}; \}   \textcolor{comment}{// for compatibility with Matlab}}
\DoxyCodeLine{100           \}}
\DoxyCodeLine{101         \}}
\DoxyCodeLine{102       \}}
\DoxyCodeLine{103     \}}
\DoxyCodeLine{104   \}}
\DoxyCodeLine{105 }
\DoxyCodeLine{106 }
\DoxyCodeLine{107 }
\DoxyCodeLine{108 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{109 \textcolor{keyword}{inline}}
\DoxyCodeLine{110 \textcolor{keywordtype}{void}}
\DoxyCodeLine{111 glue\_histc::apply(\mbox{\hyperlink{classMat}{Mat<uword>}}\& C, \textcolor{keyword}{const} \mbox{\hyperlink{classmtGlue}{mtGlue<uword,T1,T2,glue\_histc>}}\& expr)}
\DoxyCodeLine{112   \{}
\DoxyCodeLine{113   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{114   }
\DoxyCodeLine{115   \textcolor{keyword}{const} uword dim = expr.\mbox{\hyperlink{classmtGlue_ad18cf3b7394987c4983dd88ba7ed9a61}{aux\_uword}};}
\DoxyCodeLine{116   }
\DoxyCodeLine{117   arma\_debug\_check( (dim > 1), \textcolor{stringliteral}{"{}histc(): parameter 'dim' must be 0 or 1"{}} );}
\DoxyCodeLine{118   }
\DoxyCodeLine{119   \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} UA(expr.\mbox{\hyperlink{classmtGlue_a77131a39c19f01beaeaee66908385315}{A}});}
\DoxyCodeLine{120   \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T2>}} UB(expr.\mbox{\hyperlink{classmtGlue_a98973407d37b2496bab7af7032233f93}{B}});}
\DoxyCodeLine{121   }
\DoxyCodeLine{122   \textcolor{keywordflow}{if}(UA.is\_alias(C) || UB.is\_alias(C))}
\DoxyCodeLine{123     \{}
\DoxyCodeLine{124     \mbox{\hyperlink{classMat}{Mat<uword>}} tmp;}
\DoxyCodeLine{125     }
\DoxyCodeLine{126     glue\_histc::apply\_noalias(tmp, UA.M, UB.M, dim);}
\DoxyCodeLine{127     }
\DoxyCodeLine{128     C.\mbox{\hyperlink{group__Mat_gaff06a75771f96605f7cc4f8c6b3fceb7}{steal\_mem}}(tmp);}
\DoxyCodeLine{129     \}}
\DoxyCodeLine{130   \textcolor{keywordflow}{else}}
\DoxyCodeLine{131     \{}
\DoxyCodeLine{132     glue\_histc::apply\_noalias(C, UA.M, UB.M, dim);}
\DoxyCodeLine{133     \}}
\DoxyCodeLine{134   \}}
\DoxyCodeLine{135 }
\DoxyCodeLine{136 }
\DoxyCodeLine{137 }
\DoxyCodeLine{138 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{139 \textcolor{keyword}{inline}}
\DoxyCodeLine{140 \textcolor{keywordtype}{void}}
\DoxyCodeLine{141 glue\_histc\_default::apply(\mbox{\hyperlink{classMat}{Mat<uword>}}\& C, \textcolor{keyword}{const} \mbox{\hyperlink{classmtGlue}{mtGlue<uword,T1,T2,glue\_histc\_default>}}\& expr)}
\DoxyCodeLine{142   \{}
\DoxyCodeLine{143   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{144   }
\DoxyCodeLine{145   \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} UA(expr.\mbox{\hyperlink{classmtGlue_a77131a39c19f01beaeaee66908385315}{A}});}
\DoxyCodeLine{146   \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T2>}} UB(expr.\mbox{\hyperlink{classmtGlue_a98973407d37b2496bab7af7032233f93}{B}});}
\DoxyCodeLine{147   }
\DoxyCodeLine{148   \textcolor{keyword}{const} uword dim = (T1::is\_xvec) ? uword(UA.M.is\_rowvec() ? 1 : 0) : uword((T1::is\_row) ? 1 : 0);}
\DoxyCodeLine{149   }
\DoxyCodeLine{150   \textcolor{keywordflow}{if}(UA.is\_alias(C) || UB.is\_alias(C))}
\DoxyCodeLine{151     \{}
\DoxyCodeLine{152     \mbox{\hyperlink{classMat}{Mat<uword>}} tmp;}
\DoxyCodeLine{153     }
\DoxyCodeLine{154     glue\_histc::apply\_noalias(tmp, UA.M, UB.M, dim);}
\DoxyCodeLine{155     }
\DoxyCodeLine{156     C.\mbox{\hyperlink{group__Mat_gaff06a75771f96605f7cc4f8c6b3fceb7}{steal\_mem}}(tmp);}
\DoxyCodeLine{157     \}}
\DoxyCodeLine{158   \textcolor{keywordflow}{else}}
\DoxyCodeLine{159     \{}
\DoxyCodeLine{160     glue\_histc::apply\_noalias(C, UA.M, UB.M, dim);}
\DoxyCodeLine{161     \}}
\DoxyCodeLine{162   \}}
\DoxyCodeLine{163 }
\DoxyCodeLine{164 }

\end{DoxyCode}
