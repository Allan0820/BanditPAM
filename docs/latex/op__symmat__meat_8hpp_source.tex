\hypertarget{op__symmat__meat_8hpp_source}{}\doxysection{op\+\_\+symmat\+\_\+meat.\+hpp}
\label{op__symmat__meat_8hpp_source}\index{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/op\_symmat\_meat.hpp@{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/op\_symmat\_meat.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008-\/2016 Conrad Sanderson (http://conradsanderson.id.au)}}
\DoxyCodeLine{2 \textcolor{comment}{// Copyright 2008-\/2016 National ICT Australia (NICTA)}}
\DoxyCodeLine{3 \textcolor{comment}{// }}
\DoxyCodeLine{4 \textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{5 \textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{6 \textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{7 \textcolor{comment}{// http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{8 \textcolor{comment}{// }}
\DoxyCodeLine{9 \textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{10 \textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{11 \textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{12 \textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{13 \textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{14 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{19 }
\DoxyCodeLine{20 }
\DoxyCodeLine{21 }
\DoxyCodeLine{22 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{23 \textcolor{keyword}{inline}}
\DoxyCodeLine{24 \textcolor{keywordtype}{void}}
\DoxyCodeLine{25 op\_symmatu::apply(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T1,op\_symmatu>}}\& in)}
\DoxyCodeLine{26   \{}
\DoxyCodeLine{27   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{28   }
\DoxyCodeLine{29   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{30   }
\DoxyCodeLine{31   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap}{unwrap<T1>}}   tmp(in.\mbox{\hyperlink{classOp_af7ab7221b6e233cdd38b9f9b69f301ce}{m}});}
\DoxyCodeLine{32   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}} = tmp.M;}
\DoxyCodeLine{33   }
\DoxyCodeLine{34   arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.is\_square() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}symmatu(): given matrix must be square sized"{}} );}
\DoxyCodeLine{35   }
\DoxyCodeLine{36   \textcolor{keyword}{const} uword N = \mbox{\hyperlink{structA}{A}}.n\_rows;}
\DoxyCodeLine{37   }
\DoxyCodeLine{38   \textcolor{keywordflow}{if}(\&out != \&\mbox{\hyperlink{structA}{A}})}
\DoxyCodeLine{39     \{}
\DoxyCodeLine{40     out.\mbox{\hyperlink{group__Mat_ga9b739350523229ea160719b1ef106f96}{copy\_size}}(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{41     }
\DoxyCodeLine{42     \textcolor{comment}{// upper triangular: copy the diagonal and the elements above the diagonal}}
\DoxyCodeLine{43     }
\DoxyCodeLine{44     \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)}
\DoxyCodeLine{45       \{}
\DoxyCodeLine{46       \textcolor{keyword}{const} eT* A\_data   = \mbox{\hyperlink{structA}{A}}.colptr(i);}
\DoxyCodeLine{47             eT* out\_data = out.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(i);}
\DoxyCodeLine{48       }
\DoxyCodeLine{49       arrayops::copy( out\_data, A\_data, i+1 );}
\DoxyCodeLine{50       \}}
\DoxyCodeLine{51     \}}
\DoxyCodeLine{52   }
\DoxyCodeLine{53   }
\DoxyCodeLine{54   \textcolor{comment}{// reflect elements across the diagonal from upper triangle to lower triangle}}
\DoxyCodeLine{55   }
\DoxyCodeLine{56   \textcolor{keywordflow}{for}(uword col=1; col < N; ++col)}
\DoxyCodeLine{57     \{}
\DoxyCodeLine{58     \textcolor{keyword}{const} eT* coldata = out.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(col);}
\DoxyCodeLine{59           eT* row\_ptr = \&(out.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(col,0));}
\DoxyCodeLine{60     }
\DoxyCodeLine{61     \textcolor{keywordflow}{for}(uword row=0; row < col; ++row)}
\DoxyCodeLine{62       \{}
\DoxyCodeLine{63       \textcolor{comment}{// out.at(col,row) = coldata[row];}}
\DoxyCodeLine{64       }
\DoxyCodeLine{65       (*row\_ptr) = coldata[row];}
\DoxyCodeLine{66       row\_ptr += N;}
\DoxyCodeLine{67       \}}
\DoxyCodeLine{68     \}}
\DoxyCodeLine{69   \}}
\DoxyCodeLine{70 }
\DoxyCodeLine{71 }
\DoxyCodeLine{72 }
\DoxyCodeLine{73 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{74 \textcolor{keyword}{inline}}
\DoxyCodeLine{75 \textcolor{keywordtype}{void}}
\DoxyCodeLine{76 op\_symmatl::apply(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T1,op\_symmatl>}}\& in)}
\DoxyCodeLine{77   \{}
\DoxyCodeLine{78   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{79   }
\DoxyCodeLine{80   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{81   }
\DoxyCodeLine{82   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap}{unwrap<T1>}}   tmp(in.\mbox{\hyperlink{classOp_af7ab7221b6e233cdd38b9f9b69f301ce}{m}});}
\DoxyCodeLine{83   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}} = tmp.M;}
\DoxyCodeLine{84   }
\DoxyCodeLine{85   arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.is\_square() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}symmatl(): given matrix must be square sized"{}} );}
\DoxyCodeLine{86   }
\DoxyCodeLine{87   \textcolor{keyword}{const} uword N = \mbox{\hyperlink{structA}{A}}.n\_rows;}
\DoxyCodeLine{88   }
\DoxyCodeLine{89   \textcolor{keywordflow}{if}(\&out != \&\mbox{\hyperlink{structA}{A}})}
\DoxyCodeLine{90     \{}
\DoxyCodeLine{91     out.\mbox{\hyperlink{group__Mat_ga9b739350523229ea160719b1ef106f96}{copy\_size}}(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{92     }
\DoxyCodeLine{93     \textcolor{comment}{// lower triangular: copy the diagonal and the elements below the diagonal}}
\DoxyCodeLine{94     }
\DoxyCodeLine{95     \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)}
\DoxyCodeLine{96       \{}
\DoxyCodeLine{97       \textcolor{keyword}{const} eT* A\_data   = \mbox{\hyperlink{structA}{A}}.colptr(i);}
\DoxyCodeLine{98             eT* out\_data = out.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(i);}
\DoxyCodeLine{99       }
\DoxyCodeLine{100       arrayops::copy( \&out\_data[i], \&A\_data[i], N-\/i );}
\DoxyCodeLine{101       \}}
\DoxyCodeLine{102     \}}
\DoxyCodeLine{103   }
\DoxyCodeLine{104   }
\DoxyCodeLine{105   \textcolor{comment}{// reflect elements across the diagonal from lower triangle to upper triangle}}
\DoxyCodeLine{106   }
\DoxyCodeLine{107   \textcolor{keywordflow}{for}(uword col=0; col < N; ++col)}
\DoxyCodeLine{108     \{}
\DoxyCodeLine{109     \textcolor{keyword}{const} eT* coldata = out.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(col);}
\DoxyCodeLine{110           eT* row\_ptr = \&(out.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(col,col+1));}
\DoxyCodeLine{111     }
\DoxyCodeLine{112     \textcolor{keywordflow}{for}(uword row=(col+1); row < N; ++row)}
\DoxyCodeLine{113       \{}
\DoxyCodeLine{114       \textcolor{comment}{//out.at(col,row) = coldata[row];}}
\DoxyCodeLine{115       }
\DoxyCodeLine{116       (*row\_ptr) = coldata[row];}
\DoxyCodeLine{117       row\_ptr += N;}
\DoxyCodeLine{118       \}}
\DoxyCodeLine{119     \}}
\DoxyCodeLine{120   \}}
\DoxyCodeLine{121 }
\DoxyCodeLine{122 }
\DoxyCodeLine{123 }
\DoxyCodeLine{124 \textcolor{comment}{//}}
\DoxyCodeLine{125 }
\DoxyCodeLine{126 }
\DoxyCodeLine{127 }
\DoxyCodeLine{128 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{129 \textcolor{keyword}{inline}}
\DoxyCodeLine{130 \textcolor{keywordtype}{void}}
\DoxyCodeLine{131 op\_symmatu\_cx::apply(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T1,op\_symmatu\_cx>}}\& in)}
\DoxyCodeLine{132   \{}
\DoxyCodeLine{133   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{134   }
\DoxyCodeLine{135   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{136   }
\DoxyCodeLine{137   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap}{unwrap<T1>}}   tmp(in.\mbox{\hyperlink{classOp_af7ab7221b6e233cdd38b9f9b69f301ce}{m}});}
\DoxyCodeLine{138   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}} = tmp.M;}
\DoxyCodeLine{139   }
\DoxyCodeLine{140   arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.is\_square() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}symmatu(): given matrix must be square sized"{}} );}
\DoxyCodeLine{141   }
\DoxyCodeLine{142   \textcolor{keyword}{const} uword N  = \mbox{\hyperlink{structA}{A}}.n\_rows;}
\DoxyCodeLine{143   }
\DoxyCodeLine{144   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} do\_conj = (in.\mbox{\hyperlink{classOp_a489b7adb11aa809f594055a640713133}{aux\_uword\_b}} == 1);}
\DoxyCodeLine{145   }
\DoxyCodeLine{146   \textcolor{keywordflow}{if}(\&out != \&\mbox{\hyperlink{structA}{A}})}
\DoxyCodeLine{147     \{}
\DoxyCodeLine{148     out.\mbox{\hyperlink{group__Mat_ga9b739350523229ea160719b1ef106f96}{copy\_size}}(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{149     }
\DoxyCodeLine{150     \textcolor{comment}{// upper triangular: copy the diagonal and the elements above the diagonal}}
\DoxyCodeLine{151     }
\DoxyCodeLine{152     \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)}
\DoxyCodeLine{153       \{}
\DoxyCodeLine{154       \textcolor{keyword}{const} eT* A\_data   = \mbox{\hyperlink{structA}{A}}.colptr(i);}
\DoxyCodeLine{155             eT* out\_data = out.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(i);}
\DoxyCodeLine{156       }
\DoxyCodeLine{157       arrayops::copy( out\_data, A\_data, i+1 );}
\DoxyCodeLine{158       \}}
\DoxyCodeLine{159     \}}
\DoxyCodeLine{160   }
\DoxyCodeLine{161   }
\DoxyCodeLine{162   \textcolor{keywordflow}{if}(do\_conj)}
\DoxyCodeLine{163     \{}
\DoxyCodeLine{164     \textcolor{comment}{// reflect elements across the diagonal from upper triangle to lower triangle}}
\DoxyCodeLine{165     }
\DoxyCodeLine{166     \textcolor{keywordflow}{for}(uword col=1; col < N; ++col)}
\DoxyCodeLine{167       \{}
\DoxyCodeLine{168       \textcolor{keyword}{const} eT* coldata = out.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(col);}
\DoxyCodeLine{169             eT* row\_ptr = \&(out.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(col,0));}
\DoxyCodeLine{170       }
\DoxyCodeLine{171       \textcolor{keywordflow}{for}(uword row=0; row < col; ++row)}
\DoxyCodeLine{172         \{}
\DoxyCodeLine{173         \textcolor{comment}{// out.at(col,row) = std::conj(coldata[row]);}}
\DoxyCodeLine{174         }
\DoxyCodeLine{175         (*row\_ptr) = std::conj(coldata[row]);}
\DoxyCodeLine{176         row\_ptr += N;}
\DoxyCodeLine{177         \}}
\DoxyCodeLine{178       \}}
\DoxyCodeLine{179     \}}
\DoxyCodeLine{180   \textcolor{keywordflow}{else}  \textcolor{comment}{// don't do complex conjugation}}
\DoxyCodeLine{181     \{}
\DoxyCodeLine{182     \textcolor{comment}{// reflect elements across the diagonal from upper triangle to lower triangle}}
\DoxyCodeLine{183     }
\DoxyCodeLine{184     \textcolor{keywordflow}{for}(uword col=1; col < N; ++col)}
\DoxyCodeLine{185       \{}
\DoxyCodeLine{186       \textcolor{keyword}{const} eT* coldata = out.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(col);}
\DoxyCodeLine{187             eT* row\_ptr = \&(out.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(col,0));}
\DoxyCodeLine{188       }
\DoxyCodeLine{189       \textcolor{keywordflow}{for}(uword row=0; row < col; ++row)}
\DoxyCodeLine{190         \{}
\DoxyCodeLine{191         \textcolor{comment}{// out.at(col,row) = coldata[row];}}
\DoxyCodeLine{192         }
\DoxyCodeLine{193         (*row\_ptr) = coldata[row];}
\DoxyCodeLine{194         row\_ptr += N;}
\DoxyCodeLine{195         \}}
\DoxyCodeLine{196       \}}
\DoxyCodeLine{197     \}}
\DoxyCodeLine{198   \}}
\DoxyCodeLine{199 }
\DoxyCodeLine{200 }
\DoxyCodeLine{201 }
\DoxyCodeLine{202 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{203 \textcolor{keyword}{inline}}
\DoxyCodeLine{204 \textcolor{keywordtype}{void}}
\DoxyCodeLine{205 op\_symmatl\_cx::apply(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T1,op\_symmatl\_cx>}}\& in)}
\DoxyCodeLine{206   \{}
\DoxyCodeLine{207   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{208   }
\DoxyCodeLine{209   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{210   }
\DoxyCodeLine{211   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap}{unwrap<T1>}}   tmp(in.\mbox{\hyperlink{classOp_af7ab7221b6e233cdd38b9f9b69f301ce}{m}});}
\DoxyCodeLine{212   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}} = tmp.M;}
\DoxyCodeLine{213   }
\DoxyCodeLine{214   arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.is\_square() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}symmatl(): given matrix must be square sized"{}} );}
\DoxyCodeLine{215   }
\DoxyCodeLine{216   \textcolor{keyword}{const} uword N  = \mbox{\hyperlink{structA}{A}}.n\_rows;}
\DoxyCodeLine{217   }
\DoxyCodeLine{218   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} do\_conj = (in.\mbox{\hyperlink{classOp_a489b7adb11aa809f594055a640713133}{aux\_uword\_b}} == 1);}
\DoxyCodeLine{219   }
\DoxyCodeLine{220   \textcolor{keywordflow}{if}(\&out != \&\mbox{\hyperlink{structA}{A}})}
\DoxyCodeLine{221     \{}
\DoxyCodeLine{222     out.\mbox{\hyperlink{group__Mat_ga9b739350523229ea160719b1ef106f96}{copy\_size}}(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{223     }
\DoxyCodeLine{224     \textcolor{comment}{// lower triangular: copy the diagonal and the elements below the diagonal}}
\DoxyCodeLine{225     }
\DoxyCodeLine{226     \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)}
\DoxyCodeLine{227       \{}
\DoxyCodeLine{228       \textcolor{keyword}{const} eT* A\_data   = \mbox{\hyperlink{structA}{A}}.colptr(i);}
\DoxyCodeLine{229             eT* out\_data = out.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(i);}
\DoxyCodeLine{230       }
\DoxyCodeLine{231       arrayops::copy( \&out\_data[i], \&A\_data[i], N-\/i );}
\DoxyCodeLine{232       \}}
\DoxyCodeLine{233     \}}
\DoxyCodeLine{234   }
\DoxyCodeLine{235   }
\DoxyCodeLine{236   \textcolor{keywordflow}{if}(do\_conj)}
\DoxyCodeLine{237     \{}
\DoxyCodeLine{238     \textcolor{comment}{// reflect elements across the diagonal from lower triangle to upper triangle}}
\DoxyCodeLine{239     }
\DoxyCodeLine{240     \textcolor{keywordflow}{for}(uword col=0; col < N; ++col)}
\DoxyCodeLine{241       \{}
\DoxyCodeLine{242       \textcolor{keyword}{const} eT* coldata = out.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(col);}
\DoxyCodeLine{243             eT* row\_ptr = \&(out.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(col,col+1));}
\DoxyCodeLine{244       }
\DoxyCodeLine{245       \textcolor{keywordflow}{for}(uword row=(col+1); row < N; ++row)}
\DoxyCodeLine{246         \{}
\DoxyCodeLine{247         \textcolor{comment}{// out.at(col,row) = std::conj(coldata[row]);}}
\DoxyCodeLine{248         }
\DoxyCodeLine{249         (*row\_ptr) = std::conj(coldata[row]);}
\DoxyCodeLine{250         row\_ptr += N;}
\DoxyCodeLine{251         \}}
\DoxyCodeLine{252       \}}
\DoxyCodeLine{253     \}}
\DoxyCodeLine{254   \textcolor{keywordflow}{else}  \textcolor{comment}{// don't do complex conjugation}}
\DoxyCodeLine{255     \{}
\DoxyCodeLine{256     \textcolor{comment}{// reflect elements across the diagonal from lower triangle to upper triangle}}
\DoxyCodeLine{257     }
\DoxyCodeLine{258     \textcolor{keywordflow}{for}(uword col=0; col < N; ++col)}
\DoxyCodeLine{259       \{}
\DoxyCodeLine{260       \textcolor{keyword}{const} eT* coldata = out.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(col);}
\DoxyCodeLine{261             eT* row\_ptr = \&(out.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(col,col+1));}
\DoxyCodeLine{262       }
\DoxyCodeLine{263       \textcolor{keywordflow}{for}(uword row=(col+1); row < N; ++row)}
\DoxyCodeLine{264         \{}
\DoxyCodeLine{265         \textcolor{comment}{// out.at(col,row) = coldata[row];}}
\DoxyCodeLine{266         }
\DoxyCodeLine{267         (*row\_ptr) = coldata[row];}
\DoxyCodeLine{268         row\_ptr += N;}
\DoxyCodeLine{269         \}}
\DoxyCodeLine{270       \}}
\DoxyCodeLine{271     \}}
\DoxyCodeLine{272   \}}
\DoxyCodeLine{273 }
\DoxyCodeLine{274 }
\DoxyCodeLine{275 }

\end{DoxyCode}
