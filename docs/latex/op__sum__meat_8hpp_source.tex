\hypertarget{op__sum__meat_8hpp_source}{}\doxysection{op\+\_\+sum\+\_\+meat.\+hpp}
\label{op__sum__meat_8hpp_source}\index{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/op\_sum\_meat.hpp@{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/op\_sum\_meat.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008-\/2016 Conrad Sanderson (http://conradsanderson.id.au)}}
\DoxyCodeLine{2 \textcolor{comment}{// Copyright 2008-\/2016 National ICT Australia (NICTA)}}
\DoxyCodeLine{3 \textcolor{comment}{// }}
\DoxyCodeLine{4 \textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{5 \textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{6 \textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{7 \textcolor{comment}{// http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{8 \textcolor{comment}{// }}
\DoxyCodeLine{9 \textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{10 \textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{11 \textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{12 \textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{13 \textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{14 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{19 }
\DoxyCodeLine{20 }
\DoxyCodeLine{21 }
\DoxyCodeLine{22 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{23 arma\_hot}
\DoxyCodeLine{24 \textcolor{keyword}{inline}}
\DoxyCodeLine{25 \textcolor{keywordtype}{void}}
\DoxyCodeLine{26 op\_sum::apply(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T1,op\_sum>}}\& in)}
\DoxyCodeLine{27   \{}
\DoxyCodeLine{28   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{29   }
\DoxyCodeLine{30   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{31   }
\DoxyCodeLine{32   \textcolor{keyword}{const} uword dim = in.\mbox{\hyperlink{classOp_a197cb9330fe0d72c976d6223514c4bd6}{aux\_uword\_a}};}
\DoxyCodeLine{33   arma\_debug\_check( (dim > 1), \textcolor{stringliteral}{"{}sum(): parameter 'dim' must be 0 or 1"{}} );}
\DoxyCodeLine{34   }
\DoxyCodeLine{35   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} P(in.\mbox{\hyperlink{classOp_af7ab7221b6e233cdd38b9f9b69f301ce}{m}});}
\DoxyCodeLine{36   }
\DoxyCodeLine{37   \textcolor{keywordflow}{if}(P.is\_alias(out) == \textcolor{keyword}{false})}
\DoxyCodeLine{38     \{}
\DoxyCodeLine{39     op\_sum::apply\_noalias(out, P, dim);}
\DoxyCodeLine{40     \}}
\DoxyCodeLine{41   \textcolor{keywordflow}{else}}
\DoxyCodeLine{42     \{}
\DoxyCodeLine{43     \mbox{\hyperlink{classMat}{Mat<eT>}} tmp;}
\DoxyCodeLine{44     }
\DoxyCodeLine{45     op\_sum::apply\_noalias(tmp, P, dim);}
\DoxyCodeLine{46     }
\DoxyCodeLine{47     out.\mbox{\hyperlink{group__Mat_gaff06a75771f96605f7cc4f8c6b3fceb7}{steal\_mem}}(tmp);}
\DoxyCodeLine{48     \}}
\DoxyCodeLine{49   \}}
\DoxyCodeLine{50 }
\DoxyCodeLine{51 }
\DoxyCodeLine{52 }
\DoxyCodeLine{53 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{54 arma\_hot}
\DoxyCodeLine{55 \textcolor{keyword}{inline}}
\DoxyCodeLine{56 \textcolor{keywordtype}{void}}
\DoxyCodeLine{57 op\_sum::apply\_noalias(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}}\& P, \textcolor{keyword}{const} uword dim)}
\DoxyCodeLine{58   \{}
\DoxyCodeLine{59   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{60   }
\DoxyCodeLine{61   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__Mat}{is\_Mat}}<\textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::stored\_type}}>::value || (arma\_config::openmp \&\& \mbox{\hyperlink{classProxy}{Proxy<T1>::use\_mp}}))}
\DoxyCodeLine{62     \{}
\DoxyCodeLine{63     op\_sum::apply\_noalias\_unwrap(out, P, dim);}
\DoxyCodeLine{64     \}}
\DoxyCodeLine{65   \textcolor{keywordflow}{else}}
\DoxyCodeLine{66     \{}
\DoxyCodeLine{67     op\_sum::apply\_noalias\_proxy(out, P, dim);}
\DoxyCodeLine{68     \}}
\DoxyCodeLine{69   \}}
\DoxyCodeLine{70 }
\DoxyCodeLine{71 }
\DoxyCodeLine{72 }
\DoxyCodeLine{73 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{74 arma\_hot}
\DoxyCodeLine{75 \textcolor{keyword}{inline}}
\DoxyCodeLine{76 \textcolor{keywordtype}{void}}
\DoxyCodeLine{77 op\_sum::apply\_noalias\_unwrap(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}}\& P, \textcolor{keyword}{const} uword dim)}
\DoxyCodeLine{78   \{}
\DoxyCodeLine{79   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{80   }
\DoxyCodeLine{81   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{82   }
\DoxyCodeLine{83   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::stored\_type}} P\_stored\_type;}
\DoxyCodeLine{84   }
\DoxyCodeLine{85   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap}{unwrap<P\_stored\_type>}} tmp(P.Q);}
\DoxyCodeLine{86   }
\DoxyCodeLine{87   \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structunwrap}{unwrap<P\_stored\_type>::stored\_type}}\& X = tmp.M;}
\DoxyCodeLine{88   }
\DoxyCodeLine{89   \textcolor{keyword}{const} uword X\_n\_rows = X.n\_rows;}
\DoxyCodeLine{90   \textcolor{keyword}{const} uword X\_n\_cols = X.n\_cols;}
\DoxyCodeLine{91   }
\DoxyCodeLine{92   \textcolor{keywordflow}{if}(dim == 0)}
\DoxyCodeLine{93     \{}
\DoxyCodeLine{94     out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(1, X\_n\_cols);}
\DoxyCodeLine{95     }
\DoxyCodeLine{96     eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{97     }
\DoxyCodeLine{98     \textcolor{keywordflow}{for}(uword col=0; col < X\_n\_cols; ++col)}
\DoxyCodeLine{99       \{}
\DoxyCodeLine{100       out\_mem[col] = arrayops::accumulate( X.colptr(col), X\_n\_rows );}
\DoxyCodeLine{101       \}}
\DoxyCodeLine{102     \}}
\DoxyCodeLine{103   \textcolor{keywordflow}{else}}
\DoxyCodeLine{104     \{}
\DoxyCodeLine{105     out.zeros(X\_n\_rows, 1);}
\DoxyCodeLine{106     }
\DoxyCodeLine{107     eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{108     }
\DoxyCodeLine{109     \textcolor{keywordflow}{for}(uword col=0; col < X\_n\_cols; ++col)}
\DoxyCodeLine{110       \{}
\DoxyCodeLine{111       arrayops::inplace\_plus( out\_mem, X.colptr(col), X\_n\_rows );}
\DoxyCodeLine{112       \}}
\DoxyCodeLine{113     \}}
\DoxyCodeLine{114   \}}
\DoxyCodeLine{115 }
\DoxyCodeLine{116 }
\DoxyCodeLine{117 }
\DoxyCodeLine{118 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{119 arma\_hot}
\DoxyCodeLine{120 \textcolor{keyword}{inline}}
\DoxyCodeLine{121 \textcolor{keywordtype}{void}}
\DoxyCodeLine{122 op\_sum::apply\_noalias\_proxy(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}}\& P, \textcolor{keyword}{const} uword dim)}
\DoxyCodeLine{123   \{}
\DoxyCodeLine{124   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{125   }
\DoxyCodeLine{126   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{127   }
\DoxyCodeLine{128   \textcolor{keyword}{const} uword P\_n\_rows = P.get\_n\_rows();}
\DoxyCodeLine{129   \textcolor{keyword}{const} uword P\_n\_cols = P.get\_n\_cols();}
\DoxyCodeLine{130   }
\DoxyCodeLine{131   \textcolor{keywordflow}{if}(dim == 0)}
\DoxyCodeLine{132     \{}
\DoxyCodeLine{133     out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(1, P\_n\_cols);}
\DoxyCodeLine{134     }
\DoxyCodeLine{135     eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{136     }
\DoxyCodeLine{137     \textcolor{keywordflow}{for}(uword col=0; col < P\_n\_cols; ++col)}
\DoxyCodeLine{138       \{}
\DoxyCodeLine{139       eT val1 = eT(0);}
\DoxyCodeLine{140       eT val2 = eT(0);}
\DoxyCodeLine{141       }
\DoxyCodeLine{142       uword i,j;}
\DoxyCodeLine{143       \textcolor{keywordflow}{for}(i=0, j=1; j < P\_n\_rows; i+=2, j+=2)}
\DoxyCodeLine{144         \{}
\DoxyCodeLine{145         val1 += P.at(i,col);}
\DoxyCodeLine{146         val2 += P.at(j,col);}
\DoxyCodeLine{147         \}}
\DoxyCodeLine{148       }
\DoxyCodeLine{149       \textcolor{keywordflow}{if}(i < P\_n\_rows)}
\DoxyCodeLine{150         \{}
\DoxyCodeLine{151         val1 += P.at(i,col);}
\DoxyCodeLine{152         \}}
\DoxyCodeLine{153       }
\DoxyCodeLine{154       out\_mem[col] = (val1 + val2);}
\DoxyCodeLine{155       \}}
\DoxyCodeLine{156     \}}
\DoxyCodeLine{157   \textcolor{keywordflow}{else}}
\DoxyCodeLine{158     \{}
\DoxyCodeLine{159     out.zeros(P\_n\_rows, 1);}
\DoxyCodeLine{160     }
\DoxyCodeLine{161     eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{162     }
\DoxyCodeLine{163     \textcolor{keywordflow}{for}(uword col=0; col < P\_n\_cols; ++col)}
\DoxyCodeLine{164     \textcolor{keywordflow}{for}(uword row=0; row < P\_n\_rows; ++row)}
\DoxyCodeLine{165       \{}
\DoxyCodeLine{166       out\_mem[row] += P.at(row,col);}
\DoxyCodeLine{167       \}}
\DoxyCodeLine{168     \}}
\DoxyCodeLine{169   \}}
\DoxyCodeLine{170 }
\DoxyCodeLine{171 }
\DoxyCodeLine{172 }
\DoxyCodeLine{173 \textcolor{comment}{//}}
\DoxyCodeLine{174 \textcolor{comment}{// cubes}}
\DoxyCodeLine{175 }
\DoxyCodeLine{176 }
\DoxyCodeLine{177 }
\DoxyCodeLine{178 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{179 arma\_hot}
\DoxyCodeLine{180 \textcolor{keyword}{inline}}
\DoxyCodeLine{181 \textcolor{keywordtype}{void}}
\DoxyCodeLine{182 op\_sum::apply(\mbox{\hyperlink{classCube}{Cube<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classOpCube}{OpCube<T1,op\_sum>}}\& in)}
\DoxyCodeLine{183   \{}
\DoxyCodeLine{184   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{185   }
\DoxyCodeLine{186   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{187   }
\DoxyCodeLine{188   \textcolor{keyword}{const} uword dim = in.\mbox{\hyperlink{classOpCube_a13c280aa2895e181d6e5f1f0a3b2ad02}{aux\_uword\_a}};}
\DoxyCodeLine{189   arma\_debug\_check( (dim > 2), \textcolor{stringliteral}{"{}sum(): parameter 'dim' must be 0 or 1 or 2"{}} );}
\DoxyCodeLine{190   }
\DoxyCodeLine{191   \textcolor{keyword}{const} \mbox{\hyperlink{classProxyCube}{ProxyCube<T1>}} P(in.\mbox{\hyperlink{classOpCube_ab2037da2bd74604392dc38d382669e2a}{m}});}
\DoxyCodeLine{192   }
\DoxyCodeLine{193   \textcolor{keywordflow}{if}(P.is\_alias(out) == \textcolor{keyword}{false})}
\DoxyCodeLine{194     \{}
\DoxyCodeLine{195     op\_sum::apply\_noalias(out, P, dim);}
\DoxyCodeLine{196     \}}
\DoxyCodeLine{197   \textcolor{keywordflow}{else}}
\DoxyCodeLine{198     \{}
\DoxyCodeLine{199     \mbox{\hyperlink{classCube}{Cube<eT>}} tmp;}
\DoxyCodeLine{200     }
\DoxyCodeLine{201     op\_sum::apply\_noalias(tmp, P, dim);}
\DoxyCodeLine{202     }
\DoxyCodeLine{203     out.\mbox{\hyperlink{group__Cube_ga70006d5a49f67d35d4ae10cb6c5a681f}{steal\_mem}}(tmp);}
\DoxyCodeLine{204     \}}
\DoxyCodeLine{205   \}}
\DoxyCodeLine{206 }
\DoxyCodeLine{207 }
\DoxyCodeLine{208 }
\DoxyCodeLine{209 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{210 arma\_hot}
\DoxyCodeLine{211 \textcolor{keyword}{inline}}
\DoxyCodeLine{212 \textcolor{keywordtype}{void}}
\DoxyCodeLine{213 op\_sum::apply\_noalias(\mbox{\hyperlink{classCube}{Cube<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classProxyCube}{ProxyCube<T1>}}\& P, \textcolor{keyword}{const} uword dim)}
\DoxyCodeLine{214   \{}
\DoxyCodeLine{215   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{216   }
\DoxyCodeLine{217   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__Cube}{is\_Cube}}<\textcolor{keyword}{typename} \mbox{\hyperlink{classProxyCube}{ProxyCube<T1>::stored\_type}}>::value || (arma\_config::openmp \&\& \mbox{\hyperlink{classProxyCube}{ProxyCube<T1>::use\_mp}}))}
\DoxyCodeLine{218     \{}
\DoxyCodeLine{219     op\_sum::apply\_noalias\_unwrap(out, P, dim);}
\DoxyCodeLine{220     \}}
\DoxyCodeLine{221   \textcolor{keywordflow}{else}}
\DoxyCodeLine{222     \{}
\DoxyCodeLine{223     op\_sum::apply\_noalias\_proxy(out, P, dim);}
\DoxyCodeLine{224     \}}
\DoxyCodeLine{225   \}}
\DoxyCodeLine{226 }
\DoxyCodeLine{227 }
\DoxyCodeLine{228 }
\DoxyCodeLine{229 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{230 arma\_hot}
\DoxyCodeLine{231 \textcolor{keyword}{inline}}
\DoxyCodeLine{232 \textcolor{keywordtype}{void}}
\DoxyCodeLine{233 op\_sum::apply\_noalias\_unwrap(\mbox{\hyperlink{classCube}{Cube<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classProxyCube}{ProxyCube<T1>}}\& P, \textcolor{keyword}{const} uword dim)}
\DoxyCodeLine{234   \{}
\DoxyCodeLine{235   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{236   }
\DoxyCodeLine{237   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{238   }
\DoxyCodeLine{239   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{classProxyCube}{ProxyCube<T1>::stored\_type}} P\_stored\_type;}
\DoxyCodeLine{240   }
\DoxyCodeLine{241   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap__cube}{unwrap\_cube<P\_stored\_type>}} tmp(P.Q);}
\DoxyCodeLine{242   }
\DoxyCodeLine{243   \textcolor{keyword}{const} \mbox{\hyperlink{classCube}{Cube<eT>}}\& X = tmp.M;}
\DoxyCodeLine{244   }
\DoxyCodeLine{245   \textcolor{keyword}{const} uword X\_n\_rows   = X.n\_rows;}
\DoxyCodeLine{246   \textcolor{keyword}{const} uword X\_n\_cols   = X.n\_cols;}
\DoxyCodeLine{247   \textcolor{keyword}{const} uword X\_n\_slices = X.n\_slices;}
\DoxyCodeLine{248   }
\DoxyCodeLine{249   \textcolor{keywordflow}{if}(dim == 0)}
\DoxyCodeLine{250     \{}
\DoxyCodeLine{251     out.\mbox{\hyperlink{group__Cube_ga0d461586030945472fe66f7364882771}{set\_size}}(1, X\_n\_cols, X\_n\_slices);}
\DoxyCodeLine{252     }
\DoxyCodeLine{253     \textcolor{keywordflow}{for}(uword \mbox{\hyperlink{classslice}{slice}}=0; \mbox{\hyperlink{classslice}{slice}} < X\_n\_slices; ++\mbox{\hyperlink{classslice}{slice}})}
\DoxyCodeLine{254       \{}
\DoxyCodeLine{255       eT* out\_mem = out.\mbox{\hyperlink{group__Cube_gaa880766c421f4a9f006662c7fd96850e}{slice\_memptr}}(\mbox{\hyperlink{classslice}{slice}});}
\DoxyCodeLine{256       }
\DoxyCodeLine{257       \textcolor{keywordflow}{for}(uword col=0; col < X\_n\_cols; ++col)}
\DoxyCodeLine{258         \{}
\DoxyCodeLine{259         out\_mem[col] = arrayops::accumulate( X.slice\_colptr(\mbox{\hyperlink{classslice}{slice}},col), X\_n\_rows );}
\DoxyCodeLine{260         \}}
\DoxyCodeLine{261       \}}
\DoxyCodeLine{262     \}}
\DoxyCodeLine{263   \textcolor{keywordflow}{else}}
\DoxyCodeLine{264   \textcolor{keywordflow}{if}(dim == 1)}
\DoxyCodeLine{265     \{}
\DoxyCodeLine{266     out.zeros(X\_n\_rows, 1, X\_n\_slices);}
\DoxyCodeLine{267     }
\DoxyCodeLine{268     \textcolor{keywordflow}{for}(uword \mbox{\hyperlink{classslice}{slice}}=0; \mbox{\hyperlink{classslice}{slice}} < X\_n\_slices; ++\mbox{\hyperlink{classslice}{slice}})}
\DoxyCodeLine{269       \{}
\DoxyCodeLine{270       eT* out\_mem = out.\mbox{\hyperlink{group__Cube_gaa880766c421f4a9f006662c7fd96850e}{slice\_memptr}}(\mbox{\hyperlink{classslice}{slice}});}
\DoxyCodeLine{271       }
\DoxyCodeLine{272       \textcolor{keywordflow}{for}(uword col=0; col < X\_n\_cols; ++col)}
\DoxyCodeLine{273         \{}
\DoxyCodeLine{274         arrayops::inplace\_plus( out\_mem, X.slice\_colptr(\mbox{\hyperlink{classslice}{slice}},col), X\_n\_rows );}
\DoxyCodeLine{275         \}}
\DoxyCodeLine{276       \}}
\DoxyCodeLine{277     \}}
\DoxyCodeLine{278   \textcolor{keywordflow}{else}}
\DoxyCodeLine{279   \textcolor{keywordflow}{if}(dim == 2)}
\DoxyCodeLine{280     \{}
\DoxyCodeLine{281     out.zeros(X\_n\_rows, X\_n\_cols, 1);}
\DoxyCodeLine{282     }
\DoxyCodeLine{283     eT* out\_mem = out.\mbox{\hyperlink{group__Cube_ga5b00237224a8e3bfb05728de7c962f85}{memptr}}();}
\DoxyCodeLine{284     }
\DoxyCodeLine{285     \textcolor{keywordflow}{for}(uword \mbox{\hyperlink{classslice}{slice}}=0; \mbox{\hyperlink{classslice}{slice}} < X\_n\_slices; ++\mbox{\hyperlink{classslice}{slice}})}
\DoxyCodeLine{286       \{}
\DoxyCodeLine{287       arrayops::inplace\_plus(out\_mem, X.slice\_memptr(\mbox{\hyperlink{classslice}{slice}}), X.n\_elem\_slice );}
\DoxyCodeLine{288       \}}
\DoxyCodeLine{289     \}}
\DoxyCodeLine{290   \}}
\DoxyCodeLine{291 }
\DoxyCodeLine{292 }
\DoxyCodeLine{293 }
\DoxyCodeLine{294 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{295 arma\_hot}
\DoxyCodeLine{296 \textcolor{keyword}{inline}}
\DoxyCodeLine{297 \textcolor{keywordtype}{void}}
\DoxyCodeLine{298 op\_sum::apply\_noalias\_proxy(\mbox{\hyperlink{classCube}{Cube<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classProxyCube}{ProxyCube<T1>}}\& P, \textcolor{keyword}{const} uword dim)}
\DoxyCodeLine{299   \{}
\DoxyCodeLine{300   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{301   }
\DoxyCodeLine{302   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{303   }
\DoxyCodeLine{304   \textcolor{keyword}{const} uword P\_n\_rows   = P.get\_n\_rows();}
\DoxyCodeLine{305   \textcolor{keyword}{const} uword P\_n\_cols   = P.get\_n\_cols();}
\DoxyCodeLine{306   \textcolor{keyword}{const} uword P\_n\_slices = P.get\_n\_slices();}
\DoxyCodeLine{307   }
\DoxyCodeLine{308   \textcolor{keywordflow}{if}(dim == 0)}
\DoxyCodeLine{309     \{}
\DoxyCodeLine{310     out.\mbox{\hyperlink{group__Cube_ga0d461586030945472fe66f7364882771}{set\_size}}(1, P\_n\_cols, P\_n\_slices);}
\DoxyCodeLine{311     }
\DoxyCodeLine{312     \textcolor{keywordflow}{for}(uword \mbox{\hyperlink{classslice}{slice}}=0; \mbox{\hyperlink{classslice}{slice}} < P\_n\_slices; ++\mbox{\hyperlink{classslice}{slice}})}
\DoxyCodeLine{313       \{}
\DoxyCodeLine{314       eT* out\_mem = out.\mbox{\hyperlink{group__Cube_gaa880766c421f4a9f006662c7fd96850e}{slice\_memptr}}(\mbox{\hyperlink{classslice}{slice}});}
\DoxyCodeLine{315       }
\DoxyCodeLine{316       \textcolor{keywordflow}{for}(uword col=0; col < P\_n\_cols; ++col)}
\DoxyCodeLine{317         \{}
\DoxyCodeLine{318         eT val1 = eT(0);}
\DoxyCodeLine{319         eT val2 = eT(0);}
\DoxyCodeLine{320         }
\DoxyCodeLine{321         uword i,j;}
\DoxyCodeLine{322         \textcolor{keywordflow}{for}(i=0, j=1; j < P\_n\_rows; i+=2, j+=2)}
\DoxyCodeLine{323           \{}
\DoxyCodeLine{324           val1 += P.at(i,col,\mbox{\hyperlink{classslice}{slice}});}
\DoxyCodeLine{325           val2 += P.at(j,col,\mbox{\hyperlink{classslice}{slice}});}
\DoxyCodeLine{326           \}}
\DoxyCodeLine{327         }
\DoxyCodeLine{328         \textcolor{keywordflow}{if}(i < P\_n\_rows)}
\DoxyCodeLine{329           \{}
\DoxyCodeLine{330           val1 += P.at(i,col,\mbox{\hyperlink{classslice}{slice}});}
\DoxyCodeLine{331           \}}
\DoxyCodeLine{332         }
\DoxyCodeLine{333         out\_mem[col] = (val1 + val2);}
\DoxyCodeLine{334         \}}
\DoxyCodeLine{335       \}}
\DoxyCodeLine{336     \}}
\DoxyCodeLine{337   \textcolor{keywordflow}{else}}
\DoxyCodeLine{338   \textcolor{keywordflow}{if}(dim == 1)}
\DoxyCodeLine{339     \{}
\DoxyCodeLine{340     out.zeros(P\_n\_rows, 1, P\_n\_slices);}
\DoxyCodeLine{341     }
\DoxyCodeLine{342     \textcolor{keywordflow}{for}(uword \mbox{\hyperlink{classslice}{slice}}=0; \mbox{\hyperlink{classslice}{slice}} < P\_n\_slices; ++\mbox{\hyperlink{classslice}{slice}})}
\DoxyCodeLine{343       \{}
\DoxyCodeLine{344       eT* out\_mem = out.\mbox{\hyperlink{group__Cube_gaa880766c421f4a9f006662c7fd96850e}{slice\_memptr}}(\mbox{\hyperlink{classslice}{slice}});}
\DoxyCodeLine{345       }
\DoxyCodeLine{346       \textcolor{keywordflow}{for}(uword col=0; col < P\_n\_cols; ++col)}
\DoxyCodeLine{347       \textcolor{keywordflow}{for}(uword row=0; row < P\_n\_rows; ++row)}
\DoxyCodeLine{348         \{}
\DoxyCodeLine{349         out\_mem[row] += P.at(row,col,\mbox{\hyperlink{classslice}{slice}});}
\DoxyCodeLine{350         \}}
\DoxyCodeLine{351       \}}
\DoxyCodeLine{352     \}}
\DoxyCodeLine{353   \textcolor{keywordflow}{else}}
\DoxyCodeLine{354   \textcolor{keywordflow}{if}(dim == 2)}
\DoxyCodeLine{355     \{}
\DoxyCodeLine{356     out.zeros(P\_n\_rows, P\_n\_cols, 1);}
\DoxyCodeLine{357     }
\DoxyCodeLine{358     \textcolor{keywordflow}{for}(uword \mbox{\hyperlink{classslice}{slice}}=0; \mbox{\hyperlink{classslice}{slice}} < P\_n\_slices; ++\mbox{\hyperlink{classslice}{slice}})}
\DoxyCodeLine{359       \{}
\DoxyCodeLine{360       \textcolor{keywordflow}{for}(uword col=0; col < P\_n\_cols; ++col)}
\DoxyCodeLine{361         \{}
\DoxyCodeLine{362         eT* out\_mem = out.\mbox{\hyperlink{group__Cube_gafb2f22b1dae85884162f6777689e4cba}{slice\_colptr}}(0,col);}
\DoxyCodeLine{363         }
\DoxyCodeLine{364         \textcolor{keywordflow}{for}(uword row=0; row < P\_n\_rows; ++row)}
\DoxyCodeLine{365           \{}
\DoxyCodeLine{366           out\_mem[row] += P.at(row,col,\mbox{\hyperlink{classslice}{slice}});}
\DoxyCodeLine{367           \}}
\DoxyCodeLine{368         \}}
\DoxyCodeLine{369       \}}
\DoxyCodeLine{370     \}}
\DoxyCodeLine{371   \}}
\DoxyCodeLine{372 }
\DoxyCodeLine{373 }
\DoxyCodeLine{374 }

\end{DoxyCode}
