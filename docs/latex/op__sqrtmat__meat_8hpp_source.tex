\hypertarget{op__sqrtmat__meat_8hpp_source}{}\doxysection{op\+\_\+sqrtmat\+\_\+meat.\+hpp}
\label{op__sqrtmat__meat_8hpp_source}\index{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/op\_sqrtmat\_meat.hpp@{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/op\_sqrtmat\_meat.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008-\/2016 Conrad Sanderson (http://conradsanderson.id.au)}}
\DoxyCodeLine{2 \textcolor{comment}{// Copyright 2008-\/2016 National ICT Australia (NICTA)}}
\DoxyCodeLine{3 \textcolor{comment}{// }}
\DoxyCodeLine{4 \textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{5 \textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{6 \textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{7 \textcolor{comment}{// http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{8 \textcolor{comment}{// }}
\DoxyCodeLine{9 \textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{10 \textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{11 \textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{12 \textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{13 \textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{14 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{19 }
\DoxyCodeLine{20 }
\DoxyCodeLine{28 }
\DoxyCodeLine{29 }
\DoxyCodeLine{30 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{31 \textcolor{keyword}{inline}}
\DoxyCodeLine{32 \textcolor{keywordtype}{void}}
\DoxyCodeLine{33 \mbox{\hyperlink{group__op__sqrtmat_gaa5a21a53a4f925aa9ebb5316651746bb}{op\_sqrtmat::apply}}(\mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::elem\_type> >\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classmtOp}{mtOp}}<std::complex<typename T1::elem\_type>,T1,\mbox{\hyperlink{classop__sqrtmat}{op\_sqrtmat}}>\& in)}
\DoxyCodeLine{34   \{}
\DoxyCodeLine{35   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{36   }
\DoxyCodeLine{37   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} status = op\_sqrtmat::apply\_direct(out, in.m);}
\DoxyCodeLine{38   }
\DoxyCodeLine{39   \textcolor{keywordflow}{if}(status == \textcolor{keyword}{false})}
\DoxyCodeLine{40     \{}
\DoxyCodeLine{41     arma\_debug\_warn\_level(3, \textcolor{stringliteral}{"{}sqrtmat(): given matrix is singular; may not have a square root"{}});}
\DoxyCodeLine{42     \}}
\DoxyCodeLine{43   \}}
\DoxyCodeLine{44 }
\DoxyCodeLine{45 }
\DoxyCodeLine{46 }
\DoxyCodeLine{47 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{48 \textcolor{keyword}{inline}}
\DoxyCodeLine{49 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{50 op\_sqrtmat::apply\_direct(\mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::elem\_type> >\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T1,op\_diagmat>}}\& expr)}
\DoxyCodeLine{51   \{}
\DoxyCodeLine{52   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{53   }
\DoxyCodeLine{54   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type T;}
\DoxyCodeLine{55   }
\DoxyCodeLine{56   \textcolor{keyword}{const} \mbox{\hyperlink{classdiagmat__proxy}{diagmat\_proxy<T1>}} P(expr.\mbox{\hyperlink{classOp_af7ab7221b6e233cdd38b9f9b69f301ce}{m}});}
\DoxyCodeLine{57   }
\DoxyCodeLine{58   arma\_debug\_check( (P.n\_rows != P.n\_cols), \textcolor{stringliteral}{"{}sqrtmat(): given matrix must be square sized"{}} );}
\DoxyCodeLine{59   }
\DoxyCodeLine{60   \textcolor{keyword}{const} uword N = P.n\_rows;}
\DoxyCodeLine{61   }
\DoxyCodeLine{62   out.zeros(N,N);}
\DoxyCodeLine{63   }
\DoxyCodeLine{64   \textcolor{keywordtype}{bool} singular = \textcolor{keyword}{false};}
\DoxyCodeLine{65   }
\DoxyCodeLine{66   \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)}
\DoxyCodeLine{67     \{}
\DoxyCodeLine{68     \textcolor{keyword}{const} T val = P[i];}
\DoxyCodeLine{69     }
\DoxyCodeLine{70     \textcolor{keywordflow}{if}(val >= T(0))}
\DoxyCodeLine{71       \{}
\DoxyCodeLine{72       singular = (singular || (val == T(0)));}
\DoxyCodeLine{73       }
\DoxyCodeLine{74       out.at(i,i) = std::sqrt(val);}
\DoxyCodeLine{75       \}}
\DoxyCodeLine{76     \textcolor{keywordflow}{else}}
\DoxyCodeLine{77       \{}
\DoxyCodeLine{78       out.at(i,i) = std::sqrt( std::complex<T>(val) );}
\DoxyCodeLine{79       \}}
\DoxyCodeLine{80     \}}
\DoxyCodeLine{81   }
\DoxyCodeLine{82   \textcolor{keywordflow}{return} (singular) ? false : \textcolor{keyword}{true};}
\DoxyCodeLine{83   \}}
\DoxyCodeLine{84 }
\DoxyCodeLine{85 }
\DoxyCodeLine{86 }
\DoxyCodeLine{87 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{88 \textcolor{keyword}{inline}}
\DoxyCodeLine{89 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{90 op\_sqrtmat::apply\_direct(\mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::elem\_type> >\& out, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::elem\_type,T1>}}\& expr)}
\DoxyCodeLine{91   \{}
\DoxyCodeLine{92   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{93   }
\DoxyCodeLine{94   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type       in\_T;}
\DoxyCodeLine{95   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<in\_T> out\_T;}
\DoxyCodeLine{96   }
\DoxyCodeLine{97   \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} expr\_unwrap(expr.get\_ref());}
\DoxyCodeLine{98   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<in\_T>}}\& \mbox{\hyperlink{structA}{A}}   = expr\_unwrap.M;}
\DoxyCodeLine{99   }
\DoxyCodeLine{100   arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.is\_square() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}sqrtmat(): given matrix must be square sized"{}} );}
\DoxyCodeLine{101   }
\DoxyCodeLine{102   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.n\_elem == 0)}
\DoxyCodeLine{103     \{}
\DoxyCodeLine{104     out.reset();}
\DoxyCodeLine{105     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{106     \}}
\DoxyCodeLine{107   \textcolor{keywordflow}{else}}
\DoxyCodeLine{108   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.n\_elem == 1)}
\DoxyCodeLine{109     \{}
\DoxyCodeLine{110     out.set\_size(1,1);}
\DoxyCodeLine{111     out[0] = std::sqrt( std::complex<in\_T>( \mbox{\hyperlink{structA}{A}}[0] ) );}
\DoxyCodeLine{112     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{113     \}}
\DoxyCodeLine{114   }
\DoxyCodeLine{115   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_diagmat())}
\DoxyCodeLine{116     \{}
\DoxyCodeLine{117     \textcolor{keyword}{const} uword N = \mbox{\hyperlink{structA}{A}}.n\_rows;}
\DoxyCodeLine{118     }
\DoxyCodeLine{119     out.zeros(N,N);  \textcolor{comment}{// aliasing can't happen as op\_sqrtmat is defined as cx\_mat = op(mat)}}
\DoxyCodeLine{120     }
\DoxyCodeLine{121     \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)}
\DoxyCodeLine{122       \{}
\DoxyCodeLine{123       \textcolor{keyword}{const} in\_T val = \mbox{\hyperlink{structA}{A}}.at(i,i);}
\DoxyCodeLine{124       }
\DoxyCodeLine{125       \textcolor{keywordflow}{if}(val >= in\_T(0))}
\DoxyCodeLine{126         \{}
\DoxyCodeLine{127         out.at(i,i) = std::sqrt(val);}
\DoxyCodeLine{128         \}}
\DoxyCodeLine{129       \textcolor{keywordflow}{else}}
\DoxyCodeLine{130         \{}
\DoxyCodeLine{131         out.at(i,i) = std::sqrt( out\_T(val) );}
\DoxyCodeLine{132         \}}
\DoxyCodeLine{133       \}}
\DoxyCodeLine{134     }
\DoxyCodeLine{135     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{136     \}}
\DoxyCodeLine{137   }
\DoxyCodeLine{138 \textcolor{preprocessor}{  \#if defined(ARMA\_OPTIMISE\_SYMPD)}}
\DoxyCodeLine{139     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} try\_sympd = sympd\_helper::guess\_sympd\_anysize(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{140 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{141     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} try\_sympd = \textcolor{keyword}{false};}
\DoxyCodeLine{142 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{143   }
\DoxyCodeLine{144   \textcolor{keywordflow}{if}(try\_sympd)}
\DoxyCodeLine{145     \{}
\DoxyCodeLine{146     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}op\_sqrtmat: attempting sympd optimisation"{}});}
\DoxyCodeLine{147     }
\DoxyCodeLine{148     \textcolor{comment}{// if matrix A is sympd, all its eigenvalues are positive}}
\DoxyCodeLine{149     }
\DoxyCodeLine{150     \mbox{\hyperlink{classCol}{Col<in\_T>}} eigval;}
\DoxyCodeLine{151     \mbox{\hyperlink{classMat}{Mat<in\_T>}} eigvec;}
\DoxyCodeLine{152     }
\DoxyCodeLine{153     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} eig\_status = \mbox{\hyperlink{group__fn__eig__sym_gac55fe3206226539aa46643bc8ac9abe2}{eig\_sym\_helper}}(eigval, eigvec, \mbox{\hyperlink{structA}{A}}, \textcolor{charliteral}{'d'}, \textcolor{stringliteral}{"{}sqrtmat()"{}});}
\DoxyCodeLine{154     }
\DoxyCodeLine{155     \textcolor{keywordflow}{if}(eig\_status)}
\DoxyCodeLine{156       \{}
\DoxyCodeLine{157       \textcolor{comment}{// ensure each eigenvalue is > 0}}
\DoxyCodeLine{158       }
\DoxyCodeLine{159       \textcolor{keyword}{const} uword N          = eigval.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}};}
\DoxyCodeLine{160       \textcolor{keyword}{const} in\_T* eigval\_mem = eigval.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{161       }
\DoxyCodeLine{162       \textcolor{keywordtype}{bool} all\_pos = \textcolor{keyword}{true};}
\DoxyCodeLine{163       }
\DoxyCodeLine{164       \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)  \{ all\_pos = (eigval\_mem[i] <= in\_T(0)) ? \textcolor{keyword}{false} : all\_pos; \}}
\DoxyCodeLine{165       }
\DoxyCodeLine{166       \textcolor{keywordflow}{if}(all\_pos)}
\DoxyCodeLine{167         \{}
\DoxyCodeLine{168         eigval = sqrt(eigval);}
\DoxyCodeLine{169         }
\DoxyCodeLine{170         out = \mbox{\hyperlink{classconv__to}{conv\_to< Mat<out\_T>}} >::from( eigvec * \mbox{\hyperlink{group__fn__diagmat_ga8bb70dfa94511eb84368ef6107dd030e}{diagmat}}(eigval) * eigvec.t() );}
\DoxyCodeLine{171         }
\DoxyCodeLine{172         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{173         \}}
\DoxyCodeLine{174       \}}
\DoxyCodeLine{175     }
\DoxyCodeLine{176     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}op\_sqrtmat: sympd optimisation failed"{}});}
\DoxyCodeLine{177     }
\DoxyCodeLine{178     \textcolor{comment}{// fallthrough if eigen decomposition failed or an eigenvalue is zero}}
\DoxyCodeLine{179     \}}
\DoxyCodeLine{180   }
\DoxyCodeLine{181   }
\DoxyCodeLine{182   \mbox{\hyperlink{classMat}{Mat<out\_T>}} U;}
\DoxyCodeLine{183   \mbox{\hyperlink{classMat}{Mat<out\_T>}} S(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{184   }
\DoxyCodeLine{185   \textcolor{keyword}{const}  in\_T* Amem = \mbox{\hyperlink{structA}{A}}.memptr();}
\DoxyCodeLine{186         out\_T* Smem = S.memptr();}
\DoxyCodeLine{187   }
\DoxyCodeLine{188   \textcolor{keyword}{const} uword n\_elem = \mbox{\hyperlink{structA}{A}}.n\_elem;}
\DoxyCodeLine{189   }
\DoxyCodeLine{190   \textcolor{keywordflow}{for}(uword i=0; i<n\_elem; ++i)}
\DoxyCodeLine{191     \{}
\DoxyCodeLine{192     Smem[i] = std::complex<in\_T>( Amem[i] );}
\DoxyCodeLine{193     \}}
\DoxyCodeLine{194   }
\DoxyCodeLine{195   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} schur\_ok = auxlib::schur(U,S);}
\DoxyCodeLine{196   }
\DoxyCodeLine{197   \textcolor{keywordflow}{if}(schur\_ok == \textcolor{keyword}{false})}
\DoxyCodeLine{198     \{}
\DoxyCodeLine{199     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}sqrtmat(): schur decomposition failed"{}});}
\DoxyCodeLine{200     out.soft\_reset();}
\DoxyCodeLine{201     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{202     \}}
\DoxyCodeLine{203   }
\DoxyCodeLine{204   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} status = op\_sqrtmat\_cx::helper(S);}
\DoxyCodeLine{205   }
\DoxyCodeLine{206   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<out\_T>}} X = U*S;}
\DoxyCodeLine{207   }
\DoxyCodeLine{208   S.reset();}
\DoxyCodeLine{209   }
\DoxyCodeLine{210   out = X*U.t();}
\DoxyCodeLine{211   }
\DoxyCodeLine{212   \textcolor{keywordflow}{return} status;}
\DoxyCodeLine{213   \}}
\DoxyCodeLine{214 }
\DoxyCodeLine{215 }
\DoxyCodeLine{216 }
\DoxyCodeLine{217 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{218 \textcolor{keyword}{inline}}
\DoxyCodeLine{219 \textcolor{keywordtype}{void}}
\DoxyCodeLine{220 op\_sqrtmat\_cx::apply(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T1,op\_sqrtmat\_cx>}}\& in)}
\DoxyCodeLine{221   \{}
\DoxyCodeLine{222   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{223   }
\DoxyCodeLine{224   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} status = op\_sqrtmat\_cx::apply\_direct(out, in.\mbox{\hyperlink{classOp_af7ab7221b6e233cdd38b9f9b69f301ce}{m}});}
\DoxyCodeLine{225   }
\DoxyCodeLine{226   \textcolor{keywordflow}{if}(status == \textcolor{keyword}{false})}
\DoxyCodeLine{227     \{}
\DoxyCodeLine{228     arma\_debug\_warn\_level(3, \textcolor{stringliteral}{"{}sqrtmat(): given matrix is singular; may not have a square root"{}});}
\DoxyCodeLine{229     \}}
\DoxyCodeLine{230   \}}
\DoxyCodeLine{231 }
\DoxyCodeLine{232 }
\DoxyCodeLine{233 }
\DoxyCodeLine{234 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{235 \textcolor{keyword}{inline}}
\DoxyCodeLine{236 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{237 op\_sqrtmat\_cx::apply\_direct(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T1,op\_diagmat>}}\& expr)}
\DoxyCodeLine{238   \{}
\DoxyCodeLine{239   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{240   }
\DoxyCodeLine{241   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{242   }
\DoxyCodeLine{243   \textcolor{keyword}{const} \mbox{\hyperlink{classdiagmat__proxy}{diagmat\_proxy<T1>}} P(expr.\mbox{\hyperlink{classOp_af7ab7221b6e233cdd38b9f9b69f301ce}{m}});}
\DoxyCodeLine{244   }
\DoxyCodeLine{245   \textcolor{keywordtype}{bool} status = \textcolor{keyword}{false};}
\DoxyCodeLine{246   }
\DoxyCodeLine{247   \textcolor{keywordflow}{if}(P.is\_alias(out))}
\DoxyCodeLine{248     \{}
\DoxyCodeLine{249     \mbox{\hyperlink{classMat}{Mat<eT>}} tmp;}
\DoxyCodeLine{250     }
\DoxyCodeLine{251     status = op\_sqrtmat\_cx::apply\_direct\_noalias(tmp, P);}
\DoxyCodeLine{252     }
\DoxyCodeLine{253     out.\mbox{\hyperlink{group__Mat_gaff06a75771f96605f7cc4f8c6b3fceb7}{steal\_mem}}(tmp);}
\DoxyCodeLine{254     \}}
\DoxyCodeLine{255   \textcolor{keywordflow}{else}}
\DoxyCodeLine{256     \{}
\DoxyCodeLine{257     status = op\_sqrtmat\_cx::apply\_direct\_noalias(out, P);}
\DoxyCodeLine{258     \}}
\DoxyCodeLine{259   }
\DoxyCodeLine{260   \textcolor{keywordflow}{return} status;}
\DoxyCodeLine{261   \}}
\DoxyCodeLine{262 }
\DoxyCodeLine{263 }
\DoxyCodeLine{264 }
\DoxyCodeLine{265 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{266 \textcolor{keyword}{inline}}
\DoxyCodeLine{267 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{268 op\_sqrtmat\_cx::apply\_direct\_noalias(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classdiagmat__proxy}{diagmat\_proxy<T1>}}\& P)}
\DoxyCodeLine{269   \{}
\DoxyCodeLine{270   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{271   }
\DoxyCodeLine{272   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{273   }
\DoxyCodeLine{274   arma\_debug\_check( (P.n\_rows != P.n\_cols), \textcolor{stringliteral}{"{}sqrtmat(): given matrix must be square sized"{}} );}
\DoxyCodeLine{275   }
\DoxyCodeLine{276   \textcolor{keyword}{const} uword N = P.n\_rows;}
\DoxyCodeLine{277   }
\DoxyCodeLine{278   out.zeros(N,N);}
\DoxyCodeLine{279   }
\DoxyCodeLine{280   \textcolor{keyword}{const} eT zero = eT(0);}
\DoxyCodeLine{281   }
\DoxyCodeLine{282   \textcolor{keywordtype}{bool} singular = \textcolor{keyword}{false};}
\DoxyCodeLine{283   }
\DoxyCodeLine{284   \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)}
\DoxyCodeLine{285     \{}
\DoxyCodeLine{286     \textcolor{keyword}{const} eT val = P[i];}
\DoxyCodeLine{287     }
\DoxyCodeLine{288     singular = (singular || (val == zero));}
\DoxyCodeLine{289     }
\DoxyCodeLine{290     out.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,i) = std::sqrt(val);}
\DoxyCodeLine{291     \}}
\DoxyCodeLine{292   }
\DoxyCodeLine{293   \textcolor{keywordflow}{return} (singular) ? false : \textcolor{keyword}{true};}
\DoxyCodeLine{294   \}}
\DoxyCodeLine{295 }
\DoxyCodeLine{296 }
\DoxyCodeLine{297 }
\DoxyCodeLine{298 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{299 \textcolor{keyword}{inline}}
\DoxyCodeLine{300 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{301 op\_sqrtmat\_cx::apply\_direct(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::elem\_type,T1>}}\& expr)}
\DoxyCodeLine{302   \{}
\DoxyCodeLine{303   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{304   }
\DoxyCodeLine{305   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type   T;}
\DoxyCodeLine{306   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{307   }
\DoxyCodeLine{308   \mbox{\hyperlink{classMat}{Mat<eT>}} U;}
\DoxyCodeLine{309   \mbox{\hyperlink{classMat}{Mat<eT>}} S = expr.get\_ref();}
\DoxyCodeLine{310   }
\DoxyCodeLine{311   arma\_debug\_check( (S.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}} != S.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}}), \textcolor{stringliteral}{"{}sqrtmat(): given matrix must be square sized"{}} );}
\DoxyCodeLine{312   }
\DoxyCodeLine{313   \textcolor{keywordflow}{if}(S.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}} == 0)}
\DoxyCodeLine{314     \{}
\DoxyCodeLine{315     out.reset();}
\DoxyCodeLine{316     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{317     \}}
\DoxyCodeLine{318   \textcolor{keywordflow}{else}}
\DoxyCodeLine{319   \textcolor{keywordflow}{if}(S.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}} == 1)}
\DoxyCodeLine{320     \{}
\DoxyCodeLine{321     out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(1,1);}
\DoxyCodeLine{322     out[0] = std::sqrt(S[0]);}
\DoxyCodeLine{323     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{324     \}}
\DoxyCodeLine{325   }
\DoxyCodeLine{326   \textcolor{keywordflow}{if}(S.is\_diagmat())}
\DoxyCodeLine{327     \{}
\DoxyCodeLine{328     \textcolor{keyword}{const} uword N = S.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}};}
\DoxyCodeLine{329     }
\DoxyCodeLine{330     out.zeros(N,N);  \textcolor{comment}{// aliasing can't happen as S is generated}}
\DoxyCodeLine{331     }
\DoxyCodeLine{332     \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)  \{ out.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,i) = std::sqrt( S.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,i) ); \}}
\DoxyCodeLine{333     }
\DoxyCodeLine{334     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{335     \}}
\DoxyCodeLine{336   }
\DoxyCodeLine{337 \textcolor{preprocessor}{  \#if defined(ARMA\_OPTIMISE\_SYMPD)}}
\DoxyCodeLine{338     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} try\_sympd = sympd\_helper::guess\_sympd\_anysize(S);}
\DoxyCodeLine{339 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{340     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} try\_sympd = \textcolor{keyword}{false};}
\DoxyCodeLine{341 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{342   }
\DoxyCodeLine{343   \textcolor{keywordflow}{if}(try\_sympd)}
\DoxyCodeLine{344     \{}
\DoxyCodeLine{345     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}op\_sqrtmat\_cx: attempting sympd optimisation"{}});}
\DoxyCodeLine{346     }
\DoxyCodeLine{347     \textcolor{comment}{// if matrix S is sympd, all its eigenvalues are positive}}
\DoxyCodeLine{348     }
\DoxyCodeLine{349     \mbox{\hyperlink{classCol}{Col< T>}} eigval;}
\DoxyCodeLine{350     \mbox{\hyperlink{classMat}{Mat<eT>}} eigvec;}
\DoxyCodeLine{351     }
\DoxyCodeLine{352     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} eig\_status = \mbox{\hyperlink{group__fn__eig__sym_gac55fe3206226539aa46643bc8ac9abe2}{eig\_sym\_helper}}(eigval, eigvec, S, \textcolor{charliteral}{'d'}, \textcolor{stringliteral}{"{}sqrtmat()"{}});}
\DoxyCodeLine{353     }
\DoxyCodeLine{354     \textcolor{keywordflow}{if}(eig\_status)}
\DoxyCodeLine{355       \{}
\DoxyCodeLine{356       \textcolor{comment}{// ensure each eigenvalue is > 0}}
\DoxyCodeLine{357       }
\DoxyCodeLine{358       \textcolor{keyword}{const} uword N          = eigval.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}};}
\DoxyCodeLine{359       \textcolor{keyword}{const} T*    eigval\_mem = eigval.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{360       }
\DoxyCodeLine{361       \textcolor{keywordtype}{bool} all\_pos = \textcolor{keyword}{true};}
\DoxyCodeLine{362       }
\DoxyCodeLine{363       \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)  \{ all\_pos = (eigval\_mem[i] <= T(0)) ? \textcolor{keyword}{false} : all\_pos; \}}
\DoxyCodeLine{364       }
\DoxyCodeLine{365       \textcolor{keywordflow}{if}(all\_pos)}
\DoxyCodeLine{366         \{}
\DoxyCodeLine{367         eigval = sqrt(eigval);}
\DoxyCodeLine{368         }
\DoxyCodeLine{369         out = eigvec * \mbox{\hyperlink{group__fn__diagmat_ga8bb70dfa94511eb84368ef6107dd030e}{diagmat}}(eigval) * eigvec.t();}
\DoxyCodeLine{370         }
\DoxyCodeLine{371         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{372         \}}
\DoxyCodeLine{373       \}}
\DoxyCodeLine{374     }
\DoxyCodeLine{375     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}op\_sqrtmat\_cx: sympd optimisation failed"{}});}
\DoxyCodeLine{376     }
\DoxyCodeLine{377     \textcolor{comment}{// fallthrough if eigen decomposition failed or an eigenvalue is zero}}
\DoxyCodeLine{378     \}}
\DoxyCodeLine{379   }
\DoxyCodeLine{380   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} schur\_ok = auxlib::schur(U, S);}
\DoxyCodeLine{381   }
\DoxyCodeLine{382   \textcolor{keywordflow}{if}(schur\_ok == \textcolor{keyword}{false})}
\DoxyCodeLine{383     \{}
\DoxyCodeLine{384     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}sqrtmat(): schur decomposition failed"{}});}
\DoxyCodeLine{385     out.soft\_reset();}
\DoxyCodeLine{386     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{387     \}}
\DoxyCodeLine{388   }
\DoxyCodeLine{389   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} status = op\_sqrtmat\_cx::helper(S);}
\DoxyCodeLine{390   }
\DoxyCodeLine{391   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}} X = U*S;}
\DoxyCodeLine{392   }
\DoxyCodeLine{393   S.reset();}
\DoxyCodeLine{394   }
\DoxyCodeLine{395   out = X*U.t();}
\DoxyCodeLine{396   }
\DoxyCodeLine{397   \textcolor{keywordflow}{return} status;}
\DoxyCodeLine{398   \}}
\DoxyCodeLine{399 }
\DoxyCodeLine{400 }
\DoxyCodeLine{401 }
\DoxyCodeLine{402 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{403 \textcolor{keyword}{inline}}
\DoxyCodeLine{404 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{405 op\_sqrtmat\_cx::helper(\mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& S)}
\DoxyCodeLine{406   \{}
\DoxyCodeLine{407   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<T> eT;}
\DoxyCodeLine{408   }
\DoxyCodeLine{409   \textcolor{keywordflow}{if}(S.is\_empty())  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{410   }
\DoxyCodeLine{411   \textcolor{keyword}{const} uword N = S.n\_rows;}
\DoxyCodeLine{412   }
\DoxyCodeLine{413   \textcolor{keyword}{const} eT zero = eT(0);}
\DoxyCodeLine{414   }
\DoxyCodeLine{415   eT\& S\_00 = S[0];}
\DoxyCodeLine{416   }
\DoxyCodeLine{417   \textcolor{keywordtype}{bool} singular = (S\_00 == zero);}
\DoxyCodeLine{418   }
\DoxyCodeLine{419   S\_00 = std::sqrt(S\_00);}
\DoxyCodeLine{420   }
\DoxyCodeLine{421   \textcolor{keywordflow}{for}(uword j=1; j < N; ++j)}
\DoxyCodeLine{422     \{}
\DoxyCodeLine{423     eT* S\_j = S.colptr(j);}
\DoxyCodeLine{424     }
\DoxyCodeLine{425     eT\& S\_jj = S\_j[j];}
\DoxyCodeLine{426     }
\DoxyCodeLine{427     singular = (singular || (S\_jj == zero));}
\DoxyCodeLine{428     }
\DoxyCodeLine{429     S\_jj = std::sqrt(S\_jj);}
\DoxyCodeLine{430     }
\DoxyCodeLine{431     \textcolor{keywordflow}{for}(uword ii=0; ii <= (j-\/1); ++ii)}
\DoxyCodeLine{432       \{}
\DoxyCodeLine{433       \textcolor{keyword}{const} uword i = (j-\/1) -\/ ii;}
\DoxyCodeLine{434       }
\DoxyCodeLine{435       \textcolor{keyword}{const} eT* S\_i = S.colptr(i);}
\DoxyCodeLine{436       }
\DoxyCodeLine{437       \textcolor{comment}{//S\_j[i] /= (S\_i[i] + S\_j[j]);}}
\DoxyCodeLine{438       S\_j[i] /= (S\_i[i] + S\_jj);}
\DoxyCodeLine{439       }
\DoxyCodeLine{440       \textcolor{keywordflow}{for}(uword k=0; k < i; ++k)}
\DoxyCodeLine{441         \{}
\DoxyCodeLine{442         S\_j[k] -\/= S\_i[k] * S\_j[i];}
\DoxyCodeLine{443         \}}
\DoxyCodeLine{444       \}}
\DoxyCodeLine{445     \}}
\DoxyCodeLine{446   }
\DoxyCodeLine{447   \textcolor{keywordflow}{return} (singular) ? false : \textcolor{keyword}{true};}
\DoxyCodeLine{448   \}}
\DoxyCodeLine{449 }
\DoxyCodeLine{450 }
\DoxyCodeLine{451 }
\DoxyCodeLine{452 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{453 \textcolor{keyword}{inline}}
\DoxyCodeLine{454 \textcolor{keywordtype}{void}}
\DoxyCodeLine{455 op\_sqrtmat\_sympd::apply(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T1,op\_sqrtmat\_sympd>}}\& in)}
\DoxyCodeLine{456   \{}
\DoxyCodeLine{457   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{458   }
\DoxyCodeLine{459   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} status = op\_sqrtmat\_sympd::apply\_direct(out, in.\mbox{\hyperlink{classOp_af7ab7221b6e233cdd38b9f9b69f301ce}{m}});}
\DoxyCodeLine{460   }
\DoxyCodeLine{461   \textcolor{keywordflow}{if}(status == \textcolor{keyword}{false})}
\DoxyCodeLine{462     \{}
\DoxyCodeLine{463     out.soft\_reset();}
\DoxyCodeLine{464     arma\_stop\_runtime\_error(\textcolor{stringliteral}{"{}sqrtmat\_sympd(): transformation failed"{}});}
\DoxyCodeLine{465     \}}
\DoxyCodeLine{466   \}}
\DoxyCodeLine{467 }
\DoxyCodeLine{468 }
\DoxyCodeLine{469 }
\DoxyCodeLine{470 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{471 \textcolor{keyword}{inline}}
\DoxyCodeLine{472 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{473 op\_sqrtmat\_sympd::apply\_direct(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::elem\_type,T1>}}\& expr)}
\DoxyCodeLine{474   \{}
\DoxyCodeLine{475   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{476   }
\DoxyCodeLine{477 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{478     \{}
\DoxyCodeLine{479     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type   T;}
\DoxyCodeLine{480     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{481     }
\DoxyCodeLine{482     \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap}{unwrap<T1>}}   U(expr.get\_ref());}
\DoxyCodeLine{483     \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X = U.M;}
\DoxyCodeLine{484     }
\DoxyCodeLine{485     arma\_debug\_check( (X.is\_square() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}sqrtmat\_sympd(): given matrix must be square sized"{}} );}
\DoxyCodeLine{486     }
\DoxyCodeLine{487     \mbox{\hyperlink{classCol}{Col< T>}} eigval;}
\DoxyCodeLine{488     \mbox{\hyperlink{classMat}{Mat<eT>}} eigvec;}
\DoxyCodeLine{489     }
\DoxyCodeLine{490     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} status = \mbox{\hyperlink{group__fn__eig__sym_gac55fe3206226539aa46643bc8ac9abe2}{eig\_sym\_helper}}(eigval, eigvec, X, \textcolor{charliteral}{'d'}, \textcolor{stringliteral}{"{}sqrtmat\_sympd()"{}});}
\DoxyCodeLine{491     }
\DoxyCodeLine{492     \textcolor{keywordflow}{if}(status == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{493     }
\DoxyCodeLine{494     \textcolor{keyword}{const} uword N          = eigval.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}};}
\DoxyCodeLine{495     \textcolor{keyword}{const} T*    eigval\_mem = eigval.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{496     }
\DoxyCodeLine{497     \textcolor{keywordtype}{bool} all\_pos = \textcolor{keyword}{true};}
\DoxyCodeLine{498     }
\DoxyCodeLine{499     \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)  \{ all\_pos = (eigval\_mem[i] < T(0)) ? \textcolor{keyword}{false} : all\_pos; \}}
\DoxyCodeLine{500     }
\DoxyCodeLine{501     \textcolor{keywordflow}{if}(all\_pos == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{502     }
\DoxyCodeLine{503     eigval = sqrt(eigval);}
\DoxyCodeLine{504     }
\DoxyCodeLine{505     out = eigvec * \mbox{\hyperlink{group__fn__diagmat_ga8bb70dfa94511eb84368ef6107dd030e}{diagmat}}(eigval) * eigvec.t();}
\DoxyCodeLine{506     }
\DoxyCodeLine{507     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{508     \}}
\DoxyCodeLine{509 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{510     \{}
\DoxyCodeLine{511     arma\_ignore(out);}
\DoxyCodeLine{512     arma\_ignore(expr);}
\DoxyCodeLine{513     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}sqrtmat\_sympd(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{514     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{515     \}}
\DoxyCodeLine{516 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{517   \}}
\DoxyCodeLine{518 }
\DoxyCodeLine{519 }
\DoxyCodeLine{520 }

\end{DoxyCode}
