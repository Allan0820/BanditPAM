\hypertarget{op__vectorise__meat_8hpp_source}{}\doxysection{op\+\_\+vectorise\+\_\+meat.\+hpp}
\label{op__vectorise__meat_8hpp_source}\index{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/op\_vectorise\_meat.hpp@{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/op\_vectorise\_meat.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008-\/2016 Conrad Sanderson (http://conradsanderson.id.au)}}
\DoxyCodeLine{2 \textcolor{comment}{// Copyright 2008-\/2016 National ICT Australia (NICTA)}}
\DoxyCodeLine{3 \textcolor{comment}{// }}
\DoxyCodeLine{4 \textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{5 \textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{6 \textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{7 \textcolor{comment}{// http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{8 \textcolor{comment}{// }}
\DoxyCodeLine{9 \textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{10 \textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{11 \textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{12 \textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{13 \textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{14 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{17 }
\DoxyCodeLine{20 }
\DoxyCodeLine{21 }
\DoxyCodeLine{22 }
\DoxyCodeLine{23 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{24 \textcolor{keyword}{inline}}
\DoxyCodeLine{25 \textcolor{keywordtype}{void}}
\DoxyCodeLine{26 op\_vectorise\_col::apply(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T1,op\_vectorise\_col>}}\& in)}
\DoxyCodeLine{27   \{}
\DoxyCodeLine{28   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{29   }
\DoxyCodeLine{30   op\_vectorise\_col::apply\_direct(out, in.\mbox{\hyperlink{classOp_af7ab7221b6e233cdd38b9f9b69f301ce}{m}});}
\DoxyCodeLine{31   \}}
\DoxyCodeLine{32 }
\DoxyCodeLine{33 }
\DoxyCodeLine{34 }
\DoxyCodeLine{35 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{36 \textcolor{keyword}{inline}}
\DoxyCodeLine{37 \textcolor{keywordtype}{void}}
\DoxyCodeLine{38 op\_vectorise\_col::apply\_direct(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} T1\& expr)}
\DoxyCodeLine{39   \{}
\DoxyCodeLine{40   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{41   }
\DoxyCodeLine{42   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{43   }
\DoxyCodeLine{44   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__Mat}{is\_Mat<T1>::value}} || \mbox{\hyperlink{structis__Mat}{is\_Mat}}<\textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::stored\_type}}>::value || (arma\_config::openmp \&\& \mbox{\hyperlink{classProxy}{Proxy<T1>::use\_mp}}))}
\DoxyCodeLine{45     \{}
\DoxyCodeLine{46     \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap}{unwrap<T1>}} U(expr);}
\DoxyCodeLine{47     }
\DoxyCodeLine{48     \textcolor{keywordflow}{if}(\&out == \&(U.M))}
\DoxyCodeLine{49       \{}
\DoxyCodeLine{50       \textcolor{comment}{// output matrix is the same as the input matrix}}
\DoxyCodeLine{51       }
\DoxyCodeLine{52       out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(out.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}}, 1);  \textcolor{comment}{// set\_size() doesn't destroy data as long as the number of elements in the matrix remains the same}}
\DoxyCodeLine{53       \}}
\DoxyCodeLine{54     \textcolor{keywordflow}{else}}
\DoxyCodeLine{55       \{}
\DoxyCodeLine{56       out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(U.M.n\_elem, 1);}
\DoxyCodeLine{57       }
\DoxyCodeLine{58       arrayops::copy(out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), U.M.memptr(), U.M.n\_elem);}
\DoxyCodeLine{59       \}}
\DoxyCodeLine{60     \}}
\DoxyCodeLine{61   \textcolor{keywordflow}{else}}
\DoxyCodeLine{62   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__subview}{is\_subview<T1>::value}})}
\DoxyCodeLine{63     \{}
\DoxyCodeLine{64     \textcolor{keyword}{const} \mbox{\hyperlink{classsubview}{subview<eT>}}\& sv = \textcolor{keyword}{reinterpret\_cast<} \textcolor{keyword}{const }\mbox{\hyperlink{classsubview}{subview<eT>}}\& \textcolor{keyword}{>}(expr);}
\DoxyCodeLine{65     }
\DoxyCodeLine{66     \textcolor{keywordflow}{if}(\&out == \&(sv.m))}
\DoxyCodeLine{67       \{}
\DoxyCodeLine{68       \mbox{\hyperlink{classMat}{Mat<eT>}} tmp;}
\DoxyCodeLine{69       }
\DoxyCodeLine{70       op\_vectorise\_col::apply\_subview(tmp, sv);}
\DoxyCodeLine{71       }
\DoxyCodeLine{72       out.\mbox{\hyperlink{group__Mat_gaff06a75771f96605f7cc4f8c6b3fceb7}{steal\_mem}}(tmp);}
\DoxyCodeLine{73       \}}
\DoxyCodeLine{74     \textcolor{keywordflow}{else}}
\DoxyCodeLine{75       \{}
\DoxyCodeLine{76       op\_vectorise\_col::apply\_subview(out, sv);}
\DoxyCodeLine{77       \}}
\DoxyCodeLine{78     \}}
\DoxyCodeLine{79   \textcolor{keywordflow}{else}}
\DoxyCodeLine{80     \{}
\DoxyCodeLine{81     \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} P(expr);}
\DoxyCodeLine{82     }
\DoxyCodeLine{83     \textcolor{keywordflow}{if}(P.is\_alias(out))}
\DoxyCodeLine{84       \{}
\DoxyCodeLine{85       \mbox{\hyperlink{classMat}{Mat<eT>}} tmp;}
\DoxyCodeLine{86       }
\DoxyCodeLine{87       op\_vectorise\_col::apply\_proxy(tmp, P);}
\DoxyCodeLine{88       }
\DoxyCodeLine{89       out.\mbox{\hyperlink{group__Mat_gaff06a75771f96605f7cc4f8c6b3fceb7}{steal\_mem}}(tmp);}
\DoxyCodeLine{90       \}}
\DoxyCodeLine{91     \textcolor{keywordflow}{else}}
\DoxyCodeLine{92       \{}
\DoxyCodeLine{93       op\_vectorise\_col::apply\_proxy(out, P);}
\DoxyCodeLine{94       \}}
\DoxyCodeLine{95     \}}
\DoxyCodeLine{96   \}}
\DoxyCodeLine{97 }
\DoxyCodeLine{98 }
\DoxyCodeLine{99 }
\DoxyCodeLine{100 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{101 \textcolor{keyword}{inline}}
\DoxyCodeLine{102 \textcolor{keywordtype}{void}}
\DoxyCodeLine{103 op\_vectorise\_col::apply\_subview(\mbox{\hyperlink{classMat}{Mat<eT>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classsubview}{subview<eT>}}\& sv)}
\DoxyCodeLine{104   \{}
\DoxyCodeLine{105   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{106   }
\DoxyCodeLine{107   \textcolor{keyword}{const} uword sv\_n\_rows = sv.n\_rows;}
\DoxyCodeLine{108   \textcolor{keyword}{const} uword sv\_n\_cols = sv.n\_cols;}
\DoxyCodeLine{109   }
\DoxyCodeLine{110   out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(sv.n\_elem, 1);}
\DoxyCodeLine{111   }
\DoxyCodeLine{112   eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{113   }
\DoxyCodeLine{114   \textcolor{keywordflow}{for}(uword col=0; col < sv\_n\_cols; ++col)}
\DoxyCodeLine{115     \{}
\DoxyCodeLine{116     arrayops::copy(out\_mem, sv.colptr(col), sv\_n\_rows);}
\DoxyCodeLine{117     }
\DoxyCodeLine{118     out\_mem += sv\_n\_rows;}
\DoxyCodeLine{119     \}}
\DoxyCodeLine{120   \}}
\DoxyCodeLine{121 }
\DoxyCodeLine{122 }
\DoxyCodeLine{123 }
\DoxyCodeLine{124 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{125 \textcolor{keyword}{inline}}
\DoxyCodeLine{126 \textcolor{keywordtype}{void}}
\DoxyCodeLine{127 op\_vectorise\_col::apply\_proxy(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}}\& P)}
\DoxyCodeLine{128   \{}
\DoxyCodeLine{129   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{130   }
\DoxyCodeLine{131   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{132   }
\DoxyCodeLine{133   \textcolor{keyword}{const} uword N = P.get\_n\_elem();}
\DoxyCodeLine{134   }
\DoxyCodeLine{135   out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(N, 1);}
\DoxyCodeLine{136   }
\DoxyCodeLine{137   eT* outmem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{138   }
\DoxyCodeLine{139   \textcolor{keywordflow}{if}(\mbox{\hyperlink{classProxy}{Proxy<T1>::use\_at}} == \textcolor{keyword}{false})}
\DoxyCodeLine{140     \{}
\DoxyCodeLine{141     \textcolor{comment}{// TODO: add handling of aligned access ?}}
\DoxyCodeLine{142     }
\DoxyCodeLine{143     \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::ea\_type}} \mbox{\hyperlink{structA}{A}} = P.get\_ea();}
\DoxyCodeLine{144     }
\DoxyCodeLine{145     uword i,j;}
\DoxyCodeLine{146     }
\DoxyCodeLine{147     \textcolor{keywordflow}{for}(i=0, j=1; j < N; i+=2, j+=2)}
\DoxyCodeLine{148       \{}
\DoxyCodeLine{149       \textcolor{keyword}{const} eT tmp\_i = \mbox{\hyperlink{structA}{A}}[i];}
\DoxyCodeLine{150       \textcolor{keyword}{const} eT tmp\_j = \mbox{\hyperlink{structA}{A}}[j];}
\DoxyCodeLine{151       }
\DoxyCodeLine{152       outmem[i] = tmp\_i;}
\DoxyCodeLine{153       outmem[j] = tmp\_j;}
\DoxyCodeLine{154       \}}
\DoxyCodeLine{155     }
\DoxyCodeLine{156     \textcolor{keywordflow}{if}(i < N)}
\DoxyCodeLine{157       \{}
\DoxyCodeLine{158       outmem[i] = \mbox{\hyperlink{structA}{A}}[i];}
\DoxyCodeLine{159       \}}
\DoxyCodeLine{160     \}}
\DoxyCodeLine{161   \textcolor{keywordflow}{else}}
\DoxyCodeLine{162     \{}
\DoxyCodeLine{163     \textcolor{keyword}{const} uword n\_rows = P.get\_n\_rows();}
\DoxyCodeLine{164     \textcolor{keyword}{const} uword n\_cols = P.get\_n\_cols();}
\DoxyCodeLine{165     }
\DoxyCodeLine{166     \textcolor{keywordflow}{if}(n\_rows == 1)}
\DoxyCodeLine{167       \{}
\DoxyCodeLine{168       \textcolor{keywordflow}{for}(uword i=0; i < n\_cols; ++i)}
\DoxyCodeLine{169         \{}
\DoxyCodeLine{170         outmem[i] = P.at(0,i);}
\DoxyCodeLine{171         \}}
\DoxyCodeLine{172       \}}
\DoxyCodeLine{173     \textcolor{keywordflow}{else}}
\DoxyCodeLine{174       \{}
\DoxyCodeLine{175       \textcolor{keywordflow}{for}(uword col=0; col < n\_cols; ++col)}
\DoxyCodeLine{176       \textcolor{keywordflow}{for}(uword row=0; row < n\_rows; ++row)}
\DoxyCodeLine{177         \{}
\DoxyCodeLine{178         *outmem = P.at(row,col);}
\DoxyCodeLine{179         outmem++;}
\DoxyCodeLine{180         \}}
\DoxyCodeLine{181       \}}
\DoxyCodeLine{182     \}}
\DoxyCodeLine{183   \}}
\DoxyCodeLine{184 }
\DoxyCodeLine{185 }
\DoxyCodeLine{186 }
\DoxyCodeLine{187 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{188 \textcolor{keyword}{inline}}
\DoxyCodeLine{189 \textcolor{keywordtype}{void}}
\DoxyCodeLine{190 op\_vectorise\_row::apply(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T1,op\_vectorise\_row>}}\& in)}
\DoxyCodeLine{191   \{}
\DoxyCodeLine{192   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{193   }
\DoxyCodeLine{194   op\_vectorise\_row::apply\_direct(out, in.\mbox{\hyperlink{classOp_af7ab7221b6e233cdd38b9f9b69f301ce}{m}});}
\DoxyCodeLine{195   \}}
\DoxyCodeLine{196 }
\DoxyCodeLine{197 }
\DoxyCodeLine{198 }
\DoxyCodeLine{199 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{200 \textcolor{keyword}{inline}}
\DoxyCodeLine{201 \textcolor{keywordtype}{void}}
\DoxyCodeLine{202 op\_vectorise\_row::apply\_direct(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} T1\& expr)}
\DoxyCodeLine{203   \{}
\DoxyCodeLine{204   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{205   }
\DoxyCodeLine{206   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{207   }
\DoxyCodeLine{208   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} P(expr);}
\DoxyCodeLine{209   }
\DoxyCodeLine{210   \textcolor{keywordflow}{if}(P.is\_alias(out))}
\DoxyCodeLine{211     \{}
\DoxyCodeLine{212     \mbox{\hyperlink{classMat}{Mat<eT>}} tmp;}
\DoxyCodeLine{213     }
\DoxyCodeLine{214     op\_vectorise\_row::apply\_proxy(tmp, P);}
\DoxyCodeLine{215     }
\DoxyCodeLine{216     out.\mbox{\hyperlink{group__Mat_gaff06a75771f96605f7cc4f8c6b3fceb7}{steal\_mem}}(tmp);}
\DoxyCodeLine{217     \}}
\DoxyCodeLine{218   \textcolor{keywordflow}{else}}
\DoxyCodeLine{219     \{}
\DoxyCodeLine{220     op\_vectorise\_row::apply\_proxy(out, P);}
\DoxyCodeLine{221     \}}
\DoxyCodeLine{222   \}}
\DoxyCodeLine{223 }
\DoxyCodeLine{224 }
\DoxyCodeLine{225 }
\DoxyCodeLine{226 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{227 \textcolor{keyword}{inline}}
\DoxyCodeLine{228 \textcolor{keywordtype}{void}}
\DoxyCodeLine{229 op\_vectorise\_row::apply\_proxy(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}}\& P)}
\DoxyCodeLine{230   \{}
\DoxyCodeLine{231   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{232   }
\DoxyCodeLine{233   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{234   }
\DoxyCodeLine{235   \textcolor{keyword}{const} uword n\_rows = P.get\_n\_rows();}
\DoxyCodeLine{236   \textcolor{keyword}{const} uword n\_cols = P.get\_n\_cols();}
\DoxyCodeLine{237   \textcolor{keyword}{const} uword n\_elem = P.get\_n\_elem();}
\DoxyCodeLine{238   }
\DoxyCodeLine{239   out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(1, n\_elem);}
\DoxyCodeLine{240   }
\DoxyCodeLine{241   eT* outmem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{242   }
\DoxyCodeLine{243   \textcolor{keywordflow}{if}(n\_cols == 1)}
\DoxyCodeLine{244     \{}
\DoxyCodeLine{245     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__Mat}{is\_Mat}}<\textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::stored\_type}}>::value)}
\DoxyCodeLine{246       \{}
\DoxyCodeLine{247       \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap}{unwrap<typename Proxy<T1>::stored\_type}}> tmp(P.Q);}
\DoxyCodeLine{248       }
\DoxyCodeLine{249       arrayops::copy(out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), tmp.M.memptr(), n\_elem);}
\DoxyCodeLine{250       \}}
\DoxyCodeLine{251     \textcolor{keywordflow}{else}}
\DoxyCodeLine{252       \{}
\DoxyCodeLine{253       \textcolor{keywordflow}{for}(uword i=0; i < n\_elem; ++i)  \{ outmem[i] = P.at(i,0); \}}
\DoxyCodeLine{254       \}}
\DoxyCodeLine{255     \}}
\DoxyCodeLine{256   \textcolor{keywordflow}{else}}
\DoxyCodeLine{257     \{}
\DoxyCodeLine{258     \textcolor{keywordflow}{for}(uword row=0; row < n\_rows; ++row)}
\DoxyCodeLine{259       \{}
\DoxyCodeLine{260       uword i,j;}
\DoxyCodeLine{261       }
\DoxyCodeLine{262       \textcolor{keywordflow}{for}(i=0, j=1; j < n\_cols; i+=2, j+=2)}
\DoxyCodeLine{263         \{}
\DoxyCodeLine{264         \textcolor{keyword}{const} eT tmp\_i = P.at(row,i);}
\DoxyCodeLine{265         \textcolor{keyword}{const} eT tmp\_j = P.at(row,j);}
\DoxyCodeLine{266         }
\DoxyCodeLine{267         *outmem = tmp\_i; outmem++;}
\DoxyCodeLine{268         *outmem = tmp\_j; outmem++;}
\DoxyCodeLine{269         \}}
\DoxyCodeLine{270       }
\DoxyCodeLine{271       \textcolor{keywordflow}{if}(i < n\_cols)}
\DoxyCodeLine{272         \{}
\DoxyCodeLine{273         *outmem = P.at(row,i); outmem++;}
\DoxyCodeLine{274         \}}
\DoxyCodeLine{275       \}}
\DoxyCodeLine{276     \}}
\DoxyCodeLine{277   \}}
\DoxyCodeLine{278 }
\DoxyCodeLine{279 }
\DoxyCodeLine{280 }
\DoxyCodeLine{281 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{282 \textcolor{keyword}{inline}}
\DoxyCodeLine{283 \textcolor{keywordtype}{void}}
\DoxyCodeLine{284 op\_vectorise\_all::apply(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T1,op\_vectorise\_all>}}\& in)}
\DoxyCodeLine{285   \{}
\DoxyCodeLine{286   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{287   }
\DoxyCodeLine{288   \textcolor{keyword}{const} uword dim = in.\mbox{\hyperlink{classOp_a197cb9330fe0d72c976d6223514c4bd6}{aux\_uword\_a}};}
\DoxyCodeLine{289   }
\DoxyCodeLine{290   \textcolor{keywordflow}{if}(dim == 0)}
\DoxyCodeLine{291     \{}
\DoxyCodeLine{292     op\_vectorise\_col::apply\_direct(out, in.\mbox{\hyperlink{classOp_af7ab7221b6e233cdd38b9f9b69f301ce}{m}});}
\DoxyCodeLine{293     \}}
\DoxyCodeLine{294   \textcolor{keywordflow}{else}}
\DoxyCodeLine{295     \{}
\DoxyCodeLine{296     op\_vectorise\_row::apply\_direct(out, in.\mbox{\hyperlink{classOp_af7ab7221b6e233cdd38b9f9b69f301ce}{m}});}
\DoxyCodeLine{297     \}}
\DoxyCodeLine{298   \}}
\DoxyCodeLine{299 }
\DoxyCodeLine{300 }
\DoxyCodeLine{301 }
\DoxyCodeLine{302 \textcolor{comment}{//}}
\DoxyCodeLine{303 }
\DoxyCodeLine{304 }
\DoxyCodeLine{305 }
\DoxyCodeLine{306 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{307 \textcolor{keyword}{inline}}
\DoxyCodeLine{308 \textcolor{keywordtype}{void}}
\DoxyCodeLine{309 op\_vectorise\_cube\_col::apply(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classCubeToMatOp}{CubeToMatOp<T1, op\_vectorise\_cube\_col>}}\& in)}
\DoxyCodeLine{310   \{}
\DoxyCodeLine{311   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{312   }
\DoxyCodeLine{313   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{314   }
\DoxyCodeLine{315   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type}}< T1, \mbox{\hyperlink{classsubview__cube}{subview\_cube<eT>}} >::yes)}
\DoxyCodeLine{316     \{}
\DoxyCodeLine{317     op\_vectorise\_cube\_col::apply\_subview(out, \textcolor{keyword}{reinterpret\_cast<} \textcolor{keyword}{const }\mbox{\hyperlink{classsubview__cube}{subview\_cube<eT>}}\& \textcolor{keyword}{>}(in.\mbox{\hyperlink{classCubeToMatOp_aaee8cba5abf6b8a82dc5eb09f2ec7e6a}{m}}));}
\DoxyCodeLine{318     \}}
\DoxyCodeLine{319   \textcolor{keywordflow}{else}}
\DoxyCodeLine{320     \{}
\DoxyCodeLine{321     \textcolor{keyword}{const} \mbox{\hyperlink{classProxyCube}{ProxyCube<T1>}} P(in.\mbox{\hyperlink{classCubeToMatOp_aaee8cba5abf6b8a82dc5eb09f2ec7e6a}{m}});}
\DoxyCodeLine{322     }
\DoxyCodeLine{323     op\_vectorise\_cube\_col::apply\_proxy(out, P);}
\DoxyCodeLine{324     \}}
\DoxyCodeLine{325   \}}
\DoxyCodeLine{326 }
\DoxyCodeLine{327 }
\DoxyCodeLine{328 }
\DoxyCodeLine{329 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{330 \textcolor{keyword}{inline}}
\DoxyCodeLine{331 \textcolor{keywordtype}{void}}
\DoxyCodeLine{332 op\_vectorise\_cube\_col::apply\_subview(\mbox{\hyperlink{classMat}{Mat<eT>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classsubview__cube}{subview\_cube<eT>}}\& sv)}
\DoxyCodeLine{333   \{}
\DoxyCodeLine{334   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{335   }
\DoxyCodeLine{336   \textcolor{keyword}{const} uword sv\_n\_rows   = sv.n\_rows;}
\DoxyCodeLine{337   \textcolor{keyword}{const} uword sv\_n\_cols   = sv.n\_cols;}
\DoxyCodeLine{338   \textcolor{keyword}{const} uword sv\_n\_slices = sv.n\_slices;}
\DoxyCodeLine{339   }
\DoxyCodeLine{340   out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(sv.n\_elem, 1);}
\DoxyCodeLine{341   }
\DoxyCodeLine{342   eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{343   }
\DoxyCodeLine{344   \textcolor{keywordflow}{for}(uword \mbox{\hyperlink{classslice}{slice}}=0; \mbox{\hyperlink{classslice}{slice}} < sv\_n\_slices; ++\mbox{\hyperlink{classslice}{slice}})}
\DoxyCodeLine{345   \textcolor{keywordflow}{for}(uword   col=0;   col < sv\_n\_cols;   ++col  )}
\DoxyCodeLine{346     \{}
\DoxyCodeLine{347     arrayops::copy(out\_mem, sv.slice\_colptr(\mbox{\hyperlink{classslice}{slice}},col), sv\_n\_rows);}
\DoxyCodeLine{348     }
\DoxyCodeLine{349     out\_mem += sv\_n\_rows;}
\DoxyCodeLine{350     \}}
\DoxyCodeLine{351   \}}
\DoxyCodeLine{352   }
\DoxyCodeLine{353   }
\DoxyCodeLine{354   }
\DoxyCodeLine{355 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{356 \textcolor{keyword}{inline}}
\DoxyCodeLine{357 \textcolor{keywordtype}{void}}
\DoxyCodeLine{358 op\_vectorise\_cube\_col::apply\_proxy(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classProxyCube}{ProxyCube<T1>}}\& P)}
\DoxyCodeLine{359   \{}
\DoxyCodeLine{360   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{361   }
\DoxyCodeLine{362   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{363   }
\DoxyCodeLine{364   \textcolor{keyword}{const} uword N = P.get\_n\_elem();}
\DoxyCodeLine{365   }
\DoxyCodeLine{366   out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(N, 1);}
\DoxyCodeLine{367   }
\DoxyCodeLine{368   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__Cube}{is\_Cube}}<\textcolor{keyword}{typename} \mbox{\hyperlink{classProxyCube}{ProxyCube<T1>::stored\_type}}>::value || (arma\_config::openmp \&\& \mbox{\hyperlink{classProxyCube}{ProxyCube<T1>::use\_mp}}))}
\DoxyCodeLine{369     \{}
\DoxyCodeLine{370     \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap__cube}{unwrap\_cube<typename ProxyCube<T1>::stored\_type}}> tmp(P.Q);}
\DoxyCodeLine{371     }
\DoxyCodeLine{372     arrayops::copy(out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), tmp.M.memptr(), N);}
\DoxyCodeLine{373     \}}
\DoxyCodeLine{374   \textcolor{keywordflow}{else}}
\DoxyCodeLine{375     \{}
\DoxyCodeLine{376     eT* outmem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{377     }
\DoxyCodeLine{378     \textcolor{keywordflow}{if}(\mbox{\hyperlink{classProxyCube}{ProxyCube<T1>::use\_at}} == \textcolor{keyword}{false})}
\DoxyCodeLine{379       \{}
\DoxyCodeLine{380       \textcolor{keyword}{typename} \mbox{\hyperlink{classProxyCube}{ProxyCube<T1>::ea\_type}} \mbox{\hyperlink{structA}{A}} = P.get\_ea();}
\DoxyCodeLine{381       }
\DoxyCodeLine{382       uword i,j;}
\DoxyCodeLine{383       }
\DoxyCodeLine{384       \textcolor{keywordflow}{for}(i=0, j=1; j < N; i+=2, j+=2)}
\DoxyCodeLine{385         \{}
\DoxyCodeLine{386         \textcolor{keyword}{const} eT tmp\_i = \mbox{\hyperlink{structA}{A}}[i];}
\DoxyCodeLine{387         \textcolor{keyword}{const} eT tmp\_j = \mbox{\hyperlink{structA}{A}}[j];}
\DoxyCodeLine{388         }
\DoxyCodeLine{389         outmem[i] = tmp\_i;}
\DoxyCodeLine{390         outmem[j] = tmp\_j;}
\DoxyCodeLine{391         \}}
\DoxyCodeLine{392       }
\DoxyCodeLine{393       \textcolor{keywordflow}{if}(i < N)}
\DoxyCodeLine{394         \{}
\DoxyCodeLine{395         outmem[i] = \mbox{\hyperlink{structA}{A}}[i];}
\DoxyCodeLine{396         \}}
\DoxyCodeLine{397       \}}
\DoxyCodeLine{398     \textcolor{keywordflow}{else}}
\DoxyCodeLine{399       \{}
\DoxyCodeLine{400       \textcolor{keyword}{const} uword n\_rows   = P.get\_n\_rows();}
\DoxyCodeLine{401       \textcolor{keyword}{const} uword n\_cols   = P.get\_n\_cols();}
\DoxyCodeLine{402       \textcolor{keyword}{const} uword n\_slices = P.get\_n\_slices();}
\DoxyCodeLine{403       }
\DoxyCodeLine{404       \textcolor{keywordflow}{for}(uword \mbox{\hyperlink{classslice}{slice}}=0; \mbox{\hyperlink{classslice}{slice}} < n\_slices; ++\mbox{\hyperlink{classslice}{slice}})}
\DoxyCodeLine{405       \textcolor{keywordflow}{for}(uword   col=0;   col < n\_cols;   ++col  )}
\DoxyCodeLine{406       \textcolor{keywordflow}{for}(uword   row=0;   row < n\_rows;   ++row  )}
\DoxyCodeLine{407         \{}
\DoxyCodeLine{408         *outmem = P.at(row,col,\mbox{\hyperlink{classslice}{slice}});}
\DoxyCodeLine{409         outmem++;}
\DoxyCodeLine{410         \}}
\DoxyCodeLine{411       \}}
\DoxyCodeLine{412     \}}
\DoxyCodeLine{413   \}}
\DoxyCodeLine{414 }
\DoxyCodeLine{415 }
\DoxyCodeLine{416 }

\end{DoxyCode}
