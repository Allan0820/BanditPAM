\hypertarget{op__find__meat_8hpp_source}{}\doxysection{op\+\_\+find\+\_\+meat.\+hpp}
\label{op__find__meat_8hpp_source}\index{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/op\_find\_meat.hpp@{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/op\_find\_meat.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008-\/2016 Conrad Sanderson (http://conradsanderson.id.au)}}
\DoxyCodeLine{2 \textcolor{comment}{// Copyright 2008-\/2016 National ICT Australia (NICTA)}}
\DoxyCodeLine{3 \textcolor{comment}{// }}
\DoxyCodeLine{4 \textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{5 \textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{6 \textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{7 \textcolor{comment}{// http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{8 \textcolor{comment}{// }}
\DoxyCodeLine{9 \textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{10 \textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{11 \textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{12 \textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{13 \textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{14 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{17 }
\DoxyCodeLine{20 }
\DoxyCodeLine{21 }
\DoxyCodeLine{22 }
\DoxyCodeLine{23 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{24 \textcolor{keyword}{inline}}
\DoxyCodeLine{25 uword}
\DoxyCodeLine{26 op\_find::helper}
\DoxyCodeLine{27   (}
\DoxyCodeLine{28   \mbox{\hyperlink{classMat}{Mat<uword>}}\& indices,}
\DoxyCodeLine{29   \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::elem\_type, T1>}}\& X}
\DoxyCodeLine{30   )}
\DoxyCodeLine{31   \{}
\DoxyCodeLine{32   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{33   }
\DoxyCodeLine{34   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{35   }
\DoxyCodeLine{36   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} \mbox{\hyperlink{structA}{A}}(X.get\_ref());}
\DoxyCodeLine{37   }
\DoxyCodeLine{38   \textcolor{keyword}{const} uword n\_elem = \mbox{\hyperlink{structA}{A}}.get\_n\_elem();}
\DoxyCodeLine{39   }
\DoxyCodeLine{40   indices.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(n\_elem, 1);}
\DoxyCodeLine{41   }
\DoxyCodeLine{42   uword* indices\_mem = indices.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{43   uword  n\_nz        = 0;}
\DoxyCodeLine{44   }
\DoxyCodeLine{45   \textcolor{keywordflow}{if}(\mbox{\hyperlink{classProxy}{Proxy<T1>::use\_at}} == \textcolor{keyword}{false})}
\DoxyCodeLine{46     \{}
\DoxyCodeLine{47     \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::ea\_type}} PA = \mbox{\hyperlink{structA}{A}}.get\_ea();}
\DoxyCodeLine{48     }
\DoxyCodeLine{49     \textcolor{keywordflow}{for}(uword i=0; i<n\_elem; ++i)}
\DoxyCodeLine{50       \{}
\DoxyCodeLine{51       \textcolor{keywordflow}{if}(PA[i] != eT(0))  \{ indices\_mem[n\_nz] = i;  ++n\_nz; \}}
\DoxyCodeLine{52       \}}
\DoxyCodeLine{53     \}}
\DoxyCodeLine{54   \textcolor{keywordflow}{else}}
\DoxyCodeLine{55     \{}
\DoxyCodeLine{56     \textcolor{keyword}{const} uword n\_rows = \mbox{\hyperlink{structA}{A}}.get\_n\_rows();}
\DoxyCodeLine{57     \textcolor{keyword}{const} uword n\_cols = \mbox{\hyperlink{structA}{A}}.get\_n\_cols();}
\DoxyCodeLine{58     }
\DoxyCodeLine{59     uword i = 0;}
\DoxyCodeLine{60     }
\DoxyCodeLine{61     \textcolor{keywordflow}{for}(uword col=0; col < n\_cols; ++col)}
\DoxyCodeLine{62     \textcolor{keywordflow}{for}(uword row=0; row < n\_rows; ++row)}
\DoxyCodeLine{63       \{}
\DoxyCodeLine{64       \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.at(row,col) != eT(0))  \{ indices\_mem[n\_nz] = i; ++n\_nz; \}}
\DoxyCodeLine{65       }
\DoxyCodeLine{66       ++i;}
\DoxyCodeLine{67       \}}
\DoxyCodeLine{68     \}}
\DoxyCodeLine{69   }
\DoxyCodeLine{70   \textcolor{keywordflow}{return} n\_nz;}
\DoxyCodeLine{71   \}}
\DoxyCodeLine{72 }
\DoxyCodeLine{73 }
\DoxyCodeLine{74 }
\DoxyCodeLine{75 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} op\_type>}
\DoxyCodeLine{76 \textcolor{keyword}{inline}}
\DoxyCodeLine{77 uword}
\DoxyCodeLine{78 op\_find::helper}
\DoxyCodeLine{79   (}
\DoxyCodeLine{80   \mbox{\hyperlink{classMat}{Mat<uword>}}\& indices,}
\DoxyCodeLine{81   \textcolor{keyword}{const} \mbox{\hyperlink{classmtOp}{mtOp<uword, T1, op\_type>}}\& X,}
\DoxyCodeLine{82   \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__op__rel__only}{arma\_op\_rel\_only<op\_type>::result}}*           junk1,}
\DoxyCodeLine{83   \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<typename T1::elem\_type>::result* junk2}
\DoxyCodeLine{84   )}
\DoxyCodeLine{85   \{}
\DoxyCodeLine{86   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{87   arma\_ignore(junk1);}
\DoxyCodeLine{88   arma\_ignore(junk2);}
\DoxyCodeLine{89   }
\DoxyCodeLine{90   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{91   }
\DoxyCodeLine{92   \textcolor{keyword}{const} eT val = X.aux;}
\DoxyCodeLine{93   }
\DoxyCodeLine{94   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} \mbox{\hyperlink{structA}{A}}(X.m);}
\DoxyCodeLine{95   }
\DoxyCodeLine{96   \textcolor{keyword}{const} uword n\_elem = \mbox{\hyperlink{structA}{A}}.get\_n\_elem();}
\DoxyCodeLine{97   }
\DoxyCodeLine{98   indices.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(n\_elem, 1);}
\DoxyCodeLine{99   }
\DoxyCodeLine{100   uword* indices\_mem = indices.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{101   uword  n\_nz        = 0;}
\DoxyCodeLine{102   }
\DoxyCodeLine{103   \textcolor{keywordflow}{if}(\mbox{\hyperlink{classProxy}{Proxy<T1>::use\_at}} == \textcolor{keyword}{false})}
\DoxyCodeLine{104     \{}
\DoxyCodeLine{105     \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::ea\_type}} PA = \mbox{\hyperlink{structA}{A}}.get\_ea();}
\DoxyCodeLine{106     }
\DoxyCodeLine{107     uword i,j;}
\DoxyCodeLine{108     \textcolor{keywordflow}{for}(i=0, j=1; j < n\_elem; i+=2, j+=2)}
\DoxyCodeLine{109       \{}
\DoxyCodeLine{110       \textcolor{keyword}{const} eT tpi = PA[i];}
\DoxyCodeLine{111       \textcolor{keyword}{const} eT tpj = PA[j];}
\DoxyCodeLine{112       }
\DoxyCodeLine{113       \textcolor{keywordtype}{bool} not\_zero\_i;}
\DoxyCodeLine{114       \textcolor{keywordtype}{bool} not\_zero\_j;}
\DoxyCodeLine{115       }
\DoxyCodeLine{116            \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_lt\_pre   >::yes}})  \{ not\_zero\_i = (val <  tpi); \}}
\DoxyCodeLine{117       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_lt\_post  >::yes}})  \{ not\_zero\_i = (tpi <  val); \}}
\DoxyCodeLine{118       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_gt\_pre   >::yes}})  \{ not\_zero\_i = (val >  tpi); \}}
\DoxyCodeLine{119       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_gt\_post  >::yes}})  \{ not\_zero\_i = (tpi >  val); \}}
\DoxyCodeLine{120       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_lteq\_pre >::yes}})  \{ not\_zero\_i = (val <= tpi); \}}
\DoxyCodeLine{121       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_lteq\_post>::yes}})  \{ not\_zero\_i = (tpi <= val); \}}
\DoxyCodeLine{122       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_gteq\_pre >::yes}})  \{ not\_zero\_i = (val >= tpi); \}}
\DoxyCodeLine{123       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_gteq\_post>::yes}})  \{ not\_zero\_i = (tpi >= val); \}}
\DoxyCodeLine{124       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_eq       >::yes}})  \{ not\_zero\_i = (tpi == val); \}}
\DoxyCodeLine{125       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_noteq    >::yes}})  \{ not\_zero\_i = (tpi != val); \}}
\DoxyCodeLine{126       \textcolor{keywordflow}{else} \{ not\_zero\_i = \textcolor{keyword}{false}; \}}
\DoxyCodeLine{127       }
\DoxyCodeLine{128            \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_lt\_pre   >::yes}})  \{ not\_zero\_j = (val <  tpj); \}}
\DoxyCodeLine{129       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_lt\_post  >::yes}})  \{ not\_zero\_j = (tpj <  val); \}}
\DoxyCodeLine{130       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_gt\_pre   >::yes}})  \{ not\_zero\_j = (val >  tpj); \}}
\DoxyCodeLine{131       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_gt\_post  >::yes}})  \{ not\_zero\_j = (tpj >  val); \}}
\DoxyCodeLine{132       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_lteq\_pre >::yes}})  \{ not\_zero\_j = (val <= tpj); \}}
\DoxyCodeLine{133       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_lteq\_post>::yes}})  \{ not\_zero\_j = (tpj <= val); \}}
\DoxyCodeLine{134       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_gteq\_pre >::yes}})  \{ not\_zero\_j = (val >= tpj); \}}
\DoxyCodeLine{135       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_gteq\_post>::yes}})  \{ not\_zero\_j = (tpj >= val); \}}
\DoxyCodeLine{136       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_eq       >::yes}})  \{ not\_zero\_j = (tpj == val); \}}
\DoxyCodeLine{137       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_noteq    >::yes}})  \{ not\_zero\_j = (tpj != val); \}}
\DoxyCodeLine{138       \textcolor{keywordflow}{else} \{ not\_zero\_j = \textcolor{keyword}{false}; \}}
\DoxyCodeLine{139       }
\DoxyCodeLine{140       \textcolor{keywordflow}{if}(not\_zero\_i)  \{ indices\_mem[n\_nz] = i;  ++n\_nz; \}}
\DoxyCodeLine{141       \textcolor{keywordflow}{if}(not\_zero\_j)  \{ indices\_mem[n\_nz] = j;  ++n\_nz; \}}
\DoxyCodeLine{142       \}}
\DoxyCodeLine{143     }
\DoxyCodeLine{144     \textcolor{keywordflow}{if}(i < n\_elem)}
\DoxyCodeLine{145       \{}
\DoxyCodeLine{146       \textcolor{keywordtype}{bool} not\_zero;}
\DoxyCodeLine{147       }
\DoxyCodeLine{148       \textcolor{keyword}{const} eT tmp = PA[i];}
\DoxyCodeLine{149       }
\DoxyCodeLine{150            \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_lt\_pre   >::yes}})  \{ not\_zero = (val <  tmp); \}}
\DoxyCodeLine{151       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_lt\_post  >::yes}})  \{ not\_zero = (tmp <  val); \}}
\DoxyCodeLine{152       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_gt\_pre   >::yes}})  \{ not\_zero = (val >  tmp); \}}
\DoxyCodeLine{153       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_gt\_post  >::yes}})  \{ not\_zero = (tmp >  val); \}}
\DoxyCodeLine{154       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_lteq\_pre >::yes}})  \{ not\_zero = (val <= tmp); \}}
\DoxyCodeLine{155       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_lteq\_post>::yes}})  \{ not\_zero = (tmp <= val); \}}
\DoxyCodeLine{156       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_gteq\_pre >::yes}})  \{ not\_zero = (val >= tmp); \}}
\DoxyCodeLine{157       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_gteq\_post>::yes}})  \{ not\_zero = (tmp >= val); \}}
\DoxyCodeLine{158       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_eq       >::yes}})  \{ not\_zero = (tmp == val); \}}
\DoxyCodeLine{159       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_noteq    >::yes}})  \{ not\_zero = (tmp != val); \}}
\DoxyCodeLine{160       \textcolor{keywordflow}{else} \{ not\_zero = \textcolor{keyword}{false}; \}}
\DoxyCodeLine{161       }
\DoxyCodeLine{162       \textcolor{keywordflow}{if}(not\_zero)  \{ indices\_mem[n\_nz] = i;  ++n\_nz; \}}
\DoxyCodeLine{163       \}}
\DoxyCodeLine{164     \}}
\DoxyCodeLine{165   \textcolor{keywordflow}{else}}
\DoxyCodeLine{166     \{}
\DoxyCodeLine{167     \textcolor{keyword}{const} uword n\_rows = \mbox{\hyperlink{structA}{A}}.get\_n\_rows();}
\DoxyCodeLine{168     \textcolor{keyword}{const} uword n\_cols = \mbox{\hyperlink{structA}{A}}.get\_n\_cols();}
\DoxyCodeLine{169     }
\DoxyCodeLine{170     uword i = 0;}
\DoxyCodeLine{171     }
\DoxyCodeLine{172     \textcolor{keywordflow}{for}(uword col=0; col < n\_cols; ++col)}
\DoxyCodeLine{173     \textcolor{keywordflow}{for}(uword row=0; row < n\_rows; ++row)}
\DoxyCodeLine{174       \{}
\DoxyCodeLine{175       \textcolor{keyword}{const} eT tmp = \mbox{\hyperlink{structA}{A}}.at(row,col);}
\DoxyCodeLine{176       }
\DoxyCodeLine{177       \textcolor{keywordtype}{bool} not\_zero;}
\DoxyCodeLine{178       }
\DoxyCodeLine{179            \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_lt\_pre   >::yes}})  \{ not\_zero = (val <  tmp); \}}
\DoxyCodeLine{180       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_lt\_post  >::yes}})  \{ not\_zero = (tmp <  val); \}}
\DoxyCodeLine{181       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_gt\_pre   >::yes}})  \{ not\_zero = (val >  tmp); \}}
\DoxyCodeLine{182       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_gt\_post  >::yes}})  \{ not\_zero = (tmp >  val); \}}
\DoxyCodeLine{183       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_lteq\_pre >::yes}})  \{ not\_zero = (val <= tmp); \}}
\DoxyCodeLine{184       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_lteq\_post>::yes}})  \{ not\_zero = (tmp <= val); \}}
\DoxyCodeLine{185       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_gteq\_pre >::yes}})  \{ not\_zero = (val >= tmp); \}}
\DoxyCodeLine{186       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_gteq\_post>::yes}})  \{ not\_zero = (tmp >= val); \}}
\DoxyCodeLine{187       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_eq       >::yes}})  \{ not\_zero = (tmp == val); \}}
\DoxyCodeLine{188       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_noteq    >::yes}})  \{ not\_zero = (tmp != val); \}}
\DoxyCodeLine{189       \textcolor{keywordflow}{else} \{ not\_zero = \textcolor{keyword}{false}; \}}
\DoxyCodeLine{190       }
\DoxyCodeLine{191       \textcolor{keywordflow}{if}(not\_zero)  \{ indices\_mem[n\_nz] = i;  ++n\_nz; \}}
\DoxyCodeLine{192       }
\DoxyCodeLine{193       ++i;}
\DoxyCodeLine{194       \}}
\DoxyCodeLine{195     \}}
\DoxyCodeLine{196   }
\DoxyCodeLine{197   \textcolor{keywordflow}{return} n\_nz;}
\DoxyCodeLine{198   \}}
\DoxyCodeLine{199 }
\DoxyCodeLine{200 }
\DoxyCodeLine{201 }
\DoxyCodeLine{202 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} op\_type>}
\DoxyCodeLine{203 \textcolor{keyword}{inline}}
\DoxyCodeLine{204 uword}
\DoxyCodeLine{205 op\_find::helper}
\DoxyCodeLine{206   (}
\DoxyCodeLine{207   \mbox{\hyperlink{classMat}{Mat<uword>}}\& indices,}
\DoxyCodeLine{208   \textcolor{keyword}{const} \mbox{\hyperlink{classmtOp}{mtOp<uword, T1, op\_type>}}\& X,}
\DoxyCodeLine{209   \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__op__rel__only}{arma\_op\_rel\_only<op\_type>::result}}*            junk1,}
\DoxyCodeLine{210   \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<typename T1::elem\_type>::result}}* junk2}
\DoxyCodeLine{211   )}
\DoxyCodeLine{212   \{}
\DoxyCodeLine{213   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{214   arma\_ignore(junk1);}
\DoxyCodeLine{215   arma\_ignore(junk2);}
\DoxyCodeLine{216   }
\DoxyCodeLine{217   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type      eT;}
\DoxyCodeLine{218   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::ea\_type}} ea\_type;}
\DoxyCodeLine{219   }
\DoxyCodeLine{220   \textcolor{keyword}{const} eT val = X.aux;}
\DoxyCodeLine{221   }
\DoxyCodeLine{222   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} \mbox{\hyperlink{structA}{A}}(X.m);}
\DoxyCodeLine{223   }
\DoxyCodeLine{224   ea\_type     PA     = \mbox{\hyperlink{structA}{A}}.get\_ea();}
\DoxyCodeLine{225   \textcolor{keyword}{const} uword n\_elem = \mbox{\hyperlink{structA}{A}}.get\_n\_elem();}
\DoxyCodeLine{226   }
\DoxyCodeLine{227   indices.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(n\_elem, 1);}
\DoxyCodeLine{228   }
\DoxyCodeLine{229   uword* indices\_mem = indices.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{230   uword  n\_nz        = 0;}
\DoxyCodeLine{231   }
\DoxyCodeLine{232   }
\DoxyCodeLine{233   \textcolor{keywordflow}{if}(\mbox{\hyperlink{classProxy}{Proxy<T1>::use\_at}} == \textcolor{keyword}{false})}
\DoxyCodeLine{234     \{}
\DoxyCodeLine{235     \textcolor{keywordflow}{for}(uword i=0; i<n\_elem; ++i)}
\DoxyCodeLine{236       \{}
\DoxyCodeLine{237       \textcolor{keyword}{const} eT tmp = PA[i];}
\DoxyCodeLine{238       }
\DoxyCodeLine{239       \textcolor{keywordtype}{bool} not\_zero;}
\DoxyCodeLine{240       }
\DoxyCodeLine{241            \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_eq   >::yes}})  \{ not\_zero = (tmp == val); \}}
\DoxyCodeLine{242       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_noteq>::yes}})  \{ not\_zero = (tmp != val); \}}
\DoxyCodeLine{243       \textcolor{keywordflow}{else} \{ not\_zero = \textcolor{keyword}{false}; \}}
\DoxyCodeLine{244       }
\DoxyCodeLine{245       \textcolor{keywordflow}{if}(not\_zero) \{ indices\_mem[n\_nz] = i;  ++n\_nz; \}}
\DoxyCodeLine{246       \}}
\DoxyCodeLine{247     \}}
\DoxyCodeLine{248   \textcolor{keywordflow}{else}}
\DoxyCodeLine{249     \{}
\DoxyCodeLine{250     \textcolor{keyword}{const} uword n\_rows = \mbox{\hyperlink{structA}{A}}.get\_n\_rows();}
\DoxyCodeLine{251     \textcolor{keyword}{const} uword n\_cols = \mbox{\hyperlink{structA}{A}}.get\_n\_cols();}
\DoxyCodeLine{252     }
\DoxyCodeLine{253     uword i = 0;}
\DoxyCodeLine{254     }
\DoxyCodeLine{255     \textcolor{keywordflow}{for}(uword col=0; col<n\_cols; ++col)}
\DoxyCodeLine{256     \textcolor{keywordflow}{for}(uword row=0; row<n\_rows; ++row)}
\DoxyCodeLine{257       \{}
\DoxyCodeLine{258       \textcolor{keyword}{const} eT tmp = \mbox{\hyperlink{structA}{A}}.at(row,col);}
\DoxyCodeLine{259       }
\DoxyCodeLine{260       \textcolor{keywordtype}{bool} not\_zero;}
\DoxyCodeLine{261       }
\DoxyCodeLine{262            \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_eq   >::yes}})  \{ not\_zero = (tmp == val); \}}
\DoxyCodeLine{263       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_noteq>::yes}})  \{ not\_zero = (tmp != val); \}}
\DoxyCodeLine{264       \textcolor{keywordflow}{else} \{ not\_zero = \textcolor{keyword}{false}; \}}
\DoxyCodeLine{265       }
\DoxyCodeLine{266       \textcolor{keywordflow}{if}(not\_zero) \{ indices\_mem[n\_nz] = i;  ++n\_nz; \}}
\DoxyCodeLine{267       }
\DoxyCodeLine{268       i++;}
\DoxyCodeLine{269       \}}
\DoxyCodeLine{270     \}}
\DoxyCodeLine{271   }
\DoxyCodeLine{272   \textcolor{keywordflow}{return} n\_nz;}
\DoxyCodeLine{273   \}}
\DoxyCodeLine{274 }
\DoxyCodeLine{275 }
\DoxyCodeLine{276 }
\DoxyCodeLine{277 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2, \textcolor{keyword}{typename} glue\_type>}
\DoxyCodeLine{278 \textcolor{keyword}{inline}}
\DoxyCodeLine{279 uword}
\DoxyCodeLine{280 op\_find::helper}
\DoxyCodeLine{281   (}
\DoxyCodeLine{282   \mbox{\hyperlink{classMat}{Mat<uword>}}\& indices,}
\DoxyCodeLine{283   \textcolor{keyword}{const} \mbox{\hyperlink{classmtGlue}{mtGlue<uword, T1, T2, glue\_type>}}\& X,}
\DoxyCodeLine{284   \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__glue__rel__only}{arma\_glue\_rel\_only<glue\_type>::result}}*       junk1,}
\DoxyCodeLine{285   \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<typename T1::elem\_type>::result* junk2,}
\DoxyCodeLine{286   \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<typename T2::elem\_type>::result* junk3}
\DoxyCodeLine{287   )}
\DoxyCodeLine{288   \{}
\DoxyCodeLine{289   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{290   arma\_ignore(junk1);}
\DoxyCodeLine{291   arma\_ignore(junk2);}
\DoxyCodeLine{292   arma\_ignore(junk3);}
\DoxyCodeLine{293   }
\DoxyCodeLine{294   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT1;}
\DoxyCodeLine{295   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T2::elem\_type eT2;}
\DoxyCodeLine{296   }
\DoxyCodeLine{297   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::ea\_type}} ea\_type1;}
\DoxyCodeLine{298   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T2>::ea\_type}} ea\_type2;}
\DoxyCodeLine{299   }
\DoxyCodeLine{300   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} \mbox{\hyperlink{structA}{A}}(X.A);}
\DoxyCodeLine{301   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T2>}} \mbox{\hyperlink{structB}{B}}(X.B);}
\DoxyCodeLine{302   }
\DoxyCodeLine{303   arma\_debug\_assert\_same\_size(\mbox{\hyperlink{structA}{A}}, \mbox{\hyperlink{structB}{B}}, \textcolor{stringliteral}{"{}relational operator"{}});}
\DoxyCodeLine{304   }
\DoxyCodeLine{305   ea\_type1 PA = \mbox{\hyperlink{structA}{A}}.get\_ea();}
\DoxyCodeLine{306   ea\_type2 PB = \mbox{\hyperlink{structB}{B}}.get\_ea();}
\DoxyCodeLine{307   }
\DoxyCodeLine{308   \textcolor{keyword}{const} uword n\_elem = \mbox{\hyperlink{structB}{B}}.get\_n\_elem();}
\DoxyCodeLine{309   }
\DoxyCodeLine{310   indices.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(n\_elem, 1);}
\DoxyCodeLine{311   }
\DoxyCodeLine{312   uword* indices\_mem = indices.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{313   uword  n\_nz        = 0;}
\DoxyCodeLine{314   }
\DoxyCodeLine{315   \textcolor{keywordflow}{for}(uword i=0; i<n\_elem; ++i)}
\DoxyCodeLine{316     \{}
\DoxyCodeLine{317     \textcolor{keyword}{const} eT1 tmp1 = PA[i];}
\DoxyCodeLine{318     \textcolor{keyword}{const} eT2 tmp2 = PB[i];}
\DoxyCodeLine{319     }
\DoxyCodeLine{320     \textcolor{keywordtype}{bool} not\_zero;}
\DoxyCodeLine{321     }
\DoxyCodeLine{322          \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_lt    >::yes}})  \{ not\_zero = (tmp1 <  tmp2); \}}
\DoxyCodeLine{323     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_gt    >::yes}})  \{ not\_zero = (tmp1 >  tmp2); \}}
\DoxyCodeLine{324     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_lteq  >::yes}})  \{ not\_zero = (tmp1 <= tmp2); \}}
\DoxyCodeLine{325     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_gteq  >::yes}})  \{ not\_zero = (tmp1 >= tmp2); \}}
\DoxyCodeLine{326     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_eq    >::yes}})  \{ not\_zero = (tmp1 == tmp2); \}}
\DoxyCodeLine{327     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_noteq >::yes}})  \{ not\_zero = (tmp1 != tmp2); \}}
\DoxyCodeLine{328     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_and   >::yes}})  \{ not\_zero = (tmp1 \&\& tmp2); \}}
\DoxyCodeLine{329     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_or    >::yes}})  \{ not\_zero = (tmp1 || tmp2); \}}
\DoxyCodeLine{330     \textcolor{keywordflow}{else} \{ not\_zero = \textcolor{keyword}{false}; \}}
\DoxyCodeLine{331     }
\DoxyCodeLine{332     \textcolor{keywordflow}{if}(not\_zero)  \{ indices\_mem[n\_nz] = i;  ++n\_nz; \}}
\DoxyCodeLine{333     \}}
\DoxyCodeLine{334   }
\DoxyCodeLine{335   \textcolor{keywordflow}{return} n\_nz;}
\DoxyCodeLine{336   \}}
\DoxyCodeLine{337 }
\DoxyCodeLine{338 }
\DoxyCodeLine{339 }
\DoxyCodeLine{340 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2, \textcolor{keyword}{typename} glue\_type>}
\DoxyCodeLine{341 \textcolor{keyword}{inline}}
\DoxyCodeLine{342 uword}
\DoxyCodeLine{343 op\_find::helper}
\DoxyCodeLine{344   (}
\DoxyCodeLine{345   \mbox{\hyperlink{classMat}{Mat<uword>}}\& indices,}
\DoxyCodeLine{346   \textcolor{keyword}{const} \mbox{\hyperlink{classmtGlue}{mtGlue<uword, T1, T2, glue\_type>}}\& X,}
\DoxyCodeLine{347   \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__glue__rel__only}{arma\_glue\_rel\_only<glue\_type>::result}}*        junk1,}
\DoxyCodeLine{348   \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<typename T1::elem\_type>::result}}* junk2,}
\DoxyCodeLine{349   \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<typename T2::elem\_type>::result}}* junk3}
\DoxyCodeLine{350   )}
\DoxyCodeLine{351   \{}
\DoxyCodeLine{352   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{353   arma\_ignore(junk1);}
\DoxyCodeLine{354   arma\_ignore(junk2);}
\DoxyCodeLine{355   arma\_ignore(junk3);}
\DoxyCodeLine{356   }
\DoxyCodeLine{357   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::ea\_type}} ea\_type1;}
\DoxyCodeLine{358   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T2>::ea\_type}} ea\_type2;}
\DoxyCodeLine{359   }
\DoxyCodeLine{360   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} \mbox{\hyperlink{structA}{A}}(X.A);}
\DoxyCodeLine{361   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T2>}} \mbox{\hyperlink{structB}{B}}(X.B);}
\DoxyCodeLine{362   }
\DoxyCodeLine{363   arma\_debug\_assert\_same\_size(\mbox{\hyperlink{structA}{A}}, \mbox{\hyperlink{structB}{B}}, \textcolor{stringliteral}{"{}relational operator"{}});}
\DoxyCodeLine{364   }
\DoxyCodeLine{365   ea\_type1 PA = \mbox{\hyperlink{structA}{A}}.get\_ea();}
\DoxyCodeLine{366   ea\_type2 PB = \mbox{\hyperlink{structB}{B}}.get\_ea();}
\DoxyCodeLine{367   }
\DoxyCodeLine{368   \textcolor{keyword}{const} uword n\_elem = \mbox{\hyperlink{structB}{B}}.get\_n\_elem();}
\DoxyCodeLine{369   }
\DoxyCodeLine{370   indices.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(n\_elem, 1);}
\DoxyCodeLine{371   }
\DoxyCodeLine{372   uword* indices\_mem = indices.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{373   uword  n\_nz        = 0;}
\DoxyCodeLine{374   }
\DoxyCodeLine{375   }
\DoxyCodeLine{376   \textcolor{keywordflow}{if}(\mbox{\hyperlink{classProxy}{Proxy<T1>::use\_at}} == \textcolor{keyword}{false})}
\DoxyCodeLine{377     \{}
\DoxyCodeLine{378     \textcolor{keywordflow}{for}(uword i=0; i<n\_elem; ++i)}
\DoxyCodeLine{379       \{}
\DoxyCodeLine{380       \textcolor{keywordtype}{bool} not\_zero;}
\DoxyCodeLine{381       }
\DoxyCodeLine{382            \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_eq    >::yes}})  \{ not\_zero = (PA[i] == PB[i]); \}}
\DoxyCodeLine{383       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_noteq >::yes}})  \{ not\_zero = (PA[i] != PB[i]); \}}
\DoxyCodeLine{384       \textcolor{keywordflow}{else} \{ not\_zero = \textcolor{keyword}{false}; \}}
\DoxyCodeLine{385       }
\DoxyCodeLine{386       \textcolor{keywordflow}{if}(not\_zero)  \{ indices\_mem[n\_nz] = i;  ++n\_nz; \}}
\DoxyCodeLine{387       \}}
\DoxyCodeLine{388     \}}
\DoxyCodeLine{389   \textcolor{keywordflow}{else}}
\DoxyCodeLine{390     \{}
\DoxyCodeLine{391     \textcolor{keyword}{const} uword n\_rows = \mbox{\hyperlink{structA}{A}}.get\_n\_rows();}
\DoxyCodeLine{392     \textcolor{keyword}{const} uword n\_cols = \mbox{\hyperlink{structA}{A}}.get\_n\_cols();}
\DoxyCodeLine{393     }
\DoxyCodeLine{394     uword i = 0;}
\DoxyCodeLine{395     }
\DoxyCodeLine{396     \textcolor{keywordflow}{for}(uword col=0; col<n\_cols; ++col)}
\DoxyCodeLine{397     \textcolor{keywordflow}{for}(uword row=0; row<n\_rows; ++row)}
\DoxyCodeLine{398       \{}
\DoxyCodeLine{399       \textcolor{keywordtype}{bool} not\_zero;}
\DoxyCodeLine{400       }
\DoxyCodeLine{401            \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_eq    >::yes}})  \{ not\_zero = (\mbox{\hyperlink{structA}{A}}.at(row,col) == \mbox{\hyperlink{structB}{B}}.at(row,col)); \}}
\DoxyCodeLine{402       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_noteq >::yes}})  \{ not\_zero = (\mbox{\hyperlink{structA}{A}}.at(row,col) != \mbox{\hyperlink{structB}{B}}.at(row,col)); \}}
\DoxyCodeLine{403       \textcolor{keywordflow}{else} \{ not\_zero = \textcolor{keyword}{false}; \}}
\DoxyCodeLine{404       }
\DoxyCodeLine{405       \textcolor{keywordflow}{if}(not\_zero)  \{ indices\_mem[n\_nz] = i;  ++n\_nz; \}}
\DoxyCodeLine{406       }
\DoxyCodeLine{407       i++;}
\DoxyCodeLine{408       \}}
\DoxyCodeLine{409    \}}
\DoxyCodeLine{410   }
\DoxyCodeLine{411   \textcolor{keywordflow}{return} n\_nz;}
\DoxyCodeLine{412   \}}
\DoxyCodeLine{413 }
\DoxyCodeLine{414 }
\DoxyCodeLine{415 }
\DoxyCodeLine{416 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{417 \textcolor{keyword}{inline}}
\DoxyCodeLine{418 \textcolor{keywordtype}{void}}
\DoxyCodeLine{419 op\_find::apply(\mbox{\hyperlink{classMat}{Mat<uword>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classmtOp}{mtOp<uword, T1, op\_find>}}\& X)}
\DoxyCodeLine{420   \{}
\DoxyCodeLine{421   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{422   }
\DoxyCodeLine{423   \textcolor{keyword}{const} uword k    = X.aux\_uword\_a;}
\DoxyCodeLine{424   \textcolor{keyword}{const} uword \mbox{\hyperlink{classtype}{type}} = X.aux\_uword\_b;}
\DoxyCodeLine{425   }
\DoxyCodeLine{426   \mbox{\hyperlink{classMat}{Mat<uword>}} indices;}
\DoxyCodeLine{427   \textcolor{keyword}{const} uword n\_nz = op\_find::helper(indices, X.m);}
\DoxyCodeLine{428   }
\DoxyCodeLine{429   \textcolor{keywordflow}{if}(n\_nz > 0)}
\DoxyCodeLine{430     \{}
\DoxyCodeLine{431     \textcolor{keywordflow}{if}(\mbox{\hyperlink{classtype}{type}} == 0)   \textcolor{comment}{// "{}first"{}}}
\DoxyCodeLine{432       \{}
\DoxyCodeLine{433       out = (k > 0 \&\& k <= n\_nz) ? indices.\mbox{\hyperlink{group__Mat_ga06a89eae0134e0678459dc1e2748ba9e}{rows}}(0,      k-\/1   ) : indices.\mbox{\hyperlink{group__Mat_ga06a89eae0134e0678459dc1e2748ba9e}{rows}}(0, n\_nz-\/1);}
\DoxyCodeLine{434       \}}
\DoxyCodeLine{435     \textcolor{keywordflow}{else}   \textcolor{comment}{// "{}last"{}}}
\DoxyCodeLine{436       \{}
\DoxyCodeLine{437       out = (k > 0 \&\& k <= n\_nz) ? indices.\mbox{\hyperlink{group__Mat_ga06a89eae0134e0678459dc1e2748ba9e}{rows}}(n\_nz-\/k, n\_nz-\/1) : indices.\mbox{\hyperlink{group__Mat_ga06a89eae0134e0678459dc1e2748ba9e}{rows}}(0, n\_nz-\/1);}
\DoxyCodeLine{438       \}}
\DoxyCodeLine{439     \}}
\DoxyCodeLine{440   \textcolor{keywordflow}{else}}
\DoxyCodeLine{441     \{}
\DoxyCodeLine{442     out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(0,1);  \textcolor{comment}{// empty column vector}}
\DoxyCodeLine{443     \}}
\DoxyCodeLine{444   \}}
\DoxyCodeLine{445 }
\DoxyCodeLine{446 }
\DoxyCodeLine{447 }
\DoxyCodeLine{448 \textcolor{comment}{//}}
\DoxyCodeLine{449 }
\DoxyCodeLine{450 }
\DoxyCodeLine{451 }
\DoxyCodeLine{452 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{453 \textcolor{keyword}{inline}}
\DoxyCodeLine{454 \textcolor{keywordtype}{void}}
\DoxyCodeLine{455 op\_find\_simple::apply(\mbox{\hyperlink{classMat}{Mat<uword>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classmtOp}{mtOp<uword, T1, op\_find\_simple>}}\& X)}
\DoxyCodeLine{456   \{}
\DoxyCodeLine{457   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{458   }
\DoxyCodeLine{459   \mbox{\hyperlink{classMat}{Mat<uword>}} indices;}
\DoxyCodeLine{460   \textcolor{keyword}{const} uword n\_nz = op\_find::helper(indices, X.m);}
\DoxyCodeLine{461   }
\DoxyCodeLine{462   out.steal\_mem\_col(indices, n\_nz);}
\DoxyCodeLine{463   \}}
\DoxyCodeLine{464 }
\DoxyCodeLine{465 }
\DoxyCodeLine{466 }
\DoxyCodeLine{467 \textcolor{comment}{//}}
\DoxyCodeLine{468 }
\DoxyCodeLine{469 }
\DoxyCodeLine{470 }
\DoxyCodeLine{471 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{472 \textcolor{keyword}{inline}}
\DoxyCodeLine{473 \textcolor{keywordtype}{void}}
\DoxyCodeLine{474 op\_find\_finite::apply(\mbox{\hyperlink{classMat}{Mat<uword>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classmtOp}{mtOp<uword, T1, op\_find\_finite>}}\& X)}
\DoxyCodeLine{475   \{}
\DoxyCodeLine{476   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{477   }
\DoxyCodeLine{478   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} P(X.m);}
\DoxyCodeLine{479   }
\DoxyCodeLine{480   \textcolor{keyword}{const} uword n\_elem = P.get\_n\_elem();}
\DoxyCodeLine{481   }
\DoxyCodeLine{482   \mbox{\hyperlink{classMat}{Mat<uword>}} indices(n\_elem, 1, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{483   }
\DoxyCodeLine{484   uword* indices\_mem = indices.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{485   uword  count       = 0;}
\DoxyCodeLine{486   }
\DoxyCodeLine{487   \textcolor{keywordflow}{if}(\mbox{\hyperlink{classProxy}{Proxy<T1>::use\_at}} == \textcolor{keyword}{false})}
\DoxyCodeLine{488     \{}
\DoxyCodeLine{489     \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::ea\_type}} Pea = P.get\_ea();}
\DoxyCodeLine{490     }
\DoxyCodeLine{491     \textcolor{keywordflow}{for}(uword i=0; i<n\_elem; ++i)}
\DoxyCodeLine{492       \{}
\DoxyCodeLine{493       \textcolor{keywordflow}{if}( arma\_isfinite(Pea[i]) )  \{ indices\_mem[count] = i; count++; \}}
\DoxyCodeLine{494       \}}
\DoxyCodeLine{495     \}}
\DoxyCodeLine{496   \textcolor{keywordflow}{else}}
\DoxyCodeLine{497     \{}
\DoxyCodeLine{498     \textcolor{keyword}{const} uword n\_rows = P.get\_n\_rows(); }
\DoxyCodeLine{499     \textcolor{keyword}{const} uword n\_cols = P.get\_n\_cols(); }
\DoxyCodeLine{500     }
\DoxyCodeLine{501     uword i = 0;}
\DoxyCodeLine{502     }
\DoxyCodeLine{503     \textcolor{keywordflow}{for}(uword col=0; col<n\_cols; ++col)}
\DoxyCodeLine{504     \textcolor{keywordflow}{for}(uword row=0; row<n\_rows; ++row)}
\DoxyCodeLine{505       \{}
\DoxyCodeLine{506       \textcolor{keywordflow}{if}( arma\_isfinite(P.at(row,col)) )  \{ indices\_mem[count] = i; count++; \}}
\DoxyCodeLine{507       }
\DoxyCodeLine{508       i++;}
\DoxyCodeLine{509       \}}
\DoxyCodeLine{510     \}}
\DoxyCodeLine{511   }
\DoxyCodeLine{512   out.steal\_mem\_col(indices, count);}
\DoxyCodeLine{513   \}}
\DoxyCodeLine{514 }
\DoxyCodeLine{515 }
\DoxyCodeLine{516 }
\DoxyCodeLine{517 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{518 \textcolor{keyword}{inline}}
\DoxyCodeLine{519 \textcolor{keywordtype}{void}}
\DoxyCodeLine{520 op\_find\_nonfinite::apply(\mbox{\hyperlink{classMat}{Mat<uword>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classmtOp}{mtOp<uword, T1, op\_find\_nonfinite>}}\& X)}
\DoxyCodeLine{521   \{}
\DoxyCodeLine{522   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{523   }
\DoxyCodeLine{524   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} P(X.m);}
\DoxyCodeLine{525   }
\DoxyCodeLine{526   \textcolor{keyword}{const} uword n\_elem = P.get\_n\_elem();}
\DoxyCodeLine{527   }
\DoxyCodeLine{528   \mbox{\hyperlink{classMat}{Mat<uword>}} indices(n\_elem, 1, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{529   }
\DoxyCodeLine{530   uword* indices\_mem = indices.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{531   uword  count       = 0;}
\DoxyCodeLine{532   }
\DoxyCodeLine{533   \textcolor{keywordflow}{if}(\mbox{\hyperlink{classProxy}{Proxy<T1>::use\_at}} == \textcolor{keyword}{false})}
\DoxyCodeLine{534     \{}
\DoxyCodeLine{535     \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::ea\_type}} Pea = P.get\_ea();}
\DoxyCodeLine{536     }
\DoxyCodeLine{537     \textcolor{keywordflow}{for}(uword i=0; i<n\_elem; ++i)}
\DoxyCodeLine{538       \{}
\DoxyCodeLine{539       \textcolor{keywordflow}{if}( arma\_isfinite(Pea[i]) == \textcolor{keyword}{false} )  \{ indices\_mem[count] = i; count++; \}}
\DoxyCodeLine{540       \}}
\DoxyCodeLine{541     \}}
\DoxyCodeLine{542   \textcolor{keywordflow}{else}}
\DoxyCodeLine{543     \{}
\DoxyCodeLine{544     \textcolor{keyword}{const} uword n\_rows = P.get\_n\_rows(); }
\DoxyCodeLine{545     \textcolor{keyword}{const} uword n\_cols = P.get\_n\_cols(); }
\DoxyCodeLine{546     }
\DoxyCodeLine{547     uword i = 0;}
\DoxyCodeLine{548     }
\DoxyCodeLine{549     \textcolor{keywordflow}{for}(uword col=0; col<n\_cols; ++col)}
\DoxyCodeLine{550     \textcolor{keywordflow}{for}(uword row=0; row<n\_rows; ++row)}
\DoxyCodeLine{551       \{}
\DoxyCodeLine{552       \textcolor{keywordflow}{if}( arma\_isfinite(P.at(row,col)) == \textcolor{keyword}{false} )  \{ indices\_mem[count] = i; count++; \}}
\DoxyCodeLine{553       }
\DoxyCodeLine{554       i++;}
\DoxyCodeLine{555       \}}
\DoxyCodeLine{556     \}}
\DoxyCodeLine{557   }
\DoxyCodeLine{558   out.steal\_mem\_col(indices, count);}
\DoxyCodeLine{559   \}}
\DoxyCodeLine{560 }
\DoxyCodeLine{561 }
\DoxyCodeLine{562 }

\end{DoxyCode}
