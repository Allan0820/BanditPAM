\hypertarget{op__median__meat_8hpp_source}{}\doxysection{op\+\_\+median\+\_\+meat.\+hpp}
\label{op__median__meat_8hpp_source}\index{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/op\_median\_meat.hpp@{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/op\_median\_meat.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008-\/2016 Conrad Sanderson (http://conradsanderson.id.au)}}
\DoxyCodeLine{2 \textcolor{comment}{// Copyright 2008-\/2016 National ICT Australia (NICTA)}}
\DoxyCodeLine{3 \textcolor{comment}{// }}
\DoxyCodeLine{4 \textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{5 \textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{6 \textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{7 \textcolor{comment}{// http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{8 \textcolor{comment}{// }}
\DoxyCodeLine{9 \textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{10 \textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{11 \textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{12 \textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{13 \textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{14 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{19 }
\DoxyCodeLine{20 }
\DoxyCodeLine{21 }
\DoxyCodeLine{26 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{27 \textcolor{keyword}{inline}}
\DoxyCodeLine{28 \textcolor{keywordtype}{void}}
\DoxyCodeLine{29 \mbox{\hyperlink{group__op__median_ga013e282bb92396c2745633c6a6525c88}{op\_median::apply}}(\mbox{\hyperlink{classMat}{Mat<eT>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T1,op\_median>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<eT>::result* junk)}
\DoxyCodeLine{30   \{}
\DoxyCodeLine{31   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{32   arma\_ignore(junk);}
\DoxyCodeLine{33   }
\DoxyCodeLine{34   \textcolor{comment}{// typedef typename T1::elem\_type eT;}}
\DoxyCodeLine{35   }
\DoxyCodeLine{36   \textcolor{keyword}{const} uword dim = in.\mbox{\hyperlink{classOp_a197cb9330fe0d72c976d6223514c4bd6}{aux\_uword\_a}};}
\DoxyCodeLine{37   arma\_debug\_check( (dim > 1), \textcolor{stringliteral}{"{}median(): parameter 'dim' must be 0 or 1"{}} );}
\DoxyCodeLine{38   }
\DoxyCodeLine{39   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} P(in.\mbox{\hyperlink{classOp_af7ab7221b6e233cdd38b9f9b69f301ce}{m}});}
\DoxyCodeLine{40   }
\DoxyCodeLine{41   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::stored\_type}} P\_stored\_type;}
\DoxyCodeLine{42   }
\DoxyCodeLine{43   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} is\_alias = P.is\_alias(out);}
\DoxyCodeLine{44   }
\DoxyCodeLine{45   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__Mat}{is\_Mat<P\_stored\_type>::value}} || is\_alias)}
\DoxyCodeLine{46     \{}
\DoxyCodeLine{47     \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap__check}{unwrap\_check<P\_stored\_type>}} tmp(P.Q, is\_alias);}
\DoxyCodeLine{48     }
\DoxyCodeLine{49     \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structunwrap__check}{unwrap\_check<P\_stored\_type>::stored\_type}}\& X = tmp.M;}
\DoxyCodeLine{50     }
\DoxyCodeLine{51     \textcolor{keyword}{const} uword X\_n\_rows = X.n\_rows;}
\DoxyCodeLine{52     \textcolor{keyword}{const} uword X\_n\_cols = X.n\_cols;}
\DoxyCodeLine{53     }
\DoxyCodeLine{54     \textcolor{keywordflow}{if}(dim == 0)  \textcolor{comment}{// in each column}}
\DoxyCodeLine{55       \{}
\DoxyCodeLine{56       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}op\_median::apply(): dim = 0"{}});}
\DoxyCodeLine{57       }
\DoxyCodeLine{58       out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}((X\_n\_rows > 0) ? 1 : 0, X\_n\_cols);}
\DoxyCodeLine{59       }
\DoxyCodeLine{60       \textcolor{keywordflow}{if}(X\_n\_rows > 0)}
\DoxyCodeLine{61         \{}
\DoxyCodeLine{62         std::vector<eT> tmp\_vec(X\_n\_rows);}
\DoxyCodeLine{63         }
\DoxyCodeLine{64         \textcolor{keywordflow}{for}(uword col=0; col < X\_n\_cols; ++col)}
\DoxyCodeLine{65           \{}
\DoxyCodeLine{66           arrayops::copy( \&(tmp\_vec[0]), X.colptr(col), X\_n\_rows );}
\DoxyCodeLine{67           }
\DoxyCodeLine{68           out[col] = \mbox{\hyperlink{group__op__median_gac3de3527ab7889264dbbe898f7cea151}{op\_median::direct\_median}}(tmp\_vec);}
\DoxyCodeLine{69           \}}
\DoxyCodeLine{70         \}}
\DoxyCodeLine{71       \}}
\DoxyCodeLine{72     \textcolor{keywordflow}{else}  \textcolor{comment}{// in each row}}
\DoxyCodeLine{73       \{}
\DoxyCodeLine{74       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}op\_median::apply(): dim = 1"{}});}
\DoxyCodeLine{75       }
\DoxyCodeLine{76       out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(X\_n\_rows, (X\_n\_cols > 0) ? 1 : 0);}
\DoxyCodeLine{77       }
\DoxyCodeLine{78       \textcolor{keywordflow}{if}(X\_n\_cols > 0)}
\DoxyCodeLine{79         \{}
\DoxyCodeLine{80         std::vector<eT> tmp\_vec(X\_n\_cols);}
\DoxyCodeLine{81           }
\DoxyCodeLine{82         \textcolor{keywordflow}{for}(uword row=0; row < X\_n\_rows; ++row)}
\DoxyCodeLine{83           \{}
\DoxyCodeLine{84           \textcolor{keywordflow}{for}(uword col=0; col < X\_n\_cols; ++col)  \{ tmp\_vec[col] = X.at(row,col); \}}
\DoxyCodeLine{85           }
\DoxyCodeLine{86           out[row] = \mbox{\hyperlink{group__op__median_gac3de3527ab7889264dbbe898f7cea151}{op\_median::direct\_median}}(tmp\_vec);}
\DoxyCodeLine{87           \}}
\DoxyCodeLine{88         \}}
\DoxyCodeLine{89       \}}
\DoxyCodeLine{90     \}}
\DoxyCodeLine{91   \textcolor{keywordflow}{else}}
\DoxyCodeLine{92     \{}
\DoxyCodeLine{93     \textcolor{keyword}{const} uword P\_n\_rows = P.get\_n\_rows();}
\DoxyCodeLine{94     \textcolor{keyword}{const} uword P\_n\_cols = P.get\_n\_cols();}
\DoxyCodeLine{95     }
\DoxyCodeLine{96     \textcolor{keywordflow}{if}(dim == 0)  \textcolor{comment}{// in each column}}
\DoxyCodeLine{97       \{}
\DoxyCodeLine{98       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}op\_median::apply(): dim = 0"{}});}
\DoxyCodeLine{99       }
\DoxyCodeLine{100       out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}((P\_n\_rows > 0) ? 1 : 0, P\_n\_cols);}
\DoxyCodeLine{101       }
\DoxyCodeLine{102       \textcolor{keywordflow}{if}(P\_n\_rows > 0)}
\DoxyCodeLine{103         \{}
\DoxyCodeLine{104         std::vector<eT> tmp\_vec(P\_n\_rows);}
\DoxyCodeLine{105         }
\DoxyCodeLine{106         \textcolor{keywordflow}{for}(uword col=0; col < P\_n\_cols; ++col)}
\DoxyCodeLine{107           \{}
\DoxyCodeLine{108           \textcolor{keywordflow}{for}(uword row=0; row < P\_n\_rows; ++row)  \{ tmp\_vec[row] = P.at(row,col); \}}
\DoxyCodeLine{109           }
\DoxyCodeLine{110           out[col] = \mbox{\hyperlink{group__op__median_gac3de3527ab7889264dbbe898f7cea151}{op\_median::direct\_median}}(tmp\_vec);}
\DoxyCodeLine{111           \}}
\DoxyCodeLine{112         \}}
\DoxyCodeLine{113       \}}
\DoxyCodeLine{114     \textcolor{keywordflow}{else}  \textcolor{comment}{// in each row}}
\DoxyCodeLine{115       \{}
\DoxyCodeLine{116       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}op\_median::apply(): dim = 1"{}});}
\DoxyCodeLine{117       }
\DoxyCodeLine{118       out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(P\_n\_rows, (P\_n\_cols > 0) ? 1 : 0);}
\DoxyCodeLine{119       }
\DoxyCodeLine{120       \textcolor{keywordflow}{if}(P\_n\_cols > 0)}
\DoxyCodeLine{121         \{}
\DoxyCodeLine{122         std::vector<eT> tmp\_vec(P\_n\_cols);}
\DoxyCodeLine{123           }
\DoxyCodeLine{124         \textcolor{keywordflow}{for}(uword row=0; row < P\_n\_rows; ++row)}
\DoxyCodeLine{125           \{}
\DoxyCodeLine{126           \textcolor{keywordflow}{for}(uword col=0; col < P\_n\_cols; ++col)  \{ tmp\_vec[col] = P.at(row,col); \}}
\DoxyCodeLine{127           }
\DoxyCodeLine{128           out[row] = \mbox{\hyperlink{group__op__median_gac3de3527ab7889264dbbe898f7cea151}{op\_median::direct\_median}}(tmp\_vec);}
\DoxyCodeLine{129           \}}
\DoxyCodeLine{130         \}}
\DoxyCodeLine{131       \}}
\DoxyCodeLine{132     \}}
\DoxyCodeLine{133   \}}
\DoxyCodeLine{134 }
\DoxyCodeLine{135 }
\DoxyCodeLine{136 }
\DoxyCodeLine{138 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT, \textcolor{keyword}{typename} T1>}
\DoxyCodeLine{139 \textcolor{keyword}{inline}}
\DoxyCodeLine{140 \textcolor{keywordtype}{void}}
\DoxyCodeLine{141 \mbox{\hyperlink{group__op__median_ga013e282bb92396c2745633c6a6525c88}{op\_median::apply}}(\mbox{\hyperlink{classMat}{Mat<eT>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T1,op\_median>}}\& in, \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<eT>::result}}* junk)}
\DoxyCodeLine{142   \{}
\DoxyCodeLine{143   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{144   arma\_ignore(junk);}
\DoxyCodeLine{145   }
\DoxyCodeLine{146   \textcolor{comment}{// typedef typename std::complex<T> eT;}}
\DoxyCodeLine{147   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} get\_pod\_type<eT>::result T;}
\DoxyCodeLine{148   }
\DoxyCodeLine{149   arma\_type\_check(( \mbox{\hyperlink{structis__same__type}{is\_same\_type<eT, typename T1::elem\_type>::no}} ));}
\DoxyCodeLine{150   }
\DoxyCodeLine{151   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap__check}{unwrap\_check<T1>}} tmp(in.\mbox{\hyperlink{classOp_af7ab7221b6e233cdd38b9f9b69f301ce}{m}}, out);}
\DoxyCodeLine{152   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\&     X = tmp.M;}
\DoxyCodeLine{153   }
\DoxyCodeLine{154   \textcolor{keyword}{const} uword X\_n\_rows = X.n\_rows;}
\DoxyCodeLine{155   \textcolor{keyword}{const} uword X\_n\_cols = X.n\_cols;}
\DoxyCodeLine{156   }
\DoxyCodeLine{157   \textcolor{keyword}{const} uword dim = in.\mbox{\hyperlink{classOp_a197cb9330fe0d72c976d6223514c4bd6}{aux\_uword\_a}};}
\DoxyCodeLine{158   arma\_debug\_check( (dim > 1), \textcolor{stringliteral}{"{}median(): parameter 'dim' must be 0 or 1"{}} );}
\DoxyCodeLine{159   }
\DoxyCodeLine{160   \textcolor{keywordflow}{if}(dim == 0)  \textcolor{comment}{// in each column}}
\DoxyCodeLine{161     \{}
\DoxyCodeLine{162     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}op\_median::apply(): dim = 0"{}});}
\DoxyCodeLine{163     }
\DoxyCodeLine{164     out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}((X\_n\_rows > 0) ? 1 : 0, X\_n\_cols);}
\DoxyCodeLine{165     }
\DoxyCodeLine{166     \textcolor{keywordflow}{if}(X\_n\_rows > 0)}
\DoxyCodeLine{167       \{}
\DoxyCodeLine{168       std::vector< arma\_cx\_median\_packet<T> > tmp\_vec(X\_n\_rows);}
\DoxyCodeLine{169       }
\DoxyCodeLine{170       \textcolor{keywordflow}{for}(uword col=0; col<X\_n\_cols; ++col)}
\DoxyCodeLine{171         \{}
\DoxyCodeLine{172         \textcolor{keyword}{const} eT* colmem = X.colptr(col);}
\DoxyCodeLine{173         }
\DoxyCodeLine{174         \textcolor{keywordflow}{for}(uword row=0; row<X\_n\_rows; ++row)}
\DoxyCodeLine{175           \{}
\DoxyCodeLine{176           tmp\_vec[row].val   = std::abs(colmem[row]);}
\DoxyCodeLine{177           tmp\_vec[row].index = row;}
\DoxyCodeLine{178           \}}
\DoxyCodeLine{179         }
\DoxyCodeLine{180         uword index1;}
\DoxyCodeLine{181         uword index2;}
\DoxyCodeLine{182         op\_median::direct\_cx\_median\_index(index1, index2, tmp\_vec);}
\DoxyCodeLine{183           }
\DoxyCodeLine{184         out[col] = op\_mean::robust\_mean(colmem[index1], colmem[index2]);}
\DoxyCodeLine{185         \}}
\DoxyCodeLine{186       \}}
\DoxyCodeLine{187     \}}
\DoxyCodeLine{188   \textcolor{keywordflow}{else}}
\DoxyCodeLine{189   \textcolor{keywordflow}{if}(dim == 1)  \textcolor{comment}{// in each row}}
\DoxyCodeLine{190     \{}
\DoxyCodeLine{191     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}op\_median::apply(): dim = 1"{}});}
\DoxyCodeLine{192     }
\DoxyCodeLine{193     out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(X\_n\_rows, (X\_n\_cols > 0) ? 1 : 0);}
\DoxyCodeLine{194     }
\DoxyCodeLine{195     \textcolor{keywordflow}{if}(X\_n\_cols > 0)}
\DoxyCodeLine{196       \{}
\DoxyCodeLine{197       std::vector< arma\_cx\_median\_packet<T> > tmp\_vec(X\_n\_cols);}
\DoxyCodeLine{198       }
\DoxyCodeLine{199       \textcolor{keywordflow}{for}(uword row=0; row<X\_n\_rows; ++row)}
\DoxyCodeLine{200         \{}
\DoxyCodeLine{201         \textcolor{keywordflow}{for}(uword col=0; col<X\_n\_cols; ++col)}
\DoxyCodeLine{202           \{}
\DoxyCodeLine{203           tmp\_vec[col].val   = std::abs(X.at(row,col));}
\DoxyCodeLine{204           tmp\_vec[col].index = col;}
\DoxyCodeLine{205           \}}
\DoxyCodeLine{206         }
\DoxyCodeLine{207         uword index1;}
\DoxyCodeLine{208         uword index2;}
\DoxyCodeLine{209         op\_median::direct\_cx\_median\_index(index1, index2, tmp\_vec);}
\DoxyCodeLine{210         }
\DoxyCodeLine{211         out[row] = op\_mean::robust\_mean( X.at(row,index1), X.at(row,index2) );}
\DoxyCodeLine{212         \}}
\DoxyCodeLine{213       \}}
\DoxyCodeLine{214     \}}
\DoxyCodeLine{215   \}}
\DoxyCodeLine{216 }
\DoxyCodeLine{217 }
\DoxyCodeLine{218 }
\DoxyCodeLine{219 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{220 \textcolor{keyword}{inline}}
\DoxyCodeLine{221 \textcolor{keyword}{typename} T1::elem\_type}
\DoxyCodeLine{222 op\_median::median\_vec}
\DoxyCodeLine{223   (}
\DoxyCodeLine{224   \textcolor{keyword}{const} T1\& X,}
\DoxyCodeLine{225   \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<typename T1::elem\_type>::result* junk}
\DoxyCodeLine{226   )}
\DoxyCodeLine{227   \{}
\DoxyCodeLine{228   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{229   arma\_ignore(junk);}
\DoxyCodeLine{230   }
\DoxyCodeLine{231   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{232   }
\DoxyCodeLine{233   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::stored\_type}} P\_stored\_type;}
\DoxyCodeLine{234     }
\DoxyCodeLine{235   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} P(X);}
\DoxyCodeLine{236   }
\DoxyCodeLine{237   \textcolor{keyword}{const} uword n\_elem = P.get\_n\_elem();}
\DoxyCodeLine{238   }
\DoxyCodeLine{239   \textcolor{keywordflow}{if}(n\_elem == 0)}
\DoxyCodeLine{240     \{}
\DoxyCodeLine{241     arma\_debug\_check(\textcolor{keyword}{true}, \textcolor{stringliteral}{"{}median(): object has no elements"{}});}
\DoxyCodeLine{242     }
\DoxyCodeLine{243     \textcolor{keywordflow}{return} \mbox{\hyperlink{classDatum}{Datum<eT>::nan}};}
\DoxyCodeLine{244     \}}
\DoxyCodeLine{245   }
\DoxyCodeLine{246   std::vector<eT> tmp\_vec(n\_elem);}
\DoxyCodeLine{247   }
\DoxyCodeLine{248   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__Mat}{is\_Mat<P\_stored\_type>::value}})}
\DoxyCodeLine{249     \{}
\DoxyCodeLine{250     \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap}{unwrap<P\_stored\_type>}} tmp(P.Q);}
\DoxyCodeLine{251     }
\DoxyCodeLine{252     \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structunwrap}{unwrap<P\_stored\_type>::stored\_type}}\& Y = tmp.M;}
\DoxyCodeLine{253     }
\DoxyCodeLine{254     arrayops::copy( \&(tmp\_vec[0]), Y.memptr(), n\_elem );}
\DoxyCodeLine{255     \}}
\DoxyCodeLine{256   \textcolor{keywordflow}{else}}
\DoxyCodeLine{257     \{}
\DoxyCodeLine{258     \textcolor{keywordflow}{if}(\mbox{\hyperlink{classProxy}{Proxy<T1>::use\_at}} == \textcolor{keyword}{false})}
\DoxyCodeLine{259       \{}
\DoxyCodeLine{260       \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::ea\_type}} ea\_type;}
\DoxyCodeLine{261       }
\DoxyCodeLine{262       ea\_type \mbox{\hyperlink{structA}{A}} = P.get\_ea();}
\DoxyCodeLine{263       }
\DoxyCodeLine{264       \textcolor{keywordflow}{for}(uword i=0; i<n\_elem; ++i)  \{ tmp\_vec[i] = \mbox{\hyperlink{structA}{A}}[i]; \}}
\DoxyCodeLine{265       \}}
\DoxyCodeLine{266     \textcolor{keywordflow}{else}}
\DoxyCodeLine{267       \{}
\DoxyCodeLine{268       \textcolor{keyword}{const} uword n\_rows = P.get\_n\_rows();}
\DoxyCodeLine{269       \textcolor{keyword}{const} uword n\_cols = P.get\_n\_cols();}
\DoxyCodeLine{270       }
\DoxyCodeLine{271       \textcolor{keywordflow}{if}(n\_cols == 1)}
\DoxyCodeLine{272         \{}
\DoxyCodeLine{273         \textcolor{keywordflow}{for}(uword row=0; row < n\_rows; ++row)  \{ tmp\_vec[row] = P.at(row,0); \}}
\DoxyCodeLine{274         \}}
\DoxyCodeLine{275       \textcolor{keywordflow}{else}}
\DoxyCodeLine{276       \textcolor{keywordflow}{if}(n\_rows == 1)}
\DoxyCodeLine{277         \{}
\DoxyCodeLine{278         \textcolor{keywordflow}{for}(uword col=0; col < n\_cols; ++col)  \{ tmp\_vec[col] = P.at(0,col); \}}
\DoxyCodeLine{279         \}}
\DoxyCodeLine{280       \textcolor{keywordflow}{else}}
\DoxyCodeLine{281         \{}
\DoxyCodeLine{282         arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}op\_median::median\_vec(): expected a vector"{}} );}
\DoxyCodeLine{283         \}}
\DoxyCodeLine{284       \}}
\DoxyCodeLine{285     \}}
\DoxyCodeLine{286   }
\DoxyCodeLine{287   \textcolor{keywordflow}{return} \mbox{\hyperlink{group__op__median_gac3de3527ab7889264dbbe898f7cea151}{op\_median::direct\_median}}(tmp\_vec);}
\DoxyCodeLine{288   \}}
\DoxyCodeLine{289 }
\DoxyCodeLine{290 }
\DoxyCodeLine{291 }
\DoxyCodeLine{292 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{293 \textcolor{keyword}{inline}}
\DoxyCodeLine{294 \textcolor{keyword}{typename} T1::elem\_type}
\DoxyCodeLine{295 op\_median::median\_vec}
\DoxyCodeLine{296   (}
\DoxyCodeLine{297   \textcolor{keyword}{const} T1\& X,}
\DoxyCodeLine{298   \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<typename T1::elem\_type>::result}}* junk}
\DoxyCodeLine{299   )}
\DoxyCodeLine{300   \{}
\DoxyCodeLine{301   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{302   arma\_ignore(junk);}
\DoxyCodeLine{303   }
\DoxyCodeLine{304   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{305   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type   T;}
\DoxyCodeLine{306   }
\DoxyCodeLine{307   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} P(X);}
\DoxyCodeLine{308   }
\DoxyCodeLine{309   \textcolor{keyword}{const} uword n\_elem = P.get\_n\_elem();}
\DoxyCodeLine{310   }
\DoxyCodeLine{311   \textcolor{keywordflow}{if}(n\_elem == 0)}
\DoxyCodeLine{312     \{}
\DoxyCodeLine{313     arma\_debug\_check(\textcolor{keyword}{true}, \textcolor{stringliteral}{"{}median(): object has no elements"{}});}
\DoxyCodeLine{314     }
\DoxyCodeLine{315     \textcolor{keywordflow}{return} \mbox{\hyperlink{classDatum}{Datum<eT>::nan}};}
\DoxyCodeLine{316     \}}
\DoxyCodeLine{317   }
\DoxyCodeLine{318   std::vector< arma\_cx\_median\_packet<T> > tmp\_vec(n\_elem);}
\DoxyCodeLine{319   }
\DoxyCodeLine{320   \textcolor{keywordflow}{if}(\mbox{\hyperlink{classProxy}{Proxy<T1>::use\_at}} == \textcolor{keyword}{false})}
\DoxyCodeLine{321     \{}
\DoxyCodeLine{322     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::ea\_type}} ea\_type;}
\DoxyCodeLine{323     }
\DoxyCodeLine{324     ea\_type \mbox{\hyperlink{structA}{A}} = P.get\_ea();}
\DoxyCodeLine{325     }
\DoxyCodeLine{326     \textcolor{keywordflow}{for}(uword i=0; i<n\_elem; ++i)}
\DoxyCodeLine{327       \{}
\DoxyCodeLine{328       tmp\_vec[i].val   = std::abs( \mbox{\hyperlink{structA}{A}}[i] );}
\DoxyCodeLine{329       tmp\_vec[i].index = i;}
\DoxyCodeLine{330       \}}
\DoxyCodeLine{331     }
\DoxyCodeLine{332     uword index1;}
\DoxyCodeLine{333     uword index2;}
\DoxyCodeLine{334     op\_median::direct\_cx\_median\_index(index1, index2, tmp\_vec);}
\DoxyCodeLine{335     }
\DoxyCodeLine{336     \textcolor{keywordflow}{return} op\_mean::robust\_mean( \mbox{\hyperlink{structA}{A}}[index1], \mbox{\hyperlink{structA}{A}}[index2] );}
\DoxyCodeLine{337     \}}
\DoxyCodeLine{338   \textcolor{keywordflow}{else}}
\DoxyCodeLine{339     \{}
\DoxyCodeLine{340     \textcolor{keyword}{const} uword n\_rows = P.get\_n\_rows();}
\DoxyCodeLine{341     \textcolor{keyword}{const} uword n\_cols = P.get\_n\_cols();}
\DoxyCodeLine{342     }
\DoxyCodeLine{343     \textcolor{keywordflow}{if}(n\_cols == 1)}
\DoxyCodeLine{344       \{}
\DoxyCodeLine{345       \textcolor{keywordflow}{for}(uword row=0; row < n\_rows; ++row)}
\DoxyCodeLine{346         \{}
\DoxyCodeLine{347         tmp\_vec[row].val   = std::abs( P.at(row,0) );}
\DoxyCodeLine{348         tmp\_vec[row].index = row;}
\DoxyCodeLine{349         \}}
\DoxyCodeLine{350       }
\DoxyCodeLine{351       uword index1;}
\DoxyCodeLine{352       uword index2;}
\DoxyCodeLine{353       op\_median::direct\_cx\_median\_index(index1, index2, tmp\_vec);}
\DoxyCodeLine{354       }
\DoxyCodeLine{355       \textcolor{keywordflow}{return} op\_mean::robust\_mean( P.at(index1,0), P.at(index2,0) );}
\DoxyCodeLine{356       \}}
\DoxyCodeLine{357     \textcolor{keywordflow}{else}}
\DoxyCodeLine{358     \textcolor{keywordflow}{if}(n\_rows == 1)}
\DoxyCodeLine{359       \{}
\DoxyCodeLine{360       \textcolor{keywordflow}{for}(uword col=0; col < n\_cols; ++col)}
\DoxyCodeLine{361         \{}
\DoxyCodeLine{362         tmp\_vec[col].val   = std::abs( P.at(0,col) );}
\DoxyCodeLine{363         tmp\_vec[col].index = col;}
\DoxyCodeLine{364         \}}
\DoxyCodeLine{365       }
\DoxyCodeLine{366       uword index1;}
\DoxyCodeLine{367       uword index2;}
\DoxyCodeLine{368       op\_median::direct\_cx\_median\_index(index1, index2, tmp\_vec);}
\DoxyCodeLine{369       }
\DoxyCodeLine{370       \textcolor{keywordflow}{return} op\_mean::robust\_mean( P.at(0,index1), P.at(0,index2) );}
\DoxyCodeLine{371       \}}
\DoxyCodeLine{372     \textcolor{keywordflow}{else}}
\DoxyCodeLine{373       \{}
\DoxyCodeLine{374       arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}op\_median::median\_vec(): expected a vector"{}} );}
\DoxyCodeLine{375       }
\DoxyCodeLine{376       \textcolor{keywordflow}{return} eT(0);}
\DoxyCodeLine{377       \}}
\DoxyCodeLine{378     \}}
\DoxyCodeLine{379   \}}
\DoxyCodeLine{380 }
\DoxyCodeLine{381 }
\DoxyCodeLine{382 }
\DoxyCodeLine{384 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{385 \textcolor{keyword}{inline} }
\DoxyCodeLine{386 eT}
\DoxyCodeLine{387 \mbox{\hyperlink{group__op__median_gac3de3527ab7889264dbbe898f7cea151}{op\_median::direct\_median}}(std::vector<eT>\& X)}
\DoxyCodeLine{388   \{}
\DoxyCodeLine{389   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{390   }
\DoxyCodeLine{391   \textcolor{keyword}{const} uword n\_elem = uword(X.size());}
\DoxyCodeLine{392   \textcolor{keyword}{const} uword half   = n\_elem/2;}
\DoxyCodeLine{393   }
\DoxyCodeLine{394   \textcolor{keyword}{typename} std::vector<eT>::iterator first    = X.begin();}
\DoxyCodeLine{395   \textcolor{keyword}{typename} std::vector<eT>::iterator nth      = first + half;}
\DoxyCodeLine{396   \textcolor{keyword}{typename} std::vector<eT>::iterator pastlast = X.end();}
\DoxyCodeLine{397   }
\DoxyCodeLine{398   std::nth\_element(first, nth, pastlast);}
\DoxyCodeLine{399   }
\DoxyCodeLine{400   \textcolor{keywordflow}{if}((n\_elem \% 2) == 0)  \textcolor{comment}{// even number of elements}}
\DoxyCodeLine{401     \{}
\DoxyCodeLine{402     \textcolor{keyword}{typename} std::vector<eT>::iterator start   = X.begin();}
\DoxyCodeLine{403     \textcolor{keyword}{typename} std::vector<eT>::iterator pastend = start + half;}
\DoxyCodeLine{404     }
\DoxyCodeLine{405     \textcolor{keyword}{const} eT val1 = (*nth);}
\DoxyCodeLine{406     \textcolor{keyword}{const} eT val2 = (*(std::max\_element(start, pastend)));}
\DoxyCodeLine{407     }
\DoxyCodeLine{408     \textcolor{keywordflow}{return} op\_mean::robust\_mean(val1, val2);}
\DoxyCodeLine{409     \}}
\DoxyCodeLine{410   \textcolor{keywordflow}{else}  \textcolor{comment}{// odd number of elements}}
\DoxyCodeLine{411     \{}
\DoxyCodeLine{412     \textcolor{keywordflow}{return} (*nth);}
\DoxyCodeLine{413     \}}
\DoxyCodeLine{414   \}}
\DoxyCodeLine{415 }
\DoxyCodeLine{416 }
\DoxyCodeLine{417 }
\DoxyCodeLine{418 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{419 \textcolor{keyword}{inline} }
\DoxyCodeLine{420 \textcolor{keywordtype}{void}}
\DoxyCodeLine{421 op\_median::direct\_cx\_median\_index}
\DoxyCodeLine{422   (}
\DoxyCodeLine{423   uword\& out\_index1, }
\DoxyCodeLine{424   uword\& out\_index2, }
\DoxyCodeLine{425   std::vector< \mbox{\hyperlink{structarma__cx__median__packet}{arma\_cx\_median\_packet<T>}} >\& X}
\DoxyCodeLine{426   )}
\DoxyCodeLine{427   \{}
\DoxyCodeLine{428   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{429   }
\DoxyCodeLine{430   \textcolor{keyword}{typedef} \mbox{\hyperlink{structarma__cx__median__packet}{arma\_cx\_median\_packet<T>}} eT;}
\DoxyCodeLine{431   }
\DoxyCodeLine{432   \textcolor{keyword}{const} uword n\_elem = uword(X.size());}
\DoxyCodeLine{433   \textcolor{keyword}{const} uword half   = n\_elem/2;}
\DoxyCodeLine{434   }
\DoxyCodeLine{435   \textcolor{keyword}{typename} std::vector<eT>::iterator first    = X.begin();}
\DoxyCodeLine{436   \textcolor{keyword}{typename} std::vector<eT>::iterator nth      = first + half;}
\DoxyCodeLine{437   \textcolor{keyword}{typename} std::vector<eT>::iterator pastlast = X.end();}
\DoxyCodeLine{438   }
\DoxyCodeLine{439   std::nth\_element(first, nth, pastlast);}
\DoxyCodeLine{440   }
\DoxyCodeLine{441   out\_index1 = (*nth).index;}
\DoxyCodeLine{442   }
\DoxyCodeLine{443   \textcolor{keywordflow}{if}((n\_elem \% 2) == 0)  \textcolor{comment}{// even number of elements}}
\DoxyCodeLine{444     \{}
\DoxyCodeLine{445     \textcolor{keyword}{typename} std::vector<eT>::iterator start   = X.begin();}
\DoxyCodeLine{446     \textcolor{keyword}{typename} std::vector<eT>::iterator pastend = start + half;}
\DoxyCodeLine{447     }
\DoxyCodeLine{448     out\_index2 = (*(std::max\_element(start, pastend))).index;}
\DoxyCodeLine{449     \}}
\DoxyCodeLine{450   \textcolor{keywordflow}{else}  \textcolor{comment}{// odd number of elements}}
\DoxyCodeLine{451     \{}
\DoxyCodeLine{452     out\_index2 = out\_index1;}
\DoxyCodeLine{453     \}}
\DoxyCodeLine{454   \}}
\DoxyCodeLine{455 }
\DoxyCodeLine{456 }
\DoxyCodeLine{457 }
\DoxyCodeLine{459 }

\end{DoxyCode}
