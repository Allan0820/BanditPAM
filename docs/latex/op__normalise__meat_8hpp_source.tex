\hypertarget{op__normalise__meat_8hpp_source}{}\doxysection{op\+\_\+normalise\+\_\+meat.\+hpp}
\label{op__normalise__meat_8hpp_source}\index{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/op\_normalise\_meat.hpp@{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/op\_normalise\_meat.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008-\/2016 Conrad Sanderson (http://conradsanderson.id.au)}}
\DoxyCodeLine{2 \textcolor{comment}{// Copyright 2008-\/2016 National ICT Australia (NICTA)}}
\DoxyCodeLine{3 \textcolor{comment}{// }}
\DoxyCodeLine{4 \textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{5 \textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{6 \textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{7 \textcolor{comment}{// http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{8 \textcolor{comment}{// }}
\DoxyCodeLine{9 \textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{10 \textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{11 \textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{12 \textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{13 \textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{14 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{17 }
\DoxyCodeLine{20 }
\DoxyCodeLine{21 }
\DoxyCodeLine{22 }
\DoxyCodeLine{23 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{24 \textcolor{keyword}{inline}}
\DoxyCodeLine{25 \textcolor{keywordtype}{void}}
\DoxyCodeLine{26 op\_normalise\_vec::apply(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T1,op\_normalise\_vec>}}\& in)}
\DoxyCodeLine{27   \{}
\DoxyCodeLine{28   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{29   }
\DoxyCodeLine{30   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{31   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type   T;}
\DoxyCodeLine{32   }
\DoxyCodeLine{33   \textcolor{keyword}{const} uword p = in.\mbox{\hyperlink{classOp_a197cb9330fe0d72c976d6223514c4bd6}{aux\_uword\_a}};}
\DoxyCodeLine{34   }
\DoxyCodeLine{35   arma\_debug\_check( (p == 0), \textcolor{stringliteral}{"{}normalise(): parameter 'p' must be greater than zero"{}} );}
\DoxyCodeLine{36   }
\DoxyCodeLine{37   \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} U(in.\mbox{\hyperlink{classOp_af7ab7221b6e233cdd38b9f9b69f301ce}{m}});}
\DoxyCodeLine{38   }
\DoxyCodeLine{39   \textcolor{keyword}{const} T norm\_val\_a = norm(U.M, p);}
\DoxyCodeLine{40   \textcolor{keyword}{const} T norm\_val\_b = (norm\_val\_a != T(0)) ? norm\_val\_a : T(1);}
\DoxyCodeLine{41   }
\DoxyCodeLine{42   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>::has\_subview}} \&\& U.is\_alias(out))}
\DoxyCodeLine{43     \{}
\DoxyCodeLine{44     \mbox{\hyperlink{classMat}{Mat<eT>}} tmp = U.M / norm\_val\_b;}
\DoxyCodeLine{45     }
\DoxyCodeLine{46     out.\mbox{\hyperlink{group__Mat_gaff06a75771f96605f7cc4f8c6b3fceb7}{steal\_mem}}(tmp);}
\DoxyCodeLine{47     \}}
\DoxyCodeLine{48   \textcolor{keywordflow}{else}}
\DoxyCodeLine{49     \{}
\DoxyCodeLine{50     out = U.M / norm\_val\_b;}
\DoxyCodeLine{51     \}}
\DoxyCodeLine{52   \}}
\DoxyCodeLine{53 }
\DoxyCodeLine{54 }
\DoxyCodeLine{55 }
\DoxyCodeLine{56 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{57 \textcolor{keyword}{inline}}
\DoxyCodeLine{58 \textcolor{keywordtype}{void}}
\DoxyCodeLine{59 op\_normalise\_mat::apply(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T1,op\_normalise\_mat>}}\& in)}
\DoxyCodeLine{60   \{}
\DoxyCodeLine{61   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{62   }
\DoxyCodeLine{63   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{64   }
\DoxyCodeLine{65   \textcolor{keyword}{const} uword p   = in.\mbox{\hyperlink{classOp_a197cb9330fe0d72c976d6223514c4bd6}{aux\_uword\_a}};}
\DoxyCodeLine{66   \textcolor{keyword}{const} uword dim = in.\mbox{\hyperlink{classOp_a489b7adb11aa809f594055a640713133}{aux\_uword\_b}};}
\DoxyCodeLine{67   }
\DoxyCodeLine{68   arma\_debug\_check( (p   == 0), \textcolor{stringliteral}{"{}normalise(): parameter 'p' must be greater than zero"{}} );}
\DoxyCodeLine{69   arma\_debug\_check( (dim >  1), \textcolor{stringliteral}{"{}normalise(): parameter 'dim' must be 0 or 1"{}}          );}
\DoxyCodeLine{70   }
\DoxyCodeLine{71   \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} U(in.\mbox{\hyperlink{classOp_af7ab7221b6e233cdd38b9f9b69f301ce}{m}});}
\DoxyCodeLine{72   }
\DoxyCodeLine{73   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>::has\_subview}} \&\& U.is\_alias(out))}
\DoxyCodeLine{74     \{}
\DoxyCodeLine{75     \mbox{\hyperlink{classMat}{Mat<eT>}} out2;}
\DoxyCodeLine{76     }
\DoxyCodeLine{77     op\_normalise\_mat::apply(out2, U.M, p, dim);}
\DoxyCodeLine{78     }
\DoxyCodeLine{79     out.\mbox{\hyperlink{group__Mat_gaff06a75771f96605f7cc4f8c6b3fceb7}{steal\_mem}}(out2);}
\DoxyCodeLine{80     \}}
\DoxyCodeLine{81   \textcolor{keywordflow}{else}}
\DoxyCodeLine{82     \{}
\DoxyCodeLine{83     op\_normalise\_mat::apply(out, U.M, p, dim);}
\DoxyCodeLine{84     \}}
\DoxyCodeLine{85   \}}
\DoxyCodeLine{86 }
\DoxyCodeLine{87 }
\DoxyCodeLine{88 }
\DoxyCodeLine{89 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{90 \textcolor{keyword}{inline}}
\DoxyCodeLine{91 \textcolor{keywordtype}{void}}
\DoxyCodeLine{92 op\_normalise\_mat::apply(\mbox{\hyperlink{classMat}{Mat<eT>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} uword p, \textcolor{keyword}{const} uword dim)}
\DoxyCodeLine{93   \{}
\DoxyCodeLine{94   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{95   }
\DoxyCodeLine{96   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} get\_pod\_type<eT>::result T;}
\DoxyCodeLine{97   }
\DoxyCodeLine{98   out.\mbox{\hyperlink{group__Mat_ga9b739350523229ea160719b1ef106f96}{copy\_size}}(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{99   }
\DoxyCodeLine{100   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.n\_elem == 0)  \{ \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{101   }
\DoxyCodeLine{102   \textcolor{keywordflow}{if}(dim == 0)}
\DoxyCodeLine{103     \{}
\DoxyCodeLine{104     \textcolor{keyword}{const} uword n\_cols = \mbox{\hyperlink{structA}{A}}.n\_cols;}
\DoxyCodeLine{105     }
\DoxyCodeLine{106     \textcolor{keywordflow}{for}(uword i=0; i<n\_cols; ++i)}
\DoxyCodeLine{107       \{}
\DoxyCodeLine{108       \textcolor{keyword}{const} T norm\_val\_a = norm(\mbox{\hyperlink{structA}{A}}.col(i), p);}
\DoxyCodeLine{109       \textcolor{keyword}{const} T norm\_val\_b = (norm\_val\_a != T(0)) ? norm\_val\_a : T(1);}
\DoxyCodeLine{110       }
\DoxyCodeLine{111       out.\mbox{\hyperlink{group__Mat_gab68ba7bbceb5544bbd0f6f00dfe6b328}{col}}(i) = \mbox{\hyperlink{structA}{A}}.col(i) / norm\_val\_b;}
\DoxyCodeLine{112       \}}
\DoxyCodeLine{113     \}}
\DoxyCodeLine{114   \textcolor{keywordflow}{else}}
\DoxyCodeLine{115     \{}
\DoxyCodeLine{116     \textcolor{keyword}{const} uword n\_rows = \mbox{\hyperlink{structA}{A}}.n\_rows;}
\DoxyCodeLine{117     \textcolor{keyword}{const} uword n\_cols = \mbox{\hyperlink{structA}{A}}.n\_cols;}
\DoxyCodeLine{118     }
\DoxyCodeLine{119     \mbox{\hyperlink{classpodarray}{podarray<T>}} norm\_vals(n\_rows);}
\DoxyCodeLine{120     }
\DoxyCodeLine{121     T* norm\_vals\_mem = norm\_vals.memptr();}
\DoxyCodeLine{122     }
\DoxyCodeLine{123     \textcolor{keywordflow}{for}(uword i=0; i<n\_rows; ++i)}
\DoxyCodeLine{124       \{}
\DoxyCodeLine{125       \textcolor{keyword}{const} T norm\_val = norm(\mbox{\hyperlink{structA}{A}}.row(i), p);}
\DoxyCodeLine{126       }
\DoxyCodeLine{127       norm\_vals\_mem[i] = (norm\_val != T(0)) ? norm\_val : T(1);}
\DoxyCodeLine{128       \}}
\DoxyCodeLine{129     }
\DoxyCodeLine{130     \textcolor{keyword}{const} eT*   A\_mem =   \mbox{\hyperlink{structA}{A}}.memptr();}
\DoxyCodeLine{131           eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{132     }
\DoxyCodeLine{133     \textcolor{keywordflow}{for}(uword col=0; col < n\_cols; ++col)}
\DoxyCodeLine{134     \textcolor{keywordflow}{for}(uword row=0; row < n\_rows; ++row)}
\DoxyCodeLine{135       \{}
\DoxyCodeLine{136       (*out\_mem) = (*A\_mem) / norm\_vals\_mem[row];}
\DoxyCodeLine{137       }
\DoxyCodeLine{138       A\_mem++;}
\DoxyCodeLine{139       out\_mem++;}
\DoxyCodeLine{140       \}}
\DoxyCodeLine{141     \}}
\DoxyCodeLine{142   \}}
\DoxyCodeLine{143 }
\DoxyCodeLine{144 }
\DoxyCodeLine{145 }

\end{DoxyCode}
