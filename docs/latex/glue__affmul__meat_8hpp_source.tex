\hypertarget{glue__affmul__meat_8hpp_source}{}\doxysection{glue\+\_\+affmul\+\_\+meat.\+hpp}
\label{glue__affmul__meat_8hpp_source}\index{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/glue\_affmul\_meat.hpp@{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/glue\_affmul\_meat.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008-\/2016 Conrad Sanderson (http://conradsanderson.id.au)}}
\DoxyCodeLine{2 \textcolor{comment}{// Copyright 2008-\/2016 National ICT Australia (NICTA)}}
\DoxyCodeLine{3 \textcolor{comment}{// }}
\DoxyCodeLine{4 \textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{5 \textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{6 \textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{7 \textcolor{comment}{// http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{8 \textcolor{comment}{// }}
\DoxyCodeLine{9 \textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{10 \textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{11 \textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{12 \textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{13 \textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{14 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{19 }
\DoxyCodeLine{20 }
\DoxyCodeLine{21 }
\DoxyCodeLine{22 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{23 \textcolor{keyword}{inline}}
\DoxyCodeLine{24 \textcolor{keywordtype}{void}}
\DoxyCodeLine{25 glue\_affmul::apply(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classGlue}{Glue<T1,T2,glue\_affmul>}}\& X)}
\DoxyCodeLine{26   \{}
\DoxyCodeLine{27   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{28   }
\DoxyCodeLine{29   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{30   }
\DoxyCodeLine{31   \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} U1(X.A);}
\DoxyCodeLine{32   \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T2>}} U2(X.B);}
\DoxyCodeLine{33   }
\DoxyCodeLine{34   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} is\_alias = (U1.is\_alias(out) || U2.is\_alias(out));}
\DoxyCodeLine{35   }
\DoxyCodeLine{36   \textcolor{keywordflow}{if}(is\_alias == \textcolor{keyword}{false})}
\DoxyCodeLine{37     \{}
\DoxyCodeLine{38     glue\_affmul::apply\_noalias(out, U1.M, U2.M);}
\DoxyCodeLine{39     \}}
\DoxyCodeLine{40   \textcolor{keywordflow}{else}}
\DoxyCodeLine{41     \{}
\DoxyCodeLine{42     \mbox{\hyperlink{classMat}{Mat<eT>}} tmp;}
\DoxyCodeLine{43     }
\DoxyCodeLine{44     glue\_affmul::apply\_noalias(tmp, U1.M, U2.M);}
\DoxyCodeLine{45     }
\DoxyCodeLine{46     out.\mbox{\hyperlink{group__Mat_gaff06a75771f96605f7cc4f8c6b3fceb7}{steal\_mem}}(tmp);}
\DoxyCodeLine{47     \}}
\DoxyCodeLine{48   \}}
\DoxyCodeLine{49 }
\DoxyCodeLine{50 }
\DoxyCodeLine{51 }
\DoxyCodeLine{52 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{53 \textcolor{keyword}{inline}}
\DoxyCodeLine{54 \textcolor{keywordtype}{void}}
\DoxyCodeLine{55 glue\_affmul::apply\_noalias(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} T1\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} T2\& \mbox{\hyperlink{structB}{B}})}
\DoxyCodeLine{56   \{}
\DoxyCodeLine{57   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{58   }
\DoxyCodeLine{59   \textcolor{keyword}{const} uword A\_n\_cols = \mbox{\hyperlink{structA}{A}}.n\_cols;}
\DoxyCodeLine{60   \textcolor{keyword}{const} uword A\_n\_rows = \mbox{\hyperlink{structA}{A}}.n\_rows;}
\DoxyCodeLine{61   \textcolor{keyword}{const} uword B\_n\_rows = \mbox{\hyperlink{structB}{B}}.n\_rows;}
\DoxyCodeLine{62   }
\DoxyCodeLine{63   arma\_debug\_check( (A\_n\_cols != B\_n\_rows+1), \textcolor{stringliteral}{"{}affmul(): size mismatch"{}} );}
\DoxyCodeLine{64   }
\DoxyCodeLine{65   \textcolor{keywordflow}{if}(A\_n\_rows == A\_n\_cols)}
\DoxyCodeLine{66     \{}
\DoxyCodeLine{67     glue\_affmul::apply\_noalias\_square(out, \mbox{\hyperlink{structA}{A}}, \mbox{\hyperlink{structB}{B}});}
\DoxyCodeLine{68     \}}
\DoxyCodeLine{69   \textcolor{keywordflow}{else}}
\DoxyCodeLine{70   \textcolor{keywordflow}{if}(A\_n\_rows == B\_n\_rows)}
\DoxyCodeLine{71     \{}
\DoxyCodeLine{72     glue\_affmul::apply\_noalias\_rectangle(out, \mbox{\hyperlink{structA}{A}}, \mbox{\hyperlink{structB}{B}});}
\DoxyCodeLine{73     \}}
\DoxyCodeLine{74   \textcolor{keywordflow}{else}}
\DoxyCodeLine{75     \{}
\DoxyCodeLine{76     glue\_affmul::apply\_noalias\_generic(out, \mbox{\hyperlink{structA}{A}}, \mbox{\hyperlink{structB}{B}});}
\DoxyCodeLine{77     \}}
\DoxyCodeLine{78   \}}
\DoxyCodeLine{79 }
\DoxyCodeLine{80 }
\DoxyCodeLine{81 }
\DoxyCodeLine{82 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{83 \textcolor{keyword}{inline}}
\DoxyCodeLine{84 \textcolor{keywordtype}{void}}
\DoxyCodeLine{85 glue\_affmul::apply\_noalias\_square(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} T1\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} T2\& \mbox{\hyperlink{structB}{B}})}
\DoxyCodeLine{86   \{}
\DoxyCodeLine{87   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{88   }
\DoxyCodeLine{89   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{90   }
\DoxyCodeLine{91   \textcolor{comment}{// assuming that A is square sized, and A.n\_cols = B.n\_rows+1}}
\DoxyCodeLine{92   }
\DoxyCodeLine{93   \textcolor{keyword}{const} uword N        = \mbox{\hyperlink{structA}{A}}.n\_rows;}
\DoxyCodeLine{94   \textcolor{keyword}{const} uword B\_n\_cols = \mbox{\hyperlink{structB}{B}}.n\_cols;}
\DoxyCodeLine{95   }
\DoxyCodeLine{96   out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(N, B\_n\_cols);}
\DoxyCodeLine{97   }
\DoxyCodeLine{98   \textcolor{keywordflow}{if}(out.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}} == 0)  \{ \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{99   }
\DoxyCodeLine{100   \textcolor{keyword}{const} eT* A\_mem = \mbox{\hyperlink{structA}{A}}.memptr();}
\DoxyCodeLine{101   }
\DoxyCodeLine{102   \textcolor{keywordflow}{switch}(N)}
\DoxyCodeLine{103     \{}
\DoxyCodeLine{104     \textcolor{keywordflow}{case} 0:}
\DoxyCodeLine{105       \textcolor{keywordflow}{break};}
\DoxyCodeLine{106     }
\DoxyCodeLine{107     \textcolor{keywordflow}{case} 1:  \textcolor{comment}{// A is 1x1}}
\DoxyCodeLine{108       out.\mbox{\hyperlink{group__Mat_gab60eae61ede0f0df33fb2a67cf62b696}{fill}}(A\_mem[0]);}
\DoxyCodeLine{109       \textcolor{keywordflow}{break};}
\DoxyCodeLine{110     }
\DoxyCodeLine{111     \textcolor{keywordflow}{case} 2:  \textcolor{comment}{// A is 2x2}}
\DoxyCodeLine{112       \{}
\DoxyCodeLine{113       \textcolor{keywordflow}{if}(B\_n\_cols == 1)}
\DoxyCodeLine{114         \{}
\DoxyCodeLine{115         \textcolor{keyword}{const} eT*   B\_mem =   \mbox{\hyperlink{structB}{B}}.memptr();}
\DoxyCodeLine{116               eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{117         }
\DoxyCodeLine{118         \textcolor{keyword}{const} eT x = B\_mem[0];}
\DoxyCodeLine{119         }
\DoxyCodeLine{120         out\_mem[0] = A\_mem[0]*x + A\_mem[2];}
\DoxyCodeLine{121         out\_mem[1] = A\_mem[1]*x + A\_mem[3];}
\DoxyCodeLine{122         \}}
\DoxyCodeLine{123       \textcolor{keywordflow}{else}}
\DoxyCodeLine{124       \textcolor{keywordflow}{for}(uword col=0; col < B\_n\_cols; ++col)}
\DoxyCodeLine{125         \{}
\DoxyCodeLine{126         \textcolor{keyword}{const} eT*   B\_mem =   \mbox{\hyperlink{structB}{B}}.colptr(col);}
\DoxyCodeLine{127               eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(col);}
\DoxyCodeLine{128         }
\DoxyCodeLine{129         \textcolor{keyword}{const} eT x = B\_mem[0];}
\DoxyCodeLine{130         }
\DoxyCodeLine{131         out\_mem[0] = A\_mem[0]*x + A\_mem[2];}
\DoxyCodeLine{132         out\_mem[1] = A\_mem[1]*x + A\_mem[3];}
\DoxyCodeLine{133         \}}
\DoxyCodeLine{134       \}}
\DoxyCodeLine{135       \textcolor{keywordflow}{break};}
\DoxyCodeLine{136     }
\DoxyCodeLine{137     \textcolor{keywordflow}{case} 3:  \textcolor{comment}{// A is 3x3}}
\DoxyCodeLine{138       \{}
\DoxyCodeLine{139       \textcolor{keywordflow}{if}(B\_n\_cols == 1)}
\DoxyCodeLine{140         \{}
\DoxyCodeLine{141         \textcolor{keyword}{const} eT*   B\_mem =   \mbox{\hyperlink{structB}{B}}.memptr();}
\DoxyCodeLine{142               eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{143         }
\DoxyCodeLine{144         \textcolor{keyword}{const} eT x = B\_mem[0];}
\DoxyCodeLine{145         \textcolor{keyword}{const} eT y = B\_mem[1];}
\DoxyCodeLine{146         }
\DoxyCodeLine{147         out\_mem[0] = A\_mem[0]*x + A\_mem[3]*y + A\_mem[6];}
\DoxyCodeLine{148         out\_mem[1] = A\_mem[1]*x + A\_mem[4]*y + A\_mem[7];}
\DoxyCodeLine{149         out\_mem[2] = A\_mem[2]*x + A\_mem[5]*y + A\_mem[8];}
\DoxyCodeLine{150         \}}
\DoxyCodeLine{151       \textcolor{keywordflow}{else}}
\DoxyCodeLine{152       \textcolor{keywordflow}{for}(uword col=0; col < B\_n\_cols; ++col)}
\DoxyCodeLine{153         \{}
\DoxyCodeLine{154         \textcolor{keyword}{const} eT*   B\_mem =   \mbox{\hyperlink{structB}{B}}.colptr(col);}
\DoxyCodeLine{155               eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(col);}
\DoxyCodeLine{156         }
\DoxyCodeLine{157         \textcolor{keyword}{const} eT x = B\_mem[0];}
\DoxyCodeLine{158         \textcolor{keyword}{const} eT y = B\_mem[1];}
\DoxyCodeLine{159         }
\DoxyCodeLine{160         out\_mem[0] = A\_mem[0]*x + A\_mem[3]*y + A\_mem[6];}
\DoxyCodeLine{161         out\_mem[1] = A\_mem[1]*x + A\_mem[4]*y + A\_mem[7];}
\DoxyCodeLine{162         out\_mem[2] = A\_mem[2]*x + A\_mem[5]*y + A\_mem[8];}
\DoxyCodeLine{163         \}}
\DoxyCodeLine{164       \}}
\DoxyCodeLine{165       \textcolor{keywordflow}{break};}
\DoxyCodeLine{166     }
\DoxyCodeLine{167     \textcolor{keywordflow}{case} 4:  \textcolor{comment}{// A is 4x4}}
\DoxyCodeLine{168       \{}
\DoxyCodeLine{169       \textcolor{keywordflow}{if}(B\_n\_cols == 1)}
\DoxyCodeLine{170         \{}
\DoxyCodeLine{171         \textcolor{keyword}{const} eT*   B\_mem =   \mbox{\hyperlink{structB}{B}}.memptr();}
\DoxyCodeLine{172               eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{173         }
\DoxyCodeLine{174         \textcolor{keyword}{const} eT x = B\_mem[0];}
\DoxyCodeLine{175         \textcolor{keyword}{const} eT y = B\_mem[1];}
\DoxyCodeLine{176         \textcolor{keyword}{const} eT z = B\_mem[2];}
\DoxyCodeLine{177         }
\DoxyCodeLine{178         out\_mem[0] = A\_mem[ 0]*x + A\_mem[ 4]*y + A\_mem[ 8]*z + A\_mem[12];}
\DoxyCodeLine{179         out\_mem[1] = A\_mem[ 1]*x + A\_mem[ 5]*y + A\_mem[ 9]*z + A\_mem[13];}
\DoxyCodeLine{180         out\_mem[2] = A\_mem[ 2]*x + A\_mem[ 6]*y + A\_mem[10]*z + A\_mem[14];}
\DoxyCodeLine{181         out\_mem[3] = A\_mem[ 3]*x + A\_mem[ 7]*y + A\_mem[11]*z + A\_mem[15];}
\DoxyCodeLine{182         \}}
\DoxyCodeLine{183       \textcolor{keywordflow}{else}}
\DoxyCodeLine{184       \textcolor{keywordflow}{for}(uword col=0; col < B\_n\_cols; ++col)}
\DoxyCodeLine{185         \{}
\DoxyCodeLine{186         \textcolor{keyword}{const} eT*   B\_mem =   \mbox{\hyperlink{structB}{B}}.colptr(col);}
\DoxyCodeLine{187               eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(col);}
\DoxyCodeLine{188         }
\DoxyCodeLine{189         \textcolor{keyword}{const} eT x = B\_mem[0];}
\DoxyCodeLine{190         \textcolor{keyword}{const} eT y = B\_mem[1];}
\DoxyCodeLine{191         \textcolor{keyword}{const} eT z = B\_mem[2];}
\DoxyCodeLine{192         }
\DoxyCodeLine{193         out\_mem[0] = A\_mem[ 0]*x + A\_mem[ 4]*y + A\_mem[ 8]*z + A\_mem[12];}
\DoxyCodeLine{194         out\_mem[1] = A\_mem[ 1]*x + A\_mem[ 5]*y + A\_mem[ 9]*z + A\_mem[13];}
\DoxyCodeLine{195         out\_mem[2] = A\_mem[ 2]*x + A\_mem[ 6]*y + A\_mem[10]*z + A\_mem[14];}
\DoxyCodeLine{196         out\_mem[3] = A\_mem[ 3]*x + A\_mem[ 7]*y + A\_mem[11]*z + A\_mem[15];}
\DoxyCodeLine{197         \}}
\DoxyCodeLine{198       \}}
\DoxyCodeLine{199       \textcolor{keywordflow}{break};}
\DoxyCodeLine{200     }
\DoxyCodeLine{201     \textcolor{keywordflow}{case} 5:  \textcolor{comment}{// A is 5x5}}
\DoxyCodeLine{202       \{}
\DoxyCodeLine{203       \textcolor{keywordflow}{if}(B\_n\_cols == 1)}
\DoxyCodeLine{204         \{}
\DoxyCodeLine{205         \textcolor{keyword}{const} eT*   B\_mem =   \mbox{\hyperlink{structB}{B}}.memptr();}
\DoxyCodeLine{206               eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{207         }
\DoxyCodeLine{208         \textcolor{keyword}{const} eT x = B\_mem[0];}
\DoxyCodeLine{209         \textcolor{keyword}{const} eT y = B\_mem[1];}
\DoxyCodeLine{210         \textcolor{keyword}{const} eT z = B\_mem[2];}
\DoxyCodeLine{211         \textcolor{keyword}{const} eT w = B\_mem[3];}
\DoxyCodeLine{212         }
\DoxyCodeLine{213         out\_mem[0] = A\_mem[ 0]*x + A\_mem[ 5]*y + A\_mem[10]*z + A\_mem[15]*w + A\_mem[20];}
\DoxyCodeLine{214         out\_mem[1] = A\_mem[ 1]*x + A\_mem[ 6]*y + A\_mem[11]*z + A\_mem[16]*w + A\_mem[21];}
\DoxyCodeLine{215         out\_mem[2] = A\_mem[ 2]*x + A\_mem[ 7]*y + A\_mem[12]*z + A\_mem[17]*w + A\_mem[22];}
\DoxyCodeLine{216         out\_mem[3] = A\_mem[ 3]*x + A\_mem[ 8]*y + A\_mem[13]*z + A\_mem[18]*w + A\_mem[23];}
\DoxyCodeLine{217         out\_mem[4] = A\_mem[ 4]*x + A\_mem[ 9]*y + A\_mem[14]*z + A\_mem[19]*w + A\_mem[24];}
\DoxyCodeLine{218         \}}
\DoxyCodeLine{219       \textcolor{keywordflow}{else}}
\DoxyCodeLine{220       \textcolor{keywordflow}{for}(uword col=0; col < B\_n\_cols; ++col)}
\DoxyCodeLine{221         \{}
\DoxyCodeLine{222         \textcolor{keyword}{const} eT*   B\_mem =   \mbox{\hyperlink{structB}{B}}.colptr(col);}
\DoxyCodeLine{223               eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(col);}
\DoxyCodeLine{224         }
\DoxyCodeLine{225         \textcolor{keyword}{const} eT x = B\_mem[0];}
\DoxyCodeLine{226         \textcolor{keyword}{const} eT y = B\_mem[1];}
\DoxyCodeLine{227         \textcolor{keyword}{const} eT z = B\_mem[2];}
\DoxyCodeLine{228         \textcolor{keyword}{const} eT w = B\_mem[3];}
\DoxyCodeLine{229         }
\DoxyCodeLine{230         out\_mem[0] = A\_mem[ 0]*x + A\_mem[ 5]*y + A\_mem[10]*z + A\_mem[15]*w + A\_mem[20];}
\DoxyCodeLine{231         out\_mem[1] = A\_mem[ 1]*x + A\_mem[ 6]*y + A\_mem[11]*z + A\_mem[16]*w + A\_mem[21];}
\DoxyCodeLine{232         out\_mem[2] = A\_mem[ 2]*x + A\_mem[ 7]*y + A\_mem[12]*z + A\_mem[17]*w + A\_mem[22];}
\DoxyCodeLine{233         out\_mem[3] = A\_mem[ 3]*x + A\_mem[ 8]*y + A\_mem[13]*z + A\_mem[18]*w + A\_mem[23];}
\DoxyCodeLine{234         out\_mem[4] = A\_mem[ 4]*x + A\_mem[ 9]*y + A\_mem[14]*z + A\_mem[19]*w + A\_mem[24];}
\DoxyCodeLine{235         \}}
\DoxyCodeLine{236       \}}
\DoxyCodeLine{237       \textcolor{keywordflow}{break};}
\DoxyCodeLine{238     }
\DoxyCodeLine{239     \textcolor{keywordflow}{default}:}
\DoxyCodeLine{240       \{}
\DoxyCodeLine{241       \textcolor{keywordflow}{if}(B\_n\_cols == 1)}
\DoxyCodeLine{242         \{}
\DoxyCodeLine{243         \mbox{\hyperlink{classCol}{Col<eT>}} tmp(N, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{244         eT*     tmp\_mem = tmp.memptr();}
\DoxyCodeLine{245         }
\DoxyCodeLine{246         arrayops::copy(tmp\_mem, \mbox{\hyperlink{structB}{B}}.memptr(), N-\/1);}
\DoxyCodeLine{247         }
\DoxyCodeLine{248         tmp\_mem[N-\/1] = eT(1);}
\DoxyCodeLine{249         }
\DoxyCodeLine{250         out = \mbox{\hyperlink{structA}{A}} * tmp;}
\DoxyCodeLine{251         \}}
\DoxyCodeLine{252       \textcolor{keywordflow}{else}}
\DoxyCodeLine{253         \{}
\DoxyCodeLine{254         \mbox{\hyperlink{classMat}{Mat<eT>}} tmp(N, B\_n\_cols, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{255         }
\DoxyCodeLine{256         \textcolor{keywordflow}{for}(uword col=0; col < B\_n\_cols; ++col)}
\DoxyCodeLine{257           \{}
\DoxyCodeLine{258           \textcolor{keyword}{const} eT*   B\_mem =   \mbox{\hyperlink{structB}{B}}.colptr(col);}
\DoxyCodeLine{259                 eT* tmp\_mem = tmp.colptr(col);}
\DoxyCodeLine{260           }
\DoxyCodeLine{261           arrayops::copy(tmp\_mem, B\_mem, N-\/1);}
\DoxyCodeLine{262           }
\DoxyCodeLine{263           tmp\_mem[N-\/1] = eT(1);}
\DoxyCodeLine{264           \}}
\DoxyCodeLine{265         }
\DoxyCodeLine{266         out = \mbox{\hyperlink{structA}{A}} * tmp;}
\DoxyCodeLine{267         \}}
\DoxyCodeLine{268       \}}
\DoxyCodeLine{269     \}}
\DoxyCodeLine{270   \}}
\DoxyCodeLine{271 }
\DoxyCodeLine{272 }
\DoxyCodeLine{273 }
\DoxyCodeLine{274 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{275 \textcolor{keyword}{inline}}
\DoxyCodeLine{276 \textcolor{keywordtype}{void}}
\DoxyCodeLine{277 glue\_affmul::apply\_noalias\_rectangle(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} T1\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} T2\& \mbox{\hyperlink{structB}{B}})}
\DoxyCodeLine{278   \{}
\DoxyCodeLine{279   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{280   }
\DoxyCodeLine{281   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{282   }
\DoxyCodeLine{283   \textcolor{comment}{// assuming that A.n\_rows = A.n\_cols-\/1, and A.n\_cols = B.n\_rows+1}}
\DoxyCodeLine{284   \textcolor{comment}{// (A and B have the same number of rows)}}
\DoxyCodeLine{285   }
\DoxyCodeLine{286   \textcolor{keyword}{const} uword A\_n\_rows = \mbox{\hyperlink{structA}{A}}.n\_rows;}
\DoxyCodeLine{287   \textcolor{keyword}{const} uword B\_n\_cols = \mbox{\hyperlink{structB}{B}}.n\_cols;}
\DoxyCodeLine{288   }
\DoxyCodeLine{289   out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(A\_n\_rows, B\_n\_cols);}
\DoxyCodeLine{290   }
\DoxyCodeLine{291   \textcolor{keywordflow}{if}(out.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}} == 0)  \{ \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{292   }
\DoxyCodeLine{293   \textcolor{keyword}{const} eT* A\_mem = \mbox{\hyperlink{structA}{A}}.memptr();}
\DoxyCodeLine{294   }
\DoxyCodeLine{295   \textcolor{keywordflow}{switch}(A\_n\_rows)}
\DoxyCodeLine{296     \{}
\DoxyCodeLine{297     \textcolor{keywordflow}{case} 0:}
\DoxyCodeLine{298       \textcolor{keywordflow}{break};}
\DoxyCodeLine{299     }
\DoxyCodeLine{300     \textcolor{keywordflow}{case} 1:  \textcolor{comment}{// A is 1x2}}
\DoxyCodeLine{301       \{}
\DoxyCodeLine{302       \textcolor{keywordflow}{if}(B\_n\_cols == 1)}
\DoxyCodeLine{303         \{}
\DoxyCodeLine{304         \textcolor{keyword}{const} eT*   B\_mem =   \mbox{\hyperlink{structB}{B}}.memptr();}
\DoxyCodeLine{305               eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{306         }
\DoxyCodeLine{307         \textcolor{keyword}{const} eT x = B\_mem[0];}
\DoxyCodeLine{308         }
\DoxyCodeLine{309         out\_mem[0] = A\_mem[0]*x + A\_mem[1];}
\DoxyCodeLine{310         \}}
\DoxyCodeLine{311       \textcolor{keywordflow}{else}}
\DoxyCodeLine{312       \textcolor{keywordflow}{for}(uword col=0; col < B\_n\_cols; ++col)}
\DoxyCodeLine{313         \{}
\DoxyCodeLine{314         \textcolor{keyword}{const} eT*   B\_mem =   \mbox{\hyperlink{structB}{B}}.colptr(col);}
\DoxyCodeLine{315               eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(col);}
\DoxyCodeLine{316         }
\DoxyCodeLine{317         \textcolor{keyword}{const} eT x = B\_mem[0];}
\DoxyCodeLine{318         }
\DoxyCodeLine{319         out\_mem[0] = A\_mem[0]*x + A\_mem[1];}
\DoxyCodeLine{320         \}}
\DoxyCodeLine{321       \}}
\DoxyCodeLine{322       \textcolor{keywordflow}{break};}
\DoxyCodeLine{323     }
\DoxyCodeLine{324     \textcolor{keywordflow}{case} 2:  \textcolor{comment}{// A is 2x3}}
\DoxyCodeLine{325       \{}
\DoxyCodeLine{326       \textcolor{keywordflow}{if}(B\_n\_cols == 1)}
\DoxyCodeLine{327         \{}
\DoxyCodeLine{328         \textcolor{keyword}{const} eT*   B\_mem =   \mbox{\hyperlink{structB}{B}}.memptr();}
\DoxyCodeLine{329               eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{330         }
\DoxyCodeLine{331         \textcolor{keyword}{const} eT x = B\_mem[0];}
\DoxyCodeLine{332         \textcolor{keyword}{const} eT y = B\_mem[1];}
\DoxyCodeLine{333         }
\DoxyCodeLine{334         out\_mem[0] = A\_mem[0]*x + A\_mem[2]*y + A\_mem[4];}
\DoxyCodeLine{335         out\_mem[1] = A\_mem[1]*x + A\_mem[3]*y + A\_mem[5];}
\DoxyCodeLine{336         \}}
\DoxyCodeLine{337       \textcolor{keywordflow}{else}}
\DoxyCodeLine{338       \textcolor{keywordflow}{for}(uword col=0; col < B\_n\_cols; ++col)}
\DoxyCodeLine{339         \{}
\DoxyCodeLine{340         \textcolor{keyword}{const} eT*   B\_mem =   \mbox{\hyperlink{structB}{B}}.colptr(col);}
\DoxyCodeLine{341               eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(col);}
\DoxyCodeLine{342         }
\DoxyCodeLine{343         \textcolor{keyword}{const} eT x = B\_mem[0];}
\DoxyCodeLine{344         \textcolor{keyword}{const} eT y = B\_mem[1];}
\DoxyCodeLine{345         }
\DoxyCodeLine{346         out\_mem[0] = A\_mem[0]*x + A\_mem[2]*y + A\_mem[4];}
\DoxyCodeLine{347         out\_mem[1] = A\_mem[1]*x + A\_mem[3]*y + A\_mem[5];}
\DoxyCodeLine{348         \}}
\DoxyCodeLine{349       \}}
\DoxyCodeLine{350       \textcolor{keywordflow}{break};}
\DoxyCodeLine{351     }
\DoxyCodeLine{352     \textcolor{keywordflow}{case} 3:  \textcolor{comment}{// A is 3x4}}
\DoxyCodeLine{353       \{}
\DoxyCodeLine{354       \textcolor{keywordflow}{if}(B\_n\_cols == 1)}
\DoxyCodeLine{355         \{}
\DoxyCodeLine{356         \textcolor{keyword}{const} eT*   B\_mem =   \mbox{\hyperlink{structB}{B}}.memptr();}
\DoxyCodeLine{357               eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{358         }
\DoxyCodeLine{359         \textcolor{keyword}{const} eT x = B\_mem[0];}
\DoxyCodeLine{360         \textcolor{keyword}{const} eT y = B\_mem[1];}
\DoxyCodeLine{361         \textcolor{keyword}{const} eT z = B\_mem[2];}
\DoxyCodeLine{362         }
\DoxyCodeLine{363         out\_mem[0] = A\_mem[ 0]*x + A\_mem[ 3]*y + A\_mem[ 6]*z + A\_mem[ 9];}
\DoxyCodeLine{364         out\_mem[1] = A\_mem[ 1]*x + A\_mem[ 4]*y + A\_mem[ 7]*z + A\_mem[10];}
\DoxyCodeLine{365         out\_mem[2] = A\_mem[ 2]*x + A\_mem[ 5]*y + A\_mem[ 8]*z + A\_mem[11];}
\DoxyCodeLine{366         \}}
\DoxyCodeLine{367       \textcolor{keywordflow}{else}}
\DoxyCodeLine{368       \textcolor{keywordflow}{for}(uword col=0; col < B\_n\_cols; ++col)}
\DoxyCodeLine{369         \{}
\DoxyCodeLine{370         \textcolor{keyword}{const} eT*   B\_mem =   \mbox{\hyperlink{structB}{B}}.colptr(col);}
\DoxyCodeLine{371               eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(col);}
\DoxyCodeLine{372         }
\DoxyCodeLine{373         \textcolor{keyword}{const} eT x = B\_mem[0];}
\DoxyCodeLine{374         \textcolor{keyword}{const} eT y = B\_mem[1];}
\DoxyCodeLine{375         \textcolor{keyword}{const} eT z = B\_mem[2];}
\DoxyCodeLine{376         }
\DoxyCodeLine{377         out\_mem[0] = A\_mem[ 0]*x + A\_mem[ 3]*y + A\_mem[ 6]*z + A\_mem[ 9];}
\DoxyCodeLine{378         out\_mem[1] = A\_mem[ 1]*x + A\_mem[ 4]*y + A\_mem[ 7]*z + A\_mem[10];}
\DoxyCodeLine{379         out\_mem[2] = A\_mem[ 2]*x + A\_mem[ 5]*y + A\_mem[ 8]*z + A\_mem[11];}
\DoxyCodeLine{380         \}}
\DoxyCodeLine{381       \}}
\DoxyCodeLine{382       \textcolor{keywordflow}{break};}
\DoxyCodeLine{383     }
\DoxyCodeLine{384     \textcolor{keywordflow}{case} 4:  \textcolor{comment}{// A is 4x5}}
\DoxyCodeLine{385       \{}
\DoxyCodeLine{386       \textcolor{keywordflow}{if}(B\_n\_cols == 1)}
\DoxyCodeLine{387         \{}
\DoxyCodeLine{388         \textcolor{keyword}{const} eT*   B\_mem =   \mbox{\hyperlink{structB}{B}}.memptr();}
\DoxyCodeLine{389               eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{390         }
\DoxyCodeLine{391         \textcolor{keyword}{const} eT x = B\_mem[0];}
\DoxyCodeLine{392         \textcolor{keyword}{const} eT y = B\_mem[1];}
\DoxyCodeLine{393         \textcolor{keyword}{const} eT z = B\_mem[2];}
\DoxyCodeLine{394         \textcolor{keyword}{const} eT w = B\_mem[3];}
\DoxyCodeLine{395         }
\DoxyCodeLine{396         out\_mem[0] = A\_mem[ 0]*x + A\_mem[ 4]*y + A\_mem[ 8]*z + A\_mem[12]*w + A\_mem[16];}
\DoxyCodeLine{397         out\_mem[1] = A\_mem[ 1]*x + A\_mem[ 5]*y + A\_mem[ 9]*z + A\_mem[13]*w + A\_mem[17];}
\DoxyCodeLine{398         out\_mem[2] = A\_mem[ 2]*x + A\_mem[ 6]*y + A\_mem[10]*z + A\_mem[14]*w + A\_mem[18];}
\DoxyCodeLine{399         out\_mem[3] = A\_mem[ 3]*x + A\_mem[ 7]*y + A\_mem[11]*z + A\_mem[15]*w + A\_mem[19];}
\DoxyCodeLine{400         \}}
\DoxyCodeLine{401       \textcolor{keywordflow}{else}}
\DoxyCodeLine{402       \textcolor{keywordflow}{for}(uword col=0; col < B\_n\_cols; ++col)}
\DoxyCodeLine{403         \{}
\DoxyCodeLine{404         \textcolor{keyword}{const} eT*   B\_mem =   \mbox{\hyperlink{structB}{B}}.colptr(col);}
\DoxyCodeLine{405               eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(col);}
\DoxyCodeLine{406         }
\DoxyCodeLine{407         \textcolor{keyword}{const} eT x = B\_mem[0];}
\DoxyCodeLine{408         \textcolor{keyword}{const} eT y = B\_mem[1];}
\DoxyCodeLine{409         \textcolor{keyword}{const} eT z = B\_mem[2];}
\DoxyCodeLine{410         \textcolor{keyword}{const} eT w = B\_mem[3];}
\DoxyCodeLine{411         }
\DoxyCodeLine{412         out\_mem[0] = A\_mem[ 0]*x + A\_mem[ 4]*y + A\_mem[ 8]*z + A\_mem[12]*w + A\_mem[16];}
\DoxyCodeLine{413         out\_mem[1] = A\_mem[ 1]*x + A\_mem[ 5]*y + A\_mem[ 9]*z + A\_mem[13]*w + A\_mem[17];}
\DoxyCodeLine{414         out\_mem[2] = A\_mem[ 2]*x + A\_mem[ 6]*y + A\_mem[10]*z + A\_mem[14]*w + A\_mem[18];}
\DoxyCodeLine{415         out\_mem[3] = A\_mem[ 3]*x + A\_mem[ 7]*y + A\_mem[11]*z + A\_mem[15]*w + A\_mem[19];}
\DoxyCodeLine{416         \}}
\DoxyCodeLine{417       \}}
\DoxyCodeLine{418       \textcolor{keywordflow}{break};}
\DoxyCodeLine{419     }
\DoxyCodeLine{420     \textcolor{keywordflow}{default}:}
\DoxyCodeLine{421       \{}
\DoxyCodeLine{422       \textcolor{keyword}{const} uword A\_n\_cols = \mbox{\hyperlink{structA}{A}}.n\_cols;}
\DoxyCodeLine{423       }
\DoxyCodeLine{424       \textcolor{keywordflow}{if}(B\_n\_cols == 1)}
\DoxyCodeLine{425         \{}
\DoxyCodeLine{426         \mbox{\hyperlink{classCol}{Col<eT>}} tmp(A\_n\_cols, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{427         eT*     tmp\_mem = tmp.memptr();}
\DoxyCodeLine{428         }
\DoxyCodeLine{429         arrayops::copy(tmp\_mem, \mbox{\hyperlink{structB}{B}}.memptr(), A\_n\_cols-\/1);}
\DoxyCodeLine{430         }
\DoxyCodeLine{431         tmp\_mem[A\_n\_cols-\/1] = eT(1);}
\DoxyCodeLine{432         }
\DoxyCodeLine{433         out = \mbox{\hyperlink{structA}{A}} * tmp;}
\DoxyCodeLine{434         \}}
\DoxyCodeLine{435       \textcolor{keywordflow}{else}}
\DoxyCodeLine{436         \{}
\DoxyCodeLine{437         \mbox{\hyperlink{classMat}{Mat<eT>}} tmp(A\_n\_cols, B\_n\_cols, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{438         }
\DoxyCodeLine{439         \textcolor{keywordflow}{for}(uword col=0; col < B\_n\_cols; ++col)}
\DoxyCodeLine{440           \{}
\DoxyCodeLine{441           \textcolor{keyword}{const} eT*   B\_mem =   \mbox{\hyperlink{structB}{B}}.colptr(col);}
\DoxyCodeLine{442                 eT* tmp\_mem = tmp.colptr(col);}
\DoxyCodeLine{443           }
\DoxyCodeLine{444           arrayops::copy(tmp\_mem, B\_mem, A\_n\_cols-\/1);}
\DoxyCodeLine{445           }
\DoxyCodeLine{446           tmp\_mem[A\_n\_cols-\/1] = eT(1);}
\DoxyCodeLine{447           \}}
\DoxyCodeLine{448         }
\DoxyCodeLine{449         out = \mbox{\hyperlink{structA}{A}} * tmp;}
\DoxyCodeLine{450         \}}
\DoxyCodeLine{451       \}}
\DoxyCodeLine{452     \}}
\DoxyCodeLine{453   \}}
\DoxyCodeLine{454 }
\DoxyCodeLine{455 }
\DoxyCodeLine{456 }
\DoxyCodeLine{457 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{458 \textcolor{keyword}{inline}}
\DoxyCodeLine{459 \textcolor{keywordtype}{void}}
\DoxyCodeLine{460 glue\_affmul::apply\_noalias\_generic(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} T1\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} T2\& \mbox{\hyperlink{structB}{B}})}
\DoxyCodeLine{461   \{}
\DoxyCodeLine{462   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{463   }
\DoxyCodeLine{464   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{465   }
\DoxyCodeLine{466   \textcolor{comment}{// assuming that A.n\_cols = B.n\_rows+1}}
\DoxyCodeLine{467   }
\DoxyCodeLine{468   \textcolor{keyword}{const} uword B\_n\_rows = \mbox{\hyperlink{structB}{B}}.n\_rows;}
\DoxyCodeLine{469   \textcolor{keyword}{const} uword B\_n\_cols = \mbox{\hyperlink{structB}{B}}.n\_cols;}
\DoxyCodeLine{470   }
\DoxyCodeLine{471   \mbox{\hyperlink{classMat}{Mat<eT>}} tmp(B\_n\_rows+1, B\_n\_cols, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{472   }
\DoxyCodeLine{473   \textcolor{keywordflow}{for}(uword col=0; col < B\_n\_cols; ++col)}
\DoxyCodeLine{474     \{}
\DoxyCodeLine{475     \textcolor{keyword}{const} eT*   B\_mem =   \mbox{\hyperlink{structB}{B}}.colptr(col);}
\DoxyCodeLine{476           eT* tmp\_mem = tmp.colptr(col);}
\DoxyCodeLine{477     }
\DoxyCodeLine{478     arrayops::copy(tmp\_mem, B\_mem, B\_n\_rows);}
\DoxyCodeLine{479     }
\DoxyCodeLine{480     tmp\_mem[B\_n\_rows] = eT(1);}
\DoxyCodeLine{481     \}}
\DoxyCodeLine{482   }
\DoxyCodeLine{483   out = \mbox{\hyperlink{structA}{A}} * tmp;}
\DoxyCodeLine{484   \}}
\DoxyCodeLine{485 }
\DoxyCodeLine{486 }
\DoxyCodeLine{487 }

\end{DoxyCode}
