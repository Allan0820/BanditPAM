\hypertarget{op__any__meat_8hpp_source}{}\doxysection{op\+\_\+any\+\_\+meat.\+hpp}
\label{op__any__meat_8hpp_source}\index{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/op\_any\_meat.hpp@{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/op\_any\_meat.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008-\/2016 Conrad Sanderson (http://conradsanderson.id.au)}}
\DoxyCodeLine{2 \textcolor{comment}{// Copyright 2008-\/2016 National ICT Australia (NICTA)}}
\DoxyCodeLine{3 \textcolor{comment}{// }}
\DoxyCodeLine{4 \textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{5 \textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{6 \textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{7 \textcolor{comment}{// http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{8 \textcolor{comment}{// }}
\DoxyCodeLine{9 \textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{10 \textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{11 \textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{12 \textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{13 \textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{14 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{17 }
\DoxyCodeLine{20 }
\DoxyCodeLine{21 }
\DoxyCodeLine{22 }
\DoxyCodeLine{23 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{24 \textcolor{keyword}{inline}}
\DoxyCodeLine{25 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{26 op\_any::any\_vec\_helper(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::elem\_type, T1>}}\& X)}
\DoxyCodeLine{27   \{}
\DoxyCodeLine{28   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{29   }
\DoxyCodeLine{30   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{31   }
\DoxyCodeLine{32   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} P(X.get\_ref());}
\DoxyCodeLine{33   }
\DoxyCodeLine{34   \textcolor{keyword}{const} uword n\_elem = P.get\_n\_elem();}
\DoxyCodeLine{35   }
\DoxyCodeLine{36   \textcolor{keywordflow}{if}(\mbox{\hyperlink{classProxy}{Proxy<T1>::use\_at}} == \textcolor{keyword}{false})}
\DoxyCodeLine{37     \{}
\DoxyCodeLine{38     \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::ea\_type}} Pea = P.get\_ea();}
\DoxyCodeLine{39     }
\DoxyCodeLine{40     \textcolor{keywordflow}{for}(uword i=0; i<n\_elem; ++i)}
\DoxyCodeLine{41       \{}
\DoxyCodeLine{42       \textcolor{keywordflow}{if}(Pea[i] != eT(0))  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{43       \}}
\DoxyCodeLine{44     \}}
\DoxyCodeLine{45   \textcolor{keywordflow}{else}}
\DoxyCodeLine{46     \{}
\DoxyCodeLine{47     \textcolor{keyword}{const} uword n\_rows = P.get\_n\_rows();}
\DoxyCodeLine{48     \textcolor{keyword}{const} uword n\_cols = P.get\_n\_cols();}
\DoxyCodeLine{49     }
\DoxyCodeLine{50     \textcolor{keywordflow}{for}(uword col=0; col < n\_cols; ++col)}
\DoxyCodeLine{51     \textcolor{keywordflow}{for}(uword row=0; row < n\_rows; ++row)}
\DoxyCodeLine{52       \{}
\DoxyCodeLine{53       \textcolor{keywordflow}{if}(P.at(row,col) != eT(0))  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{54       \}}
\DoxyCodeLine{55     \}}
\DoxyCodeLine{56   }
\DoxyCodeLine{57   \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{58   \}}
\DoxyCodeLine{59 }
\DoxyCodeLine{60 }
\DoxyCodeLine{61 }
\DoxyCodeLine{62 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{63 \textcolor{keyword}{inline}}
\DoxyCodeLine{64 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{65 op\_any::any\_vec\_helper(\textcolor{keyword}{const} \mbox{\hyperlink{classsubview}{subview<eT>}}\& X)}
\DoxyCodeLine{66   \{}
\DoxyCodeLine{67   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{68   }
\DoxyCodeLine{69   \textcolor{keyword}{const} uword X\_n\_rows = X.n\_rows;}
\DoxyCodeLine{70   \textcolor{keyword}{const} uword X\_n\_cols = X.n\_cols;}
\DoxyCodeLine{71   }
\DoxyCodeLine{72   \textcolor{keywordflow}{if}(X\_n\_rows == 1)}
\DoxyCodeLine{73     \{}
\DoxyCodeLine{74     \textcolor{keywordflow}{for}(uword col=0; col < X\_n\_cols; ++col)}
\DoxyCodeLine{75       \{}
\DoxyCodeLine{76       \textcolor{keywordflow}{if}(X.at(0,col) != eT(0))  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{77       \}}
\DoxyCodeLine{78     \}}
\DoxyCodeLine{79   \textcolor{keywordflow}{else}}
\DoxyCodeLine{80     \{}
\DoxyCodeLine{81     \textcolor{keywordflow}{for}(uword col=0; col < X\_n\_cols; ++col)}
\DoxyCodeLine{82       \{}
\DoxyCodeLine{83       \textcolor{keyword}{const} eT* X\_colmem = X.colptr(col);}
\DoxyCodeLine{84       }
\DoxyCodeLine{85       \textcolor{keywordflow}{for}(uword row=0; row < X\_n\_rows; ++row)}
\DoxyCodeLine{86         \{}
\DoxyCodeLine{87         \textcolor{keywordflow}{if}(X\_colmem[row] != eT(0))  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{88         \}}
\DoxyCodeLine{89       \}}
\DoxyCodeLine{90     \}}
\DoxyCodeLine{91   }
\DoxyCodeLine{92   \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{93   \}}
\DoxyCodeLine{94 }
\DoxyCodeLine{95 }
\DoxyCodeLine{96 }
\DoxyCodeLine{97 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{98 \textcolor{keyword}{inline}}
\DoxyCodeLine{99 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{100 op\_any::any\_vec\_helper(\textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T1, op\_vectorise\_col>}}\& X)}
\DoxyCodeLine{101   \{}
\DoxyCodeLine{102   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{103   }
\DoxyCodeLine{104   \textcolor{keywordflow}{return} op\_any::any\_vec\_helper(X.m);}
\DoxyCodeLine{105   \}}
\DoxyCodeLine{106 }
\DoxyCodeLine{107 }
\DoxyCodeLine{108 }
\DoxyCodeLine{109 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} op\_type>}
\DoxyCodeLine{110 \textcolor{keyword}{inline}}
\DoxyCodeLine{111 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{112 op\_any::any\_vec\_helper}
\DoxyCodeLine{113   (}
\DoxyCodeLine{114   \textcolor{keyword}{const} \mbox{\hyperlink{classmtOp}{mtOp<uword, T1, op\_type>}}\& X,}
\DoxyCodeLine{115   \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__op__rel__only}{arma\_op\_rel\_only<op\_type>::result}}*           junk1,}
\DoxyCodeLine{116   \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<typename T1::elem\_type>::result* junk2}
\DoxyCodeLine{117   )}
\DoxyCodeLine{118   \{}
\DoxyCodeLine{119   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{120   arma\_ignore(junk1);}
\DoxyCodeLine{121   arma\_ignore(junk2);}
\DoxyCodeLine{122   }
\DoxyCodeLine{123   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{124   }
\DoxyCodeLine{125   \textcolor{keyword}{const} eT val = X.aux;}
\DoxyCodeLine{126   }
\DoxyCodeLine{127   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} P(X.m);}
\DoxyCodeLine{128   }
\DoxyCodeLine{129   }
\DoxyCodeLine{130   \textcolor{keywordflow}{if}(\mbox{\hyperlink{classProxy}{Proxy<T1>::use\_at}} == \textcolor{keyword}{false})}
\DoxyCodeLine{131     \{}
\DoxyCodeLine{132     \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::ea\_type}} Pea = P.get\_ea();}
\DoxyCodeLine{133     }
\DoxyCodeLine{134     \textcolor{keyword}{const} uword n\_elem = P.get\_n\_elem();}
\DoxyCodeLine{135   }
\DoxyCodeLine{136     \textcolor{keywordflow}{for}(uword i=0; i < n\_elem; ++i)}
\DoxyCodeLine{137       \{}
\DoxyCodeLine{138       \textcolor{keyword}{const} eT tmp = Pea[i];}
\DoxyCodeLine{139       }
\DoxyCodeLine{140            \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_lt\_pre   >::yes}})  \{ \textcolor{keywordflow}{if}(val <  tmp) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{141       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_lt\_post  >::yes}})  \{ \textcolor{keywordflow}{if}(tmp <  val) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{142       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_gt\_pre   >::yes}})  \{ \textcolor{keywordflow}{if}(val >  tmp) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{143       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_gt\_post  >::yes}})  \{ \textcolor{keywordflow}{if}(tmp >  val) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{144       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_lteq\_pre >::yes}})  \{ \textcolor{keywordflow}{if}(val <= tmp) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{145       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_lteq\_post>::yes}})  \{ \textcolor{keywordflow}{if}(tmp <= val) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{146       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_gteq\_pre >::yes}})  \{ \textcolor{keywordflow}{if}(val >= tmp) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{147       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_gteq\_post>::yes}})  \{ \textcolor{keywordflow}{if}(tmp >= val) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{148       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_eq       >::yes}})  \{ \textcolor{keywordflow}{if}(tmp == val) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{149       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_noteq    >::yes}})  \{ \textcolor{keywordflow}{if}(tmp != val) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{150       \}}
\DoxyCodeLine{151     \}}
\DoxyCodeLine{152   \textcolor{keywordflow}{else}}
\DoxyCodeLine{153     \{}
\DoxyCodeLine{154     \textcolor{keyword}{const} uword n\_rows = P.get\_n\_rows();}
\DoxyCodeLine{155     \textcolor{keyword}{const} uword n\_cols = P.get\_n\_cols();}
\DoxyCodeLine{156     }
\DoxyCodeLine{157     \textcolor{keywordflow}{for}(uword col=0; col < n\_cols; ++col)}
\DoxyCodeLine{158     \textcolor{keywordflow}{for}(uword row=0; row < n\_rows; ++row)}
\DoxyCodeLine{159       \{}
\DoxyCodeLine{160       \textcolor{keyword}{const} eT tmp = P.at(row,col);}
\DoxyCodeLine{161       }
\DoxyCodeLine{162            \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_lt\_pre   >::yes}})  \{ \textcolor{keywordflow}{if}(val <  tmp) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{163       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_lt\_post  >::yes}})  \{ \textcolor{keywordflow}{if}(tmp <  val) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{164       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_gt\_pre   >::yes}})  \{ \textcolor{keywordflow}{if}(val >  tmp) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{165       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_gt\_post  >::yes}})  \{ \textcolor{keywordflow}{if}(tmp >  val) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{166       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_lteq\_pre >::yes}})  \{ \textcolor{keywordflow}{if}(val <= tmp) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{167       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_lteq\_post>::yes}})  \{ \textcolor{keywordflow}{if}(tmp <= val) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{168       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_gteq\_pre >::yes}})  \{ \textcolor{keywordflow}{if}(val >= tmp) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{169       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_gteq\_post>::yes}})  \{ \textcolor{keywordflow}{if}(tmp >= val) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{170       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_eq       >::yes}})  \{ \textcolor{keywordflow}{if}(tmp == val) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{171       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<op\_type, op\_rel\_noteq    >::yes}})  \{ \textcolor{keywordflow}{if}(tmp != val) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{172       \}}
\DoxyCodeLine{173     \}}
\DoxyCodeLine{174   }
\DoxyCodeLine{175   \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{176   \}}
\DoxyCodeLine{177 }
\DoxyCodeLine{178 }
\DoxyCodeLine{179 }
\DoxyCodeLine{180 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2, \textcolor{keyword}{typename} glue\_type>}
\DoxyCodeLine{181 \textcolor{keyword}{inline}}
\DoxyCodeLine{182 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{183 op\_any::any\_vec\_helper}
\DoxyCodeLine{184   (}
\DoxyCodeLine{185   \textcolor{keyword}{const} \mbox{\hyperlink{classmtGlue}{mtGlue<uword, T1, T2, glue\_type>}}\& X,}
\DoxyCodeLine{186   \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__glue__rel__only}{arma\_glue\_rel\_only<glue\_type>::result}}*       junk1,}
\DoxyCodeLine{187   \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<typename T1::elem\_type>::result* junk2,}
\DoxyCodeLine{188   \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<typename T2::elem\_type>::result* junk3}
\DoxyCodeLine{189   )}
\DoxyCodeLine{190   \{}
\DoxyCodeLine{191   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{192   arma\_ignore(junk1);}
\DoxyCodeLine{193   arma\_ignore(junk2);}
\DoxyCodeLine{194   arma\_ignore(junk3);}
\DoxyCodeLine{195   }
\DoxyCodeLine{196   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT1;}
\DoxyCodeLine{197   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T2::elem\_type eT2;}
\DoxyCodeLine{198   }
\DoxyCodeLine{199   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::ea\_type}} ea\_type1;}
\DoxyCodeLine{200   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T2>::ea\_type}} ea\_type2;}
\DoxyCodeLine{201   }
\DoxyCodeLine{202   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} \mbox{\hyperlink{structA}{A}}(X.A);}
\DoxyCodeLine{203   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T2>}} \mbox{\hyperlink{structB}{B}}(X.B);}
\DoxyCodeLine{204   }
\DoxyCodeLine{205   arma\_debug\_assert\_same\_size(\mbox{\hyperlink{structA}{A}}, \mbox{\hyperlink{structB}{B}}, \textcolor{stringliteral}{"{}relational operator"{}});}
\DoxyCodeLine{206   }
\DoxyCodeLine{207   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_at = (\mbox{\hyperlink{classProxy}{Proxy<T1>::use\_at}} || \mbox{\hyperlink{classProxy}{Proxy<T2>::use\_at}});}
\DoxyCodeLine{208   }
\DoxyCodeLine{209   \textcolor{keywordflow}{if}(use\_at == \textcolor{keyword}{false})}
\DoxyCodeLine{210     \{}
\DoxyCodeLine{211     ea\_type1 PA = \mbox{\hyperlink{structA}{A}}.get\_ea();}
\DoxyCodeLine{212     ea\_type2 PB = \mbox{\hyperlink{structB}{B}}.get\_ea();}
\DoxyCodeLine{213     }
\DoxyCodeLine{214     \textcolor{keyword}{const} uword n\_elem = \mbox{\hyperlink{structA}{A}}.get\_n\_elem();}
\DoxyCodeLine{215     }
\DoxyCodeLine{216     \textcolor{keywordflow}{for}(uword i=0; i<n\_elem; ++i)}
\DoxyCodeLine{217       \{}
\DoxyCodeLine{218       \textcolor{keyword}{const} eT1 tmp1 = PA[i];}
\DoxyCodeLine{219       \textcolor{keyword}{const} eT2 tmp2 = PB[i];}
\DoxyCodeLine{220       }
\DoxyCodeLine{221            \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_lt    >::yes}})  \{ \textcolor{keywordflow}{if}(tmp1 <  tmp2) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{222       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_gt    >::yes}})  \{ \textcolor{keywordflow}{if}(tmp1 >  tmp2) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{223       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_lteq  >::yes}})  \{ \textcolor{keywordflow}{if}(tmp1 <= tmp2) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{224       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_gteq  >::yes}})  \{ \textcolor{keywordflow}{if}(tmp1 >= tmp2) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{225       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_eq    >::yes}})  \{ \textcolor{keywordflow}{if}(tmp1 == tmp2) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{226       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_noteq >::yes}})  \{ \textcolor{keywordflow}{if}(tmp1 != tmp2) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{227       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_and   >::yes}})  \{ \textcolor{keywordflow}{if}(tmp1 \&\& tmp2) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{228       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_or    >::yes}})  \{ \textcolor{keywordflow}{if}(tmp1 || tmp2) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{229       \}}
\DoxyCodeLine{230     \}}
\DoxyCodeLine{231   \textcolor{keywordflow}{else}}
\DoxyCodeLine{232     \{}
\DoxyCodeLine{233     \textcolor{keyword}{const} uword n\_rows = \mbox{\hyperlink{structA}{A}}.get\_n\_rows();}
\DoxyCodeLine{234     \textcolor{keyword}{const} uword n\_cols = \mbox{\hyperlink{structA}{A}}.get\_n\_cols();}
\DoxyCodeLine{235     }
\DoxyCodeLine{236     \textcolor{keywordflow}{for}(uword col=0; col < n\_cols; ++col)}
\DoxyCodeLine{237     \textcolor{keywordflow}{for}(uword row=0; row < n\_rows; ++row)}
\DoxyCodeLine{238       \{}
\DoxyCodeLine{239       \textcolor{keyword}{const} eT1 tmp1 = \mbox{\hyperlink{structA}{A}}.at(row,col);}
\DoxyCodeLine{240       \textcolor{keyword}{const} eT2 tmp2 = \mbox{\hyperlink{structB}{B}}.at(row,col);}
\DoxyCodeLine{241       }
\DoxyCodeLine{242            \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_lt    >::yes}})  \{ \textcolor{keywordflow}{if}(tmp1 <  tmp2) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{243       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_gt    >::yes}})  \{ \textcolor{keywordflow}{if}(tmp1 >  tmp2) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{244       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_lteq  >::yes}})  \{ \textcolor{keywordflow}{if}(tmp1 <= tmp2) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{245       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_gteq  >::yes}})  \{ \textcolor{keywordflow}{if}(tmp1 >= tmp2) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{246       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_eq    >::yes}})  \{ \textcolor{keywordflow}{if}(tmp1 == tmp2) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{247       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_noteq >::yes}})  \{ \textcolor{keywordflow}{if}(tmp1 != tmp2) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{248       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_and   >::yes}})  \{ \textcolor{keywordflow}{if}(tmp1 \&\& tmp2) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{249       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__same__type}{is\_same\_type<glue\_type, glue\_rel\_or    >::yes}})  \{ \textcolor{keywordflow}{if}(tmp1 || tmp2) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} \}}
\DoxyCodeLine{250       \}}
\DoxyCodeLine{251     \}}
\DoxyCodeLine{252   }
\DoxyCodeLine{253   \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{254   \}}
\DoxyCodeLine{255 }
\DoxyCodeLine{256 }
\DoxyCodeLine{257 }
\DoxyCodeLine{258 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{259 \textcolor{keyword}{inline}}
\DoxyCodeLine{260 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{261 op\_any::any\_vec(T1\& X)}
\DoxyCodeLine{262   \{}
\DoxyCodeLine{263   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{264   }
\DoxyCodeLine{265   \textcolor{keywordflow}{return} op\_any::any\_vec\_helper(X);}
\DoxyCodeLine{266   \}}
\DoxyCodeLine{267 }
\DoxyCodeLine{268 }
\DoxyCodeLine{269 }
\DoxyCodeLine{270 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{271 \textcolor{keyword}{inline}}
\DoxyCodeLine{272 \textcolor{keywordtype}{void}}
\DoxyCodeLine{273 op\_any::apply\_helper(\mbox{\hyperlink{classMat}{Mat<uword>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}}\& P, \textcolor{keyword}{const} uword dim)}
\DoxyCodeLine{274   \{}
\DoxyCodeLine{275   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{276   }
\DoxyCodeLine{277   \textcolor{keyword}{const} uword n\_rows = P.get\_n\_rows();}
\DoxyCodeLine{278   \textcolor{keyword}{const} uword n\_cols = P.get\_n\_cols();}
\DoxyCodeLine{279   }
\DoxyCodeLine{280   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::elem\_type}} eT;}
\DoxyCodeLine{281   }
\DoxyCodeLine{282   \textcolor{keywordflow}{if}(dim == 0)  \textcolor{comment}{// traverse rows (ie. process each column)}}
\DoxyCodeLine{283     \{}
\DoxyCodeLine{284     out.zeros(1, n\_cols);}
\DoxyCodeLine{285     }
\DoxyCodeLine{286     uword* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{287     }
\DoxyCodeLine{288     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__Mat}{is\_Mat}}<\textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::stored\_type}}>::value)}
\DoxyCodeLine{289       \{}
\DoxyCodeLine{290       \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap}{unwrap<typename Proxy<T1>::stored\_type}}> U(P.Q);}
\DoxyCodeLine{291       }
\DoxyCodeLine{292       \textcolor{keywordflow}{for}(uword col=0; col < n\_cols; ++col)}
\DoxyCodeLine{293         \{}
\DoxyCodeLine{294         \textcolor{keyword}{const} eT* colmem = U.M.colptr(col);}
\DoxyCodeLine{295         }
\DoxyCodeLine{296         \textcolor{keywordflow}{for}(uword row=0; row < n\_rows; ++row)}
\DoxyCodeLine{297           \{}
\DoxyCodeLine{298           \textcolor{keywordflow}{if}(colmem[row] != eT(0))  \{ out\_mem[col] = uword(1); \textcolor{keywordflow}{break}; \}}
\DoxyCodeLine{299           \}}
\DoxyCodeLine{300         \}}
\DoxyCodeLine{301       \}}
\DoxyCodeLine{302     \textcolor{keywordflow}{else}}
\DoxyCodeLine{303       \{}
\DoxyCodeLine{304       \textcolor{keywordflow}{for}(uword col=0; col < n\_cols; ++col)}
\DoxyCodeLine{305         \{}
\DoxyCodeLine{306         \textcolor{keywordflow}{for}(uword row=0; row < n\_rows; ++row)}
\DoxyCodeLine{307           \{}
\DoxyCodeLine{308           \textcolor{keywordflow}{if}(P.at(row,col) != eT(0))  \{ out\_mem[col] = uword(1); \textcolor{keywordflow}{break}; \}}
\DoxyCodeLine{309           \}}
\DoxyCodeLine{310         \}}
\DoxyCodeLine{311       \}}
\DoxyCodeLine{312     \}}
\DoxyCodeLine{313   \textcolor{keywordflow}{else}}
\DoxyCodeLine{314     \{}
\DoxyCodeLine{315     out.zeros(n\_rows, 1);}
\DoxyCodeLine{316     }
\DoxyCodeLine{317     uword* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{318     }
\DoxyCodeLine{319     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__Mat}{is\_Mat}}<\textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::stored\_type}}>::value)}
\DoxyCodeLine{320       \{}
\DoxyCodeLine{321       \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap}{unwrap<typename Proxy<T1>::stored\_type}}> U(P.Q);}
\DoxyCodeLine{322       }
\DoxyCodeLine{323       \textcolor{keywordflow}{for}(uword col=0; col < n\_cols; ++col)}
\DoxyCodeLine{324         \{}
\DoxyCodeLine{325         \textcolor{keyword}{const} eT* colmem = U.M.colptr(col);}
\DoxyCodeLine{326         }
\DoxyCodeLine{327         \textcolor{keywordflow}{for}(uword row=0; row < n\_rows; ++row)}
\DoxyCodeLine{328           \{}
\DoxyCodeLine{329           \textcolor{keywordflow}{if}(colmem[row] != eT(0))  \{ out\_mem[row] = uword(1); \}}
\DoxyCodeLine{330           \}}
\DoxyCodeLine{331         \}}
\DoxyCodeLine{332       \}}
\DoxyCodeLine{333     \textcolor{keywordflow}{else}}
\DoxyCodeLine{334       \{}
\DoxyCodeLine{335       \textcolor{keywordflow}{for}(uword col=0; col < n\_cols; ++col)}
\DoxyCodeLine{336         \{}
\DoxyCodeLine{337         \textcolor{keywordflow}{for}(uword row=0; row < n\_rows; ++row)}
\DoxyCodeLine{338           \{}
\DoxyCodeLine{339           \textcolor{keywordflow}{if}(P.at(row,col) != eT(0))  \{ out\_mem[row] = uword(1); \}}
\DoxyCodeLine{340           \}}
\DoxyCodeLine{341         \}}
\DoxyCodeLine{342       \}}
\DoxyCodeLine{343     \}}
\DoxyCodeLine{344   \}}
\DoxyCodeLine{345 }
\DoxyCodeLine{346 }
\DoxyCodeLine{347 }
\DoxyCodeLine{348 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{349 \textcolor{keyword}{inline}}
\DoxyCodeLine{350 \textcolor{keywordtype}{void}}
\DoxyCodeLine{351 op\_any::apply(\mbox{\hyperlink{classMat}{Mat<uword>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classmtOp}{mtOp<uword, T1, op\_any>}}\& X)}
\DoxyCodeLine{352   \{}
\DoxyCodeLine{353   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{354   }
\DoxyCodeLine{355   \textcolor{keyword}{const} uword dim = X.aux\_uword\_a;}
\DoxyCodeLine{356   }
\DoxyCodeLine{357   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} P(X.m);}
\DoxyCodeLine{358   }
\DoxyCodeLine{359   \textcolor{keywordflow}{if}(P.is\_alias(out) == \textcolor{keyword}{false})}
\DoxyCodeLine{360     \{}
\DoxyCodeLine{361     op\_any::apply\_helper(out, P, dim);}
\DoxyCodeLine{362     \}}
\DoxyCodeLine{363   \textcolor{keywordflow}{else}}
\DoxyCodeLine{364     \{}
\DoxyCodeLine{365     \mbox{\hyperlink{classMat}{Mat<uword>}} out2;}
\DoxyCodeLine{366     }
\DoxyCodeLine{367     op\_any::apply\_helper(out2, P, dim);}
\DoxyCodeLine{368     }
\DoxyCodeLine{369     out.\mbox{\hyperlink{group__Mat_gaff06a75771f96605f7cc4f8c6b3fceb7}{steal\_mem}}(out2);}
\DoxyCodeLine{370     \}}
\DoxyCodeLine{371   \}}
\DoxyCodeLine{372 }
\DoxyCodeLine{373 }
\DoxyCodeLine{374 }

\end{DoxyCode}
