\hypertarget{memory_8hpp_source}{}\doxysection{memory.\+hpp}
\label{memory_8hpp_source}\index{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/memory.hpp@{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/memory.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008-\/2016 Conrad Sanderson (http://conradsanderson.id.au)}}
\DoxyCodeLine{2 \textcolor{comment}{// Copyright 2008-\/2016 National ICT Australia (NICTA)}}
\DoxyCodeLine{3 \textcolor{comment}{// }}
\DoxyCodeLine{4 \textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{5 \textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{6 \textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{7 \textcolor{comment}{// http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{8 \textcolor{comment}{// }}
\DoxyCodeLine{9 \textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{10 \textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{11 \textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{12 \textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{13 \textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{14 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{19 }
\DoxyCodeLine{20 }
\DoxyCodeLine{21 \textcolor{keyword}{class }\mbox{\hyperlink{classmemory}{memory}}}
\DoxyCodeLine{22   \{}
\DoxyCodeLine{23   \textcolor{keyword}{public}:}
\DoxyCodeLine{24   }
\DoxyCodeLine{25   \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT> \textcolor{keyword}{inline} arma\_malloc \textcolor{keyword}{static} eT* acquire(\textcolor{keyword}{const} uword n\_elem);}
\DoxyCodeLine{26   }
\DoxyCodeLine{27   \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT> arma\_inline \textcolor{keyword}{static} \textcolor{keywordtype}{void} release(eT* mem);}
\DoxyCodeLine{28   }
\DoxyCodeLine{29   \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT> arma\_inline \textcolor{keyword}{static} \textcolor{keywordtype}{bool}      is\_aligned(\textcolor{keyword}{const} eT*  mem);}
\DoxyCodeLine{30   \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT> arma\_inline \textcolor{keyword}{static} \textcolor{keywordtype}{void} mark\_as\_aligned(      eT*\& mem);}
\DoxyCodeLine{31   \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT> arma\_inline \textcolor{keyword}{static} \textcolor{keywordtype}{void} mark\_as\_aligned(\textcolor{keyword}{const} eT*\& mem);}
\DoxyCodeLine{32   \};}
\DoxyCodeLine{33 }
\DoxyCodeLine{34 }
\DoxyCodeLine{35 }
\DoxyCodeLine{36 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{37 \textcolor{keyword}{inline}}
\DoxyCodeLine{38 arma\_malloc}
\DoxyCodeLine{39 eT*}
\DoxyCodeLine{40 memory::acquire(\textcolor{keyword}{const} uword n\_elem)}
\DoxyCodeLine{41   \{}
\DoxyCodeLine{42   \textcolor{keywordflow}{if}(n\_elem == 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr}; \}}
\DoxyCodeLine{43   }
\DoxyCodeLine{44   arma\_debug\_check}
\DoxyCodeLine{45     (}
\DoxyCodeLine{46     ( \textcolor{keywordtype}{size\_t}(n\_elem) > (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::numeric\_limits<size\_t>::max}}() / \textcolor{keyword}{sizeof}(eT)) ),}
\DoxyCodeLine{47     \textcolor{stringliteral}{"{}arma::memory::acquire(): requested size is too large"{}}}
\DoxyCodeLine{48     );}
\DoxyCodeLine{49   }
\DoxyCodeLine{50   eT* out\_memptr;}
\DoxyCodeLine{51   }
\DoxyCodeLine{52 \textcolor{preprocessor}{  \#if   defined(ARMA\_USE\_TBB\_ALLOC)}}
\DoxyCodeLine{53     \{}
\DoxyCodeLine{54     out\_memptr = (eT *) scalable\_malloc(\textcolor{keyword}{sizeof}(eT)*n\_elem);}
\DoxyCodeLine{55     \}}
\DoxyCodeLine{56 \textcolor{preprocessor}{  \#elif defined(ARMA\_USE\_MKL\_ALLOC)}}
\DoxyCodeLine{57     \{}
\DoxyCodeLine{58     out\_memptr = (eT *) mkl\_malloc( \textcolor{keyword}{sizeof}(eT)*n\_elem, 32 );}
\DoxyCodeLine{59     \}}
\DoxyCodeLine{60 \textcolor{preprocessor}{  \#elif defined(ARMA\_USE\_NUMPY\_ALLOC)}}
\DoxyCodeLine{61     \{}
\DoxyCodeLine{62     out\_memptr = (eT *) npy\_malloc(\textcolor{keyword}{sizeof}(eT) * n\_elem);}
\DoxyCodeLine{63     \}}
\DoxyCodeLine{64 \textcolor{preprocessor}{  \#elif defined(ARMA\_HAVE\_POSIX\_MEMALIGN)}}
\DoxyCodeLine{65     \{}
\DoxyCodeLine{66     eT* memptr = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{67     }
\DoxyCodeLine{68     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} n\_bytes   = \textcolor{keyword}{sizeof}(eT)*\textcolor{keywordtype}{size\_t}(n\_elem);}
\DoxyCodeLine{69     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} alignment = (n\_bytes >= size\_t(1024)) ? \textcolor{keywordtype}{size\_t}(32) : size\_t(16);}
\DoxyCodeLine{70     }
\DoxyCodeLine{71     \textcolor{comment}{// TODO: investigate apparent memory leak when using alignment >= 64 (as shown on Fedora 28, glibc 2.27)}}
\DoxyCodeLine{72     \textcolor{keywordtype}{int} status = posix\_memalign((\textcolor{keywordtype}{void} **)\&memptr, ( (alignment >= \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{void}*)) ? alignment : \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{void}*) ), n\_bytes);}
\DoxyCodeLine{73     }
\DoxyCodeLine{74     out\_memptr = (status == 0) ? memptr : \textcolor{keyword}{nullptr};}
\DoxyCodeLine{75     \}}
\DoxyCodeLine{76 \textcolor{preprocessor}{  \#elif defined(\_MSC\_VER)}}
\DoxyCodeLine{77     \{}
\DoxyCodeLine{78     \textcolor{comment}{//out\_memptr = (eT *) malloc(sizeof(eT)*n\_elem);}}
\DoxyCodeLine{79     \textcolor{comment}{//out\_memptr = (eT *) \_aligned\_malloc( sizeof(eT)*n\_elem, 16 );  // lives in malloc.h}}
\DoxyCodeLine{80     }
\DoxyCodeLine{81     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} n\_bytes   = \textcolor{keyword}{sizeof}(eT)*\textcolor{keywordtype}{size\_t}(n\_elem);}
\DoxyCodeLine{82     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} alignment = (n\_bytes >= size\_t(1024)) ? \textcolor{keywordtype}{size\_t}(32) : size\_t(16);}
\DoxyCodeLine{83     }
\DoxyCodeLine{84     out\_memptr = (eT *) \_aligned\_malloc( n\_bytes, alignment );}
\DoxyCodeLine{85     \}}
\DoxyCodeLine{86 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{87     \{}
\DoxyCodeLine{88     \textcolor{comment}{//return ( new(std::nothrow) eT[n\_elem] );}}
\DoxyCodeLine{89     out\_memptr = (eT *) malloc(\textcolor{keyword}{sizeof}(eT)*n\_elem);}
\DoxyCodeLine{90     \}}
\DoxyCodeLine{91 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{92   }
\DoxyCodeLine{93   \textcolor{comment}{// TODO: for mingw, use \_\_mingw\_aligned\_malloc}}
\DoxyCodeLine{94   }
\DoxyCodeLine{95   arma\_check\_bad\_alloc( (out\_memptr == \textcolor{keyword}{nullptr}), \textcolor{stringliteral}{"{}arma::memory::acquire(): out of memory"{}} );}
\DoxyCodeLine{96   }
\DoxyCodeLine{97   \textcolor{keywordflow}{return} out\_memptr;}
\DoxyCodeLine{98   \}}
\DoxyCodeLine{99 }
\DoxyCodeLine{100 }
\DoxyCodeLine{101 }
\DoxyCodeLine{102 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{103 arma\_inline}
\DoxyCodeLine{104 \textcolor{keywordtype}{void}}
\DoxyCodeLine{105 memory::release(eT* mem)}
\DoxyCodeLine{106   \{}
\DoxyCodeLine{107   \textcolor{keywordflow}{if}(mem == \textcolor{keyword}{nullptr})  \{ \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{108   }
\DoxyCodeLine{109 \textcolor{preprocessor}{  \#if   defined(ARMA\_USE\_TBB\_ALLOC)}}
\DoxyCodeLine{110     \{}
\DoxyCodeLine{111     scalable\_free( (\textcolor{keywordtype}{void} *)(mem) );}
\DoxyCodeLine{112     \}}
\DoxyCodeLine{113 \textcolor{preprocessor}{  \#elif defined(ARMA\_USE\_MKL\_ALLOC)}}
\DoxyCodeLine{114     \{}
\DoxyCodeLine{115     mkl\_free( (\textcolor{keywordtype}{void} *)(mem) );}
\DoxyCodeLine{116     \}}
\DoxyCodeLine{117 \textcolor{preprocessor}{  \#elif defined(ARMA\_USE\_NUMPY\_ALLOC)}}
\DoxyCodeLine{118     \{}
\DoxyCodeLine{119     npy\_free( (\textcolor{keywordtype}{void} *)(mem) );}
\DoxyCodeLine{120     \}}
\DoxyCodeLine{121 \textcolor{preprocessor}{  \#elif defined(ARMA\_HAVE\_POSIX\_MEMALIGN)}}
\DoxyCodeLine{122     \{}
\DoxyCodeLine{123     free( (\textcolor{keywordtype}{void} *)(mem) );}
\DoxyCodeLine{124     \}}
\DoxyCodeLine{125 \textcolor{preprocessor}{  \#elif defined(\_MSC\_VER)}}
\DoxyCodeLine{126     \{}
\DoxyCodeLine{127     \textcolor{comment}{//free( (void *)(mem) );}}
\DoxyCodeLine{128     \_aligned\_free( (\textcolor{keywordtype}{void} *)(mem) );}
\DoxyCodeLine{129     \}}
\DoxyCodeLine{130 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{131     \{}
\DoxyCodeLine{132     \textcolor{comment}{//delete [] mem;}}
\DoxyCodeLine{133     free( (\textcolor{keywordtype}{void} *)(mem) );}
\DoxyCodeLine{134     \}}
\DoxyCodeLine{135 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{136   }
\DoxyCodeLine{137   \textcolor{comment}{// TODO: for mingw, use \_\_mingw\_aligned\_free}}
\DoxyCodeLine{138   \}}
\DoxyCodeLine{139 }
\DoxyCodeLine{140 }
\DoxyCodeLine{141 }
\DoxyCodeLine{142 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{143 arma\_inline}
\DoxyCodeLine{144 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{145 memory::is\_aligned(\textcolor{keyword}{const} eT* mem)}
\DoxyCodeLine{146   \{}
\DoxyCodeLine{147 \textcolor{preprocessor}{  \#if (defined(ARMA\_HAVE\_ICC\_ASSUME\_ALIGNED) || defined(ARMA\_HAVE\_GCC\_ASSUME\_ALIGNED)) \&\& !defined(ARMA\_DONT\_CHECK\_ALIGNMENT)}}
\DoxyCodeLine{148     \{}
\DoxyCodeLine{149     \textcolor{keywordflow}{return} (\textcolor{keyword}{sizeof}(std::size\_t) >= \textcolor{keyword}{sizeof}(eT*)) ? ((std::size\_t(mem) \& 0x0F) == 0) : \textcolor{keyword}{false};}
\DoxyCodeLine{150     \}}
\DoxyCodeLine{151 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{152     \{}
\DoxyCodeLine{153     arma\_ignore(mem);}
\DoxyCodeLine{154     }
\DoxyCodeLine{155     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{156     \}}
\DoxyCodeLine{157 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{158   \}}
\DoxyCodeLine{159 }
\DoxyCodeLine{160 }
\DoxyCodeLine{161 }
\DoxyCodeLine{162 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{163 arma\_inline}
\DoxyCodeLine{164 \textcolor{keywordtype}{void}}
\DoxyCodeLine{165 memory::mark\_as\_aligned(eT*\& mem)}
\DoxyCodeLine{166   \{}
\DoxyCodeLine{167 \textcolor{preprocessor}{  \#if defined(ARMA\_HAVE\_ICC\_ASSUME\_ALIGNED)}}
\DoxyCodeLine{168     \{}
\DoxyCodeLine{169     \_\_assume\_aligned(mem, 16);}
\DoxyCodeLine{170     \}}
\DoxyCodeLine{171 \textcolor{preprocessor}{  \#elif defined(ARMA\_HAVE\_GCC\_ASSUME\_ALIGNED)}}
\DoxyCodeLine{172     \{}
\DoxyCodeLine{173     mem = (eT*)\_\_builtin\_assume\_aligned(mem, 16);}
\DoxyCodeLine{174     \}}
\DoxyCodeLine{175 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{176     \{}
\DoxyCodeLine{177     arma\_ignore(mem);}
\DoxyCodeLine{178     \}}
\DoxyCodeLine{179 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{180   }
\DoxyCodeLine{181   \textcolor{comment}{// TODO: MSVC?  \_\_assume( (mem \& 0x0F) == 0 );}}
\DoxyCodeLine{182   \textcolor{comment}{//}}
\DoxyCodeLine{183   \textcolor{comment}{// http://comments.gmane.org/gmane.comp.gcc.patches/239430}}
\DoxyCodeLine{184   \textcolor{comment}{// GCC \_\_builtin\_assume\_aligned is similar to ICC's \_\_assume\_aligned,}}
\DoxyCodeLine{185   \textcolor{comment}{// so for lvalue first argument ICC's \_\_assume\_aligned can be emulated using}}
\DoxyCodeLine{186   \textcolor{comment}{// \#define \_\_assume\_aligned(lvalueptr, align) lvalueptr = \_\_builtin\_assume\_aligned (lvalueptr, align) }}
\DoxyCodeLine{187   \textcolor{comment}{//}}
\DoxyCodeLine{188   \textcolor{comment}{// http://www.inf.ethz.ch/personal/markusp/teaching/263-\/2300-\/ETH-\/spring11/slides/class19.pdf}}
\DoxyCodeLine{189   \textcolor{comment}{// http://software.intel.com/sites/products/documentation/hpc/composerxe/en-\/us/cpp/lin/index.htm}}
\DoxyCodeLine{190   \textcolor{comment}{// http://d3f8ykwhia686p.cloudfront.net/1live/intel/CompilerAutovectorizationGuide.pdf}}
\DoxyCodeLine{191   \}}
\DoxyCodeLine{192 }
\DoxyCodeLine{193 }
\DoxyCodeLine{194 }
\DoxyCodeLine{195 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{196 arma\_inline}
\DoxyCodeLine{197 \textcolor{keywordtype}{void}}
\DoxyCodeLine{198 memory::mark\_as\_aligned(\textcolor{keyword}{const} eT*\& mem)}
\DoxyCodeLine{199   \{}
\DoxyCodeLine{200 \textcolor{preprocessor}{  \#if defined(ARMA\_HAVE\_ICC\_ASSUME\_ALIGNED)}}
\DoxyCodeLine{201     \{}
\DoxyCodeLine{202     \_\_assume\_aligned(mem, 16);}
\DoxyCodeLine{203     \}}
\DoxyCodeLine{204 \textcolor{preprocessor}{  \#elif defined(ARMA\_HAVE\_GCC\_ASSUME\_ALIGNED)}}
\DoxyCodeLine{205     \{}
\DoxyCodeLine{206     mem = (\textcolor{keyword}{const} eT*)\_\_builtin\_assume\_aligned(mem, 16);}
\DoxyCodeLine{207     \}}
\DoxyCodeLine{208 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{209     \{}
\DoxyCodeLine{210     arma\_ignore(mem);}
\DoxyCodeLine{211     \}}
\DoxyCodeLine{212 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{213   \}}
\DoxyCodeLine{214 }
\DoxyCodeLine{215 }
\DoxyCodeLine{216 }

\end{DoxyCode}
