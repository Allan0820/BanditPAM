\hypertarget{mul__herk_8hpp_source}{}\doxysection{mul\+\_\+herk.\+hpp}
\label{mul__herk_8hpp_source}\index{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/mul\_herk.hpp@{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/mul\_herk.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008-\/2016 Conrad Sanderson (http://conradsanderson.id.au)}}
\DoxyCodeLine{2 \textcolor{comment}{// Copyright 2008-\/2016 National ICT Australia (NICTA)}}
\DoxyCodeLine{3 \textcolor{comment}{// }}
\DoxyCodeLine{4 \textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{5 \textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{6 \textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{7 \textcolor{comment}{// http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{8 \textcolor{comment}{// }}
\DoxyCodeLine{9 \textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{10 \textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{11 \textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{12 \textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{13 \textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{14 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{19 }
\DoxyCodeLine{20 }
\DoxyCodeLine{21 }
\DoxyCodeLine{22 \textcolor{keyword}{class }\mbox{\hyperlink{classherk__helper}{herk\_helper}}}
\DoxyCodeLine{23   \{}
\DoxyCodeLine{24   \textcolor{keyword}{public}:}
\DoxyCodeLine{25   }
\DoxyCodeLine{26   \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{27   \textcolor{keyword}{inline}}
\DoxyCodeLine{28   \textcolor{keyword}{static}}
\DoxyCodeLine{29   \textcolor{keywordtype}{void}}
\DoxyCodeLine{30   inplace\_conj\_copy\_upper\_tri\_to\_lower\_tri(\mbox{\hyperlink{classMat}{Mat<eT>}}\& C)}
\DoxyCodeLine{31     \{}
\DoxyCodeLine{32     \textcolor{comment}{// under the assumption that C is a square matrix}}
\DoxyCodeLine{33     }
\DoxyCodeLine{34     \textcolor{keyword}{const} uword N = C.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}};}
\DoxyCodeLine{35     }
\DoxyCodeLine{36     \textcolor{keywordflow}{for}(uword k=0; k < N; ++k)}
\DoxyCodeLine{37       \{}
\DoxyCodeLine{38       eT* colmem = C.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(k);}
\DoxyCodeLine{39       }
\DoxyCodeLine{40       \textcolor{keywordflow}{for}(uword i=(k+1); i < N; ++i)}
\DoxyCodeLine{41         \{}
\DoxyCodeLine{42         colmem[i] = std::conj( C.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(k,i) );}
\DoxyCodeLine{43         \}}
\DoxyCodeLine{44       \}}
\DoxyCodeLine{45     \}}
\DoxyCodeLine{46   }
\DoxyCodeLine{47   }
\DoxyCodeLine{48   \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{49   \textcolor{keyword}{static}}
\DoxyCodeLine{50   arma\_hot}
\DoxyCodeLine{51   \textcolor{keyword}{inline}}
\DoxyCodeLine{52   eT}
\DoxyCodeLine{53   dot\_conj\_row(\textcolor{keyword}{const} uword n\_elem, \textcolor{keyword}{const} eT* \textcolor{keyword}{const} \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structB}{B}}, \textcolor{keyword}{const} uword row)}
\DoxyCodeLine{54     \{}
\DoxyCodeLine{55     arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{56     }
\DoxyCodeLine{57     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} get\_pod\_type<eT>::result T;}
\DoxyCodeLine{58     }
\DoxyCodeLine{59     T val\_real = T(0);}
\DoxyCodeLine{60     T val\_imag = T(0);}
\DoxyCodeLine{61     }
\DoxyCodeLine{62     \textcolor{keywordflow}{for}(uword i=0; i<n\_elem; ++i)}
\DoxyCodeLine{63       \{}
\DoxyCodeLine{64       \textcolor{keyword}{const} std::complex<T>\& X = \mbox{\hyperlink{structA}{A}}[i];}
\DoxyCodeLine{65       \textcolor{keyword}{const} std::complex<T>\& Y = \mbox{\hyperlink{structB}{B}}.at(row,i);}
\DoxyCodeLine{66       }
\DoxyCodeLine{67       \textcolor{keyword}{const} T a = X.real();}
\DoxyCodeLine{68       \textcolor{keyword}{const} T b = X.imag();}
\DoxyCodeLine{69       }
\DoxyCodeLine{70       \textcolor{keyword}{const} T c = Y.real();}
\DoxyCodeLine{71       \textcolor{keyword}{const} T d = Y.imag();}
\DoxyCodeLine{72       }
\DoxyCodeLine{73       val\_real += (a*c) + (b*d);}
\DoxyCodeLine{74       val\_imag += (b*c) -\/ (a*d);}
\DoxyCodeLine{75       \}}
\DoxyCodeLine{76     }
\DoxyCodeLine{77     \textcolor{keywordflow}{return} std::complex<T>(val\_real, val\_imag);}
\DoxyCodeLine{78     \}}
\DoxyCodeLine{79   }
\DoxyCodeLine{80   \};}
\DoxyCodeLine{81 }
\DoxyCodeLine{82 }
\DoxyCodeLine{83 }
\DoxyCodeLine{84 \textcolor{keyword}{template}<const \textcolor{keywordtype}{bool} do\_trans\_A=false, const \textcolor{keywordtype}{bool} use\_alpha=false, const \textcolor{keywordtype}{bool} use\_beta=false>}
\DoxyCodeLine{85 \textcolor{keyword}{class }\mbox{\hyperlink{classherk__vec}{herk\_vec}}}
\DoxyCodeLine{86   \{}
\DoxyCodeLine{87   \textcolor{keyword}{public}:}
\DoxyCodeLine{88   }
\DoxyCodeLine{89   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} TA>}
\DoxyCodeLine{90   arma\_hot}
\DoxyCodeLine{91   \textcolor{keyword}{inline}}
\DoxyCodeLine{92   \textcolor{keyword}{static}}
\DoxyCodeLine{93   \textcolor{keywordtype}{void}}
\DoxyCodeLine{94   apply}
\DoxyCodeLine{95     (}
\DoxyCodeLine{96           \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& C,}
\DoxyCodeLine{97     \textcolor{keyword}{const} TA\&                     \mbox{\hyperlink{structA}{A}},}
\DoxyCodeLine{98     \textcolor{keyword}{const} T                       alpha = T(1),}
\DoxyCodeLine{99     \textcolor{keyword}{const} T                       beta  = T(0)}
\DoxyCodeLine{100     )}
\DoxyCodeLine{101     \{}
\DoxyCodeLine{102     arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{103     }
\DoxyCodeLine{104     \textcolor{keyword}{typedef} std::complex<T> eT;}
\DoxyCodeLine{105     }
\DoxyCodeLine{106     \textcolor{keyword}{const} uword A\_n\_rows = \mbox{\hyperlink{structA}{A}}.n\_rows;}
\DoxyCodeLine{107     \textcolor{keyword}{const} uword A\_n\_cols = \mbox{\hyperlink{structA}{A}}.n\_cols;}
\DoxyCodeLine{108     }
\DoxyCodeLine{109     \textcolor{comment}{// for beta != 0, C is assumed to be hermitian}}
\DoxyCodeLine{110     }
\DoxyCodeLine{111     \textcolor{comment}{// do\_trans\_A == false  -\/>   C = alpha * A   * A\string^H + beta*C}}
\DoxyCodeLine{112     \textcolor{comment}{// do\_trans\_A == true   -\/>   C = alpha * A\string^H * A   + beta*C}}
\DoxyCodeLine{113     }
\DoxyCodeLine{114     \textcolor{keyword}{const} eT* A\_mem = \mbox{\hyperlink{structA}{A}}.memptr();}
\DoxyCodeLine{115     }
\DoxyCodeLine{116     \textcolor{keywordflow}{if}(do\_trans\_A == \textcolor{keyword}{false})}
\DoxyCodeLine{117       \{}
\DoxyCodeLine{118       \textcolor{keywordflow}{if}(A\_n\_rows == 1)}
\DoxyCodeLine{119         \{}
\DoxyCodeLine{120         \textcolor{keyword}{const} eT acc = op\_cdot::direct\_cdot(A\_n\_cols, A\_mem, A\_mem);}
\DoxyCodeLine{121         }
\DoxyCodeLine{122              \textcolor{keywordflow}{if}( (use\_alpha == \textcolor{keyword}{false}) \&\& (use\_beta == \textcolor{keyword}{false}) )  \{ C[0] =       acc;             \}}
\DoxyCodeLine{123         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( (use\_alpha == \textcolor{keyword}{true} ) \&\& (use\_beta == \textcolor{keyword}{false}) )  \{ C[0] = alpha*acc;             \}}
\DoxyCodeLine{124         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( (use\_alpha == \textcolor{keyword}{false}) \&\& (use\_beta == \textcolor{keyword}{true} ) )  \{ C[0] =       acc + beta*C[0]; \}}
\DoxyCodeLine{125         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( (use\_alpha == \textcolor{keyword}{true} ) \&\& (use\_beta == \textcolor{keyword}{true} ) )  \{ C[0] = alpha*acc + beta*C[0]; \}}
\DoxyCodeLine{126         \}}
\DoxyCodeLine{127       \textcolor{keywordflow}{else}}
\DoxyCodeLine{128       \textcolor{keywordflow}{for}(uword row\_A=0; row\_A < A\_n\_rows; ++row\_A)}
\DoxyCodeLine{129         \{}
\DoxyCodeLine{130         \textcolor{keyword}{const} eT\& A\_rowdata = A\_mem[row\_A];}
\DoxyCodeLine{131         }
\DoxyCodeLine{132         \textcolor{keywordflow}{for}(uword k=row\_A; k < A\_n\_rows; ++k)}
\DoxyCodeLine{133           \{}
\DoxyCodeLine{134           \textcolor{keyword}{const} eT acc = A\_rowdata * std::conj( A\_mem[k] );}
\DoxyCodeLine{135           }
\DoxyCodeLine{136           \textcolor{keywordflow}{if}( (use\_alpha == \textcolor{keyword}{false}) \&\& (use\_beta == \textcolor{keyword}{false}) )}
\DoxyCodeLine{137             \{}
\DoxyCodeLine{138                               C.at(row\_A, k) = acc;}
\DoxyCodeLine{139             \textcolor{keywordflow}{if}(row\_A != k)  \{ C.at(k, row\_A) = std::conj(acc); \}}
\DoxyCodeLine{140             \}}
\DoxyCodeLine{141           \textcolor{keywordflow}{else}}
\DoxyCodeLine{142           \textcolor{keywordflow}{if}( (use\_alpha == \textcolor{keyword}{true}) \&\& (use\_beta == \textcolor{keyword}{false}) )}
\DoxyCodeLine{143             \{}
\DoxyCodeLine{144             \textcolor{keyword}{const} eT val = alpha*acc;}
\DoxyCodeLine{145             }
\DoxyCodeLine{146                               C.at(row\_A, k) = val;}
\DoxyCodeLine{147             \textcolor{keywordflow}{if}(row\_A != k)  \{ C.at(k, row\_A) = std::conj(val); \}}
\DoxyCodeLine{148             \}}
\DoxyCodeLine{149           \textcolor{keywordflow}{else}}
\DoxyCodeLine{150           \textcolor{keywordflow}{if}( (use\_alpha == \textcolor{keyword}{false}) \&\& (use\_beta == \textcolor{keyword}{true}) )}
\DoxyCodeLine{151             \{}
\DoxyCodeLine{152                               C.at(row\_A, k) =           acc  + beta*C.at(row\_A, k);}
\DoxyCodeLine{153             \textcolor{keywordflow}{if}(row\_A != k)  \{ C.at(k, row\_A) = std::conj(acc) + beta*C.at(k, row\_A); \}}
\DoxyCodeLine{154             \}}
\DoxyCodeLine{155           \textcolor{keywordflow}{else}}
\DoxyCodeLine{156           \textcolor{keywordflow}{if}( (use\_alpha == \textcolor{keyword}{true}) \&\& (use\_beta == \textcolor{keyword}{true}) )}
\DoxyCodeLine{157             \{}
\DoxyCodeLine{158             \textcolor{keyword}{const} eT val = alpha*acc;}
\DoxyCodeLine{159             }
\DoxyCodeLine{160                               C.at(row\_A, k) =           val  + beta*C.at(row\_A, k);}
\DoxyCodeLine{161             \textcolor{keywordflow}{if}(row\_A != k)  \{ C.at(k, row\_A) = std::conj(val) + beta*C.at(k, row\_A); \}}
\DoxyCodeLine{162             \}}
\DoxyCodeLine{163           \}}
\DoxyCodeLine{164         \}}
\DoxyCodeLine{165       \}}
\DoxyCodeLine{166     \textcolor{keywordflow}{else}}
\DoxyCodeLine{167     \textcolor{keywordflow}{if}(do\_trans\_A == \textcolor{keyword}{true})}
\DoxyCodeLine{168       \{}
\DoxyCodeLine{169       \textcolor{keywordflow}{if}(A\_n\_cols == 1)}
\DoxyCodeLine{170         \{}
\DoxyCodeLine{171         \textcolor{keyword}{const} eT acc = op\_cdot::direct\_cdot(A\_n\_rows, A\_mem, A\_mem);}
\DoxyCodeLine{172         }
\DoxyCodeLine{173              \textcolor{keywordflow}{if}( (use\_alpha == \textcolor{keyword}{false}) \&\& (use\_beta == \textcolor{keyword}{false}) )  \{ C[0] =       acc;             \}}
\DoxyCodeLine{174         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( (use\_alpha == \textcolor{keyword}{true} ) \&\& (use\_beta == \textcolor{keyword}{false}) )  \{ C[0] = alpha*acc;             \}}
\DoxyCodeLine{175         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( (use\_alpha == \textcolor{keyword}{false}) \&\& (use\_beta == \textcolor{keyword}{true} ) )  \{ C[0] =       acc + beta*C[0]; \}}
\DoxyCodeLine{176         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( (use\_alpha == \textcolor{keyword}{true} ) \&\& (use\_beta == \textcolor{keyword}{true} ) )  \{ C[0] = alpha*acc + beta*C[0]; \}}
\DoxyCodeLine{177         \}}
\DoxyCodeLine{178       \textcolor{keywordflow}{else}}
\DoxyCodeLine{179       \textcolor{keywordflow}{for}(uword col\_A=0; col\_A < A\_n\_cols; ++col\_A)}
\DoxyCodeLine{180         \{}
\DoxyCodeLine{181         \textcolor{comment}{// col\_A is interpreted as row\_A when storing the results in matrix C}}
\DoxyCodeLine{182         }
\DoxyCodeLine{183         \textcolor{keyword}{const} eT A\_coldata = std::conj( A\_mem[col\_A] );}
\DoxyCodeLine{184         }
\DoxyCodeLine{185         \textcolor{keywordflow}{for}(uword k=col\_A; k < A\_n\_cols ; ++k)}
\DoxyCodeLine{186           \{}
\DoxyCodeLine{187           \textcolor{keyword}{const} eT acc = A\_coldata * A\_mem[k];}
\DoxyCodeLine{188           }
\DoxyCodeLine{189           \textcolor{keywordflow}{if}( (use\_alpha == \textcolor{keyword}{false}) \&\& (use\_beta == \textcolor{keyword}{false}) )}
\DoxyCodeLine{190             \{}
\DoxyCodeLine{191                               C.at(col\_A, k) = acc;}
\DoxyCodeLine{192             \textcolor{keywordflow}{if}(col\_A != k)  \{ C.at(k, col\_A) = std::conj(acc); \}}
\DoxyCodeLine{193             \}}
\DoxyCodeLine{194           \textcolor{keywordflow}{else}}
\DoxyCodeLine{195           \textcolor{keywordflow}{if}( (use\_alpha == \textcolor{keyword}{true} ) \&\& (use\_beta == \textcolor{keyword}{false}) )}
\DoxyCodeLine{196             \{}
\DoxyCodeLine{197             \textcolor{keyword}{const} eT val = alpha*acc;}
\DoxyCodeLine{198             }
\DoxyCodeLine{199                               C.at(col\_A, k) = val;}
\DoxyCodeLine{200             \textcolor{keywordflow}{if}(col\_A != k)  \{ C.at(k, col\_A) = std::conj(val); \}}
\DoxyCodeLine{201             \}}
\DoxyCodeLine{202           \textcolor{keywordflow}{else}}
\DoxyCodeLine{203           \textcolor{keywordflow}{if}( (use\_alpha == \textcolor{keyword}{false}) \&\& (use\_beta == \textcolor{keyword}{true} ) )}
\DoxyCodeLine{204             \{}
\DoxyCodeLine{205                               C.at(col\_A, k) =           acc  + beta*C.at(col\_A, k);}
\DoxyCodeLine{206             \textcolor{keywordflow}{if}(col\_A != k)  \{ C.at(k, col\_A) = std::conj(acc) + beta*C.at(k, col\_A); \}}
\DoxyCodeLine{207             \}}
\DoxyCodeLine{208           \textcolor{keywordflow}{else}}
\DoxyCodeLine{209           \textcolor{keywordflow}{if}( (use\_alpha == \textcolor{keyword}{true} ) \&\& (use\_beta == \textcolor{keyword}{true} ) )}
\DoxyCodeLine{210             \{}
\DoxyCodeLine{211             \textcolor{keyword}{const} eT val = alpha*acc;}
\DoxyCodeLine{212             }
\DoxyCodeLine{213                               C.at(col\_A, k) =           val  + beta*C.at(col\_A, k);}
\DoxyCodeLine{214             \textcolor{keywordflow}{if}(col\_A != k)  \{ C.at(k, col\_A) = std::conj(val) + beta*C.at(k, col\_A); \}}
\DoxyCodeLine{215             \}}
\DoxyCodeLine{216           \}}
\DoxyCodeLine{217         \}}
\DoxyCodeLine{218       \}}
\DoxyCodeLine{219     \}}
\DoxyCodeLine{220   }
\DoxyCodeLine{221   \};}
\DoxyCodeLine{222 }
\DoxyCodeLine{223 }
\DoxyCodeLine{224 }
\DoxyCodeLine{225 \textcolor{keyword}{template}<const \textcolor{keywordtype}{bool} do\_trans\_A=false, const \textcolor{keywordtype}{bool} use\_alpha=false, const \textcolor{keywordtype}{bool} use\_beta=false>}
\DoxyCodeLine{226 \textcolor{keyword}{class }\mbox{\hyperlink{classherk__emul}{herk\_emul}}}
\DoxyCodeLine{227   \{}
\DoxyCodeLine{228   \textcolor{keyword}{public}:}
\DoxyCodeLine{229   }
\DoxyCodeLine{230   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} TA>}
\DoxyCodeLine{231   arma\_hot}
\DoxyCodeLine{232   \textcolor{keyword}{inline}}
\DoxyCodeLine{233   \textcolor{keyword}{static}}
\DoxyCodeLine{234   \textcolor{keywordtype}{void}}
\DoxyCodeLine{235   apply}
\DoxyCodeLine{236     (}
\DoxyCodeLine{237           \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& C,}
\DoxyCodeLine{238     \textcolor{keyword}{const} TA\&                     \mbox{\hyperlink{structA}{A}},}
\DoxyCodeLine{239     \textcolor{keyword}{const} T                       alpha = T(1),}
\DoxyCodeLine{240     \textcolor{keyword}{const} T                       beta  = T(0)}
\DoxyCodeLine{241     )}
\DoxyCodeLine{242     \{}
\DoxyCodeLine{243     arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{244     }
\DoxyCodeLine{245     \textcolor{keyword}{typedef} std::complex<T> eT;}
\DoxyCodeLine{246     }
\DoxyCodeLine{247     \textcolor{comment}{// do\_trans\_A == false  -\/>   C = alpha * A   * A\string^H + beta*C}}
\DoxyCodeLine{248     \textcolor{comment}{// do\_trans\_A == true   -\/>   C = alpha * A\string^H * A   + beta*C}}
\DoxyCodeLine{249     }
\DoxyCodeLine{250     \textcolor{keywordflow}{if}(do\_trans\_A == \textcolor{keyword}{false})}
\DoxyCodeLine{251       \{}
\DoxyCodeLine{252       \mbox{\hyperlink{classMat}{Mat<eT>}} AA;}
\DoxyCodeLine{253       }
\DoxyCodeLine{254       op\_htrans::apply\_mat\_noalias(AA, \mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{255       }
\DoxyCodeLine{256       \mbox{\hyperlink{classherk__emul}{herk\_emul<true, use\_alpha, use\_beta>::apply}}(C, AA, alpha, beta);}
\DoxyCodeLine{257       \}}
\DoxyCodeLine{258     \textcolor{keywordflow}{else}}
\DoxyCodeLine{259     \textcolor{keywordflow}{if}(do\_trans\_A == \textcolor{keyword}{true})}
\DoxyCodeLine{260       \{}
\DoxyCodeLine{261       \textcolor{keyword}{const} uword A\_n\_rows = \mbox{\hyperlink{structA}{A}}.n\_rows;}
\DoxyCodeLine{262       \textcolor{keyword}{const} uword A\_n\_cols = \mbox{\hyperlink{structA}{A}}.n\_cols;}
\DoxyCodeLine{263       }
\DoxyCodeLine{264       \textcolor{keywordflow}{for}(uword col\_A=0; col\_A < A\_n\_cols; ++col\_A)}
\DoxyCodeLine{265         \{}
\DoxyCodeLine{266         \textcolor{comment}{// col\_A is interpreted as row\_A when storing the results in matrix C}}
\DoxyCodeLine{267         }
\DoxyCodeLine{268         \textcolor{keyword}{const} eT* A\_coldata = \mbox{\hyperlink{structA}{A}}.colptr(col\_A);}
\DoxyCodeLine{269         }
\DoxyCodeLine{270         \textcolor{keywordflow}{for}(uword k=col\_A; k < A\_n\_cols ; ++k)}
\DoxyCodeLine{271           \{}
\DoxyCodeLine{272           \textcolor{keyword}{const} eT acc = op\_cdot::direct\_cdot(A\_n\_rows, A\_coldata, \mbox{\hyperlink{structA}{A}}.colptr(k));}
\DoxyCodeLine{273           }
\DoxyCodeLine{274           \textcolor{keywordflow}{if}( (use\_alpha == \textcolor{keyword}{false}) \&\& (use\_beta == \textcolor{keyword}{false}) )}
\DoxyCodeLine{275             \{}
\DoxyCodeLine{276                               C.at(col\_A, k) = acc;}
\DoxyCodeLine{277             \textcolor{keywordflow}{if}(col\_A != k)  \{ C.at(k, col\_A) = std::conj(acc); \}}
\DoxyCodeLine{278             \}}
\DoxyCodeLine{279           \textcolor{keywordflow}{else}}
\DoxyCodeLine{280           \textcolor{keywordflow}{if}( (use\_alpha == \textcolor{keyword}{true}) \&\& (use\_beta == \textcolor{keyword}{false}) )}
\DoxyCodeLine{281             \{}
\DoxyCodeLine{282             \textcolor{keyword}{const} eT val = alpha*acc;}
\DoxyCodeLine{283             }
\DoxyCodeLine{284                               C.at(col\_A, k) = val;}
\DoxyCodeLine{285             \textcolor{keywordflow}{if}(col\_A != k)  \{ C.at(k, col\_A) = std::conj(val); \}}
\DoxyCodeLine{286             \}}
\DoxyCodeLine{287           \textcolor{keywordflow}{else}}
\DoxyCodeLine{288           \textcolor{keywordflow}{if}( (use\_alpha == \textcolor{keyword}{false}) \&\& (use\_beta == \textcolor{keyword}{true}) )}
\DoxyCodeLine{289             \{}
\DoxyCodeLine{290                               C.at(col\_A, k) =           acc  + beta*C.at(col\_A, k);}
\DoxyCodeLine{291             \textcolor{keywordflow}{if}(col\_A != k)  \{ C.at(k, col\_A) = std::conj(acc) + beta*C.at(k, col\_A); \}}
\DoxyCodeLine{292             \}}
\DoxyCodeLine{293           \textcolor{keywordflow}{else}}
\DoxyCodeLine{294           \textcolor{keywordflow}{if}( (use\_alpha == \textcolor{keyword}{true}) \&\& (use\_beta == \textcolor{keyword}{true}) )}
\DoxyCodeLine{295             \{}
\DoxyCodeLine{296             \textcolor{keyword}{const} eT val = alpha*acc;}
\DoxyCodeLine{297             }
\DoxyCodeLine{298                               C.at(col\_A, k) =           val  + beta*C.at(col\_A, k);}
\DoxyCodeLine{299             \textcolor{keywordflow}{if}(col\_A != k)  \{ C.at(k, col\_A) = std::conj(val) + beta*C.at(k, col\_A); \}}
\DoxyCodeLine{300             \}}
\DoxyCodeLine{301           \}}
\DoxyCodeLine{302         \}}
\DoxyCodeLine{303       \}}
\DoxyCodeLine{304     \}}
\DoxyCodeLine{305   }
\DoxyCodeLine{306   \};}
\DoxyCodeLine{307 }
\DoxyCodeLine{308 }
\DoxyCodeLine{309 }
\DoxyCodeLine{310 \textcolor{keyword}{template}<const \textcolor{keywordtype}{bool} do\_trans\_A=false, const \textcolor{keywordtype}{bool} use\_alpha=false, const \textcolor{keywordtype}{bool} use\_beta=false>}
\DoxyCodeLine{311 \textcolor{keyword}{class }\mbox{\hyperlink{classherk}{herk}}}
\DoxyCodeLine{312   \{}
\DoxyCodeLine{313   \textcolor{keyword}{public}:}
\DoxyCodeLine{314   }
\DoxyCodeLine{315   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} TA>}
\DoxyCodeLine{316   \textcolor{keyword}{inline}}
\DoxyCodeLine{317   \textcolor{keyword}{static}}
\DoxyCodeLine{318   \textcolor{keywordtype}{void}}
\DoxyCodeLine{319   apply\_blas\_type( \mbox{\hyperlink{classMat}{Mat}}<std::complex<T>>\& C, \textcolor{keyword}{const} TA\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} T alpha = T(1), \textcolor{keyword}{const} T beta = T(0) )}
\DoxyCodeLine{320     \{}
\DoxyCodeLine{321     arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{322     }
\DoxyCodeLine{323     \textcolor{keyword}{const} uword threshold = 16;}
\DoxyCodeLine{324     }
\DoxyCodeLine{325     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_vec())}
\DoxyCodeLine{326       \{}
\DoxyCodeLine{327       \textcolor{comment}{// work around poor handling of vectors by herk() in ATLAS 3.8.4 and standard BLAS}}
\DoxyCodeLine{328       }
\DoxyCodeLine{329       \mbox{\hyperlink{classherk__vec}{herk\_vec<do\_trans\_A, use\_alpha, use\_beta>::apply}}(C,\mbox{\hyperlink{structA}{A}},alpha,beta);}
\DoxyCodeLine{330       }
\DoxyCodeLine{331       \textcolor{keywordflow}{return};}
\DoxyCodeLine{332       \}}
\DoxyCodeLine{333     }
\DoxyCodeLine{334     }
\DoxyCodeLine{335     \textcolor{keywordflow}{if}( (\mbox{\hyperlink{structA}{A}}.n\_elem <= threshold) )}
\DoxyCodeLine{336       \{}
\DoxyCodeLine{337       \mbox{\hyperlink{classherk__emul}{herk\_emul<do\_trans\_A, use\_alpha, use\_beta>::apply}}(C,\mbox{\hyperlink{structA}{A}},alpha,beta);}
\DoxyCodeLine{338       \}}
\DoxyCodeLine{339     \textcolor{keywordflow}{else}}
\DoxyCodeLine{340       \{}
\DoxyCodeLine{341 \textcolor{preprocessor}{      \#if defined(ARMA\_USE\_ATLAS)}}
\DoxyCodeLine{342         \{}
\DoxyCodeLine{343         \textcolor{keywordflow}{if}(use\_beta == \textcolor{keyword}{true})}
\DoxyCodeLine{344           \{}
\DoxyCodeLine{345           \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<T> eT;}
\DoxyCodeLine{346           }
\DoxyCodeLine{347           \textcolor{comment}{// use a temporary matrix, as we can't assume that matrix C is already symmetric}}
\DoxyCodeLine{348           \mbox{\hyperlink{classMat}{Mat<eT>}} D(C.n\_rows, C.n\_cols, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{349           }
\DoxyCodeLine{350           \mbox{\hyperlink{classherk}{herk<do\_trans\_A, use\_alpha, false>::apply\_blas\_type}}(D,\mbox{\hyperlink{structA}{A}},alpha);}
\DoxyCodeLine{351           }
\DoxyCodeLine{352           \textcolor{comment}{// NOTE: assuming beta=1; this is okay for now, as currently glue\_times only uses beta=1}}
\DoxyCodeLine{353           arrayops::inplace\_plus(C.memptr(), D.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), C.n\_elem);}
\DoxyCodeLine{354           }
\DoxyCodeLine{355           \textcolor{keywordflow}{return};}
\DoxyCodeLine{356           \}}
\DoxyCodeLine{357         }
\DoxyCodeLine{358         atlas::cblas\_herk<T>}
\DoxyCodeLine{359           (}
\DoxyCodeLine{360           atlas::CblasColMajor,}
\DoxyCodeLine{361           atlas::CblasUpper,}
\DoxyCodeLine{362           (do\_trans\_A) ? CblasConjTrans : atlas::CblasNoTrans,}
\DoxyCodeLine{363           C.n\_cols,}
\DoxyCodeLine{364           (do\_trans\_A) ? \mbox{\hyperlink{structA}{A}}.n\_rows : \mbox{\hyperlink{structA}{A}}.n\_cols,}
\DoxyCodeLine{365           (use\_alpha) ? alpha : T(1),}
\DoxyCodeLine{366           \mbox{\hyperlink{structA}{A}}.mem,}
\DoxyCodeLine{367           (do\_trans\_A) ? \mbox{\hyperlink{structA}{A}}.n\_rows : C.n\_cols,}
\DoxyCodeLine{368           (use\_beta) ? beta : T(0),}
\DoxyCodeLine{369           C.memptr(),}
\DoxyCodeLine{370           C.n\_cols}
\DoxyCodeLine{371           );}
\DoxyCodeLine{372         }
\DoxyCodeLine{373         herk\_helper::inplace\_conj\_copy\_upper\_tri\_to\_lower\_tri(C);}
\DoxyCodeLine{374         \}}
\DoxyCodeLine{375 \textcolor{preprocessor}{      \#elif defined(ARMA\_USE\_BLAS)}}
\DoxyCodeLine{376         \{}
\DoxyCodeLine{377         \textcolor{keywordflow}{if}(use\_beta == \textcolor{keyword}{true})}
\DoxyCodeLine{378           \{}
\DoxyCodeLine{379           \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<T> eT;}
\DoxyCodeLine{380           }
\DoxyCodeLine{381           \textcolor{comment}{// use a temporary matrix, as we can't assume that matrix C is already symmetric}}
\DoxyCodeLine{382           \mbox{\hyperlink{classMat}{Mat<eT>}} D(C.n\_rows, C.n\_cols, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{383           }
\DoxyCodeLine{384           \mbox{\hyperlink{classherk}{herk<do\_trans\_A, use\_alpha, false>::apply\_blas\_type}}(D,\mbox{\hyperlink{structA}{A}},alpha);}
\DoxyCodeLine{385           }
\DoxyCodeLine{386           \textcolor{comment}{// NOTE: assuming beta=1; this is okay for now, as currently glue\_times only uses beta=1}}
\DoxyCodeLine{387           arrayops::inplace\_plus(C.memptr(), D.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), C.n\_elem);}
\DoxyCodeLine{388           }
\DoxyCodeLine{389           \textcolor{keywordflow}{return};}
\DoxyCodeLine{390           \}}
\DoxyCodeLine{391         }
\DoxyCodeLine{392         arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}blas::herk()"{}});}
\DoxyCodeLine{393         }
\DoxyCodeLine{394         \textcolor{keyword}{const} \textcolor{keywordtype}{char} uplo = \textcolor{charliteral}{'U'};}
\DoxyCodeLine{395         }
\DoxyCodeLine{396         \textcolor{keyword}{const} \textcolor{keywordtype}{char} trans\_A = (do\_trans\_A) ? \textcolor{charliteral}{'C'} : \textcolor{charliteral}{'N'};}
\DoxyCodeLine{397         }
\DoxyCodeLine{398         \textcolor{keyword}{const} blas\_int n = blas\_int(C.n\_cols);}
\DoxyCodeLine{399         \textcolor{keyword}{const} blas\_int k = (do\_trans\_A) ? blas\_int(\mbox{\hyperlink{structA}{A}}.n\_rows) : blas\_int(\mbox{\hyperlink{structA}{A}}.n\_cols);}
\DoxyCodeLine{400         }
\DoxyCodeLine{401         \textcolor{keyword}{const} T local\_alpha = (use\_alpha) ? alpha : T(1);}
\DoxyCodeLine{402         \textcolor{keyword}{const} T local\_beta  = (use\_beta)  ? beta  : T(0);}
\DoxyCodeLine{403         }
\DoxyCodeLine{404         \textcolor{keyword}{const} blas\_int lda = (do\_trans\_A) ? k : n;}
\DoxyCodeLine{405         }
\DoxyCodeLine{406         arma\_extra\_debug\_print( \mbox{\hyperlink{classarma__str_1_1format}{arma\_str::format}}(\textcolor{stringliteral}{"{}blas::herk(): trans\_A = \%c"{}}) \% trans\_A );}
\DoxyCodeLine{407         }
\DoxyCodeLine{408         blas::herk<T>}
\DoxyCodeLine{409           (}
\DoxyCodeLine{410           \&uplo,}
\DoxyCodeLine{411           \&trans\_A,}
\DoxyCodeLine{412           \&n,}
\DoxyCodeLine{413           \&k,}
\DoxyCodeLine{414           \&local\_alpha,}
\DoxyCodeLine{415           \mbox{\hyperlink{structA}{A}}.mem,}
\DoxyCodeLine{416           \&lda,}
\DoxyCodeLine{417           \&local\_beta,}
\DoxyCodeLine{418           C.memptr(),}
\DoxyCodeLine{419           \&n \textcolor{comment}{// \&ldc}}
\DoxyCodeLine{420           );}
\DoxyCodeLine{421         }
\DoxyCodeLine{422         herk\_helper::inplace\_conj\_copy\_upper\_tri\_to\_lower\_tri(C);}
\DoxyCodeLine{423         \}}
\DoxyCodeLine{424 \textcolor{preprocessor}{      \#else}}
\DoxyCodeLine{425         \{}
\DoxyCodeLine{426         \mbox{\hyperlink{classherk__emul}{herk\_emul<do\_trans\_A, use\_alpha, use\_beta>::apply}}(C,\mbox{\hyperlink{structA}{A}},alpha,beta);}
\DoxyCodeLine{427         \}}
\DoxyCodeLine{428 \textcolor{preprocessor}{      \#endif}}
\DoxyCodeLine{429       \}}
\DoxyCodeLine{430     }
\DoxyCodeLine{431     \}}
\DoxyCodeLine{432   }
\DoxyCodeLine{433   }
\DoxyCodeLine{434   }
\DoxyCodeLine{435   \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT, \textcolor{keyword}{typename} TA>}
\DoxyCodeLine{436   \textcolor{keyword}{inline}}
\DoxyCodeLine{437   \textcolor{keyword}{static}}
\DoxyCodeLine{438   \textcolor{keywordtype}{void}}
\DoxyCodeLine{439   apply( \mbox{\hyperlink{classMat}{Mat<eT>}}\& C, \textcolor{keyword}{const} TA\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} eT alpha = eT(1), \textcolor{keyword}{const} eT beta = eT(0), \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<eT>::result* junk = \textcolor{keyword}{nullptr} )}
\DoxyCodeLine{440     \{}
\DoxyCodeLine{441     arma\_ignore(C);}
\DoxyCodeLine{442     arma\_ignore(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{443     arma\_ignore(alpha);}
\DoxyCodeLine{444     arma\_ignore(beta);}
\DoxyCodeLine{445     arma\_ignore(junk);}
\DoxyCodeLine{446     }
\DoxyCodeLine{447     \textcolor{comment}{// herk() cannot be used by non-\/complex matrices}}
\DoxyCodeLine{448     }
\DoxyCodeLine{449     \textcolor{keywordflow}{return};}
\DoxyCodeLine{450     \}}
\DoxyCodeLine{451   }
\DoxyCodeLine{452   }
\DoxyCodeLine{453   }
\DoxyCodeLine{454   \textcolor{keyword}{template}<\textcolor{keyword}{typename} TA>}
\DoxyCodeLine{455   arma\_inline}
\DoxyCodeLine{456   \textcolor{keyword}{static}}
\DoxyCodeLine{457   \textcolor{keywordtype}{void}}
\DoxyCodeLine{458   apply}
\DoxyCodeLine{459     (}
\DoxyCodeLine{460           \mbox{\hyperlink{classMat}{Mat}}< std::complex<float> >\& C,}
\DoxyCodeLine{461     \textcolor{keyword}{const} TA\&                         \mbox{\hyperlink{structA}{A}},}
\DoxyCodeLine{462     \textcolor{keyword}{const} \textcolor{keywordtype}{float}                       alpha = \textcolor{keywordtype}{float}(1),}
\DoxyCodeLine{463     \textcolor{keyword}{const} \textcolor{keywordtype}{float}                       beta  = \textcolor{keywordtype}{float}(0)}
\DoxyCodeLine{464     )}
\DoxyCodeLine{465     \{}
\DoxyCodeLine{466     \mbox{\hyperlink{classherk}{herk<do\_trans\_A, use\_alpha, use\_beta>::apply\_blas\_type}}(C,\mbox{\hyperlink{structA}{A}},alpha,beta);}
\DoxyCodeLine{467     \}}
\DoxyCodeLine{468   }
\DoxyCodeLine{469   }
\DoxyCodeLine{470   }
\DoxyCodeLine{471   \textcolor{keyword}{template}<\textcolor{keyword}{typename} TA>}
\DoxyCodeLine{472   arma\_inline}
\DoxyCodeLine{473   \textcolor{keyword}{static}}
\DoxyCodeLine{474   \textcolor{keywordtype}{void}}
\DoxyCodeLine{475   apply}
\DoxyCodeLine{476     (}
\DoxyCodeLine{477           \mbox{\hyperlink{classMat}{Mat}}< std::complex<double> >\& C,}
\DoxyCodeLine{478     \textcolor{keyword}{const} TA\&                          \mbox{\hyperlink{structA}{A}},}
\DoxyCodeLine{479     \textcolor{keyword}{const} \textcolor{keywordtype}{double}                       alpha = \textcolor{keywordtype}{double}(1),}
\DoxyCodeLine{480     \textcolor{keyword}{const} \textcolor{keywordtype}{double}                       beta  = \textcolor{keywordtype}{double}(0)}
\DoxyCodeLine{481     )}
\DoxyCodeLine{482     \{}
\DoxyCodeLine{483     \mbox{\hyperlink{classherk}{herk<do\_trans\_A, use\_alpha, use\_beta>::apply\_blas\_type}}(C,\mbox{\hyperlink{structA}{A}},alpha,beta);}
\DoxyCodeLine{484     \}}
\DoxyCodeLine{485   }
\DoxyCodeLine{486   \};}
\DoxyCodeLine{487 }
\DoxyCodeLine{488 }
\DoxyCodeLine{489 }

\end{DoxyCode}
