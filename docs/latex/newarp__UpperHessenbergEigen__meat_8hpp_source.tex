\hypertarget{newarp__UpperHessenbergEigen__meat_8hpp_source}{}\doxysection{newarp\+\_\+\+Upper\+Hessenberg\+Eigen\+\_\+meat.\+hpp}
\label{newarp__UpperHessenbergEigen__meat_8hpp_source}\index{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/newarp\_UpperHessenbergEigen\_meat.hpp@{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/newarp\_UpperHessenbergEigen\_meat.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008-\/2016 Conrad Sanderson (http://conradsanderson.id.au)}}
\DoxyCodeLine{2 \textcolor{comment}{// Copyright 2008-\/2016 National ICT Australia (NICTA)}}
\DoxyCodeLine{3 \textcolor{comment}{// }}
\DoxyCodeLine{4 \textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{5 \textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{6 \textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{7 \textcolor{comment}{// http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{8 \textcolor{comment}{// }}
\DoxyCodeLine{9 \textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{10 \textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{11 \textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{12 \textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{13 \textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{14 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{17 \textcolor{keyword}{namespace }newarp}
\DoxyCodeLine{18 \{}
\DoxyCodeLine{19 }
\DoxyCodeLine{20 }
\DoxyCodeLine{21 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{22 \textcolor{keyword}{inline}}
\DoxyCodeLine{23 \mbox{\hyperlink{classnewarp_1_1UpperHessenbergEigen_a8da8a6eeec9eee77206cf244cc2684eb}{UpperHessenbergEigen<eT>::UpperHessenbergEigen}}()}
\DoxyCodeLine{24   : n(0)}
\DoxyCodeLine{25   , computed(false)}
\DoxyCodeLine{26   \{}
\DoxyCodeLine{27   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{28   \}}
\DoxyCodeLine{29 }
\DoxyCodeLine{30 }
\DoxyCodeLine{31 }
\DoxyCodeLine{32 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{33 \textcolor{keyword}{inline}}
\DoxyCodeLine{34 \mbox{\hyperlink{classnewarp_1_1UpperHessenbergEigen_a8da8a6eeec9eee77206cf244cc2684eb}{UpperHessenbergEigen<eT>::UpperHessenbergEigen}}(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& mat\_obj)}
\DoxyCodeLine{35   : n(mat\_obj.n\_rows)}
\DoxyCodeLine{36   , computed(false)}
\DoxyCodeLine{37   \{}
\DoxyCodeLine{38   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{39   }
\DoxyCodeLine{40   \mbox{\hyperlink{classnewarp_1_1UpperHessenbergEigen_a815a316c5f562ec790ad1dbb65c1001b}{compute}}(mat\_obj);}
\DoxyCodeLine{41   \}}
\DoxyCodeLine{42 }
\DoxyCodeLine{43 }
\DoxyCodeLine{44 }
\DoxyCodeLine{45 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{46 \textcolor{keyword}{inline}}
\DoxyCodeLine{47 \textcolor{keywordtype}{void}}
\DoxyCodeLine{48 \mbox{\hyperlink{classnewarp_1_1UpperHessenbergEigen_a815a316c5f562ec790ad1dbb65c1001b}{UpperHessenbergEigen<eT>::compute}}(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& mat\_obj)}
\DoxyCodeLine{49   \{}
\DoxyCodeLine{50   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{51   }
\DoxyCodeLine{52   arma\_debug\_check( (mat\_obj.\mbox{\hyperlink{group__Mat_ga1f860b22491beb19251642270d04d8f1}{is\_square}}() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}newarp::UpperHessenbergEigen::compute(): matrix must be square"{}} );}
\DoxyCodeLine{53   }
\DoxyCodeLine{54   n = blas\_int(mat\_obj.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}});}
\DoxyCodeLine{55   }
\DoxyCodeLine{56   mat\_Z.set\_size(n, n);}
\DoxyCodeLine{57   mat\_T.set\_size(n, n);}
\DoxyCodeLine{58   evals.set\_size(n);}
\DoxyCodeLine{59   }
\DoxyCodeLine{60   mat\_Z.eye();}
\DoxyCodeLine{61   mat\_T = mat\_obj;}
\DoxyCodeLine{62   }
\DoxyCodeLine{63   blas\_int want\_T = blas\_int(1);}
\DoxyCodeLine{64   blas\_int want\_Z = blas\_int(1);}
\DoxyCodeLine{65   }
\DoxyCodeLine{66   blas\_int ilo  = blas\_int(1);}
\DoxyCodeLine{67   blas\_int ihi  = blas\_int(n);}
\DoxyCodeLine{68   blas\_int iloz = blas\_int(1);}
\DoxyCodeLine{69   blas\_int ihiz = blas\_int(n);}
\DoxyCodeLine{70   }
\DoxyCodeLine{71   blas\_int info = blas\_int(0);}
\DoxyCodeLine{72   }
\DoxyCodeLine{73   \mbox{\hyperlink{classpodarray}{podarray<eT>}} wr(\textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(n));}
\DoxyCodeLine{74   \mbox{\hyperlink{classpodarray}{podarray<eT>}} wi(\textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(n));}
\DoxyCodeLine{75   }
\DoxyCodeLine{76   }
\DoxyCodeLine{77   lapack::lahqr(\&want\_T, \&want\_Z, \&n, \&ilo, \&ihi, mat\_T.memptr(), \&n, wr.memptr(), wi.memptr(), \&iloz, \&ihiz, mat\_Z.memptr(), \&n, \&info);}
\DoxyCodeLine{78   }
\DoxyCodeLine{79   \textcolor{keywordflow}{for}(blas\_int i = 0; i < n; i++)}
\DoxyCodeLine{80     \{}
\DoxyCodeLine{81     evals(i) = std::complex<eT>(wr[i], wi[i]);}
\DoxyCodeLine{82     \}}
\DoxyCodeLine{83   }
\DoxyCodeLine{84   \textcolor{keywordflow}{if}(info > 0)  \{ arma\_stop\_runtime\_error(\textcolor{stringliteral}{"{}lapack::lahqr(): failed to compute all eigenvalues"{}}); \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{85   }
\DoxyCodeLine{86   \textcolor{keywordtype}{char}     side   = \textcolor{charliteral}{'R'};}
\DoxyCodeLine{87   \textcolor{keywordtype}{char}     howmny = \textcolor{charliteral}{'B'};}
\DoxyCodeLine{88   blas\_int m      = blas\_int(0);}
\DoxyCodeLine{89   }
\DoxyCodeLine{90   \mbox{\hyperlink{classpodarray}{podarray<eT>}} work(\textcolor{keyword}{static\_cast<}uword\textcolor{keyword}{>}(3 * n));}
\DoxyCodeLine{91   }
\DoxyCodeLine{92   lapack::trevc(\&side, \&howmny, (blas\_int*) NULL, \&n, mat\_T.memptr(), \&n, (eT*) NULL, \&n, mat\_Z.memptr(), \&n, \&n, \&m, work.memptr(), \&info);}
\DoxyCodeLine{93   }
\DoxyCodeLine{94   \textcolor{keywordflow}{if}(info < 0)  \{ arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}lapack::trevc(): illegal value"{}}); \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{95   }
\DoxyCodeLine{96   computed = \textcolor{keyword}{true};}
\DoxyCodeLine{97   \}}
\DoxyCodeLine{98 }
\DoxyCodeLine{99 }
\DoxyCodeLine{100 }
\DoxyCodeLine{101 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{102 \textcolor{keyword}{inline}}
\DoxyCodeLine{103 \mbox{\hyperlink{classCol}{Col< std::complex<eT>}} >}
\DoxyCodeLine{104 \mbox{\hyperlink{classnewarp_1_1UpperHessenbergEigen_a1c0f3d5d4f0155fb40c5497c9bf0e009}{UpperHessenbergEigen<eT>::eigenvalues}}()}
\DoxyCodeLine{105   \{}
\DoxyCodeLine{106   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{107   }
\DoxyCodeLine{108   arma\_debug\_check( (computed == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}newarp::UpperHessenbergEigen::eigenvalues(): need to call compute() first"{}} );}
\DoxyCodeLine{109 }
\DoxyCodeLine{110   \textcolor{keywordflow}{return} evals;}
\DoxyCodeLine{111   \}}
\DoxyCodeLine{112 }
\DoxyCodeLine{113 }
\DoxyCodeLine{114 }
\DoxyCodeLine{115 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{116 \textcolor{keyword}{inline}}
\DoxyCodeLine{117 \mbox{\hyperlink{classMat}{Mat< std::complex<eT>}} >}
\DoxyCodeLine{118 \mbox{\hyperlink{classnewarp_1_1UpperHessenbergEigen_a3196bdf70cc62982ba599fcef540b6d1}{UpperHessenbergEigen<eT>::eigenvectors}}()}
\DoxyCodeLine{119   \{}
\DoxyCodeLine{120   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{121   }
\DoxyCodeLine{122   arma\_debug\_check( (computed == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}newarp::UpperHessenbergEigen::eigenvectors(): need to call compute() first"{}} );}
\DoxyCodeLine{123 }
\DoxyCodeLine{124   \textcolor{comment}{// Lapack will set the imaginary parts of real eigenvalues to be exact zero}}
\DoxyCodeLine{125   \mbox{\hyperlink{classMat}{Mat< std::complex<eT>}} > evecs(n, n, \mbox{\hyperlink{structarma__zeros__indicator}{arma\_zeros\_indicator}}());}
\DoxyCodeLine{126   }
\DoxyCodeLine{127   std::complex<eT>* col\_ptr = evecs.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{128   }
\DoxyCodeLine{129   \textcolor{keywordflow}{for}(blas\_int i = 0; i < n; i++)}
\DoxyCodeLine{130     \{}
\DoxyCodeLine{131     \textcolor{keywordflow}{if}(cx\_attrib::is\_real(evals(i), eT(0)))}
\DoxyCodeLine{132       \{}
\DoxyCodeLine{133       \textcolor{comment}{// for real eigenvector, normalise and copy}}
\DoxyCodeLine{134       eT z\_norm = norm(mat\_Z.col(i));}
\DoxyCodeLine{135       }
\DoxyCodeLine{136       \textcolor{keywordflow}{for}(blas\_int j = 0; j < n; j++)}
\DoxyCodeLine{137         \{}
\DoxyCodeLine{138         col\_ptr[j] = std::complex<eT>(mat\_Z(j, i) / z\_norm, eT(0));}
\DoxyCodeLine{139         \}}
\DoxyCodeLine{140 }
\DoxyCodeLine{141       col\_ptr += n;}
\DoxyCodeLine{142       \}}
\DoxyCodeLine{143     \textcolor{keywordflow}{else}}
\DoxyCodeLine{144       \{}
\DoxyCodeLine{145       \textcolor{comment}{// complex eigenvectors are stored in consecutive columns}}
\DoxyCodeLine{146       eT r2 = dot(mat\_Z.col(i), mat\_Z.col(i));}
\DoxyCodeLine{147       eT i2 = dot(mat\_Z.col(i + 1), mat\_Z.col(i + 1));}
\DoxyCodeLine{148       }
\DoxyCodeLine{149       eT  z\_norm = std::sqrt(r2 + i2);}
\DoxyCodeLine{150       eT* z\_ptr  = mat\_Z.colptr(i);}
\DoxyCodeLine{151       }
\DoxyCodeLine{152       \textcolor{keywordflow}{for}(blas\_int j = 0; j < n; j++)}
\DoxyCodeLine{153         \{}
\DoxyCodeLine{154         col\_ptr[j    ] = std::complex<eT>(z\_ptr[j] / z\_norm, z\_ptr[j + n] / z\_norm);}
\DoxyCodeLine{155         col\_ptr[j + n] = std::conj(col\_ptr[j]);}
\DoxyCodeLine{156         \}}
\DoxyCodeLine{157 }
\DoxyCodeLine{158       i++;}
\DoxyCodeLine{159       col\_ptr += 2 * n;}
\DoxyCodeLine{160       \}}
\DoxyCodeLine{161     \}}
\DoxyCodeLine{162 }
\DoxyCodeLine{163   \textcolor{keywordflow}{return} evecs;}
\DoxyCodeLine{164   \}}
\DoxyCodeLine{165 }
\DoxyCodeLine{166 }
\DoxyCodeLine{167 \}  \textcolor{comment}{// namespace newarp}}

\end{DoxyCode}
