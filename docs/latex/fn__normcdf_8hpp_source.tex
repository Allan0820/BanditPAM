\hypertarget{fn__normcdf_8hpp_source}{}\doxysection{fn\+\_\+normcdf.\+hpp}
\label{fn__normcdf_8hpp_source}\index{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/fn\_normcdf.hpp@{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/fn\_normcdf.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008-\/2016 Conrad Sanderson (http://conradsanderson.id.au)}}
\DoxyCodeLine{2 \textcolor{comment}{// Copyright 2008-\/2016 National ICT Australia (NICTA)}}
\DoxyCodeLine{3 \textcolor{comment}{// }}
\DoxyCodeLine{4 \textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{5 \textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{6 \textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{7 \textcolor{comment}{// http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{8 \textcolor{comment}{// }}
\DoxyCodeLine{9 \textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{10 \textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{11 \textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{12 \textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{13 \textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{14 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{19 }
\DoxyCodeLine{20 }
\DoxyCodeLine{21 }
\DoxyCodeLine{22 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2, \textcolor{keyword}{typename} T3>}
\DoxyCodeLine{23 \textcolor{keyword}{inline}}
\DoxyCodeLine{24 \textcolor{keyword}{typename} \mbox{\hyperlink{structenable__if2}{enable\_if2}}< (\mbox{\hyperlink{structis__real}{is\_real<typename T1::elem\_type>::value}}), \textcolor{keywordtype}{void} >::result}
\DoxyCodeLine{25 normcdf\_helper(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::elem\_type, T1>}}\& X\_expr, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::elem\_type, T2>}}\& M\_expr, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::elem\_type, T3>}}\& S\_expr)}
\DoxyCodeLine{26   \{}
\DoxyCodeLine{27   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{28   }
\DoxyCodeLine{29   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{30   }
\DoxyCodeLine{31   \textcolor{keywordflow}{if}(\mbox{\hyperlink{classProxy}{Proxy<T1>::use\_at}} || \mbox{\hyperlink{classProxy}{Proxy<T2>::use\_at}} || \mbox{\hyperlink{classProxy}{Proxy<T3>::use\_at}})}
\DoxyCodeLine{32     \{}
\DoxyCodeLine{33     \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} UX(X\_expr.get\_ref());}
\DoxyCodeLine{34     \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T2>}} UM(M\_expr.get\_ref());}
\DoxyCodeLine{35     \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T3>}} US(S\_expr.get\_ref());}
\DoxyCodeLine{36     }
\DoxyCodeLine{37     normcdf\_helper(out, UX.M, UM.M, US.M);}
\DoxyCodeLine{38     }
\DoxyCodeLine{39     \textcolor{keywordflow}{return};}
\DoxyCodeLine{40     \}}
\DoxyCodeLine{41   }
\DoxyCodeLine{42   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} PX(X\_expr.get\_ref());}
\DoxyCodeLine{43   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T2>}} PM(M\_expr.get\_ref());}
\DoxyCodeLine{44   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T3>}} PS(S\_expr.get\_ref());}
\DoxyCodeLine{45   }
\DoxyCodeLine{46   arma\_debug\_check( ( (PX.get\_n\_rows() != PM.get\_n\_rows()) || (PX.get\_n\_cols() != PM.get\_n\_cols()) || (PM.get\_n\_rows() != PS.get\_n\_rows()) || (PM.get\_n\_cols() != PS.get\_n\_cols()) ), \textcolor{stringliteral}{"{}normcdf(): size mismatch"{}} );}
\DoxyCodeLine{47   }
\DoxyCodeLine{48   out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(PX.get\_n\_rows(), PX.get\_n\_cols());}
\DoxyCodeLine{49   }
\DoxyCodeLine{50   eT* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{51   }
\DoxyCodeLine{52   \textcolor{keyword}{const} uword N = PX.get\_n\_elem();}
\DoxyCodeLine{53   }
\DoxyCodeLine{54   \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::ea\_type}} X\_ea = PX.get\_ea();}
\DoxyCodeLine{55   \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T2>::ea\_type}} M\_ea = PM.get\_ea();}
\DoxyCodeLine{56   \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T3>::ea\_type}} S\_ea = PS.get\_ea();}
\DoxyCodeLine{57   }
\DoxyCodeLine{58   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_mp = arma\_config::openmp \&\& \mbox{\hyperlink{structmp__gate}{mp\_gate<eT,true>::eval}}(N);}
\DoxyCodeLine{59   }
\DoxyCodeLine{60   \textcolor{keywordflow}{if}(use\_mp)}
\DoxyCodeLine{61     \{}
\DoxyCodeLine{62 \textcolor{preprocessor}{    \#if defined(ARMA\_USE\_OPENMP)}}
\DoxyCodeLine{63       \{}
\DoxyCodeLine{64       \textcolor{keyword}{const} \textcolor{keywordtype}{int} n\_threads = mp\_thread\_limit::get();}
\DoxyCodeLine{65 \textcolor{preprocessor}{      \#pragma omp parallel for schedule(static) num\_threads(n\_threads)}}
\DoxyCodeLine{66       \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)}
\DoxyCodeLine{67         \{}
\DoxyCodeLine{68         \textcolor{keyword}{const} eT tmp = (X\_ea[i] -\/ M\_ea[i]) / (S\_ea[i] * (-\/\mbox{\hyperlink{classDatum}{Datum<eT>::sqrt2}}));}
\DoxyCodeLine{69         }
\DoxyCodeLine{70         out\_mem[i] = eT(0.5) * std::erfc(tmp);}
\DoxyCodeLine{71         \}}
\DoxyCodeLine{72       \}}
\DoxyCodeLine{73 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{74     \}}
\DoxyCodeLine{75   \textcolor{keywordflow}{else}}
\DoxyCodeLine{76     \{}
\DoxyCodeLine{77     \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)}
\DoxyCodeLine{78       \{}
\DoxyCodeLine{79       \textcolor{keyword}{const} eT tmp = (X\_ea[i] -\/ M\_ea[i]) / (S\_ea[i] * (-\/\mbox{\hyperlink{classDatum}{Datum<eT>::sqrt2}}));}
\DoxyCodeLine{80       }
\DoxyCodeLine{81       out\_mem[i] = eT(0.5) * std::erfc(tmp);}
\DoxyCodeLine{82       \}}
\DoxyCodeLine{83     \}}
\DoxyCodeLine{84   \}}
\DoxyCodeLine{85 }
\DoxyCodeLine{86 }
\DoxyCodeLine{87 }
\DoxyCodeLine{88 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{89 \textcolor{keyword}{inline}}
\DoxyCodeLine{90 arma\_warn\_unused}
\DoxyCodeLine{91 \textcolor{keyword}{typename} \mbox{\hyperlink{structenable__if2}{enable\_if2}}< (\mbox{\hyperlink{structis__real}{is\_real<eT>::value}}), eT >::result}
\DoxyCodeLine{92 normcdf(\textcolor{keyword}{const} eT x)}
\DoxyCodeLine{93   \{}
\DoxyCodeLine{94   \textcolor{keyword}{const} eT out = eT(0.5) * std::erfc( x / (-\/\mbox{\hyperlink{classDatum}{Datum<eT>::sqrt2}}) );}
\DoxyCodeLine{95   }
\DoxyCodeLine{96   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{97   \}}
\DoxyCodeLine{98 }
\DoxyCodeLine{99 }
\DoxyCodeLine{100 }
\DoxyCodeLine{101 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{102 \textcolor{keyword}{inline}}
\DoxyCodeLine{103 arma\_warn\_unused}
\DoxyCodeLine{104 \textcolor{keyword}{typename} \mbox{\hyperlink{structenable__if2}{enable\_if2}}< (\mbox{\hyperlink{structis__real}{is\_real<eT>::value}}), eT >::result}
\DoxyCodeLine{105 normcdf(\textcolor{keyword}{const} eT x, \textcolor{keyword}{const} eT mu, \textcolor{keyword}{const} eT sigma)}
\DoxyCodeLine{106   \{}
\DoxyCodeLine{107   \textcolor{keyword}{const} eT tmp = (x -\/ mu) / (sigma * (-\/\mbox{\hyperlink{classDatum}{Datum<eT>::sqrt2}}));}
\DoxyCodeLine{108   }
\DoxyCodeLine{109   \textcolor{keyword}{const} eT out = eT(0.5) * std::erfc(tmp);}
\DoxyCodeLine{110   }
\DoxyCodeLine{111   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{112   \}}
\DoxyCodeLine{113 }
\DoxyCodeLine{114 }
\DoxyCodeLine{115 }
\DoxyCodeLine{116 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT, \textcolor{keyword}{typename} T2, \textcolor{keyword}{typename} T3>}
\DoxyCodeLine{117 \textcolor{keyword}{inline}}
\DoxyCodeLine{118 arma\_warn\_unused}
\DoxyCodeLine{119 \textcolor{keyword}{typename} \mbox{\hyperlink{structenable__if2}{enable\_if2}}< (\mbox{\hyperlink{structis__real}{is\_real<eT>::value}}), \mbox{\hyperlink{classMat}{Mat<eT>}} >::result}
\DoxyCodeLine{120 normcdf(\textcolor{keyword}{const} eT x, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<eT, T2>}}\& M\_expr, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<eT, T3>}}\& S\_expr)}
\DoxyCodeLine{121   \{}
\DoxyCodeLine{122   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{123   }
\DoxyCodeLine{124   \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T2>}} UM(M\_expr.get\_ref());}
\DoxyCodeLine{125   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\&     M = UM.M;}
\DoxyCodeLine{126   }
\DoxyCodeLine{127   \mbox{\hyperlink{classMat}{Mat<eT>}} out;}
\DoxyCodeLine{128   }
\DoxyCodeLine{129   normcdf\_helper(out, x*ones< \mbox{\hyperlink{classMat}{Mat<eT>}} >(arma::size(M)), M, S\_expr.get\_ref());}
\DoxyCodeLine{130   }
\DoxyCodeLine{131   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{132   \}}
\DoxyCodeLine{133 }
\DoxyCodeLine{134 }
\DoxyCodeLine{135 }
\DoxyCodeLine{136 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{137 \textcolor{keyword}{inline}}
\DoxyCodeLine{138 arma\_warn\_unused}
\DoxyCodeLine{139 \textcolor{keyword}{typename} \mbox{\hyperlink{structenable__if2}{enable\_if2}}< (\mbox{\hyperlink{structis__real}{is\_real<typename T1::elem\_type>::value}}), \mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}} >::result}
\DoxyCodeLine{140 normcdf(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::elem\_type, T1>}}\& X\_expr)}
\DoxyCodeLine{141   \{}
\DoxyCodeLine{142   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{143   }
\DoxyCodeLine{144   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{145   }
\DoxyCodeLine{146   \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} UX(X\_expr.get\_ref());}
\DoxyCodeLine{147   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\&     X = UX.M;}
\DoxyCodeLine{148   }
\DoxyCodeLine{149   \mbox{\hyperlink{classMat}{Mat<eT>}} out;}
\DoxyCodeLine{150   }
\DoxyCodeLine{151   normcdf\_helper(out, X, zeros< \mbox{\hyperlink{classMat}{Mat<eT>}} >(arma::size(X)), ones< \mbox{\hyperlink{classMat}{Mat<eT>}} >(arma::size(X)));}
\DoxyCodeLine{152   }
\DoxyCodeLine{153   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{154   \}}
\DoxyCodeLine{155 }
\DoxyCodeLine{156 }
\DoxyCodeLine{157 }
\DoxyCodeLine{158 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{159 \textcolor{keyword}{inline}}
\DoxyCodeLine{160 arma\_warn\_unused}
\DoxyCodeLine{161 \textcolor{keyword}{typename} \mbox{\hyperlink{structenable__if2}{enable\_if2}}< (\mbox{\hyperlink{structis__real}{is\_real<typename T1::elem\_type>::value}}), \mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}} >::result}
\DoxyCodeLine{162 normcdf(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::elem\_type, T1>}}\& X\_expr, \textcolor{keyword}{const} \textcolor{keyword}{typename} T1::elem\_type mu, \textcolor{keyword}{const} \textcolor{keyword}{typename} T1::elem\_type sigma)}
\DoxyCodeLine{163   \{}
\DoxyCodeLine{164   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{165   }
\DoxyCodeLine{166   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{167   }
\DoxyCodeLine{168   \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} UX(X\_expr.get\_ref());}
\DoxyCodeLine{169   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\&     X = UX.M;}
\DoxyCodeLine{170   }
\DoxyCodeLine{171   \mbox{\hyperlink{classMat}{Mat<eT>}} out;}
\DoxyCodeLine{172   }
\DoxyCodeLine{173   normcdf\_helper(out, X, mu*ones< \mbox{\hyperlink{classMat}{Mat<eT>}} >(arma::size(X)), sigma*ones< \mbox{\hyperlink{classMat}{Mat<eT>}} >(arma::size(X)));}
\DoxyCodeLine{174   }
\DoxyCodeLine{175   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{176   \}}
\DoxyCodeLine{177 }
\DoxyCodeLine{178 }
\DoxyCodeLine{179 }
\DoxyCodeLine{180 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2, \textcolor{keyword}{typename} T3>}
\DoxyCodeLine{181 \textcolor{keyword}{inline}}
\DoxyCodeLine{182 arma\_warn\_unused}
\DoxyCodeLine{183 \textcolor{keyword}{typename} \mbox{\hyperlink{structenable__if2}{enable\_if2}}< (\mbox{\hyperlink{structis__real}{is\_real<typename T1::elem\_type>::value}}), \mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}} >::result}
\DoxyCodeLine{184 normcdf(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::elem\_type, T1>}}\& X\_expr, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::elem\_type, T2>}}\& M\_expr, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::elem\_type, T3>}}\& S\_expr)}
\DoxyCodeLine{185   \{}
\DoxyCodeLine{186   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{187   }
\DoxyCodeLine{188   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{189   }
\DoxyCodeLine{190   \mbox{\hyperlink{classMat}{Mat<eT>}} out;}
\DoxyCodeLine{191   }
\DoxyCodeLine{192   normcdf\_helper(out, X\_expr.get\_ref(), M\_expr.get\_ref(), S\_expr.get\_ref());}
\DoxyCodeLine{193   }
\DoxyCodeLine{194   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{195   \}}
\DoxyCodeLine{196 }
\DoxyCodeLine{197 }
\DoxyCodeLine{198 }

\end{DoxyCode}
