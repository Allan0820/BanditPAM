\hypertarget{op__index__min__meat_8hpp_source}{}\doxysection{op\+\_\+index\+\_\+min\+\_\+meat.\+hpp}
\label{op__index__min__meat_8hpp_source}\index{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/op\_index\_min\_meat.hpp@{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/op\_index\_min\_meat.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008-\/2016 Conrad Sanderson (http://conradsanderson.id.au)}}
\DoxyCodeLine{2 \textcolor{comment}{// Copyright 2008-\/2016 National ICT Australia (NICTA)}}
\DoxyCodeLine{3 \textcolor{comment}{// }}
\DoxyCodeLine{4 \textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{5 \textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{6 \textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{7 \textcolor{comment}{// http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{8 \textcolor{comment}{// }}
\DoxyCodeLine{9 \textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{10 \textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{11 \textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{12 \textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{13 \textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{14 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{19 }
\DoxyCodeLine{20 }
\DoxyCodeLine{21 }
\DoxyCodeLine{22 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{23 \textcolor{keyword}{inline}}
\DoxyCodeLine{24 \textcolor{keywordtype}{void}}
\DoxyCodeLine{25 op\_index\_min::apply(\mbox{\hyperlink{classMat}{Mat<uword>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classmtOp}{mtOp<uword,T1,op\_index\_min>}}\& in)}
\DoxyCodeLine{26   \{}
\DoxyCodeLine{27   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{28   }
\DoxyCodeLine{29   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{30   }
\DoxyCodeLine{31   \textcolor{keyword}{const} uword dim = in.\mbox{\hyperlink{classmtOp_aa3be9e3923050ab93ceb94dbdb958aa7}{aux\_uword\_a}};}
\DoxyCodeLine{32   arma\_debug\_check( (dim > 1), \textcolor{stringliteral}{"{}index\_min(): parameter 'dim' must be 0 or 1"{}} );}
\DoxyCodeLine{33   }
\DoxyCodeLine{34   \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} U(in.\mbox{\hyperlink{classmtOp_a36bff6e38e68a900a5d4f1443d7f6dc2}{m}});}
\DoxyCodeLine{35   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X = U.M;}
\DoxyCodeLine{36   }
\DoxyCodeLine{37   \textcolor{keywordflow}{if}(U.is\_alias(out) == \textcolor{keyword}{false})}
\DoxyCodeLine{38     \{}
\DoxyCodeLine{39     op\_index\_min::apply\_noalias(out, X, dim);}
\DoxyCodeLine{40     \}}
\DoxyCodeLine{41   \textcolor{keywordflow}{else}}
\DoxyCodeLine{42     \{}
\DoxyCodeLine{43     \mbox{\hyperlink{classMat}{Mat<uword>}} tmp;}
\DoxyCodeLine{44     }
\DoxyCodeLine{45     op\_index\_min::apply\_noalias(tmp, X, dim);}
\DoxyCodeLine{46     }
\DoxyCodeLine{47     out.\mbox{\hyperlink{group__Mat_gaff06a75771f96605f7cc4f8c6b3fceb7}{steal\_mem}}(tmp);}
\DoxyCodeLine{48     \}}
\DoxyCodeLine{49   \}}
\DoxyCodeLine{50 }
\DoxyCodeLine{51 }
\DoxyCodeLine{52 }
\DoxyCodeLine{53 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{54 \textcolor{keyword}{inline}}
\DoxyCodeLine{55 \textcolor{keywordtype}{void}}
\DoxyCodeLine{56 op\_index\_min::apply\_noalias(\mbox{\hyperlink{classMat}{Mat<uword>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X, \textcolor{keyword}{const} uword dim)}
\DoxyCodeLine{57   \{}
\DoxyCodeLine{58   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{59   }
\DoxyCodeLine{60   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} get\_pod\_type<eT>::result T;}
\DoxyCodeLine{61   }
\DoxyCodeLine{62   \textcolor{keyword}{const} uword X\_n\_rows = X.n\_rows;}
\DoxyCodeLine{63   \textcolor{keyword}{const} uword X\_n\_cols = X.n\_cols;}
\DoxyCodeLine{64   }
\DoxyCodeLine{65   \textcolor{keywordflow}{if}(dim == 0)}
\DoxyCodeLine{66     \{}
\DoxyCodeLine{67     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}op\_index\_min::apply(): dim = 0"{}});}
\DoxyCodeLine{68     }
\DoxyCodeLine{69     out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}((X\_n\_rows > 0) ? 1 : 0, X\_n\_cols);}
\DoxyCodeLine{70     }
\DoxyCodeLine{71     \textcolor{keywordflow}{if}(X\_n\_rows == 0)  \{ \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{72     }
\DoxyCodeLine{73     uword* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{74     }
\DoxyCodeLine{75     \textcolor{keywordflow}{for}(uword col=0; col < X\_n\_cols; ++col)}
\DoxyCodeLine{76       \{}
\DoxyCodeLine{77       op\_min::direct\_min( X.colptr(col), X\_n\_rows, out\_mem[col] );}
\DoxyCodeLine{78       \}}
\DoxyCodeLine{79     \}}
\DoxyCodeLine{80   \textcolor{keywordflow}{else}}
\DoxyCodeLine{81   \textcolor{keywordflow}{if}(dim == 1)}
\DoxyCodeLine{82     \{}
\DoxyCodeLine{83     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}op\_index\_min::apply(): dim = 1"{}});}
\DoxyCodeLine{84     }
\DoxyCodeLine{85     out.zeros(X\_n\_rows, (X\_n\_cols > 0) ? 1 : 0);}
\DoxyCodeLine{86     }
\DoxyCodeLine{87     \textcolor{keywordflow}{if}(X\_n\_cols == 0)  \{ \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{88     }
\DoxyCodeLine{89     uword* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{90     }
\DoxyCodeLine{91     \mbox{\hyperlink{classCol}{Col<T>}} tmp(X\_n\_rows, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{92     }
\DoxyCodeLine{93     T* tmp\_mem = tmp.memptr();}
\DoxyCodeLine{94     }
\DoxyCodeLine{95     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__cx}{is\_cx<eT>::yes}})}
\DoxyCodeLine{96       \{}
\DoxyCodeLine{97       \textcolor{keyword}{const} eT* col\_mem = X.colptr(0);}
\DoxyCodeLine{98       }
\DoxyCodeLine{99       \textcolor{keywordflow}{for}(uword row=0; row < X\_n\_rows; ++row)}
\DoxyCodeLine{100         \{}
\DoxyCodeLine{101         tmp\_mem[row] = eop\_aux::arma\_abs(col\_mem[row]);}
\DoxyCodeLine{102         \}}
\DoxyCodeLine{103       \}}
\DoxyCodeLine{104     \textcolor{keywordflow}{else}}
\DoxyCodeLine{105       \{}
\DoxyCodeLine{106       arrayops::copy(tmp\_mem, (T*)(X.colptr(0)), X\_n\_rows);}
\DoxyCodeLine{107       \}}
\DoxyCodeLine{108     }
\DoxyCodeLine{109     \textcolor{keywordflow}{for}(uword col=1; col < X\_n\_cols; ++col)}
\DoxyCodeLine{110       \{}
\DoxyCodeLine{111       \textcolor{keyword}{const} eT* col\_mem = X.colptr(col);}
\DoxyCodeLine{112       }
\DoxyCodeLine{113       \textcolor{keywordflow}{for}(uword row=0; row < X\_n\_rows; ++row)}
\DoxyCodeLine{114         \{}
\DoxyCodeLine{115         T\& min\_val = tmp\_mem[row];}
\DoxyCodeLine{116         T  col\_val = (\mbox{\hyperlink{structis__cx}{is\_cx<eT>::yes}}) ? T(eop\_aux::arma\_abs(col\_mem[row])) : T(\mbox{\hyperlink{classaccess_a9687cee4d2be0fe591998d6f5c6d0849}{access::tmp\_real}}(col\_mem[row]));}
\DoxyCodeLine{117         }
\DoxyCodeLine{118         \textcolor{keywordflow}{if}(min\_val > col\_val)}
\DoxyCodeLine{119           \{}
\DoxyCodeLine{120           min\_val = col\_val;}
\DoxyCodeLine{121           }
\DoxyCodeLine{122           out\_mem[row] = col;}
\DoxyCodeLine{123           \}}
\DoxyCodeLine{124         \}}
\DoxyCodeLine{125       \}}
\DoxyCodeLine{126     \}}
\DoxyCodeLine{127   \}}
\DoxyCodeLine{128 }
\DoxyCodeLine{129 }
\DoxyCodeLine{130 }
\DoxyCodeLine{131 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{132 \textcolor{keyword}{inline}}
\DoxyCodeLine{133 \textcolor{keywordtype}{void}}
\DoxyCodeLine{134 op\_index\_min::apply(\mbox{\hyperlink{classCube}{Cube<uword>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classmtOpCube}{mtOpCube<uword, T1, op\_index\_min>}}\& in)}
\DoxyCodeLine{135   \{}
\DoxyCodeLine{136   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{137   }
\DoxyCodeLine{138   \textcolor{keyword}{const} uword dim = in.\mbox{\hyperlink{classmtOpCube_a708fbc4848b0f9020dd9fbd663e0a1e5}{aux\_uword\_a}};}
\DoxyCodeLine{139   arma\_debug\_check( (dim > 2), \textcolor{stringliteral}{"{}index\_min(): parameter 'dim' must be 0 or 1 or 2"{}} );}
\DoxyCodeLine{140   }
\DoxyCodeLine{141   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap__cube}{unwrap\_cube<T1>}} U(in.\mbox{\hyperlink{classmtOpCube_a138bd6382aa304713adf55d2357b220d}{m}});}
\DoxyCodeLine{142   }
\DoxyCodeLine{143   \textcolor{keywordflow}{if}(U.is\_alias(out) == \textcolor{keyword}{false})}
\DoxyCodeLine{144     \{}
\DoxyCodeLine{145     op\_index\_min::apply\_noalias(out, U.M, dim);}
\DoxyCodeLine{146     \}}
\DoxyCodeLine{147   \textcolor{keywordflow}{else}}
\DoxyCodeLine{148     \{}
\DoxyCodeLine{149     \mbox{\hyperlink{classCube}{Cube<uword>}} tmp;}
\DoxyCodeLine{150     }
\DoxyCodeLine{151     op\_index\_min::apply\_noalias(tmp, U.M, dim);}
\DoxyCodeLine{152     }
\DoxyCodeLine{153     out.\mbox{\hyperlink{group__Cube_ga70006d5a49f67d35d4ae10cb6c5a681f}{steal\_mem}}(tmp);}
\DoxyCodeLine{154     \}}
\DoxyCodeLine{155   \}}
\DoxyCodeLine{156 }
\DoxyCodeLine{157 }
\DoxyCodeLine{158 }
\DoxyCodeLine{159 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{160 \textcolor{keyword}{inline}}
\DoxyCodeLine{161 \textcolor{keywordtype}{void}}
\DoxyCodeLine{162 op\_index\_min::apply\_noalias(\mbox{\hyperlink{classCube}{Cube<uword>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classCube}{Cube<eT>}}\& X, \textcolor{keyword}{const} uword dim, \textcolor{keyword}{const} \textcolor{keyword}{typename} arma\_not\_cx<eT>::result* junk)}
\DoxyCodeLine{163   \{}
\DoxyCodeLine{164   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{165   arma\_ignore(junk);}
\DoxyCodeLine{166   }
\DoxyCodeLine{167   \textcolor{keyword}{const} uword X\_n\_rows   = X.n\_rows;}
\DoxyCodeLine{168   \textcolor{keyword}{const} uword X\_n\_cols   = X.n\_cols;}
\DoxyCodeLine{169   \textcolor{keyword}{const} uword X\_n\_slices = X.n\_slices;}
\DoxyCodeLine{170   }
\DoxyCodeLine{171   \textcolor{keywordflow}{if}(dim == 0)}
\DoxyCodeLine{172     \{}
\DoxyCodeLine{173     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}op\_index\_min::apply(): dim = 0"{}});}
\DoxyCodeLine{174     }
\DoxyCodeLine{175     out.\mbox{\hyperlink{group__Cube_ga0d461586030945472fe66f7364882771}{set\_size}}((X\_n\_rows > 0) ? 1 : 0, X\_n\_cols, X\_n\_slices);}
\DoxyCodeLine{176     }
\DoxyCodeLine{177     \textcolor{keywordflow}{if}(out.\mbox{\hyperlink{group__Cube_gaecc2db3371bc45d670ca59e6be7d6abc}{is\_empty}}() || X.is\_empty())  \{ \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{178     }
\DoxyCodeLine{179     \textcolor{keywordflow}{for}(uword \mbox{\hyperlink{classslice}{slice}}=0; \mbox{\hyperlink{classslice}{slice}} < X\_n\_slices; ++\mbox{\hyperlink{classslice}{slice}})}
\DoxyCodeLine{180       \{}
\DoxyCodeLine{181       uword* out\_mem = out.\mbox{\hyperlink{group__Cube_gaa880766c421f4a9f006662c7fd96850e}{slice\_memptr}}(\mbox{\hyperlink{classslice}{slice}});}
\DoxyCodeLine{182       }
\DoxyCodeLine{183       \textcolor{keywordflow}{for}(uword col=0; col < X\_n\_cols; ++col)}
\DoxyCodeLine{184         \{}
\DoxyCodeLine{185         op\_min::direct\_min( X.slice\_colptr(\mbox{\hyperlink{classslice}{slice}},col), X\_n\_rows, out\_mem[col] );}
\DoxyCodeLine{186         \}}
\DoxyCodeLine{187       \}}
\DoxyCodeLine{188     \}}
\DoxyCodeLine{189   \textcolor{keywordflow}{else}}
\DoxyCodeLine{190   \textcolor{keywordflow}{if}(dim == 1)}
\DoxyCodeLine{191     \{}
\DoxyCodeLine{192     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}op\_index\_min::apply(): dim = 1"{}});}
\DoxyCodeLine{193     }
\DoxyCodeLine{194     out.zeros(X\_n\_rows, (X\_n\_cols > 0) ? 1 : 0, X\_n\_slices);}
\DoxyCodeLine{195     }
\DoxyCodeLine{196     \textcolor{keywordflow}{if}(out.\mbox{\hyperlink{group__Cube_gaecc2db3371bc45d670ca59e6be7d6abc}{is\_empty}}() || X.is\_empty())  \{ \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{197     }
\DoxyCodeLine{198     \mbox{\hyperlink{classCol}{Col<eT>}} tmp(X\_n\_rows, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{199     }
\DoxyCodeLine{200     eT* tmp\_mem = tmp.memptr();}
\DoxyCodeLine{201     }
\DoxyCodeLine{202     \textcolor{keywordflow}{for}(uword \mbox{\hyperlink{classslice}{slice}}=0; \mbox{\hyperlink{classslice}{slice}} < X\_n\_slices; ++\mbox{\hyperlink{classslice}{slice}})}
\DoxyCodeLine{203       \{}
\DoxyCodeLine{204       uword* out\_mem = out.\mbox{\hyperlink{group__Cube_gaa880766c421f4a9f006662c7fd96850e}{slice\_memptr}}(\mbox{\hyperlink{classslice}{slice}});}
\DoxyCodeLine{205       }
\DoxyCodeLine{206       arrayops::copy(tmp\_mem, X.slice\_colptr(\mbox{\hyperlink{classslice}{slice}},0), X\_n\_rows);}
\DoxyCodeLine{207       }
\DoxyCodeLine{208       \textcolor{keywordflow}{for}(uword col=1; col < X\_n\_cols; ++col)}
\DoxyCodeLine{209         \{}
\DoxyCodeLine{210         \textcolor{keyword}{const} eT* col\_mem = X.slice\_colptr(\mbox{\hyperlink{classslice}{slice}},col);}
\DoxyCodeLine{211         }
\DoxyCodeLine{212         \textcolor{keywordflow}{for}(uword row=0; row < X\_n\_rows; ++row)}
\DoxyCodeLine{213           \{}
\DoxyCodeLine{214           \textcolor{keyword}{const} eT val = col\_mem[row];}
\DoxyCodeLine{215           }
\DoxyCodeLine{216           \textcolor{keywordflow}{if}(val < tmp\_mem[row])}
\DoxyCodeLine{217             \{}
\DoxyCodeLine{218             tmp\_mem[row] = val;}
\DoxyCodeLine{219             out\_mem[row] = col;}
\DoxyCodeLine{220             \}}
\DoxyCodeLine{221           \}}
\DoxyCodeLine{222         \}}
\DoxyCodeLine{223       \}}
\DoxyCodeLine{224     \}}
\DoxyCodeLine{225   \textcolor{keywordflow}{else}}
\DoxyCodeLine{226   \textcolor{keywordflow}{if}(dim == 2)}
\DoxyCodeLine{227     \{}
\DoxyCodeLine{228     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}op\_index\_min::apply(): dim = 2"{}});}
\DoxyCodeLine{229     }
\DoxyCodeLine{230     out.zeros(X\_n\_rows, X\_n\_cols, (X\_n\_slices > 0) ? 1 : 0);}
\DoxyCodeLine{231     }
\DoxyCodeLine{232     \textcolor{keywordflow}{if}(out.\mbox{\hyperlink{group__Cube_gaecc2db3371bc45d670ca59e6be7d6abc}{is\_empty}}() || X.is\_empty())  \{ \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{233     }
\DoxyCodeLine{234     \mbox{\hyperlink{classMat}{Mat<eT>}} tmp(X.slice\_memptr(0), X\_n\_rows, X\_n\_cols);  \textcolor{comment}{// copy slice 0}}
\DoxyCodeLine{235     }
\DoxyCodeLine{236     eT*    tmp\_mem = tmp.memptr();}
\DoxyCodeLine{237     uword* out\_mem = out.\mbox{\hyperlink{group__Cube_ga5b00237224a8e3bfb05728de7c962f85}{memptr}}();}
\DoxyCodeLine{238     }
\DoxyCodeLine{239     \textcolor{keyword}{const} uword N = X.n\_elem\_slice;}
\DoxyCodeLine{240     }
\DoxyCodeLine{241     \textcolor{keywordflow}{for}(uword \mbox{\hyperlink{classslice}{slice}}=1; \mbox{\hyperlink{classslice}{slice}} < X\_n\_slices; ++\mbox{\hyperlink{classslice}{slice}})}
\DoxyCodeLine{242       \{}
\DoxyCodeLine{243       \textcolor{keyword}{const} eT* X\_slice\_mem = X.slice\_memptr(\mbox{\hyperlink{classslice}{slice}});}
\DoxyCodeLine{244       }
\DoxyCodeLine{245       \textcolor{keywordflow}{for}(uword i=0; i < N; ++i)}
\DoxyCodeLine{246         \{}
\DoxyCodeLine{247         \textcolor{keyword}{const} eT val = X\_slice\_mem[i];}
\DoxyCodeLine{248         }
\DoxyCodeLine{249         \textcolor{keywordflow}{if}(val < tmp\_mem[i])}
\DoxyCodeLine{250           \{}
\DoxyCodeLine{251           tmp\_mem[i] = val;}
\DoxyCodeLine{252           out\_mem[i] = \mbox{\hyperlink{classslice}{slice}};}
\DoxyCodeLine{253           \}}
\DoxyCodeLine{254         \}}
\DoxyCodeLine{255       \}}
\DoxyCodeLine{256     \}}
\DoxyCodeLine{257   \}}
\DoxyCodeLine{258 }
\DoxyCodeLine{259 }
\DoxyCodeLine{260 }
\DoxyCodeLine{261 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{262 \textcolor{keyword}{inline}}
\DoxyCodeLine{263 \textcolor{keywordtype}{void}}
\DoxyCodeLine{264 op\_index\_min::apply\_noalias(\mbox{\hyperlink{classCube}{Cube<uword>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classCube}{Cube<eT>}}\& X, \textcolor{keyword}{const} uword dim, \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<eT>::result}}* junk)}
\DoxyCodeLine{265   \{}
\DoxyCodeLine{266   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{267   arma\_ignore(junk);}
\DoxyCodeLine{268   }
\DoxyCodeLine{269   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} get\_pod\_type<eT>::result T;}
\DoxyCodeLine{270   }
\DoxyCodeLine{271   \textcolor{keyword}{const} uword X\_n\_rows   = X.n\_rows;}
\DoxyCodeLine{272   \textcolor{keyword}{const} uword X\_n\_cols   = X.n\_cols;}
\DoxyCodeLine{273   \textcolor{keyword}{const} uword X\_n\_slices = X.n\_slices;}
\DoxyCodeLine{274   }
\DoxyCodeLine{275   \textcolor{keywordflow}{if}(dim == 0)}
\DoxyCodeLine{276     \{}
\DoxyCodeLine{277     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}op\_index\_min::apply(): dim = 0"{}});}
\DoxyCodeLine{278     }
\DoxyCodeLine{279     out.\mbox{\hyperlink{group__Cube_ga0d461586030945472fe66f7364882771}{set\_size}}((X\_n\_rows > 0) ? 1 : 0, X\_n\_cols, X\_n\_slices);}
\DoxyCodeLine{280     }
\DoxyCodeLine{281     \textcolor{keywordflow}{if}(out.\mbox{\hyperlink{group__Cube_gaecc2db3371bc45d670ca59e6be7d6abc}{is\_empty}}() || X.is\_empty())  \{ \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{282     }
\DoxyCodeLine{283     \textcolor{keywordflow}{for}(uword \mbox{\hyperlink{classslice}{slice}}=0; \mbox{\hyperlink{classslice}{slice}} < X\_n\_slices; ++\mbox{\hyperlink{classslice}{slice}})}
\DoxyCodeLine{284       \{}
\DoxyCodeLine{285       uword* out\_mem = out.\mbox{\hyperlink{group__Cube_gaa880766c421f4a9f006662c7fd96850e}{slice\_memptr}}(\mbox{\hyperlink{classslice}{slice}});}
\DoxyCodeLine{286       }
\DoxyCodeLine{287       \textcolor{keywordflow}{for}(uword col=0; col < X\_n\_cols; ++col)}
\DoxyCodeLine{288         \{}
\DoxyCodeLine{289         op\_min::direct\_min( X.slice\_colptr(\mbox{\hyperlink{classslice}{slice}},col), X\_n\_rows, out\_mem[col] );}
\DoxyCodeLine{290         \}}
\DoxyCodeLine{291       \}}
\DoxyCodeLine{292     \}}
\DoxyCodeLine{293   \textcolor{keywordflow}{else}}
\DoxyCodeLine{294   \textcolor{keywordflow}{if}(dim == 1)}
\DoxyCodeLine{295     \{}
\DoxyCodeLine{296     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}op\_index\_min::apply(): dim = 1"{}});}
\DoxyCodeLine{297     }
\DoxyCodeLine{298     out.zeros(X\_n\_rows, (X\_n\_cols > 0) ? 1 : 0, X\_n\_slices);}
\DoxyCodeLine{299     }
\DoxyCodeLine{300     \textcolor{keywordflow}{if}(out.\mbox{\hyperlink{group__Cube_gaecc2db3371bc45d670ca59e6be7d6abc}{is\_empty}}() || X.is\_empty())  \{ \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{301     }
\DoxyCodeLine{302     \mbox{\hyperlink{classCol}{Col<T>}} tmp(X\_n\_rows, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{303     }
\DoxyCodeLine{304     T* tmp\_mem = tmp.memptr();}
\DoxyCodeLine{305     }
\DoxyCodeLine{306     \textcolor{keywordflow}{for}(uword \mbox{\hyperlink{classslice}{slice}}=0; \mbox{\hyperlink{classslice}{slice}} < X\_n\_slices; ++\mbox{\hyperlink{classslice}{slice}})}
\DoxyCodeLine{307       \{}
\DoxyCodeLine{308       uword* out\_mem = out.\mbox{\hyperlink{group__Cube_gaa880766c421f4a9f006662c7fd96850e}{slice\_memptr}}(\mbox{\hyperlink{classslice}{slice}});}
\DoxyCodeLine{309       }
\DoxyCodeLine{310       \textcolor{keyword}{const} eT* col0\_mem = X.slice\_colptr(\mbox{\hyperlink{classslice}{slice}},0);}
\DoxyCodeLine{311       }
\DoxyCodeLine{312       \textcolor{keywordflow}{for}(uword row=0; row < X\_n\_rows; ++row)}
\DoxyCodeLine{313         \{}
\DoxyCodeLine{314         tmp\_mem[row] = std::abs( col0\_mem[row] );}
\DoxyCodeLine{315         \}}
\DoxyCodeLine{316       }
\DoxyCodeLine{317       \textcolor{keywordflow}{for}(uword col=1; col < X\_n\_cols; ++col)}
\DoxyCodeLine{318         \{}
\DoxyCodeLine{319         \textcolor{keyword}{const} eT* col\_mem = X.slice\_colptr(\mbox{\hyperlink{classslice}{slice}},col);}
\DoxyCodeLine{320         }
\DoxyCodeLine{321         \textcolor{keywordflow}{for}(uword row=0; row < X\_n\_rows; ++row)}
\DoxyCodeLine{322           \{}
\DoxyCodeLine{323           \textcolor{keyword}{const} T val = std::abs( col\_mem[row] );}
\DoxyCodeLine{324           }
\DoxyCodeLine{325           \textcolor{keywordflow}{if}(val < tmp\_mem[row])}
\DoxyCodeLine{326             \{}
\DoxyCodeLine{327             tmp\_mem[row] = val;}
\DoxyCodeLine{328             out\_mem[row] = col;}
\DoxyCodeLine{329             \}}
\DoxyCodeLine{330           \}}
\DoxyCodeLine{331         \}}
\DoxyCodeLine{332       \}}
\DoxyCodeLine{333     \}}
\DoxyCodeLine{334   \textcolor{keywordflow}{else}}
\DoxyCodeLine{335   \textcolor{keywordflow}{if}(dim == 2)}
\DoxyCodeLine{336     \{}
\DoxyCodeLine{337     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}op\_index\_min::apply(): dim = 2"{}});}
\DoxyCodeLine{338     }
\DoxyCodeLine{339     out.zeros(X\_n\_rows, X\_n\_cols, (X\_n\_slices > 0) ? 1 : 0);}
\DoxyCodeLine{340     }
\DoxyCodeLine{341     \textcolor{keywordflow}{if}(out.\mbox{\hyperlink{group__Cube_gaecc2db3371bc45d670ca59e6be7d6abc}{is\_empty}}() || X.is\_empty())  \{ \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{342     }
\DoxyCodeLine{343     uword* out\_mem = out.\mbox{\hyperlink{group__Cube_ga5b00237224a8e3bfb05728de7c962f85}{memptr}}();}
\DoxyCodeLine{344     }
\DoxyCodeLine{345     \mbox{\hyperlink{classMat}{Mat<T>}} tmp(X\_n\_rows, X\_n\_cols, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{346     }
\DoxyCodeLine{347            T*      tmp\_mem = tmp.memptr();}
\DoxyCodeLine{348     \textcolor{keyword}{const} eT* X\_slice0\_mem = X.slice\_memptr(0);}
\DoxyCodeLine{349     }
\DoxyCodeLine{350     \textcolor{keyword}{const} uword N = X.n\_elem\_slice;}
\DoxyCodeLine{351     }
\DoxyCodeLine{352     \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)}
\DoxyCodeLine{353       \{}
\DoxyCodeLine{354       tmp\_mem[i] = std::abs( X\_slice0\_mem[i] );}
\DoxyCodeLine{355       \}}
\DoxyCodeLine{356     }
\DoxyCodeLine{357     \textcolor{keywordflow}{for}(uword \mbox{\hyperlink{classslice}{slice}}=1; \mbox{\hyperlink{classslice}{slice}} < X\_n\_slices; ++\mbox{\hyperlink{classslice}{slice}})}
\DoxyCodeLine{358       \{}
\DoxyCodeLine{359       \textcolor{keyword}{const} eT* X\_slice\_mem = X.slice\_memptr(\mbox{\hyperlink{classslice}{slice}});}
\DoxyCodeLine{360       }
\DoxyCodeLine{361       \textcolor{keywordflow}{for}(uword i=0; i < N; ++i)}
\DoxyCodeLine{362         \{}
\DoxyCodeLine{363         \textcolor{keyword}{const} T val = std::abs( X\_slice\_mem[i] );}
\DoxyCodeLine{364         }
\DoxyCodeLine{365         \textcolor{keywordflow}{if}(val < tmp\_mem[i])}
\DoxyCodeLine{366           \{}
\DoxyCodeLine{367           tmp\_mem[i] = val;}
\DoxyCodeLine{368           out\_mem[i] = \mbox{\hyperlink{classslice}{slice}};}
\DoxyCodeLine{369           \}}
\DoxyCodeLine{370         \}}
\DoxyCodeLine{371       \}}
\DoxyCodeLine{372     \}}
\DoxyCodeLine{373   \}}
\DoxyCodeLine{374 }
\DoxyCodeLine{375 }
\DoxyCodeLine{376 }
\DoxyCodeLine{377 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{378 \textcolor{keyword}{inline}}
\DoxyCodeLine{379 \textcolor{keywordtype}{void}}
\DoxyCodeLine{380 op\_index\_min::apply(\mbox{\hyperlink{classMat}{Mat<uword>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{structSpBase}{SpBase<typename T1::elem\_type,T1>}}\& expr, \textcolor{keyword}{const} uword dim)}
\DoxyCodeLine{381   \{}
\DoxyCodeLine{382   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{383   }
\DoxyCodeLine{384   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{385   }
\DoxyCodeLine{386   arma\_debug\_check( (dim > 1), \textcolor{stringliteral}{"{}index\_min(): parameter 'dim' must be 0 or 1"{}} );}
\DoxyCodeLine{387   }
\DoxyCodeLine{388   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap__spmat}{unwrap\_spmat<T1>}} U(expr.get\_ref());}
\DoxyCodeLine{389   \textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& X   = U.M;}
\DoxyCodeLine{390   }
\DoxyCodeLine{391   \textcolor{keyword}{const} uword X\_n\_rows = X.n\_rows;}
\DoxyCodeLine{392   \textcolor{keyword}{const} uword X\_n\_cols = X.n\_cols;}
\DoxyCodeLine{393   }
\DoxyCodeLine{394   \textcolor{keywordflow}{if}(dim == 0)}
\DoxyCodeLine{395     \{}
\DoxyCodeLine{396     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}op\_index\_min::apply(): dim = 0"{}});}
\DoxyCodeLine{397     }
\DoxyCodeLine{398     out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}((X\_n\_rows > 0) ? 1 : 0, X\_n\_cols);}
\DoxyCodeLine{399     }
\DoxyCodeLine{400     \textcolor{keywordflow}{if}(X\_n\_rows == 0)  \{ \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{401     }
\DoxyCodeLine{402     uword* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{403     }
\DoxyCodeLine{404     \textcolor{keywordflow}{for}(uword col=0; col < X\_n\_cols; ++col)}
\DoxyCodeLine{405       \{}
\DoxyCodeLine{406       out\_mem[col] = X.col(col).index\_min();}
\DoxyCodeLine{407       \}}
\DoxyCodeLine{408     \}}
\DoxyCodeLine{409   \textcolor{keywordflow}{else}}
\DoxyCodeLine{410   \textcolor{keywordflow}{if}(dim == 1)}
\DoxyCodeLine{411     \{}
\DoxyCodeLine{412     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}op\_index\_min::apply(): dim = 1"{}});}
\DoxyCodeLine{413     }
\DoxyCodeLine{414     out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(X\_n\_rows, (X\_n\_cols > 0) ? 1 : 0);}
\DoxyCodeLine{415     }
\DoxyCodeLine{416     \textcolor{keywordflow}{if}(X\_n\_cols == 0)  \{ \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{417     }
\DoxyCodeLine{418     uword* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{419     }
\DoxyCodeLine{420     \textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}} Xt = X.st();}
\DoxyCodeLine{421     }
\DoxyCodeLine{422     \textcolor{keywordflow}{for}(uword row=0; row < X\_n\_rows; ++row)}
\DoxyCodeLine{423       \{}
\DoxyCodeLine{424       out\_mem[row] = Xt.col(row).index\_min();}
\DoxyCodeLine{425       \}}
\DoxyCodeLine{426     \}}
\DoxyCodeLine{427   \}}
\DoxyCodeLine{428 }
\DoxyCodeLine{429 }
\DoxyCodeLine{430 }

\end{DoxyCode}
