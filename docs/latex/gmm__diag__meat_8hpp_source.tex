\hypertarget{gmm__diag__meat_8hpp_source}{}\doxysection{gmm\+\_\+diag\+\_\+meat.\+hpp}
\label{gmm__diag__meat_8hpp_source}\index{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/gmm\_diag\_meat.hpp@{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/gmm\_diag\_meat.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008-\/2016 Conrad Sanderson (http://conradsanderson.id.au)}}
\DoxyCodeLine{2 \textcolor{comment}{// Copyright 2008-\/2016 National ICT Australia (NICTA)}}
\DoxyCodeLine{3 \textcolor{comment}{// }}
\DoxyCodeLine{4 \textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{5 \textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{6 \textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{7 \textcolor{comment}{// http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{8 \textcolor{comment}{// }}
\DoxyCodeLine{9 \textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{10 \textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{11 \textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{12 \textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{13 \textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{14 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{19 }
\DoxyCodeLine{20 }
\DoxyCodeLine{21 \textcolor{keyword}{namespace }gmm\_priv}
\DoxyCodeLine{22 \{}
\DoxyCodeLine{23 }
\DoxyCodeLine{24 }
\DoxyCodeLine{25 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{26 \textcolor{keyword}{inline}}
\DoxyCodeLine{27 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::\string~gmm\_diag}}()}
\DoxyCodeLine{28   \{}
\DoxyCodeLine{29   arma\_extra\_debug\_sigprint\_this(\textcolor{keyword}{this});}
\DoxyCodeLine{30   }
\DoxyCodeLine{31   arma\_type\_check(( (\mbox{\hyperlink{structis__same__type}{is\_same\_type<eT,float>::value}} == \textcolor{keyword}{false}) \&\& (\mbox{\hyperlink{structis__same__type}{is\_same\_type<eT,double>::value}} == \textcolor{keyword}{false}) ));}
\DoxyCodeLine{32   \}}
\DoxyCodeLine{33 }
\DoxyCodeLine{34 }
\DoxyCodeLine{35 }
\DoxyCodeLine{36 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{37 \textcolor{keyword}{inline}}
\DoxyCodeLine{38 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::gmm\_diag}}()}
\DoxyCodeLine{39   \{}
\DoxyCodeLine{40   arma\_extra\_debug\_sigprint\_this(\textcolor{keyword}{this});}
\DoxyCodeLine{41   \}}
\DoxyCodeLine{42 }
\DoxyCodeLine{43 }
\DoxyCodeLine{44 }
\DoxyCodeLine{45 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{46 \textcolor{keyword}{inline}}
\DoxyCodeLine{47 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::gmm\_diag}}(\textcolor{keyword}{const} \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>}}\& x)}
\DoxyCodeLine{48   \{}
\DoxyCodeLine{49   arma\_extra\_debug\_sigprint\_this(\textcolor{keyword}{this});}
\DoxyCodeLine{50   }
\DoxyCodeLine{51   init(x);}
\DoxyCodeLine{52   \}}
\DoxyCodeLine{53 }
\DoxyCodeLine{54 }
\DoxyCodeLine{55 }
\DoxyCodeLine{56 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{57 \textcolor{keyword}{inline}}
\DoxyCodeLine{58 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>}}\&}
\DoxyCodeLine{59 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::operator=}}(\textcolor{keyword}{const} \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>}}\& x)}
\DoxyCodeLine{60   \{}
\DoxyCodeLine{61   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{62   }
\DoxyCodeLine{63   init(x);}
\DoxyCodeLine{64   }
\DoxyCodeLine{65   \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{66   \}}
\DoxyCodeLine{67 }
\DoxyCodeLine{68 }
\DoxyCodeLine{69 }
\DoxyCodeLine{70 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{71 \textcolor{keyword}{inline}}
\DoxyCodeLine{72 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::gmm\_diag}}(\textcolor{keyword}{const} \mbox{\hyperlink{classgmm__priv_1_1gmm__full}{gmm\_full<eT>}}\& x)}
\DoxyCodeLine{73   \{}
\DoxyCodeLine{74   arma\_extra\_debug\_sigprint\_this(\textcolor{keyword}{this});}
\DoxyCodeLine{75   }
\DoxyCodeLine{76   init(x);}
\DoxyCodeLine{77   \}}
\DoxyCodeLine{78 }
\DoxyCodeLine{79 }
\DoxyCodeLine{80 }
\DoxyCodeLine{81 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{82 \textcolor{keyword}{inline}}
\DoxyCodeLine{83 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>}}\&}
\DoxyCodeLine{84 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::operator=}}(\textcolor{keyword}{const} \mbox{\hyperlink{classgmm__priv_1_1gmm__full}{gmm\_full<eT>}}\& x)}
\DoxyCodeLine{85   \{}
\DoxyCodeLine{86   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{87   }
\DoxyCodeLine{88   init(x);}
\DoxyCodeLine{89   }
\DoxyCodeLine{90   \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{91   \}}
\DoxyCodeLine{92 }
\DoxyCodeLine{93 }
\DoxyCodeLine{94 }
\DoxyCodeLine{95 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{96 \textcolor{keyword}{inline}}
\DoxyCodeLine{97 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::gmm\_diag}}(\textcolor{keyword}{const} uword in\_n\_dims, \textcolor{keyword}{const} uword in\_n\_gaus)}
\DoxyCodeLine{98   \{}
\DoxyCodeLine{99   arma\_extra\_debug\_sigprint\_this(\textcolor{keyword}{this});}
\DoxyCodeLine{100   }
\DoxyCodeLine{101   init(in\_n\_dims, in\_n\_gaus);}
\DoxyCodeLine{102   \}}
\DoxyCodeLine{103 }
\DoxyCodeLine{104 }
\DoxyCodeLine{105 }
\DoxyCodeLine{106 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{107 \textcolor{keyword}{inline}}
\DoxyCodeLine{108 \textcolor{keywordtype}{void}}
\DoxyCodeLine{109 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::reset}}()}
\DoxyCodeLine{110   \{}
\DoxyCodeLine{111   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{112   }
\DoxyCodeLine{113   init(0, 0);}
\DoxyCodeLine{114   \}}
\DoxyCodeLine{115 }
\DoxyCodeLine{116 }
\DoxyCodeLine{117 }
\DoxyCodeLine{118 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{119 \textcolor{keyword}{inline}}
\DoxyCodeLine{120 \textcolor{keywordtype}{void}}
\DoxyCodeLine{121 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::reset}}(\textcolor{keyword}{const} uword in\_n\_dims, \textcolor{keyword}{const} uword in\_n\_gaus)}
\DoxyCodeLine{122   \{}
\DoxyCodeLine{123   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{124   }
\DoxyCodeLine{125   init(in\_n\_dims, in\_n\_gaus);}
\DoxyCodeLine{126   \}}
\DoxyCodeLine{127 }
\DoxyCodeLine{128 }
\DoxyCodeLine{129 }
\DoxyCodeLine{130 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{131 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2, \textcolor{keyword}{typename} T3>}
\DoxyCodeLine{132 \textcolor{keyword}{inline}}
\DoxyCodeLine{133 \textcolor{keywordtype}{void}}
\DoxyCodeLine{134 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::set\_params}}(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<eT,T1>}}\& in\_means\_expr, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<eT,T2>}}\& in\_dcovs\_expr, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<eT,T3>}}\& in\_hefts\_expr)}
\DoxyCodeLine{135   \{}
\DoxyCodeLine{136   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{137   }
\DoxyCodeLine{138   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap}{unwrap<T1>}} tmp1(in\_means\_expr.get\_ref());}
\DoxyCodeLine{139   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap}{unwrap<T2>}} tmp2(in\_dcovs\_expr.get\_ref());}
\DoxyCodeLine{140   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap}{unwrap<T3>}} tmp3(in\_hefts\_expr.get\_ref());}
\DoxyCodeLine{141   }
\DoxyCodeLine{142   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& in\_means = tmp1.M;}
\DoxyCodeLine{143   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& in\_dcovs = tmp2.M;}
\DoxyCodeLine{144   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& in\_hefts = tmp3.M;}
\DoxyCodeLine{145   }
\DoxyCodeLine{146   arma\_debug\_check}
\DoxyCodeLine{147     (}
\DoxyCodeLine{148     (arma::size(in\_means) != arma::size(in\_dcovs)) || (in\_hefts.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}} != in\_means.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}}) || (in\_hefts.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}} != 1),}
\DoxyCodeLine{149     \textcolor{stringliteral}{"{}gmm\_diag::set\_params(): given parameters have inconsistent and/or wrong sizes"{}}}
\DoxyCodeLine{150     );}
\DoxyCodeLine{151   }
\DoxyCodeLine{152   arma\_debug\_check( (in\_means.\mbox{\hyperlink{group__Mat_gad78d4808815d1521085b8eeee1c2aab4}{is\_finite}}() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}gmm\_diag::set\_params(): given means have non-\/finite values"{}} );}
\DoxyCodeLine{153   arma\_debug\_check( (in\_dcovs.\mbox{\hyperlink{group__Mat_gad78d4808815d1521085b8eeee1c2aab4}{is\_finite}}() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}gmm\_diag::set\_params(): given dcovs have non-\/finite values"{}} );}
\DoxyCodeLine{154   arma\_debug\_check( (in\_hefts.\mbox{\hyperlink{group__Mat_gad78d4808815d1521085b8eeee1c2aab4}{is\_finite}}() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}gmm\_diag::set\_params(): given hefts have non-\/finite values"{}} );}
\DoxyCodeLine{155   }
\DoxyCodeLine{156   arma\_debug\_check( (\mbox{\hyperlink{group__fn__any_gac40fe1298ebcc7b720fa3ea03f410b06}{any}}(vectorise(in\_dcovs) <= eT(0))), \textcolor{stringliteral}{"{}gmm\_diag::set\_params(): given dcovs have negative or zero values"{}} );}
\DoxyCodeLine{157   arma\_debug\_check( (\mbox{\hyperlink{group__fn__any_gac40fe1298ebcc7b720fa3ea03f410b06}{any}}(vectorise(in\_hefts) <  eT(0))), \textcolor{stringliteral}{"{}gmm\_diag::set\_params(): given hefts have negative values"{}}         );}
\DoxyCodeLine{158   }
\DoxyCodeLine{159   \textcolor{keyword}{const} eT s = \mbox{\hyperlink{group__fn__accu_ga010aa66ecb6b417277db3e21cc10f6e6}{accu}}(in\_hefts);}
\DoxyCodeLine{160   }
\DoxyCodeLine{161   arma\_debug\_check( ((s < (eT(1) -\/ eT(0.001))) || (s > (eT(1) + eT(0.001)))), \textcolor{stringliteral}{"{}gmm\_diag::set\_params(): sum of given hefts is not 1"{}} );}
\DoxyCodeLine{162   }
\DoxyCodeLine{163   \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(means) = in\_means;}
\DoxyCodeLine{164   \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(dcovs) = in\_dcovs;}
\DoxyCodeLine{165   \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(hefts) = in\_hefts;}
\DoxyCodeLine{166   }
\DoxyCodeLine{167   init\_constants();}
\DoxyCodeLine{168   \}}
\DoxyCodeLine{169 }
\DoxyCodeLine{170 }
\DoxyCodeLine{171 }
\DoxyCodeLine{172 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{173 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{174 \textcolor{keyword}{inline}}
\DoxyCodeLine{175 \textcolor{keywordtype}{void}}
\DoxyCodeLine{176 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::set\_means}}(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<eT,T1>}}\& in\_means\_expr)}
\DoxyCodeLine{177   \{}
\DoxyCodeLine{178   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{179   }
\DoxyCodeLine{180   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap}{unwrap<T1>}} tmp(in\_means\_expr.get\_ref());}
\DoxyCodeLine{181   }
\DoxyCodeLine{182   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& in\_means = tmp.M;}
\DoxyCodeLine{183   }
\DoxyCodeLine{184   arma\_debug\_check( (arma::size(in\_means) != arma::size(means)), \textcolor{stringliteral}{"{}gmm\_diag::set\_means(): given means have incompatible size"{}} );}
\DoxyCodeLine{185   arma\_debug\_check( (in\_means.\mbox{\hyperlink{group__Mat_gad78d4808815d1521085b8eeee1c2aab4}{is\_finite}}() == \textcolor{keyword}{false}),             \textcolor{stringliteral}{"{}gmm\_diag::set\_means(): given means have non-\/finite values"{}} );}
\DoxyCodeLine{186   }
\DoxyCodeLine{187   \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(means) = in\_means;}
\DoxyCodeLine{188   \}}
\DoxyCodeLine{189 }
\DoxyCodeLine{190 }
\DoxyCodeLine{191 }
\DoxyCodeLine{192 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{193 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{194 \textcolor{keyword}{inline}}
\DoxyCodeLine{195 \textcolor{keywordtype}{void}}
\DoxyCodeLine{196 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::set\_dcovs}}(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<eT,T1>}}\& in\_dcovs\_expr)}
\DoxyCodeLine{197   \{}
\DoxyCodeLine{198   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{199   }
\DoxyCodeLine{200   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap}{unwrap<T1>}} tmp(in\_dcovs\_expr.get\_ref());}
\DoxyCodeLine{201   }
\DoxyCodeLine{202   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& in\_dcovs = tmp.M;}
\DoxyCodeLine{203   }
\DoxyCodeLine{204   arma\_debug\_check( (arma::size(in\_dcovs) != arma::size(dcovs)), \textcolor{stringliteral}{"{}gmm\_diag::set\_dcovs(): given dcovs have incompatible size"{}}       );}
\DoxyCodeLine{205   arma\_debug\_check( (in\_dcovs.\mbox{\hyperlink{group__Mat_gad78d4808815d1521085b8eeee1c2aab4}{is\_finite}}() == \textcolor{keyword}{false}),             \textcolor{stringliteral}{"{}gmm\_diag::set\_dcovs(): given dcovs have non-\/finite values"{}}       );}
\DoxyCodeLine{206   arma\_debug\_check( (\mbox{\hyperlink{group__fn__any_gac40fe1298ebcc7b720fa3ea03f410b06}{any}}(vectorise(in\_dcovs) <= eT(0))),         \textcolor{stringliteral}{"{}gmm\_diag::set\_dcovs(): given dcovs have negative or zero values"{}} );}
\DoxyCodeLine{207   }
\DoxyCodeLine{208   \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(dcovs) = in\_dcovs;}
\DoxyCodeLine{209   }
\DoxyCodeLine{210   init\_constants();}
\DoxyCodeLine{211   \}}
\DoxyCodeLine{212 }
\DoxyCodeLine{213 }
\DoxyCodeLine{214 }
\DoxyCodeLine{215 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{216 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{217 \textcolor{keyword}{inline}}
\DoxyCodeLine{218 \textcolor{keywordtype}{void}}
\DoxyCodeLine{219 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::set\_hefts}}(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<eT,T1>}}\& in\_hefts\_expr)}
\DoxyCodeLine{220   \{}
\DoxyCodeLine{221   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{222   }
\DoxyCodeLine{223   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap}{unwrap<T1>}} tmp(in\_hefts\_expr.get\_ref());}
\DoxyCodeLine{224   }
\DoxyCodeLine{225   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& in\_hefts = tmp.M;}
\DoxyCodeLine{226   }
\DoxyCodeLine{227   arma\_debug\_check( (arma::size(in\_hefts) != arma::size(hefts)), \textcolor{stringliteral}{"{}gmm\_diag::set\_hefts(): given hefts have incompatible size"{}} );}
\DoxyCodeLine{228   arma\_debug\_check( (in\_hefts.\mbox{\hyperlink{group__Mat_gad78d4808815d1521085b8eeee1c2aab4}{is\_finite}}() == \textcolor{keyword}{false}),             \textcolor{stringliteral}{"{}gmm\_diag::set\_hefts(): given hefts have non-\/finite values"{}} );}
\DoxyCodeLine{229   arma\_debug\_check( (\mbox{\hyperlink{group__fn__any_gac40fe1298ebcc7b720fa3ea03f410b06}{any}}(vectorise(in\_hefts) <  eT(0))),         \textcolor{stringliteral}{"{}gmm\_diag::set\_hefts(): given hefts have negative values"{}}   );}
\DoxyCodeLine{230   }
\DoxyCodeLine{231   \textcolor{keyword}{const} eT s = \mbox{\hyperlink{group__fn__accu_ga010aa66ecb6b417277db3e21cc10f6e6}{accu}}(in\_hefts);}
\DoxyCodeLine{232   }
\DoxyCodeLine{233   arma\_debug\_check( ((s < (eT(1) -\/ eT(0.001))) || (s > (eT(1) + eT(0.001)))), \textcolor{stringliteral}{"{}gmm\_diag::set\_hefts(): sum of given hefts is not 1"{}} );}
\DoxyCodeLine{234   }
\DoxyCodeLine{235   \textcolor{comment}{// make sure all hefts are positive and non-\/zero}}
\DoxyCodeLine{236   }
\DoxyCodeLine{237   \textcolor{keyword}{const} eT* in\_hefts\_mem = in\_hefts.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{238         eT*    hefts\_mem = \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(hefts).memptr();}
\DoxyCodeLine{239   }
\DoxyCodeLine{240   \textcolor{keywordflow}{for}(uword i=0; i < hefts.n\_elem; ++i)}
\DoxyCodeLine{241     \{}
\DoxyCodeLine{242     hefts\_mem[i] = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})( in\_hefts\_mem[i], \mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::numeric\_limits<eT>::min}}() );}
\DoxyCodeLine{243     \}}
\DoxyCodeLine{244   }
\DoxyCodeLine{245   \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(hefts) /= \mbox{\hyperlink{group__fn__accu_ga010aa66ecb6b417277db3e21cc10f6e6}{accu}}(hefts);}
\DoxyCodeLine{246   }
\DoxyCodeLine{247   log\_hefts = log(hefts);}
\DoxyCodeLine{248   \}}
\DoxyCodeLine{249 }
\DoxyCodeLine{250 }
\DoxyCodeLine{251 }
\DoxyCodeLine{252 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{253 \textcolor{keyword}{inline}}
\DoxyCodeLine{254 uword}
\DoxyCodeLine{255 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::n\_dims}}()\textcolor{keyword}{ const}}
\DoxyCodeLine{256 \textcolor{keyword}{  }\{}
\DoxyCodeLine{257   \textcolor{keywordflow}{return} means.n\_rows;}
\DoxyCodeLine{258   \}}
\DoxyCodeLine{259 }
\DoxyCodeLine{260 }
\DoxyCodeLine{261 }
\DoxyCodeLine{262 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{263 \textcolor{keyword}{inline}}
\DoxyCodeLine{264 uword}
\DoxyCodeLine{265 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::n\_gaus}}()\textcolor{keyword}{ const}}
\DoxyCodeLine{266 \textcolor{keyword}{  }\{}
\DoxyCodeLine{267   \textcolor{keywordflow}{return} means.n\_cols;}
\DoxyCodeLine{268   \}}
\DoxyCodeLine{269 }
\DoxyCodeLine{270 }
\DoxyCodeLine{271 }
\DoxyCodeLine{272 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{273 \textcolor{keyword}{inline}}
\DoxyCodeLine{274 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{275 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::load}}(\textcolor{keyword}{const} std::string \mbox{\hyperlink{structname}{name}})}
\DoxyCodeLine{276   \{}
\DoxyCodeLine{277   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{278   }
\DoxyCodeLine{279   \mbox{\hyperlink{classCube}{Cube<eT>}} Q;}
\DoxyCodeLine{280   }
\DoxyCodeLine{281   \textcolor{keywordtype}{bool} status = Q.\mbox{\hyperlink{group__Cube_ga12aef27ddc9114a6f4d039d70f450f89}{load}}(\mbox{\hyperlink{structname}{name}}, \mbox{\hyperlink{group__diskio_gga0de594dadb1bc493ecc618520a2d260eab4ea3228fa70b58ac40bc995f57431b9}{arma\_binary}});}
\DoxyCodeLine{282   }
\DoxyCodeLine{283   \textcolor{keywordflow}{if}( (status == \textcolor{keyword}{false}) || (Q.\mbox{\hyperlink{classCube_a9b6ae66090ee092173190a85c0c3e5dd}{n\_slices}} != 2) )}
\DoxyCodeLine{284     \{}
\DoxyCodeLine{285     reset();}
\DoxyCodeLine{286     arma\_debug\_warn\_level(3, \textcolor{stringliteral}{"{}gmm\_diag::load(): problem with loading or incompatible format"{}});}
\DoxyCodeLine{287     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{288     \}}
\DoxyCodeLine{289   }
\DoxyCodeLine{290   \textcolor{keywordflow}{if}( (Q.\mbox{\hyperlink{classCube_af2375467da364bb326010c46050fab2a}{n\_rows}} < 2) || (Q.\mbox{\hyperlink{classCube_a59704a57c131771a28faa0ffc71004a9}{n\_cols}} < 1) )}
\DoxyCodeLine{291     \{}
\DoxyCodeLine{292     reset();}
\DoxyCodeLine{293     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{294     \}}
\DoxyCodeLine{295   }
\DoxyCodeLine{296   \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(hefts) = Q.\mbox{\hyperlink{group__Cube_gaa096114dbf2eefcaed52f92da5064697}{slice}}(0).row(0);}
\DoxyCodeLine{297   \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(means) = Q.\mbox{\hyperlink{group__Cube_gaa096114dbf2eefcaed52f92da5064697}{slice}}(0).submat(1, 0, Q.\mbox{\hyperlink{classCube_af2375467da364bb326010c46050fab2a}{n\_rows}}-\/1, Q.\mbox{\hyperlink{classCube_a59704a57c131771a28faa0ffc71004a9}{n\_cols}}-\/1);}
\DoxyCodeLine{298   \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(dcovs) = Q.\mbox{\hyperlink{group__Cube_gaa096114dbf2eefcaed52f92da5064697}{slice}}(1).submat(1, 0, Q.\mbox{\hyperlink{classCube_af2375467da364bb326010c46050fab2a}{n\_rows}}-\/1, Q.\mbox{\hyperlink{classCube_a59704a57c131771a28faa0ffc71004a9}{n\_cols}}-\/1);}
\DoxyCodeLine{299   }
\DoxyCodeLine{300   init\_constants();}
\DoxyCodeLine{301   }
\DoxyCodeLine{302   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{303   \}}
\DoxyCodeLine{304 }
\DoxyCodeLine{305 }
\DoxyCodeLine{306 }
\DoxyCodeLine{307 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{308 \textcolor{keyword}{inline}}
\DoxyCodeLine{309 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{310 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::save}}(\textcolor{keyword}{const} std::string \mbox{\hyperlink{structname}{name}})\textcolor{keyword}{ const}}
\DoxyCodeLine{311 \textcolor{keyword}{  }\{}
\DoxyCodeLine{312   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{313   }
\DoxyCodeLine{314   \mbox{\hyperlink{classCube}{Cube<eT>}} Q(means.n\_rows + 1, means.n\_cols, 2, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{315   }
\DoxyCodeLine{316   \textcolor{keywordflow}{if}(Q.\mbox{\hyperlink{classCube_a4903e94049fa6d9f0d62dbcbf376da96}{n\_elem}} > 0)}
\DoxyCodeLine{317     \{}
\DoxyCodeLine{318     Q.\mbox{\hyperlink{group__Cube_gaa096114dbf2eefcaed52f92da5064697}{slice}}(0).row(0) = hefts;}
\DoxyCodeLine{319     Q.\mbox{\hyperlink{group__Cube_gaa096114dbf2eefcaed52f92da5064697}{slice}}(1).row(0).zeros();  \textcolor{comment}{// reserved for future use}}
\DoxyCodeLine{320     }
\DoxyCodeLine{321     Q.\mbox{\hyperlink{group__Cube_gaa096114dbf2eefcaed52f92da5064697}{slice}}(0).submat(1, 0, arma::size(means)) = means;}
\DoxyCodeLine{322     Q.\mbox{\hyperlink{group__Cube_gaa096114dbf2eefcaed52f92da5064697}{slice}}(1).submat(1, 0, arma::size(dcovs)) = dcovs;}
\DoxyCodeLine{323     \}}
\DoxyCodeLine{324   }
\DoxyCodeLine{325   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} status = Q.\mbox{\hyperlink{group__Cube_ga40a0fb134b57ca3cf46a125737363c26}{save}}(\mbox{\hyperlink{structname}{name}}, \mbox{\hyperlink{group__diskio_gga0de594dadb1bc493ecc618520a2d260eab4ea3228fa70b58ac40bc995f57431b9}{arma\_binary}});}
\DoxyCodeLine{326   }
\DoxyCodeLine{327   \textcolor{keywordflow}{return} status;}
\DoxyCodeLine{328   \}}
\DoxyCodeLine{329 }
\DoxyCodeLine{330 }
\DoxyCodeLine{331 }
\DoxyCodeLine{332 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{333 \textcolor{keyword}{inline}}
\DoxyCodeLine{334 \mbox{\hyperlink{classCol}{Col<eT>}}}
\DoxyCodeLine{335 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::generate}}()\textcolor{keyword}{ const}}
\DoxyCodeLine{336 \textcolor{keyword}{  }\{}
\DoxyCodeLine{337   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{338   }
\DoxyCodeLine{339   \textcolor{keyword}{const} uword N\_dims = means.n\_rows;}
\DoxyCodeLine{340   \textcolor{keyword}{const} uword N\_gaus = means.n\_cols;}
\DoxyCodeLine{341   }
\DoxyCodeLine{342   \mbox{\hyperlink{classCol}{Col<eT>}} out( ((N\_gaus > 0) ? N\_dims : uword(0)), fill::randn );}
\DoxyCodeLine{343   }
\DoxyCodeLine{344   \textcolor{keywordflow}{if}(N\_gaus > 0)}
\DoxyCodeLine{345     \{}
\DoxyCodeLine{346     \textcolor{keyword}{const} \textcolor{keywordtype}{double} val = randu<double>();}
\DoxyCodeLine{347     }
\DoxyCodeLine{348     \textcolor{keywordtype}{double} csum    = double(0);}
\DoxyCodeLine{349     uword  gaus\_id = 0;}
\DoxyCodeLine{350     }
\DoxyCodeLine{351     \textcolor{keywordflow}{for}(uword j=0; j < N\_gaus; ++j)}
\DoxyCodeLine{352       \{}
\DoxyCodeLine{353       csum += hefts[j];}
\DoxyCodeLine{354       }
\DoxyCodeLine{355       \textcolor{keywordflow}{if}(val <= csum)  \{ gaus\_id = j; \textcolor{keywordflow}{break}; \}}
\DoxyCodeLine{356       \}}
\DoxyCodeLine{357     }
\DoxyCodeLine{358     out \%= sqrt(dcovs.col(gaus\_id));}
\DoxyCodeLine{359     out += means.col(gaus\_id);}
\DoxyCodeLine{360     \}}
\DoxyCodeLine{361   }
\DoxyCodeLine{362   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{363   \}}
\DoxyCodeLine{364 }
\DoxyCodeLine{365 }
\DoxyCodeLine{366 }
\DoxyCodeLine{367 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{368 \textcolor{keyword}{inline}}
\DoxyCodeLine{369 \mbox{\hyperlink{classMat}{Mat<eT>}}}
\DoxyCodeLine{370 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::generate}}(\textcolor{keyword}{const} uword N\_vec)\textcolor{keyword}{ const}}
\DoxyCodeLine{371 \textcolor{keyword}{  }\{}
\DoxyCodeLine{372   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{373   }
\DoxyCodeLine{374   \textcolor{keyword}{const} uword N\_dims = means.n\_rows;}
\DoxyCodeLine{375   \textcolor{keyword}{const} uword N\_gaus = means.n\_cols;}
\DoxyCodeLine{376   }
\DoxyCodeLine{377   \mbox{\hyperlink{classMat}{Mat<eT>}} out( ( (N\_gaus > 0) ? N\_dims : uword(0) ), N\_vec, fill::randn );}
\DoxyCodeLine{378   }
\DoxyCodeLine{379   \textcolor{keywordflow}{if}(N\_gaus > 0)}
\DoxyCodeLine{380     \{}
\DoxyCodeLine{381     \textcolor{keyword}{const} eT* hefts\_mem = hefts.memptr();}
\DoxyCodeLine{382     }
\DoxyCodeLine{383     \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}} sqrt\_dcovs = sqrt(dcovs);}
\DoxyCodeLine{384     }
\DoxyCodeLine{385     \textcolor{keywordflow}{for}(uword i=0; i < N\_vec; ++i)}
\DoxyCodeLine{386       \{}
\DoxyCodeLine{387       \textcolor{keyword}{const} \textcolor{keywordtype}{double} val = randu<double>();}
\DoxyCodeLine{388       }
\DoxyCodeLine{389       \textcolor{keywordtype}{double} csum    = double(0);}
\DoxyCodeLine{390       uword  gaus\_id = 0;}
\DoxyCodeLine{391       }
\DoxyCodeLine{392       \textcolor{keywordflow}{for}(uword j=0; j < N\_gaus; ++j)}
\DoxyCodeLine{393         \{}
\DoxyCodeLine{394         csum += hefts\_mem[j];}
\DoxyCodeLine{395         }
\DoxyCodeLine{396         \textcolor{keywordflow}{if}(val <= csum)  \{ gaus\_id = j; \textcolor{keywordflow}{break}; \}}
\DoxyCodeLine{397         \}}
\DoxyCodeLine{398       }
\DoxyCodeLine{399       \mbox{\hyperlink{classsubview__col}{subview\_col<eT>}} out\_col = out.\mbox{\hyperlink{group__subview_gaa4a4545f6c1f9475df3130e71121240e}{col}}(i);}
\DoxyCodeLine{400       }
\DoxyCodeLine{401       out\_col \%= sqrt\_dcovs.\mbox{\hyperlink{group__Mat_gab68ba7bbceb5544bbd0f6f00dfe6b328}{col}}(gaus\_id);}
\DoxyCodeLine{402       out\_col += means.\mbox{\hyperlink{group__subview_gaa4a4545f6c1f9475df3130e71121240e}{col}}(gaus\_id);}
\DoxyCodeLine{403       \}}
\DoxyCodeLine{404     \}}
\DoxyCodeLine{405   }
\DoxyCodeLine{406   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{407   \}}
\DoxyCodeLine{408 }
\DoxyCodeLine{409 }
\DoxyCodeLine{410 }
\DoxyCodeLine{411 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{412 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{413 \textcolor{keyword}{inline}}
\DoxyCodeLine{414 eT}
\DoxyCodeLine{415 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::log\_p}}(\textcolor{keyword}{const} T1\& expr, \textcolor{keyword}{const} gmm\_empty\_arg\& junk1, \textcolor{keyword}{typename} \mbox{\hyperlink{structenable__if}{enable\_if}}<((\mbox{\hyperlink{structis__arma__type}{is\_arma\_type<T1>::value}}) \&\& (\mbox{\hyperlink{structresolves__to__colvector}{resolves\_to\_colvector<T1>::value}} == \textcolor{keyword}{true}))>::result* junk2)\textcolor{keyword}{ const}}
\DoxyCodeLine{416 \textcolor{keyword}{  }\{}
\DoxyCodeLine{417   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{418   arma\_ignore(junk1);}
\DoxyCodeLine{419   arma\_ignore(junk2);}
\DoxyCodeLine{420   }
\DoxyCodeLine{421   \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} tmp(expr);}
\DoxyCodeLine{422   }
\DoxyCodeLine{423   arma\_debug\_check( (tmp.M.n\_rows != means.n\_rows), \textcolor{stringliteral}{"{}gmm\_diag::log\_p(): incompatible dimensions"{}} );}
\DoxyCodeLine{424   }
\DoxyCodeLine{425   \textcolor{keywordflow}{return} internal\_scalar\_log\_p( tmp.M.memptr() );}
\DoxyCodeLine{426   \}}
\DoxyCodeLine{427 }
\DoxyCodeLine{428 }
\DoxyCodeLine{429 }
\DoxyCodeLine{430 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{431 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{432 \textcolor{keyword}{inline}}
\DoxyCodeLine{433 eT}
\DoxyCodeLine{434 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::log\_p}}(\textcolor{keyword}{const} T1\& expr, \textcolor{keyword}{const} uword gaus\_id, \textcolor{keyword}{typename} \mbox{\hyperlink{structenable__if}{enable\_if}}<((\mbox{\hyperlink{structis__arma__type}{is\_arma\_type<T1>::value}}) \&\& (\mbox{\hyperlink{structresolves__to__colvector}{resolves\_to\_colvector<T1>::value}} == \textcolor{keyword}{true}))>::result* junk2)\textcolor{keyword}{ const}}
\DoxyCodeLine{435 \textcolor{keyword}{  }\{}
\DoxyCodeLine{436   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{437   arma\_ignore(junk2);}
\DoxyCodeLine{438   }
\DoxyCodeLine{439   \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} tmp(expr);}
\DoxyCodeLine{440   }
\DoxyCodeLine{441   arma\_debug\_check( (tmp.M.n\_rows != means.n\_rows), \textcolor{stringliteral}{"{}gmm\_diag::log\_p(): incompatible dimensions"{}} );}
\DoxyCodeLine{442   }
\DoxyCodeLine{443   arma\_debug\_check( (gaus\_id >= means.n\_cols), \textcolor{stringliteral}{"{}gmm\_diag::log\_p(): specified gaussian is out of range"{}} );}
\DoxyCodeLine{444   }
\DoxyCodeLine{445   \textcolor{keywordflow}{return} internal\_scalar\_log\_p( tmp.M.memptr(), gaus\_id );}
\DoxyCodeLine{446   \}}
\DoxyCodeLine{447 }
\DoxyCodeLine{448 }
\DoxyCodeLine{449 }
\DoxyCodeLine{450 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{451 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{452 \textcolor{keyword}{inline}}
\DoxyCodeLine{453 \mbox{\hyperlink{classRow}{Row<eT>}}}
\DoxyCodeLine{454 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::log\_p}}(\textcolor{keyword}{const} T1\& expr, \textcolor{keyword}{const} gmm\_empty\_arg\& junk1, \textcolor{keyword}{typename} \mbox{\hyperlink{structenable__if}{enable\_if}}<((\mbox{\hyperlink{structis__arma__type}{is\_arma\_type<T1>::value}}) \&\& (\mbox{\hyperlink{structresolves__to__colvector}{resolves\_to\_colvector<T1>::value}} == \textcolor{keyword}{false}))>::result* junk2)\textcolor{keyword}{ const}}
\DoxyCodeLine{455 \textcolor{keyword}{  }\{}
\DoxyCodeLine{456   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{457   arma\_ignore(junk1);}
\DoxyCodeLine{458   arma\_ignore(junk2);}
\DoxyCodeLine{459   }
\DoxyCodeLine{460   \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} tmp(expr);}
\DoxyCodeLine{461   }
\DoxyCodeLine{462   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X = tmp.M;}
\DoxyCodeLine{463   }
\DoxyCodeLine{464   \textcolor{keywordflow}{return} internal\_vec\_log\_p(X);}
\DoxyCodeLine{465   \}}
\DoxyCodeLine{466 }
\DoxyCodeLine{467 }
\DoxyCodeLine{468 }
\DoxyCodeLine{469 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{470 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{471 \textcolor{keyword}{inline}}
\DoxyCodeLine{472 \mbox{\hyperlink{classRow}{Row<eT>}}}
\DoxyCodeLine{473 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::log\_p}}(\textcolor{keyword}{const} T1\& expr, \textcolor{keyword}{const} uword gaus\_id, \textcolor{keyword}{typename} \mbox{\hyperlink{structenable__if}{enable\_if}}<((\mbox{\hyperlink{structis__arma__type}{is\_arma\_type<T1>::value}}) \&\& (\mbox{\hyperlink{structresolves__to__colvector}{resolves\_to\_colvector<T1>::value}} == \textcolor{keyword}{false}))>::result* junk2)\textcolor{keyword}{ const}}
\DoxyCodeLine{474 \textcolor{keyword}{  }\{}
\DoxyCodeLine{475   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{476   arma\_ignore(junk2);}
\DoxyCodeLine{477   }
\DoxyCodeLine{478   \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} tmp(expr);}
\DoxyCodeLine{479   }
\DoxyCodeLine{480   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X = tmp.M;}
\DoxyCodeLine{481   }
\DoxyCodeLine{482   \textcolor{keywordflow}{return} internal\_vec\_log\_p(X, gaus\_id);}
\DoxyCodeLine{483   \}}
\DoxyCodeLine{484 }
\DoxyCodeLine{485 }
\DoxyCodeLine{486 }
\DoxyCodeLine{487 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{488 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{489 \textcolor{keyword}{inline}}
\DoxyCodeLine{490 eT}
\DoxyCodeLine{491 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::sum\_log\_p}}(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<eT,T1>}}\& expr)\textcolor{keyword}{ const}}
\DoxyCodeLine{492 \textcolor{keyword}{  }\{}
\DoxyCodeLine{493   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{494   }
\DoxyCodeLine{495   \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} tmp(expr.get\_ref());}
\DoxyCodeLine{496   }
\DoxyCodeLine{497   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X = tmp.M;}
\DoxyCodeLine{498   }
\DoxyCodeLine{499   \textcolor{keywordflow}{return} internal\_sum\_log\_p(X);}
\DoxyCodeLine{500   \}}
\DoxyCodeLine{501 }
\DoxyCodeLine{502 }
\DoxyCodeLine{503 }
\DoxyCodeLine{504 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{505 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{506 \textcolor{keyword}{inline}}
\DoxyCodeLine{507 eT}
\DoxyCodeLine{508 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::sum\_log\_p}}(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<eT,T1>}}\& expr, \textcolor{keyword}{const} uword gaus\_id)\textcolor{keyword}{ const}}
\DoxyCodeLine{509 \textcolor{keyword}{  }\{}
\DoxyCodeLine{510   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{511   }
\DoxyCodeLine{512   \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} tmp(expr.get\_ref());}
\DoxyCodeLine{513   }
\DoxyCodeLine{514   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X = tmp.M;}
\DoxyCodeLine{515   }
\DoxyCodeLine{516   \textcolor{keywordflow}{return} internal\_sum\_log\_p(X, gaus\_id);}
\DoxyCodeLine{517   \}}
\DoxyCodeLine{518 }
\DoxyCodeLine{519 }
\DoxyCodeLine{520 }
\DoxyCodeLine{521 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{522 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{523 \textcolor{keyword}{inline}}
\DoxyCodeLine{524 eT}
\DoxyCodeLine{525 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::avg\_log\_p}}(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<eT,T1>}}\& expr)\textcolor{keyword}{ const}}
\DoxyCodeLine{526 \textcolor{keyword}{  }\{}
\DoxyCodeLine{527   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{528   }
\DoxyCodeLine{529   \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} tmp(expr.get\_ref());}
\DoxyCodeLine{530   }
\DoxyCodeLine{531   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X = tmp.M;}
\DoxyCodeLine{532   }
\DoxyCodeLine{533   \textcolor{keywordflow}{return} internal\_avg\_log\_p(X);}
\DoxyCodeLine{534   \}}
\DoxyCodeLine{535 }
\DoxyCodeLine{536 }
\DoxyCodeLine{537 }
\DoxyCodeLine{538 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{539 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{540 \textcolor{keyword}{inline}}
\DoxyCodeLine{541 eT}
\DoxyCodeLine{542 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::avg\_log\_p}}(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<eT,T1>}}\& expr, \textcolor{keyword}{const} uword gaus\_id)\textcolor{keyword}{ const}}
\DoxyCodeLine{543 \textcolor{keyword}{  }\{}
\DoxyCodeLine{544   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{545   }
\DoxyCodeLine{546   \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} tmp(expr.get\_ref());}
\DoxyCodeLine{547   }
\DoxyCodeLine{548   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X = tmp.M;}
\DoxyCodeLine{549   }
\DoxyCodeLine{550   \textcolor{keywordflow}{return} internal\_avg\_log\_p(X, gaus\_id);}
\DoxyCodeLine{551   \}}
\DoxyCodeLine{552 }
\DoxyCodeLine{553 }
\DoxyCodeLine{554 }
\DoxyCodeLine{555 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{556 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{557 \textcolor{keyword}{inline}}
\DoxyCodeLine{558 uword}
\DoxyCodeLine{559 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::assign}}(\textcolor{keyword}{const} T1\& expr, \textcolor{keyword}{const} \mbox{\hyperlink{structgmm__dist__mode}{gmm\_dist\_mode}}\& dist, \textcolor{keyword}{typename} \mbox{\hyperlink{structenable__if}{enable\_if}}<((\mbox{\hyperlink{structis__arma__type}{is\_arma\_type<T1>::value}}) \&\& (\mbox{\hyperlink{structresolves__to__colvector}{resolves\_to\_colvector<T1>::value}} == \textcolor{keyword}{true}))>::result* junk)\textcolor{keyword}{ const}}
\DoxyCodeLine{560 \textcolor{keyword}{  }\{}
\DoxyCodeLine{561   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{562   arma\_ignore(junk);}
\DoxyCodeLine{563   }
\DoxyCodeLine{564   \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} tmp(expr);}
\DoxyCodeLine{565   }
\DoxyCodeLine{566   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X = tmp.M;}
\DoxyCodeLine{567   }
\DoxyCodeLine{568   \textcolor{keywordflow}{return} internal\_scalar\_assign(X, dist);}
\DoxyCodeLine{569   \}}
\DoxyCodeLine{570 }
\DoxyCodeLine{571 }
\DoxyCodeLine{572 }
\DoxyCodeLine{573 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{574 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{575 \textcolor{keyword}{inline}}
\DoxyCodeLine{576 \mbox{\hyperlink{classRow}{urowvec}}}
\DoxyCodeLine{577 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::assign}}(\textcolor{keyword}{const} T1\& expr, \textcolor{keyword}{const} \mbox{\hyperlink{structgmm__dist__mode}{gmm\_dist\_mode}}\& dist, \textcolor{keyword}{typename} \mbox{\hyperlink{structenable__if}{enable\_if}}<((\mbox{\hyperlink{structis__arma__type}{is\_arma\_type<T1>::value}}) \&\& (\mbox{\hyperlink{structresolves__to__colvector}{resolves\_to\_colvector<T1>::value}} == \textcolor{keyword}{false}))>::result* junk)\textcolor{keyword}{ const}}
\DoxyCodeLine{578 \textcolor{keyword}{  }\{}
\DoxyCodeLine{579   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{580   arma\_ignore(junk);}
\DoxyCodeLine{581   }
\DoxyCodeLine{582   \mbox{\hyperlink{classRow}{urowvec}} out;}
\DoxyCodeLine{583   }
\DoxyCodeLine{584   \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} tmp(expr);}
\DoxyCodeLine{585   }
\DoxyCodeLine{586   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X = tmp.M;}
\DoxyCodeLine{587   }
\DoxyCodeLine{588   internal\_vec\_assign(out, X, dist);}
\DoxyCodeLine{589   }
\DoxyCodeLine{590   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{591   \}}
\DoxyCodeLine{592 }
\DoxyCodeLine{593 }
\DoxyCodeLine{594 }
\DoxyCodeLine{595 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{596 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{597 \textcolor{keyword}{inline}}
\DoxyCodeLine{598 \mbox{\hyperlink{classRow}{urowvec}}}
\DoxyCodeLine{599 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::raw\_hist}}(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<eT,T1>}}\& expr, \textcolor{keyword}{const} \mbox{\hyperlink{structgmm__dist__mode}{gmm\_dist\_mode}}\& dist\_mode)\textcolor{keyword}{ const}}
\DoxyCodeLine{600 \textcolor{keyword}{  }\{}
\DoxyCodeLine{601   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{602   }
\DoxyCodeLine{603   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap}{unwrap<T1>}}   tmp(expr.get\_ref());}
\DoxyCodeLine{604   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X = tmp.M;}
\DoxyCodeLine{605   }
\DoxyCodeLine{606   arma\_debug\_check( (X.n\_rows != means.n\_rows), \textcolor{stringliteral}{"{}gmm\_diag::raw\_hist(): incompatible dimensions"{}} );}
\DoxyCodeLine{607   }
\DoxyCodeLine{608   arma\_debug\_check( ((dist\_mode != eucl\_dist) \&\& (dist\_mode != prob\_dist)), \textcolor{stringliteral}{"{}gmm\_diag::raw\_hist(): unsupported distance mode"{}} );}
\DoxyCodeLine{609   }
\DoxyCodeLine{610   \mbox{\hyperlink{classRow}{urowvec}} hist;}
\DoxyCodeLine{611   }
\DoxyCodeLine{612   internal\_raw\_hist(hist, X, dist\_mode);}
\DoxyCodeLine{613   }
\DoxyCodeLine{614   \textcolor{keywordflow}{return} hist;}
\DoxyCodeLine{615   \}}
\DoxyCodeLine{616 }
\DoxyCodeLine{617 }
\DoxyCodeLine{618 }
\DoxyCodeLine{619 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{620 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{621 \textcolor{keyword}{inline}}
\DoxyCodeLine{622 \mbox{\hyperlink{classRow}{Row<eT>}}}
\DoxyCodeLine{623 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::norm\_hist}}(\textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<eT,T1>}}\& expr, \textcolor{keyword}{const} \mbox{\hyperlink{structgmm__dist__mode}{gmm\_dist\_mode}}\& dist\_mode)\textcolor{keyword}{ const}}
\DoxyCodeLine{624 \textcolor{keyword}{  }\{}
\DoxyCodeLine{625   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{626   }
\DoxyCodeLine{627   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap}{unwrap<T1>}}   tmp(expr.get\_ref());}
\DoxyCodeLine{628   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X = tmp.M;}
\DoxyCodeLine{629   }
\DoxyCodeLine{630   arma\_debug\_check( (X.n\_rows != means.n\_rows), \textcolor{stringliteral}{"{}gmm\_diag::norm\_hist(): incompatible dimensions"{}} );}
\DoxyCodeLine{631   }
\DoxyCodeLine{632   arma\_debug\_check( ((dist\_mode != eucl\_dist) \&\& (dist\_mode != prob\_dist)), \textcolor{stringliteral}{"{}gmm\_diag::norm\_hist(): unsupported distance mode"{}} );}
\DoxyCodeLine{633   }
\DoxyCodeLine{634   \mbox{\hyperlink{classRow}{urowvec}} hist;}
\DoxyCodeLine{635   }
\DoxyCodeLine{636   internal\_raw\_hist(hist, X, dist\_mode);}
\DoxyCodeLine{637   }
\DoxyCodeLine{638   \textcolor{keyword}{const} uword  hist\_n\_elem = hist.n\_elem;}
\DoxyCodeLine{639   \textcolor{keyword}{const} uword* hist\_mem    = hist.memptr();}
\DoxyCodeLine{640   }
\DoxyCodeLine{641   eT acc = eT(0);}
\DoxyCodeLine{642   \textcolor{keywordflow}{for}(uword i=0; i<hist\_n\_elem; ++i)  \{ acc += eT(hist\_mem[i]); \}}
\DoxyCodeLine{643   }
\DoxyCodeLine{644   \textcolor{keywordflow}{if}(acc == eT(0))  \{ acc = eT(1); \}}
\DoxyCodeLine{645   }
\DoxyCodeLine{646   \mbox{\hyperlink{classRow}{Row<eT>}} out(hist\_n\_elem, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{647   }
\DoxyCodeLine{648   eT* out\_mem = out.memptr();}
\DoxyCodeLine{649   }
\DoxyCodeLine{650   \textcolor{keywordflow}{for}(uword i=0; i<hist\_n\_elem; ++i)  \{ out\_mem[i] = eT(hist\_mem[i]) / acc; \}}
\DoxyCodeLine{651   }
\DoxyCodeLine{652   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{653   \}}
\DoxyCodeLine{654 }
\DoxyCodeLine{655 }
\DoxyCodeLine{656 }
\DoxyCodeLine{657 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{658 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{659 \textcolor{keyword}{inline}}
\DoxyCodeLine{660 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{661 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::learn}}}
\DoxyCodeLine{662   (}
\DoxyCodeLine{663   \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<eT,T1>}}\&   data,}
\DoxyCodeLine{664   \textcolor{keyword}{const} uword          N\_gaus,}
\DoxyCodeLine{665   \textcolor{keyword}{const} \mbox{\hyperlink{structgmm__dist__mode}{gmm\_dist\_mode}}\& dist\_mode,}
\DoxyCodeLine{666   \textcolor{keyword}{const} \mbox{\hyperlink{structgmm__seed__mode}{gmm\_seed\_mode}}\& seed\_mode,}
\DoxyCodeLine{667   \textcolor{keyword}{const} uword          km\_iter,}
\DoxyCodeLine{668   \textcolor{keyword}{const} uword          em\_iter,}
\DoxyCodeLine{669   \textcolor{keyword}{const} eT             var\_floor,}
\DoxyCodeLine{670   \textcolor{keyword}{const} \textcolor{keywordtype}{bool}           print\_mode}
\DoxyCodeLine{671   )}
\DoxyCodeLine{672   \{}
\DoxyCodeLine{673   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{674   }
\DoxyCodeLine{675   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} dist\_mode\_ok = (dist\_mode == eucl\_dist) || (dist\_mode == maha\_dist);}
\DoxyCodeLine{676   }
\DoxyCodeLine{677   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} seed\_mode\_ok = \(\backslash\)}
\DoxyCodeLine{678        (seed\_mode == keep\_existing)}
\DoxyCodeLine{679     || (seed\_mode == static\_subset)}
\DoxyCodeLine{680     || (seed\_mode == static\_spread)}
\DoxyCodeLine{681     || (seed\_mode == random\_subset)}
\DoxyCodeLine{682     || (seed\_mode == random\_spread);}
\DoxyCodeLine{683   }
\DoxyCodeLine{684   arma\_debug\_check( (dist\_mode\_ok == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}gmm\_diag::learn(): dist\_mode must be eucl\_dist or maha\_dist"{}} );}
\DoxyCodeLine{685   arma\_debug\_check( (seed\_mode\_ok == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}gmm\_diag::learn(): unknown seed\_mode"{}}                        );}
\DoxyCodeLine{686   arma\_debug\_check( (var\_floor < eT(0)    ), \textcolor{stringliteral}{"{}gmm\_diag::learn(): variance floor is negative"{}}               );}
\DoxyCodeLine{687   }
\DoxyCodeLine{688   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap}{unwrap<T1>}}   tmp\_X(data.get\_ref());}
\DoxyCodeLine{689   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X = tmp\_X.M;}
\DoxyCodeLine{690   }
\DoxyCodeLine{691   \textcolor{keywordflow}{if}(X.is\_empty()          )  \{ arma\_debug\_warn\_level(3, \textcolor{stringliteral}{"{}gmm\_diag::learn(): given matrix is empty"{}}             ); \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{692   \textcolor{keywordflow}{if}(X.is\_finite() == \textcolor{keyword}{false})  \{ arma\_debug\_warn\_level(3, \textcolor{stringliteral}{"{}gmm\_diag::learn(): given matrix has non-\/finite values"{}}); \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{693   }
\DoxyCodeLine{694   \textcolor{keywordflow}{if}(N\_gaus == 0)  \{ reset(); \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{695   }
\DoxyCodeLine{696   \textcolor{keywordflow}{if}(dist\_mode == maha\_dist)}
\DoxyCodeLine{697     \{}
\DoxyCodeLine{698     mah\_aux = var(X,1,1);}
\DoxyCodeLine{699     }
\DoxyCodeLine{700     \textcolor{keyword}{const} uword mah\_aux\_n\_elem = mah\_aux.n\_elem;}
\DoxyCodeLine{701           eT*   mah\_aux\_mem    = mah\_aux.memptr();}
\DoxyCodeLine{702     }
\DoxyCodeLine{703     \textcolor{keywordflow}{for}(uword i=0; i < mah\_aux\_n\_elem; ++i)}
\DoxyCodeLine{704       \{}
\DoxyCodeLine{705       \textcolor{keyword}{const} eT val = mah\_aux\_mem[i];}
\DoxyCodeLine{706       }
\DoxyCodeLine{707       mah\_aux\_mem[i] = ((val != eT(0)) \&\& arma\_isfinite(val)) ? eT(1) / val : eT(1);}
\DoxyCodeLine{708       \}}
\DoxyCodeLine{709     \}}
\DoxyCodeLine{710   }
\DoxyCodeLine{711   }
\DoxyCodeLine{712   \textcolor{comment}{// copy current model, in case of failure by k-\/means and/or EM}}
\DoxyCodeLine{713   }
\DoxyCodeLine{714   \textcolor{keyword}{const} \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>}} orig = (*this);}
\DoxyCodeLine{715   }
\DoxyCodeLine{716   }
\DoxyCodeLine{717   \textcolor{comment}{// initial means}}
\DoxyCodeLine{718   }
\DoxyCodeLine{719   \textcolor{keywordflow}{if}(seed\_mode == keep\_existing)}
\DoxyCodeLine{720     \{}
\DoxyCodeLine{721     \textcolor{keywordflow}{if}(means.is\_empty()        )  \{ arma\_debug\_warn\_level(3, \textcolor{stringliteral}{"{}gmm\_diag::learn(): no existing means"{}}      ); \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{722     \textcolor{keywordflow}{if}(X.n\_rows != means.n\_rows)  \{ arma\_debug\_warn\_level(3, \textcolor{stringliteral}{"{}gmm\_diag::learn(): dimensionality mismatch"{}}); \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{723     }
\DoxyCodeLine{724     \textcolor{comment}{// TODO: also check for number of vectors?}}
\DoxyCodeLine{725     \}}
\DoxyCodeLine{726   \textcolor{keywordflow}{else}}
\DoxyCodeLine{727     \{}
\DoxyCodeLine{728     \textcolor{keywordflow}{if}(X.n\_cols < N\_gaus)  \{ arma\_debug\_warn\_level(3, \textcolor{stringliteral}{"{}gmm\_diag::learn(): number of vectors is less than number of gaussians"{}}); \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{729     }
\DoxyCodeLine{730     reset(X.n\_rows, N\_gaus);}
\DoxyCodeLine{731     }
\DoxyCodeLine{732     \textcolor{keywordflow}{if}(print\_mode)  \{ get\_cout\_stream() << \textcolor{stringliteral}{"{}gmm\_diag::learn(): generating initial means\(\backslash\)n"{}}; get\_cout\_stream().flush(); \}}
\DoxyCodeLine{733     }
\DoxyCodeLine{734          \textcolor{keywordflow}{if}(dist\_mode == eucl\_dist)  \{ generate\_initial\_means<1>(X, seed\_mode); \}}
\DoxyCodeLine{735     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(dist\_mode == maha\_dist)  \{ generate\_initial\_means<2>(X, seed\_mode); \}}
\DoxyCodeLine{736     \}}
\DoxyCodeLine{737   }
\DoxyCodeLine{738   }
\DoxyCodeLine{739   \textcolor{comment}{// k-\/means}}
\DoxyCodeLine{740   }
\DoxyCodeLine{741   \textcolor{keywordflow}{if}(km\_iter > 0)}
\DoxyCodeLine{742     \{}
\DoxyCodeLine{743     \textcolor{keyword}{const} \mbox{\hyperlink{classarma__ostream__state}{arma\_ostream\_state}} stream\_state(get\_cout\_stream());}
\DoxyCodeLine{744     }
\DoxyCodeLine{745     \textcolor{keywordtype}{bool} status = \textcolor{keyword}{false};}
\DoxyCodeLine{746     }
\DoxyCodeLine{747          \textcolor{keywordflow}{if}(dist\_mode == eucl\_dist)  \{ status = km\_iterate<1>(X, km\_iter, print\_mode, \textcolor{stringliteral}{"{}gmm\_diag::learn(): k-\/means"{}}); \}}
\DoxyCodeLine{748     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(dist\_mode == maha\_dist)  \{ status = km\_iterate<2>(X, km\_iter, print\_mode, \textcolor{stringliteral}{"{}gmm\_diag::learn(): k-\/means"{}}); \}}
\DoxyCodeLine{749     }
\DoxyCodeLine{750     stream\_state.restore(get\_cout\_stream());}
\DoxyCodeLine{751     }
\DoxyCodeLine{752     \textcolor{keywordflow}{if}(status == \textcolor{keyword}{false})  \{ arma\_debug\_warn\_level(3, \textcolor{stringliteral}{"{}gmm\_diag::learn(): k-\/means algorithm failed; not enough data, or too many gaussians requested"{}}); init(orig); \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{753     \}}
\DoxyCodeLine{754   }
\DoxyCodeLine{755   }
\DoxyCodeLine{756   \textcolor{comment}{// initial dcovs}}
\DoxyCodeLine{757   }
\DoxyCodeLine{758   \textcolor{keyword}{const} eT var\_floor\_actual = (eT(var\_floor) > eT(0)) ? eT(var\_floor) : \mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::numeric\_limits<eT>::min}}();}
\DoxyCodeLine{759   }
\DoxyCodeLine{760   \textcolor{keywordflow}{if}(seed\_mode != keep\_existing)}
\DoxyCodeLine{761     \{}
\DoxyCodeLine{762     \textcolor{keywordflow}{if}(print\_mode)  \{ get\_cout\_stream() << \textcolor{stringliteral}{"{}gmm\_diag::learn(): generating initial covariances\(\backslash\)n"{}}; get\_cout\_stream().flush(); \}}
\DoxyCodeLine{763     }
\DoxyCodeLine{764          \textcolor{keywordflow}{if}(dist\_mode == eucl\_dist)  \{ generate\_initial\_params<1>(X, var\_floor\_actual); \}}
\DoxyCodeLine{765     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(dist\_mode == maha\_dist)  \{ generate\_initial\_params<2>(X, var\_floor\_actual); \}}
\DoxyCodeLine{766     \}}
\DoxyCodeLine{767   }
\DoxyCodeLine{768   }
\DoxyCodeLine{769   \textcolor{comment}{// EM algorithm}}
\DoxyCodeLine{770   }
\DoxyCodeLine{771   \textcolor{keywordflow}{if}(em\_iter > 0)}
\DoxyCodeLine{772     \{}
\DoxyCodeLine{773     \textcolor{keyword}{const} \mbox{\hyperlink{classarma__ostream__state}{arma\_ostream\_state}} stream\_state(get\_cout\_stream());}
\DoxyCodeLine{774     }
\DoxyCodeLine{775     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} status = em\_iterate(X, em\_iter, var\_floor\_actual, print\_mode);}
\DoxyCodeLine{776     }
\DoxyCodeLine{777     stream\_state.restore(get\_cout\_stream());}
\DoxyCodeLine{778     }
\DoxyCodeLine{779     \textcolor{keywordflow}{if}(status == \textcolor{keyword}{false})  \{ arma\_debug\_warn\_level(3, \textcolor{stringliteral}{"{}gmm\_diag::learn(): EM algorithm failed"{}}); init(orig); \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{780     \}}
\DoxyCodeLine{781   }
\DoxyCodeLine{782   mah\_aux.reset();}
\DoxyCodeLine{783   }
\DoxyCodeLine{784   init\_constants();}
\DoxyCodeLine{785   }
\DoxyCodeLine{786   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{787   \}}
\DoxyCodeLine{788 }
\DoxyCodeLine{789 }
\DoxyCodeLine{790 }
\DoxyCodeLine{791 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{792 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{793 \textcolor{keyword}{inline}}
\DoxyCodeLine{794 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{795 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::kmeans\_wrapper}}}
\DoxyCodeLine{796   (}
\DoxyCodeLine{797         \mbox{\hyperlink{classMat}{Mat<eT>}}\&       user\_means,}
\DoxyCodeLine{798   \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<eT,T1>}}\&   data,}
\DoxyCodeLine{799   \textcolor{keyword}{const} uword          N\_gaus,}
\DoxyCodeLine{800   \textcolor{keyword}{const} \mbox{\hyperlink{structgmm__seed__mode}{gmm\_seed\_mode}}\& seed\_mode,}
\DoxyCodeLine{801   \textcolor{keyword}{const} uword          km\_iter,}
\DoxyCodeLine{802   \textcolor{keyword}{const} \textcolor{keywordtype}{bool}           print\_mode}
\DoxyCodeLine{803   )}
\DoxyCodeLine{804   \{}
\DoxyCodeLine{805   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{806   }
\DoxyCodeLine{807   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} seed\_mode\_ok = \(\backslash\)}
\DoxyCodeLine{808        (seed\_mode == keep\_existing)}
\DoxyCodeLine{809     || (seed\_mode == static\_subset)}
\DoxyCodeLine{810     || (seed\_mode == static\_spread)}
\DoxyCodeLine{811     || (seed\_mode == random\_subset)}
\DoxyCodeLine{812     || (seed\_mode == random\_spread);}
\DoxyCodeLine{813   }
\DoxyCodeLine{814   arma\_debug\_check( (seed\_mode\_ok == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}kmeans(): unknown seed\_mode"{}} );}
\DoxyCodeLine{815   }
\DoxyCodeLine{816   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap}{unwrap<T1>}}   tmp\_X(data.get\_ref());}
\DoxyCodeLine{817   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X = tmp\_X.M;}
\DoxyCodeLine{818   }
\DoxyCodeLine{819   \textcolor{keywordflow}{if}(X.is\_empty()          )  \{ arma\_debug\_warn\_level(3, \textcolor{stringliteral}{"{}kmeans(): given matrix is empty"{}}             ); \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{820   \textcolor{keywordflow}{if}(X.is\_finite() == \textcolor{keyword}{false})  \{ arma\_debug\_warn\_level(3, \textcolor{stringliteral}{"{}kmeans(): given matrix has non-\/finite values"{}}); \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{821   }
\DoxyCodeLine{822   \textcolor{keywordflow}{if}(N\_gaus == 0)  \{ reset(); \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{823   }
\DoxyCodeLine{824   }
\DoxyCodeLine{825   \textcolor{comment}{// initial means}}
\DoxyCodeLine{826   }
\DoxyCodeLine{827   \textcolor{keywordflow}{if}(seed\_mode == keep\_existing)}
\DoxyCodeLine{828     \{}
\DoxyCodeLine{829     \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(means) = user\_means;}
\DoxyCodeLine{830     }
\DoxyCodeLine{831     \textcolor{keywordflow}{if}(means.is\_empty()        )  \{ arma\_debug\_warn\_level(3, \textcolor{stringliteral}{"{}kmeans(): no existing means"{}}      ); \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{832     \textcolor{keywordflow}{if}(X.n\_rows != means.n\_rows)  \{ arma\_debug\_warn\_level(3, \textcolor{stringliteral}{"{}kmeans(): dimensionality mismatch"{}}); \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{833     }
\DoxyCodeLine{834     \textcolor{comment}{// TODO: also check for number of vectors?}}
\DoxyCodeLine{835     \}}
\DoxyCodeLine{836   \textcolor{keywordflow}{else}}
\DoxyCodeLine{837     \{}
\DoxyCodeLine{838     \textcolor{keywordflow}{if}(X.n\_cols < N\_gaus)  \{ arma\_debug\_warn\_level(3, \textcolor{stringliteral}{"{}kmeans(): number of vectors is less than number of means"{}}); \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{839     }
\DoxyCodeLine{840     \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(means).zeros(X.n\_rows, N\_gaus);}
\DoxyCodeLine{841     }
\DoxyCodeLine{842     \textcolor{keywordflow}{if}(print\_mode)  \{ get\_cout\_stream() << \textcolor{stringliteral}{"{}kmeans(): generating initial means\(\backslash\)n"{}}; \}}
\DoxyCodeLine{843     }
\DoxyCodeLine{844     generate\_initial\_means<1>(X, seed\_mode);}
\DoxyCodeLine{845     \}}
\DoxyCodeLine{846   }
\DoxyCodeLine{847   }
\DoxyCodeLine{848   \textcolor{comment}{// k-\/means}}
\DoxyCodeLine{849   }
\DoxyCodeLine{850   \textcolor{keywordflow}{if}(km\_iter > 0)}
\DoxyCodeLine{851     \{}
\DoxyCodeLine{852     \textcolor{keyword}{const} \mbox{\hyperlink{classarma__ostream__state}{arma\_ostream\_state}} stream\_state(get\_cout\_stream());}
\DoxyCodeLine{853     }
\DoxyCodeLine{854     \textcolor{keywordtype}{bool} status = \textcolor{keyword}{false};}
\DoxyCodeLine{855     }
\DoxyCodeLine{856     status = km\_iterate<1>(X, km\_iter, print\_mode, \textcolor{stringliteral}{"{}kmeans()"{}});}
\DoxyCodeLine{857     }
\DoxyCodeLine{858     stream\_state.restore(get\_cout\_stream());}
\DoxyCodeLine{859     }
\DoxyCodeLine{860     \textcolor{keywordflow}{if}(status == \textcolor{keyword}{false})  \{ arma\_debug\_warn\_level(3, \textcolor{stringliteral}{"{}kmeans(): clustering failed; not enough data, or too many means requested"{}}); \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{861     \}}
\DoxyCodeLine{862   }
\DoxyCodeLine{863   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{864   \}}
\DoxyCodeLine{865 }
\DoxyCodeLine{866 }
\DoxyCodeLine{867 }
\DoxyCodeLine{868 \textcolor{comment}{//}}
\DoxyCodeLine{869 \textcolor{comment}{//}}
\DoxyCodeLine{870 \textcolor{comment}{//}}
\DoxyCodeLine{871 }
\DoxyCodeLine{872 }
\DoxyCodeLine{873 }
\DoxyCodeLine{874 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{875 \textcolor{keyword}{inline}}
\DoxyCodeLine{876 \textcolor{keywordtype}{void}}
\DoxyCodeLine{877 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::init}}(\textcolor{keyword}{const} \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>}}\& x)}
\DoxyCodeLine{878   \{}
\DoxyCodeLine{879   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{880   }
\DoxyCodeLine{881   \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>}}\& t = *\textcolor{keyword}{this};}
\DoxyCodeLine{882   }
\DoxyCodeLine{883   \textcolor{keywordflow}{if}(\&t != \&x)}
\DoxyCodeLine{884     \{}
\DoxyCodeLine{885     \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(t.means) = x.means;}
\DoxyCodeLine{886     \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(t.dcovs) = x.dcovs;}
\DoxyCodeLine{887     \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(t.hefts) = x.hefts;}
\DoxyCodeLine{888     }
\DoxyCodeLine{889     init\_constants();}
\DoxyCodeLine{890     \}}
\DoxyCodeLine{891   \}}
\DoxyCodeLine{892 }
\DoxyCodeLine{893 }
\DoxyCodeLine{894 }
\DoxyCodeLine{895 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{896 \textcolor{keyword}{inline}}
\DoxyCodeLine{897 \textcolor{keywordtype}{void}}
\DoxyCodeLine{898 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::init}}(\textcolor{keyword}{const} \mbox{\hyperlink{classgmm__priv_1_1gmm__full}{gmm\_full<eT>}}\& x)}
\DoxyCodeLine{899   \{}
\DoxyCodeLine{900   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{901   }
\DoxyCodeLine{902   \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(hefts) = x.hefts;}
\DoxyCodeLine{903   \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(means) = x.means;}
\DoxyCodeLine{904   }
\DoxyCodeLine{905   \textcolor{keyword}{const} uword N\_dims = x.means.n\_rows;}
\DoxyCodeLine{906   \textcolor{keyword}{const} uword N\_gaus = x.means.n\_cols;}
\DoxyCodeLine{907   }
\DoxyCodeLine{908   \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(dcovs).zeros(N\_dims,N\_gaus);}
\DoxyCodeLine{909   }
\DoxyCodeLine{910   \textcolor{keywordflow}{for}(uword g=0; g < N\_gaus; ++g)}
\DoxyCodeLine{911     \{}
\DoxyCodeLine{912     \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& fcov = x.fcovs.slice(g);}
\DoxyCodeLine{913     }
\DoxyCodeLine{914     eT* dcov\_mem = \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(dcovs).colptr(g);}
\DoxyCodeLine{915     }
\DoxyCodeLine{916     \textcolor{keywordflow}{for}(uword d=0; d < N\_dims; ++d)}
\DoxyCodeLine{917       \{}
\DoxyCodeLine{918       dcov\_mem[d] = fcov.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(d,d);}
\DoxyCodeLine{919       \}}
\DoxyCodeLine{920     \}}
\DoxyCodeLine{921   }
\DoxyCodeLine{922   init\_constants();}
\DoxyCodeLine{923   \}}
\DoxyCodeLine{924 }
\DoxyCodeLine{925 }
\DoxyCodeLine{926 }
\DoxyCodeLine{927 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{928 \textcolor{keyword}{inline}}
\DoxyCodeLine{929 \textcolor{keywordtype}{void}}
\DoxyCodeLine{930 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::init}}(\textcolor{keyword}{const} uword in\_n\_dims, \textcolor{keyword}{const} uword in\_n\_gaus)}
\DoxyCodeLine{931   \{}
\DoxyCodeLine{932   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{933   }
\DoxyCodeLine{934   \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(means).zeros(in\_n\_dims, in\_n\_gaus);}
\DoxyCodeLine{935   }
\DoxyCodeLine{936   \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(dcovs).ones(in\_n\_dims, in\_n\_gaus);}
\DoxyCodeLine{937   }
\DoxyCodeLine{938   \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(hefts).set\_size(in\_n\_gaus);}
\DoxyCodeLine{939   }
\DoxyCodeLine{940   \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(hefts).fill(eT(1) / eT(in\_n\_gaus));}
\DoxyCodeLine{941   }
\DoxyCodeLine{942   init\_constants();}
\DoxyCodeLine{943   \}}
\DoxyCodeLine{944 }
\DoxyCodeLine{945 }
\DoxyCodeLine{946 }
\DoxyCodeLine{947 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{948 \textcolor{keyword}{inline}}
\DoxyCodeLine{949 \textcolor{keywordtype}{void}}
\DoxyCodeLine{950 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::init\_constants}}()}
\DoxyCodeLine{951   \{}
\DoxyCodeLine{952   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{953   }
\DoxyCodeLine{954   \textcolor{keyword}{const} uword N\_dims = means.n\_rows;}
\DoxyCodeLine{955   \textcolor{keyword}{const} uword N\_gaus = means.n\_cols;}
\DoxyCodeLine{956   }
\DoxyCodeLine{957   \textcolor{comment}{// }}
\DoxyCodeLine{958   }
\DoxyCodeLine{959   inv\_dcovs.copy\_size(dcovs);}
\DoxyCodeLine{960   }
\DoxyCodeLine{961   \textcolor{keyword}{const} eT*     dcovs\_mem =     dcovs.memptr();}
\DoxyCodeLine{962         eT* inv\_dcovs\_mem = inv\_dcovs.memptr();}
\DoxyCodeLine{963   }
\DoxyCodeLine{964   \textcolor{keyword}{const} uword dcovs\_n\_elem = dcovs.n\_elem;}
\DoxyCodeLine{965   }
\DoxyCodeLine{966   \textcolor{keywordflow}{for}(uword i=0; i < dcovs\_n\_elem; ++i)}
\DoxyCodeLine{967     \{}
\DoxyCodeLine{968     inv\_dcovs\_mem[i] = eT(1) / (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})( dcovs\_mem[i], \mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::numeric\_limits<eT>::min}}() );}
\DoxyCodeLine{969     \}}
\DoxyCodeLine{970   }
\DoxyCodeLine{971   \textcolor{comment}{//}}
\DoxyCodeLine{972   }
\DoxyCodeLine{973   \textcolor{keyword}{const} eT tmp = (eT(N\_dims)/eT(2)) * std::log(eT(2) * \mbox{\hyperlink{classDatum}{Datum<eT>::pi}});}
\DoxyCodeLine{974   }
\DoxyCodeLine{975   log\_det\_etc.set\_size(N\_gaus);}
\DoxyCodeLine{976   }
\DoxyCodeLine{977   \textcolor{keywordflow}{for}(uword g=0; g < N\_gaus; ++g)}
\DoxyCodeLine{978     \{}
\DoxyCodeLine{979     \textcolor{keyword}{const} eT* dcovs\_colmem = dcovs.colptr(g);}
\DoxyCodeLine{980     }
\DoxyCodeLine{981     eT log\_det\_val = eT(0);}
\DoxyCodeLine{982     }
\DoxyCodeLine{983     \textcolor{keywordflow}{for}(uword d=0; d < N\_dims; ++d)}
\DoxyCodeLine{984       \{}
\DoxyCodeLine{985       log\_det\_val += std::log( (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})( dcovs\_colmem[d], \mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::numeric\_limits<eT>::min}}() ) );}
\DoxyCodeLine{986       \}}
\DoxyCodeLine{987     }
\DoxyCodeLine{988     log\_det\_etc[g] = eT(-\/1) * ( tmp + eT(0.5) * log\_det\_val );}
\DoxyCodeLine{989     \}}
\DoxyCodeLine{990   }
\DoxyCodeLine{991   \textcolor{comment}{//}}
\DoxyCodeLine{992   }
\DoxyCodeLine{993   eT* hefts\_mem = \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(hefts).memptr();}
\DoxyCodeLine{994   }
\DoxyCodeLine{995   \textcolor{keywordflow}{for}(uword g=0; g < N\_gaus; ++g)}
\DoxyCodeLine{996     \{}
\DoxyCodeLine{997     hefts\_mem[g] = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})( hefts\_mem[g], \mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::numeric\_limits<eT>::min}}() );}
\DoxyCodeLine{998     \}}
\DoxyCodeLine{999   }
\DoxyCodeLine{1000   log\_hefts = log(hefts);}
\DoxyCodeLine{1001   \}}
\DoxyCodeLine{1002 }
\DoxyCodeLine{1003 }
\DoxyCodeLine{1004 }
\DoxyCodeLine{1005 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{1006 \textcolor{keyword}{inline}}
\DoxyCodeLine{1007 \mbox{\hyperlink{classMat}{umat}}}
\DoxyCodeLine{1008 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::internal\_gen\_boundaries}}(\textcolor{keyword}{const} uword N)\textcolor{keyword}{ const}}
\DoxyCodeLine{1009 \textcolor{keyword}{  }\{}
\DoxyCodeLine{1010   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1011   }
\DoxyCodeLine{1012 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_OPENMP)}}
\DoxyCodeLine{1013     \textcolor{keyword}{const} uword n\_threads\_avail = (omp\_in\_parallel()) ? uword(1) : uword(omp\_get\_max\_threads());}
\DoxyCodeLine{1014     \textcolor{keyword}{const} uword n\_threads       = (n\_threads\_avail > 0) ? ( (n\_threads\_avail <= N) ? n\_threads\_avail : 1 ) : 1;}
\DoxyCodeLine{1015 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{1016     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} uword n\_threads = 1;}
\DoxyCodeLine{1017 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{1018   }
\DoxyCodeLine{1019   \textcolor{comment}{// get\_cout\_stream() << "{}gmm\_diag::internal\_gen\_boundaries(): n\_threads: "{} << n\_threads << '\(\backslash\)n';}}
\DoxyCodeLine{1020   }
\DoxyCodeLine{1021   \mbox{\hyperlink{classMat}{umat}} boundaries(2, n\_threads, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{1022   }
\DoxyCodeLine{1023   \textcolor{keywordflow}{if}(N > 0)}
\DoxyCodeLine{1024     \{}
\DoxyCodeLine{1025     \textcolor{keyword}{const} uword chunk\_size = N / n\_threads;}
\DoxyCodeLine{1026     }
\DoxyCodeLine{1027     uword count = 0;}
\DoxyCodeLine{1028     }
\DoxyCodeLine{1029     \textcolor{keywordflow}{for}(uword t=0; t<n\_threads; t++)}
\DoxyCodeLine{1030       \{}
\DoxyCodeLine{1031       boundaries.at(0,t) = count;}
\DoxyCodeLine{1032       }
\DoxyCodeLine{1033       count += chunk\_size;}
\DoxyCodeLine{1034       }
\DoxyCodeLine{1035       boundaries.at(1,t) = count-\/1;}
\DoxyCodeLine{1036       \}}
\DoxyCodeLine{1037     }
\DoxyCodeLine{1038     boundaries.at(1,n\_threads-\/1) = N -\/ 1;}
\DoxyCodeLine{1039     \}}
\DoxyCodeLine{1040   \textcolor{keywordflow}{else}}
\DoxyCodeLine{1041     \{}
\DoxyCodeLine{1042     boundaries.zeros();}
\DoxyCodeLine{1043     \}}
\DoxyCodeLine{1044   }
\DoxyCodeLine{1045   \textcolor{comment}{// get\_cout\_stream() << "{}gmm\_diag::internal\_gen\_boundaries(): boundaries: "{} << '\(\backslash\)n' << boundaries << '\(\backslash\)n';}}
\DoxyCodeLine{1046   }
\DoxyCodeLine{1047   \textcolor{keywordflow}{return} boundaries;}
\DoxyCodeLine{1048   \}}
\DoxyCodeLine{1049 }
\DoxyCodeLine{1050 }
\DoxyCodeLine{1051 }
\DoxyCodeLine{1052 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{1053 arma\_hot}
\DoxyCodeLine{1054 \textcolor{keyword}{inline}}
\DoxyCodeLine{1055 eT}
\DoxyCodeLine{1056 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::internal\_scalar\_log\_p}}(\textcolor{keyword}{const} eT* x)\textcolor{keyword}{ const}}
\DoxyCodeLine{1057 \textcolor{keyword}{  }\{}
\DoxyCodeLine{1058   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1059   }
\DoxyCodeLine{1060   \textcolor{keyword}{const} eT* log\_hefts\_mem = log\_hefts.mem;}
\DoxyCodeLine{1061   }
\DoxyCodeLine{1062   \textcolor{keyword}{const} uword N\_gaus = means.n\_cols;}
\DoxyCodeLine{1063   }
\DoxyCodeLine{1064   \textcolor{keywordflow}{if}(N\_gaus > 0)}
\DoxyCodeLine{1065     \{}
\DoxyCodeLine{1066     eT log\_sum = internal\_scalar\_log\_p(x, 0) + log\_hefts\_mem[0];}
\DoxyCodeLine{1067     }
\DoxyCodeLine{1068     \textcolor{keywordflow}{for}(uword g=1; g < N\_gaus; ++g)}
\DoxyCodeLine{1069       \{}
\DoxyCodeLine{1070       \textcolor{keyword}{const} eT tmp = internal\_scalar\_log\_p(x, g) + log\_hefts\_mem[g];}
\DoxyCodeLine{1071       }
\DoxyCodeLine{1072       log\_sum = log\_add\_exp(log\_sum, tmp);}
\DoxyCodeLine{1073       \}}
\DoxyCodeLine{1074     }
\DoxyCodeLine{1075     \textcolor{keywordflow}{return} log\_sum;}
\DoxyCodeLine{1076     \}}
\DoxyCodeLine{1077   \textcolor{keywordflow}{else}}
\DoxyCodeLine{1078     \{}
\DoxyCodeLine{1079     \textcolor{keywordflow}{return} -\/\mbox{\hyperlink{classDatum}{Datum<eT>::inf}};}
\DoxyCodeLine{1080     \}}
\DoxyCodeLine{1081   \}}
\DoxyCodeLine{1082 }
\DoxyCodeLine{1083 }
\DoxyCodeLine{1084 }
\DoxyCodeLine{1085 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{1086 arma\_hot}
\DoxyCodeLine{1087 \textcolor{keyword}{inline}}
\DoxyCodeLine{1088 eT}
\DoxyCodeLine{1089 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::internal\_scalar\_log\_p}}(\textcolor{keyword}{const} eT* x, \textcolor{keyword}{const} uword g)\textcolor{keyword}{ const}}
\DoxyCodeLine{1090 \textcolor{keyword}{  }\{}
\DoxyCodeLine{1091   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1092   }
\DoxyCodeLine{1093   \textcolor{keyword}{const} eT*     mean =     means.colptr(g);}
\DoxyCodeLine{1094   \textcolor{keyword}{const} eT* inv\_dcov = inv\_dcovs.colptr(g);}
\DoxyCodeLine{1095   }
\DoxyCodeLine{1096   \textcolor{keyword}{const} uword N\_dims = means.n\_rows;}
\DoxyCodeLine{1097   }
\DoxyCodeLine{1098   eT val\_i = eT(0);}
\DoxyCodeLine{1099   eT val\_j = eT(0);}
\DoxyCodeLine{1100   }
\DoxyCodeLine{1101   uword i,j;}
\DoxyCodeLine{1102   }
\DoxyCodeLine{1103   \textcolor{keywordflow}{for}(i=0, j=1; j<N\_dims; i+=2, j+=2)}
\DoxyCodeLine{1104     \{}
\DoxyCodeLine{1105     eT tmp\_i = x[i];}
\DoxyCodeLine{1106     eT tmp\_j = x[j];}
\DoxyCodeLine{1107     }
\DoxyCodeLine{1108     tmp\_i -\/= mean[i];}
\DoxyCodeLine{1109     tmp\_j -\/= mean[j];}
\DoxyCodeLine{1110     }
\DoxyCodeLine{1111     val\_i += (tmp\_i*tmp\_i) * inv\_dcov[i];}
\DoxyCodeLine{1112     val\_j += (tmp\_j*tmp\_j) * inv\_dcov[j];}
\DoxyCodeLine{1113     \}}
\DoxyCodeLine{1114   }
\DoxyCodeLine{1115   \textcolor{keywordflow}{if}(i < N\_dims)}
\DoxyCodeLine{1116     \{}
\DoxyCodeLine{1117     \textcolor{keyword}{const} eT tmp = x[i] -\/ mean[i];}
\DoxyCodeLine{1118     }
\DoxyCodeLine{1119     val\_i += (tmp*tmp) * inv\_dcov[i];}
\DoxyCodeLine{1120     \}}
\DoxyCodeLine{1121   }
\DoxyCodeLine{1122   \textcolor{keywordflow}{return} eT(-\/0.5)*(val\_i + val\_j) + log\_det\_etc.mem[g];}
\DoxyCodeLine{1123   \}}
\DoxyCodeLine{1124 }
\DoxyCodeLine{1125 }
\DoxyCodeLine{1126 }
\DoxyCodeLine{1127 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{1128 \textcolor{keyword}{inline}}
\DoxyCodeLine{1129 \mbox{\hyperlink{classRow}{Row<eT>}}}
\DoxyCodeLine{1130 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::internal\_vec\_log\_p}}(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X)\textcolor{keyword}{ const}}
\DoxyCodeLine{1131 \textcolor{keyword}{  }\{}
\DoxyCodeLine{1132   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1133   }
\DoxyCodeLine{1134   arma\_debug\_check( (X.n\_rows != means.n\_rows), \textcolor{stringliteral}{"{}gmm\_diag::log\_p(): incompatible dimensions"{}} );}
\DoxyCodeLine{1135   }
\DoxyCodeLine{1136   \textcolor{keyword}{const} uword N = X.n\_cols;}
\DoxyCodeLine{1137   }
\DoxyCodeLine{1138   \mbox{\hyperlink{classRow}{Row<eT>}} out(N, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{1139   }
\DoxyCodeLine{1140   \textcolor{keywordflow}{if}(N > 0)}
\DoxyCodeLine{1141     \{}
\DoxyCodeLine{1142 \textcolor{preprocessor}{    \#if defined(ARMA\_USE\_OPENMP)}}
\DoxyCodeLine{1143       \{}
\DoxyCodeLine{1144       \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{umat}} boundaries = internal\_gen\_boundaries(N);}
\DoxyCodeLine{1145       }
\DoxyCodeLine{1146       \textcolor{keyword}{const} uword n\_threads = boundaries.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}};}
\DoxyCodeLine{1147       }
\DoxyCodeLine{1148 \textcolor{preprocessor}{      \#pragma omp parallel for schedule(static)}}
\DoxyCodeLine{1149       \textcolor{keywordflow}{for}(uword t=0; t < n\_threads; ++t)}
\DoxyCodeLine{1150         \{}
\DoxyCodeLine{1151         \textcolor{keyword}{const} uword start\_index = boundaries.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(0,t);}
\DoxyCodeLine{1152         \textcolor{keyword}{const} uword   end\_index = boundaries.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(1,t);}
\DoxyCodeLine{1153         }
\DoxyCodeLine{1154         eT* out\_mem = out.memptr();}
\DoxyCodeLine{1155         }
\DoxyCodeLine{1156         \textcolor{keywordflow}{for}(uword i=start\_index; i <= end\_index; ++i)}
\DoxyCodeLine{1157           \{}
\DoxyCodeLine{1158           out\_mem[i] = internal\_scalar\_log\_p( X.colptr(i) );}
\DoxyCodeLine{1159           \}}
\DoxyCodeLine{1160         \}}
\DoxyCodeLine{1161       \}}
\DoxyCodeLine{1162 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{1163       \{}
\DoxyCodeLine{1164       eT* out\_mem = out.memptr();}
\DoxyCodeLine{1165       }
\DoxyCodeLine{1166       \textcolor{keywordflow}{for}(uword i=0; i < N; ++i)}
\DoxyCodeLine{1167         \{}
\DoxyCodeLine{1168         out\_mem[i] = internal\_scalar\_log\_p( X.colptr(i) );}
\DoxyCodeLine{1169         \}}
\DoxyCodeLine{1170       \}}
\DoxyCodeLine{1171 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{1172     \}}
\DoxyCodeLine{1173   }
\DoxyCodeLine{1174   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{1175   \}}
\DoxyCodeLine{1176 }
\DoxyCodeLine{1177 }
\DoxyCodeLine{1178 }
\DoxyCodeLine{1179 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{1180 \textcolor{keyword}{inline}}
\DoxyCodeLine{1181 \mbox{\hyperlink{classRow}{Row<eT>}}}
\DoxyCodeLine{1182 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::internal\_vec\_log\_p}}(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X, \textcolor{keyword}{const} uword gaus\_id)\textcolor{keyword}{ const}}
\DoxyCodeLine{1183 \textcolor{keyword}{  }\{}
\DoxyCodeLine{1184   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1185   }
\DoxyCodeLine{1186   arma\_debug\_check( (X.n\_rows != means.n\_rows), \textcolor{stringliteral}{"{}gmm\_diag::log\_p(): incompatible dimensions"{}} );}
\DoxyCodeLine{1187   arma\_debug\_check( (gaus\_id  >= means.n\_cols), \textcolor{stringliteral}{"{}gmm\_diag::log\_p(): specified gaussian is out of range"{}} );}
\DoxyCodeLine{1188   }
\DoxyCodeLine{1189   \textcolor{keyword}{const} uword N = X.n\_cols;}
\DoxyCodeLine{1190   }
\DoxyCodeLine{1191   \mbox{\hyperlink{classRow}{Row<eT>}} out(N, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{1192   }
\DoxyCodeLine{1193   \textcolor{keywordflow}{if}(N > 0)}
\DoxyCodeLine{1194     \{}
\DoxyCodeLine{1195 \textcolor{preprocessor}{    \#if defined(ARMA\_USE\_OPENMP)}}
\DoxyCodeLine{1196       \{}
\DoxyCodeLine{1197       \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{umat}} boundaries = internal\_gen\_boundaries(N);}
\DoxyCodeLine{1198       }
\DoxyCodeLine{1199       \textcolor{keyword}{const} uword n\_threads = boundaries.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}};}
\DoxyCodeLine{1200       }
\DoxyCodeLine{1201 \textcolor{preprocessor}{      \#pragma omp parallel for schedule(static)}}
\DoxyCodeLine{1202       \textcolor{keywordflow}{for}(uword t=0; t < n\_threads; ++t)}
\DoxyCodeLine{1203         \{}
\DoxyCodeLine{1204         \textcolor{keyword}{const} uword start\_index = boundaries.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(0,t);}
\DoxyCodeLine{1205         \textcolor{keyword}{const} uword   end\_index = boundaries.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(1,t);}
\DoxyCodeLine{1206         }
\DoxyCodeLine{1207         eT* out\_mem = out.memptr();}
\DoxyCodeLine{1208         }
\DoxyCodeLine{1209         \textcolor{keywordflow}{for}(uword i=start\_index; i <= end\_index; ++i)}
\DoxyCodeLine{1210           \{}
\DoxyCodeLine{1211           out\_mem[i] = internal\_scalar\_log\_p( X.colptr(i), gaus\_id );}
\DoxyCodeLine{1212           \}}
\DoxyCodeLine{1213         \}}
\DoxyCodeLine{1214       \}}
\DoxyCodeLine{1215 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{1216       \{}
\DoxyCodeLine{1217       eT* out\_mem = out.memptr();}
\DoxyCodeLine{1218       }
\DoxyCodeLine{1219       \textcolor{keywordflow}{for}(uword i=0; i < N; ++i)}
\DoxyCodeLine{1220         \{}
\DoxyCodeLine{1221         out\_mem[i] = internal\_scalar\_log\_p( X.colptr(i), gaus\_id );}
\DoxyCodeLine{1222         \}}
\DoxyCodeLine{1223       \}}
\DoxyCodeLine{1224 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{1225     \}}
\DoxyCodeLine{1226   }
\DoxyCodeLine{1227   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{1228   \}}
\DoxyCodeLine{1229 }
\DoxyCodeLine{1230 }
\DoxyCodeLine{1231 }
\DoxyCodeLine{1232 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{1233 \textcolor{keyword}{inline}}
\DoxyCodeLine{1234 eT}
\DoxyCodeLine{1235 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::internal\_sum\_log\_p}}(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X)\textcolor{keyword}{ const}}
\DoxyCodeLine{1236 \textcolor{keyword}{  }\{}
\DoxyCodeLine{1237   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1238   }
\DoxyCodeLine{1239   arma\_debug\_check( (X.n\_rows != means.n\_rows), \textcolor{stringliteral}{"{}gmm\_diag::sum\_log\_p(): incompatible dimensions"{}} );}
\DoxyCodeLine{1240     }
\DoxyCodeLine{1241   \textcolor{keyword}{const} uword N = X.n\_cols;}
\DoxyCodeLine{1242   }
\DoxyCodeLine{1243   \textcolor{keywordflow}{if}(N == 0)  \{ \textcolor{keywordflow}{return} (-\/\mbox{\hyperlink{classDatum}{Datum<eT>::inf}}); \}}
\DoxyCodeLine{1244   }
\DoxyCodeLine{1245   }
\DoxyCodeLine{1246 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_OPENMP)}}
\DoxyCodeLine{1247     \{}
\DoxyCodeLine{1248     \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{umat}} boundaries = internal\_gen\_boundaries(N);}
\DoxyCodeLine{1249     }
\DoxyCodeLine{1250     \textcolor{keyword}{const} uword n\_threads = boundaries.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}};}
\DoxyCodeLine{1251     }
\DoxyCodeLine{1252     \mbox{\hyperlink{classCol}{Col<eT>}} t\_accs(n\_threads, \mbox{\hyperlink{structarma__zeros__indicator}{arma\_zeros\_indicator}}());}
\DoxyCodeLine{1253     }
\DoxyCodeLine{1254 \textcolor{preprocessor}{    \#pragma omp parallel for schedule(static)}}
\DoxyCodeLine{1255     \textcolor{keywordflow}{for}(uword t=0; t < n\_threads; ++t)}
\DoxyCodeLine{1256       \{}
\DoxyCodeLine{1257       \textcolor{keyword}{const} uword start\_index = boundaries.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(0,t);}
\DoxyCodeLine{1258       \textcolor{keyword}{const} uword   end\_index = boundaries.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(1,t);}
\DoxyCodeLine{1259       }
\DoxyCodeLine{1260       eT t\_acc = eT(0);}
\DoxyCodeLine{1261       }
\DoxyCodeLine{1262       \textcolor{keywordflow}{for}(uword i=start\_index; i <= end\_index; ++i)}
\DoxyCodeLine{1263         \{}
\DoxyCodeLine{1264         t\_acc += internal\_scalar\_log\_p( X.colptr(i) );}
\DoxyCodeLine{1265         \}}
\DoxyCodeLine{1266       }
\DoxyCodeLine{1267       t\_accs[t] = t\_acc;}
\DoxyCodeLine{1268       \}}
\DoxyCodeLine{1269     }
\DoxyCodeLine{1270     \textcolor{keywordflow}{return} eT(\mbox{\hyperlink{group__fn__accu_ga010aa66ecb6b417277db3e21cc10f6e6}{accu}}(t\_accs));}
\DoxyCodeLine{1271     \}}
\DoxyCodeLine{1272 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{1273     \{}
\DoxyCodeLine{1274     eT acc = eT(0);}
\DoxyCodeLine{1275     }
\DoxyCodeLine{1276     \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)}
\DoxyCodeLine{1277       \{}
\DoxyCodeLine{1278       acc += internal\_scalar\_log\_p( X.colptr(i) );}
\DoxyCodeLine{1279       \}}
\DoxyCodeLine{1280     }
\DoxyCodeLine{1281     \textcolor{keywordflow}{return} acc;}
\DoxyCodeLine{1282     \}}
\DoxyCodeLine{1283 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{1284   \}}
\DoxyCodeLine{1285 }
\DoxyCodeLine{1286 }
\DoxyCodeLine{1287 }
\DoxyCodeLine{1288 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{1289 \textcolor{keyword}{inline}}
\DoxyCodeLine{1290 eT}
\DoxyCodeLine{1291 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::internal\_sum\_log\_p}}(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X, \textcolor{keyword}{const} uword gaus\_id)\textcolor{keyword}{ const}}
\DoxyCodeLine{1292 \textcolor{keyword}{  }\{}
\DoxyCodeLine{1293   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1294   }
\DoxyCodeLine{1295   arma\_debug\_check( (X.n\_rows != means.n\_rows), \textcolor{stringliteral}{"{}gmm\_diag::sum\_log\_p(): incompatible dimensions"{}}            );}
\DoxyCodeLine{1296   arma\_debug\_check( (gaus\_id  >= means.n\_cols), \textcolor{stringliteral}{"{}gmm\_diag::sum\_log\_p(): specified gaussian is out of range"{}} );}
\DoxyCodeLine{1297     }
\DoxyCodeLine{1298   \textcolor{keyword}{const} uword N = X.n\_cols;}
\DoxyCodeLine{1299   }
\DoxyCodeLine{1300   \textcolor{keywordflow}{if}(N == 0)  \{ \textcolor{keywordflow}{return} (-\/\mbox{\hyperlink{classDatum}{Datum<eT>::inf}}); \}}
\DoxyCodeLine{1301   }
\DoxyCodeLine{1302   }
\DoxyCodeLine{1303 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_OPENMP)}}
\DoxyCodeLine{1304     \{}
\DoxyCodeLine{1305     \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{umat}} boundaries = internal\_gen\_boundaries(N);}
\DoxyCodeLine{1306     }
\DoxyCodeLine{1307     \textcolor{keyword}{const} uword n\_threads = boundaries.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}};}
\DoxyCodeLine{1308     }
\DoxyCodeLine{1309     \mbox{\hyperlink{classCol}{Col<eT>}} t\_accs(n\_threads, \mbox{\hyperlink{structarma__zeros__indicator}{arma\_zeros\_indicator}}());}
\DoxyCodeLine{1310     }
\DoxyCodeLine{1311 \textcolor{preprocessor}{    \#pragma omp parallel for schedule(static)}}
\DoxyCodeLine{1312     \textcolor{keywordflow}{for}(uword t=0; t < n\_threads; ++t)}
\DoxyCodeLine{1313       \{}
\DoxyCodeLine{1314       \textcolor{keyword}{const} uword start\_index = boundaries.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(0,t);}
\DoxyCodeLine{1315       \textcolor{keyword}{const} uword   end\_index = boundaries.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(1,t);}
\DoxyCodeLine{1316       }
\DoxyCodeLine{1317       eT t\_acc = eT(0);}
\DoxyCodeLine{1318       }
\DoxyCodeLine{1319       \textcolor{keywordflow}{for}(uword i=start\_index; i <= end\_index; ++i)}
\DoxyCodeLine{1320         \{}
\DoxyCodeLine{1321         t\_acc += internal\_scalar\_log\_p( X.colptr(i), gaus\_id );}
\DoxyCodeLine{1322         \}}
\DoxyCodeLine{1323       }
\DoxyCodeLine{1324       t\_accs[t] = t\_acc;}
\DoxyCodeLine{1325       \}}
\DoxyCodeLine{1326     }
\DoxyCodeLine{1327     \textcolor{keywordflow}{return} eT(\mbox{\hyperlink{group__fn__accu_ga010aa66ecb6b417277db3e21cc10f6e6}{accu}}(t\_accs));}
\DoxyCodeLine{1328     \}}
\DoxyCodeLine{1329 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{1330     \{}
\DoxyCodeLine{1331     eT acc = eT(0);}
\DoxyCodeLine{1332     }
\DoxyCodeLine{1333     \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)}
\DoxyCodeLine{1334       \{}
\DoxyCodeLine{1335       acc += internal\_scalar\_log\_p( X.colptr(i), gaus\_id );}
\DoxyCodeLine{1336       \}}
\DoxyCodeLine{1337     }
\DoxyCodeLine{1338     \textcolor{keywordflow}{return} acc;}
\DoxyCodeLine{1339     \}}
\DoxyCodeLine{1340 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{1341   \}}
\DoxyCodeLine{1342 }
\DoxyCodeLine{1343 }
\DoxyCodeLine{1344 }
\DoxyCodeLine{1345 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{1346 \textcolor{keyword}{inline}}
\DoxyCodeLine{1347 eT}
\DoxyCodeLine{1348 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::internal\_avg\_log\_p}}(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X)\textcolor{keyword}{ const}}
\DoxyCodeLine{1349 \textcolor{keyword}{  }\{}
\DoxyCodeLine{1350   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1351   }
\DoxyCodeLine{1352   arma\_debug\_check( (X.n\_rows != means.n\_rows), \textcolor{stringliteral}{"{}gmm\_diag::avg\_log\_p(): incompatible dimensions"{}} );}
\DoxyCodeLine{1353     }
\DoxyCodeLine{1354   \textcolor{keyword}{const} uword N = X.n\_cols;}
\DoxyCodeLine{1355   }
\DoxyCodeLine{1356   \textcolor{keywordflow}{if}(N == 0)  \{ \textcolor{keywordflow}{return} (-\/\mbox{\hyperlink{classDatum}{Datum<eT>::inf}}); \}}
\DoxyCodeLine{1357   }
\DoxyCodeLine{1358   }
\DoxyCodeLine{1359 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_OPENMP)}}
\DoxyCodeLine{1360     \{}
\DoxyCodeLine{1361     \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{umat}} boundaries = internal\_gen\_boundaries(N);}
\DoxyCodeLine{1362     }
\DoxyCodeLine{1363     \textcolor{keyword}{const} uword n\_threads = boundaries.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}};}
\DoxyCodeLine{1364     }
\DoxyCodeLine{1365     \mbox{\hyperlink{classfield}{field< running\_mean\_scalar<eT>}} > t\_running\_means(n\_threads);}
\DoxyCodeLine{1366     }
\DoxyCodeLine{1367     }
\DoxyCodeLine{1368 \textcolor{preprocessor}{    \#pragma omp parallel for schedule(static)}}
\DoxyCodeLine{1369     \textcolor{keywordflow}{for}(uword t=0; t < n\_threads; ++t)}
\DoxyCodeLine{1370       \{}
\DoxyCodeLine{1371       \textcolor{keyword}{const} uword start\_index = boundaries.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(0,t);}
\DoxyCodeLine{1372       \textcolor{keyword}{const} uword   end\_index = boundaries.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(1,t);}
\DoxyCodeLine{1373       }
\DoxyCodeLine{1374       running\_mean\_scalar<eT>\& current\_running\_mean = t\_running\_means[t];}
\DoxyCodeLine{1375       }
\DoxyCodeLine{1376       \textcolor{keywordflow}{for}(uword i=start\_index; i <= end\_index; ++i)}
\DoxyCodeLine{1377         \{}
\DoxyCodeLine{1378         current\_running\_mean( internal\_scalar\_log\_p( X.colptr(i) ) );}
\DoxyCodeLine{1379         \}}
\DoxyCodeLine{1380       \}}
\DoxyCodeLine{1381     }
\DoxyCodeLine{1382     }
\DoxyCodeLine{1383     eT avg = eT(0);}
\DoxyCodeLine{1384     }
\DoxyCodeLine{1385     \textcolor{keywordflow}{for}(uword t=0; t < n\_threads; ++t)}
\DoxyCodeLine{1386       \{}
\DoxyCodeLine{1387       running\_mean\_scalar<eT>\& current\_running\_mean = t\_running\_means[t];}
\DoxyCodeLine{1388       }
\DoxyCodeLine{1389       \textcolor{keyword}{const} eT w = eT(current\_running\_mean.count()) / eT(N);}
\DoxyCodeLine{1390       }
\DoxyCodeLine{1391       avg += w * current\_running\_mean.mean();}
\DoxyCodeLine{1392       \}}
\DoxyCodeLine{1393     }
\DoxyCodeLine{1394     \textcolor{keywordflow}{return} avg;}
\DoxyCodeLine{1395     \}}
\DoxyCodeLine{1396 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{1397     \{}
\DoxyCodeLine{1398     running\_mean\_scalar<eT> running\_mean;}
\DoxyCodeLine{1399     }
\DoxyCodeLine{1400     \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)}
\DoxyCodeLine{1401       \{}
\DoxyCodeLine{1402       running\_mean( internal\_scalar\_log\_p( X.colptr(i) ) );}
\DoxyCodeLine{1403       \}}
\DoxyCodeLine{1404     }
\DoxyCodeLine{1405     \textcolor{keywordflow}{return} running\_mean.mean();}
\DoxyCodeLine{1406     \}}
\DoxyCodeLine{1407 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{1408   \}}
\DoxyCodeLine{1409 }
\DoxyCodeLine{1410 }
\DoxyCodeLine{1411 }
\DoxyCodeLine{1412 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{1413 \textcolor{keyword}{inline}}
\DoxyCodeLine{1414 eT}
\DoxyCodeLine{1415 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::internal\_avg\_log\_p}}(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X, \textcolor{keyword}{const} uword gaus\_id)\textcolor{keyword}{ const}}
\DoxyCodeLine{1416 \textcolor{keyword}{  }\{}
\DoxyCodeLine{1417   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1418   }
\DoxyCodeLine{1419   arma\_debug\_check( (X.n\_rows != means.n\_rows), \textcolor{stringliteral}{"{}gmm\_diag::avg\_log\_p(): incompatible dimensions"{}}            );}
\DoxyCodeLine{1420   arma\_debug\_check( (gaus\_id  >= means.n\_cols), \textcolor{stringliteral}{"{}gmm\_diag::avg\_log\_p(): specified gaussian is out of range"{}} );}
\DoxyCodeLine{1421   }
\DoxyCodeLine{1422   \textcolor{keyword}{const} uword N = X.n\_cols;}
\DoxyCodeLine{1423   }
\DoxyCodeLine{1424   \textcolor{keywordflow}{if}(N == 0)  \{ \textcolor{keywordflow}{return} (-\/\mbox{\hyperlink{classDatum}{Datum<eT>::inf}}); \}}
\DoxyCodeLine{1425   }
\DoxyCodeLine{1426   }
\DoxyCodeLine{1427 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_OPENMP)}}
\DoxyCodeLine{1428     \{}
\DoxyCodeLine{1429     \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{umat}} boundaries = internal\_gen\_boundaries(N);}
\DoxyCodeLine{1430     }
\DoxyCodeLine{1431     \textcolor{keyword}{const} uword n\_threads = boundaries.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}};}
\DoxyCodeLine{1432     }
\DoxyCodeLine{1433     \mbox{\hyperlink{classfield}{field< running\_mean\_scalar<eT>}} > t\_running\_means(n\_threads);}
\DoxyCodeLine{1434     }
\DoxyCodeLine{1435     }
\DoxyCodeLine{1436 \textcolor{preprocessor}{    \#pragma omp parallel for schedule(static)}}
\DoxyCodeLine{1437     \textcolor{keywordflow}{for}(uword t=0; t < n\_threads; ++t)}
\DoxyCodeLine{1438       \{}
\DoxyCodeLine{1439       \textcolor{keyword}{const} uword start\_index = boundaries.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(0,t);}
\DoxyCodeLine{1440       \textcolor{keyword}{const} uword   end\_index = boundaries.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(1,t);}
\DoxyCodeLine{1441       }
\DoxyCodeLine{1442       running\_mean\_scalar<eT>\& current\_running\_mean = t\_running\_means[t];}
\DoxyCodeLine{1443       }
\DoxyCodeLine{1444       \textcolor{keywordflow}{for}(uword i=start\_index; i <= end\_index; ++i)}
\DoxyCodeLine{1445         \{}
\DoxyCodeLine{1446         current\_running\_mean( internal\_scalar\_log\_p( X.colptr(i), gaus\_id) );}
\DoxyCodeLine{1447         \}}
\DoxyCodeLine{1448       \}}
\DoxyCodeLine{1449     }
\DoxyCodeLine{1450     }
\DoxyCodeLine{1451     eT avg = eT(0);}
\DoxyCodeLine{1452     }
\DoxyCodeLine{1453     \textcolor{keywordflow}{for}(uword t=0; t < n\_threads; ++t)}
\DoxyCodeLine{1454       \{}
\DoxyCodeLine{1455       running\_mean\_scalar<eT>\& current\_running\_mean = t\_running\_means[t];}
\DoxyCodeLine{1456       }
\DoxyCodeLine{1457       \textcolor{keyword}{const} eT w = eT(current\_running\_mean.count()) / eT(N);}
\DoxyCodeLine{1458       }
\DoxyCodeLine{1459       avg += w * current\_running\_mean.mean();}
\DoxyCodeLine{1460       \}}
\DoxyCodeLine{1461     }
\DoxyCodeLine{1462     \textcolor{keywordflow}{return} avg;}
\DoxyCodeLine{1463     \}}
\DoxyCodeLine{1464 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{1465     \{}
\DoxyCodeLine{1466     running\_mean\_scalar<eT> running\_mean;}
\DoxyCodeLine{1467     }
\DoxyCodeLine{1468     \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)}
\DoxyCodeLine{1469       \{}
\DoxyCodeLine{1470       running\_mean( internal\_scalar\_log\_p( X.colptr(i), gaus\_id ) );}
\DoxyCodeLine{1471       \}}
\DoxyCodeLine{1472     }
\DoxyCodeLine{1473     \textcolor{keywordflow}{return} running\_mean.mean();}
\DoxyCodeLine{1474     \}}
\DoxyCodeLine{1475 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{1476   \}}
\DoxyCodeLine{1477 }
\DoxyCodeLine{1478 }
\DoxyCodeLine{1479 }
\DoxyCodeLine{1480 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{1481 \textcolor{keyword}{inline}}
\DoxyCodeLine{1482 uword}
\DoxyCodeLine{1483 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::internal\_scalar\_assign}}(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X, \textcolor{keyword}{const} \mbox{\hyperlink{structgmm__dist__mode}{gmm\_dist\_mode}}\& dist\_mode)\textcolor{keyword}{ const}}
\DoxyCodeLine{1484 \textcolor{keyword}{  }\{}
\DoxyCodeLine{1485   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1486   }
\DoxyCodeLine{1487   \textcolor{keyword}{const} uword N\_dims = means.n\_rows;}
\DoxyCodeLine{1488   \textcolor{keyword}{const} uword N\_gaus = means.n\_cols;}
\DoxyCodeLine{1489   }
\DoxyCodeLine{1490   arma\_debug\_check( (X.n\_rows != N\_dims), \textcolor{stringliteral}{"{}gmm\_diag::assign(): incompatible dimensions"{}} );}
\DoxyCodeLine{1491   arma\_debug\_check( (N\_gaus == 0),        \textcolor{stringliteral}{"{}gmm\_diag::assign(): model has no means"{}}      );}
\DoxyCodeLine{1492   }
\DoxyCodeLine{1493   \textcolor{keyword}{const} eT* X\_mem = X.colptr(0);}
\DoxyCodeLine{1494   }
\DoxyCodeLine{1495   \textcolor{keywordflow}{if}(dist\_mode == eucl\_dist)}
\DoxyCodeLine{1496     \{}
\DoxyCodeLine{1497     eT    best\_dist = \mbox{\hyperlink{classDatum}{Datum<eT>::inf}};}
\DoxyCodeLine{1498     uword best\_g    = 0;}
\DoxyCodeLine{1499     }
\DoxyCodeLine{1500     \textcolor{keywordflow}{for}(uword g=0; g < N\_gaus; ++g)}
\DoxyCodeLine{1501       \{}
\DoxyCodeLine{1502       \textcolor{keyword}{const} eT tmp\_dist = distance<eT,1>::eval(N\_dims, X\_mem, means.colptr(g), X\_mem);}
\DoxyCodeLine{1503       }
\DoxyCodeLine{1504       \textcolor{keywordflow}{if}(tmp\_dist <= best\_dist)  \{ best\_dist = tmp\_dist;  best\_g = g; \}}
\DoxyCodeLine{1505       \}}
\DoxyCodeLine{1506     }
\DoxyCodeLine{1507     \textcolor{keywordflow}{return} best\_g;}
\DoxyCodeLine{1508     \}}
\DoxyCodeLine{1509   \textcolor{keywordflow}{else}}
\DoxyCodeLine{1510   \textcolor{keywordflow}{if}(dist\_mode == prob\_dist)}
\DoxyCodeLine{1511     \{}
\DoxyCodeLine{1512     \textcolor{keyword}{const} eT* log\_hefts\_mem = log\_hefts.memptr();}
\DoxyCodeLine{1513     }
\DoxyCodeLine{1514     eT    best\_p = -\/\mbox{\hyperlink{classDatum}{Datum<eT>::inf}};}
\DoxyCodeLine{1515     uword best\_g = 0;}
\DoxyCodeLine{1516     }
\DoxyCodeLine{1517     \textcolor{keywordflow}{for}(uword g=0; g < N\_gaus; ++g)}
\DoxyCodeLine{1518       \{}
\DoxyCodeLine{1519       \textcolor{keyword}{const} eT tmp\_p = internal\_scalar\_log\_p(X\_mem, g) + log\_hefts\_mem[g];}
\DoxyCodeLine{1520       }
\DoxyCodeLine{1521       \textcolor{keywordflow}{if}(tmp\_p >= best\_p)  \{ best\_p = tmp\_p;  best\_g = g; \}}
\DoxyCodeLine{1522       \}}
\DoxyCodeLine{1523     }
\DoxyCodeLine{1524     \textcolor{keywordflow}{return} best\_g;}
\DoxyCodeLine{1525     \}}
\DoxyCodeLine{1526   \textcolor{keywordflow}{else}}
\DoxyCodeLine{1527     \{}
\DoxyCodeLine{1528     arma\_debug\_check(\textcolor{keyword}{true}, \textcolor{stringliteral}{"{}gmm\_diag::assign(): unsupported distance mode"{}});}
\DoxyCodeLine{1529     \}}
\DoxyCodeLine{1530   }
\DoxyCodeLine{1531   \textcolor{keywordflow}{return} uword(0);}
\DoxyCodeLine{1532   \}}
\DoxyCodeLine{1533 }
\DoxyCodeLine{1534 }
\DoxyCodeLine{1535 }
\DoxyCodeLine{1536 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{1537 \textcolor{keyword}{inline}}
\DoxyCodeLine{1538 \textcolor{keywordtype}{void}}
\DoxyCodeLine{1539 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::internal\_vec\_assign}}(\mbox{\hyperlink{classRow}{urowvec}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X, \textcolor{keyword}{const} \mbox{\hyperlink{structgmm__dist__mode}{gmm\_dist\_mode}}\& dist\_mode)\textcolor{keyword}{ const}}
\DoxyCodeLine{1540 \textcolor{keyword}{  }\{}
\DoxyCodeLine{1541   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1542   }
\DoxyCodeLine{1543   \textcolor{keyword}{const} uword N\_dims = means.n\_rows;}
\DoxyCodeLine{1544   \textcolor{keyword}{const} uword N\_gaus = means.n\_cols;}
\DoxyCodeLine{1545   }
\DoxyCodeLine{1546   arma\_debug\_check( (X.n\_rows != N\_dims), \textcolor{stringliteral}{"{}gmm\_diag::assign(): incompatible dimensions"{}} );}
\DoxyCodeLine{1547   }
\DoxyCodeLine{1548   \textcolor{keyword}{const} uword X\_n\_cols = (N\_gaus > 0) ? X.n\_cols : 0;}
\DoxyCodeLine{1549   }
\DoxyCodeLine{1550   out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(1,X\_n\_cols);}
\DoxyCodeLine{1551   }
\DoxyCodeLine{1552   uword* out\_mem = out.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{1553   }
\DoxyCodeLine{1554   \textcolor{keywordflow}{if}(dist\_mode == eucl\_dist)}
\DoxyCodeLine{1555     \{}
\DoxyCodeLine{1556 \textcolor{preprocessor}{    \#if defined(ARMA\_USE\_OPENMP)}}
\DoxyCodeLine{1557       \{}
\DoxyCodeLine{1558 \textcolor{preprocessor}{      \#pragma omp parallel for schedule(static)}}
\DoxyCodeLine{1559       \textcolor{keywordflow}{for}(uword i=0; i<X\_n\_cols; ++i)}
\DoxyCodeLine{1560         \{}
\DoxyCodeLine{1561         \textcolor{keyword}{const} eT* X\_colptr = X.colptr(i);}
\DoxyCodeLine{1562         }
\DoxyCodeLine{1563         eT    best\_dist = \mbox{\hyperlink{classDatum}{Datum<eT>::inf}};}
\DoxyCodeLine{1564         uword best\_g    = 0;}
\DoxyCodeLine{1565         }
\DoxyCodeLine{1566         \textcolor{keywordflow}{for}(uword g=0; g<N\_gaus; ++g)}
\DoxyCodeLine{1567           \{}
\DoxyCodeLine{1568           \textcolor{keyword}{const} eT tmp\_dist = distance<eT,1>::eval(N\_dims, X\_colptr, means.colptr(g), X\_colptr);}
\DoxyCodeLine{1569           }
\DoxyCodeLine{1570           \textcolor{keywordflow}{if}(tmp\_dist <= best\_dist)  \{ best\_dist = tmp\_dist;  best\_g = g; \}}
\DoxyCodeLine{1571           \}}
\DoxyCodeLine{1572         }
\DoxyCodeLine{1573         out\_mem[i] = best\_g;}
\DoxyCodeLine{1574         \}}
\DoxyCodeLine{1575       \}}
\DoxyCodeLine{1576 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{1577       \{}
\DoxyCodeLine{1578       \textcolor{keywordflow}{for}(uword i=0; i<X\_n\_cols; ++i)}
\DoxyCodeLine{1579         \{}
\DoxyCodeLine{1580         \textcolor{keyword}{const} eT* X\_colptr = X.colptr(i);}
\DoxyCodeLine{1581         }
\DoxyCodeLine{1582         eT    best\_dist = \mbox{\hyperlink{classDatum}{Datum<eT>::inf}};}
\DoxyCodeLine{1583         uword best\_g    = 0;}
\DoxyCodeLine{1584         }
\DoxyCodeLine{1585         \textcolor{keywordflow}{for}(uword g=0; g<N\_gaus; ++g)}
\DoxyCodeLine{1586           \{}
\DoxyCodeLine{1587           \textcolor{keyword}{const} eT tmp\_dist = distance<eT,1>::eval(N\_dims, X\_colptr, means.colptr(g), X\_colptr);}
\DoxyCodeLine{1588           }
\DoxyCodeLine{1589           \textcolor{keywordflow}{if}(tmp\_dist <= best\_dist)  \{ best\_dist = tmp\_dist;  best\_g = g; \}}
\DoxyCodeLine{1590           \}}
\DoxyCodeLine{1591         }
\DoxyCodeLine{1592         out\_mem[i] = best\_g;}
\DoxyCodeLine{1593         \}}
\DoxyCodeLine{1594       \}}
\DoxyCodeLine{1595 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{1596     \}}
\DoxyCodeLine{1597   \textcolor{keywordflow}{else}}
\DoxyCodeLine{1598   \textcolor{keywordflow}{if}(dist\_mode == prob\_dist)}
\DoxyCodeLine{1599     \{}
\DoxyCodeLine{1600 \textcolor{preprocessor}{    \#if defined(ARMA\_USE\_OPENMP)}}
\DoxyCodeLine{1601       \{}
\DoxyCodeLine{1602       \textcolor{keyword}{const} eT* log\_hefts\_mem = log\_hefts.memptr();}
\DoxyCodeLine{1603       }
\DoxyCodeLine{1604 \textcolor{preprocessor}{      \#pragma omp parallel for schedule(static)}}
\DoxyCodeLine{1605       \textcolor{keywordflow}{for}(uword i=0; i<X\_n\_cols; ++i)}
\DoxyCodeLine{1606         \{}
\DoxyCodeLine{1607         \textcolor{keyword}{const} eT* X\_colptr = X.colptr(i);}
\DoxyCodeLine{1608         }
\DoxyCodeLine{1609         eT    best\_p = -\/\mbox{\hyperlink{classDatum}{Datum<eT>::inf}};}
\DoxyCodeLine{1610         uword best\_g = 0;}
\DoxyCodeLine{1611         }
\DoxyCodeLine{1612         \textcolor{keywordflow}{for}(uword g=0; g<N\_gaus; ++g)}
\DoxyCodeLine{1613           \{}
\DoxyCodeLine{1614           \textcolor{keyword}{const} eT tmp\_p = internal\_scalar\_log\_p(X\_colptr, g) + log\_hefts\_mem[g];}
\DoxyCodeLine{1615           }
\DoxyCodeLine{1616           \textcolor{keywordflow}{if}(tmp\_p >= best\_p)  \{ best\_p = tmp\_p;  best\_g = g; \}}
\DoxyCodeLine{1617           \}}
\DoxyCodeLine{1618         }
\DoxyCodeLine{1619         out\_mem[i] = best\_g;}
\DoxyCodeLine{1620         \}}
\DoxyCodeLine{1621       \}}
\DoxyCodeLine{1622 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{1623       \{}
\DoxyCodeLine{1624       \textcolor{keyword}{const} eT* log\_hefts\_mem = log\_hefts.memptr();}
\DoxyCodeLine{1625       }
\DoxyCodeLine{1626       \textcolor{keywordflow}{for}(uword i=0; i<X\_n\_cols; ++i)}
\DoxyCodeLine{1627         \{}
\DoxyCodeLine{1628         \textcolor{keyword}{const} eT* X\_colptr = X.colptr(i);}
\DoxyCodeLine{1629          }
\DoxyCodeLine{1630         eT    best\_p = -\/\mbox{\hyperlink{classDatum}{Datum<eT>::inf}};}
\DoxyCodeLine{1631         uword best\_g = 0;}
\DoxyCodeLine{1632         }
\DoxyCodeLine{1633         \textcolor{keywordflow}{for}(uword g=0; g<N\_gaus; ++g)}
\DoxyCodeLine{1634           \{}
\DoxyCodeLine{1635           \textcolor{keyword}{const} eT tmp\_p = internal\_scalar\_log\_p(X\_colptr, g) + log\_hefts\_mem[g];}
\DoxyCodeLine{1636           }
\DoxyCodeLine{1637           \textcolor{keywordflow}{if}(tmp\_p >= best\_p)  \{ best\_p = tmp\_p;  best\_g = g; \}}
\DoxyCodeLine{1638           \}}
\DoxyCodeLine{1639         }
\DoxyCodeLine{1640         out\_mem[i] = best\_g;}
\DoxyCodeLine{1641         \}}
\DoxyCodeLine{1642       \}}
\DoxyCodeLine{1643 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{1644     \}}
\DoxyCodeLine{1645   \textcolor{keywordflow}{else}}
\DoxyCodeLine{1646     \{}
\DoxyCodeLine{1647     arma\_debug\_check(\textcolor{keyword}{true}, \textcolor{stringliteral}{"{}gmm\_diag::assign(): unsupported distance mode"{}});}
\DoxyCodeLine{1648     \}}
\DoxyCodeLine{1649   \}}
\DoxyCodeLine{1650 }
\DoxyCodeLine{1651 }
\DoxyCodeLine{1652 }
\DoxyCodeLine{1653 }
\DoxyCodeLine{1654 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{1655 \textcolor{keyword}{inline}}
\DoxyCodeLine{1656 \textcolor{keywordtype}{void}}
\DoxyCodeLine{1657 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::internal\_raw\_hist}}(\mbox{\hyperlink{classRow}{urowvec}}\& hist, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X, \textcolor{keyword}{const} \mbox{\hyperlink{structgmm__dist__mode}{gmm\_dist\_mode}}\& dist\_mode)\textcolor{keyword}{ const}}
\DoxyCodeLine{1658 \textcolor{keyword}{  }\{}
\DoxyCodeLine{1659   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1660   }
\DoxyCodeLine{1661   \textcolor{keyword}{const} uword N\_dims = means.n\_rows;}
\DoxyCodeLine{1662   \textcolor{keyword}{const} uword N\_gaus = means.n\_cols;}
\DoxyCodeLine{1663   }
\DoxyCodeLine{1664   \textcolor{keyword}{const} uword X\_n\_cols = X.n\_cols;}
\DoxyCodeLine{1665   }
\DoxyCodeLine{1666   hist.zeros(N\_gaus);}
\DoxyCodeLine{1667   }
\DoxyCodeLine{1668   \textcolor{keywordflow}{if}(N\_gaus == 0)  \{ \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{1669   }
\DoxyCodeLine{1670 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_OPENMP)}}
\DoxyCodeLine{1671     \{}
\DoxyCodeLine{1672     \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{umat}} boundaries = internal\_gen\_boundaries(X\_n\_cols);}
\DoxyCodeLine{1673     }
\DoxyCodeLine{1674     \textcolor{keyword}{const} uword n\_threads = boundaries.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}};}
\DoxyCodeLine{1675     }
\DoxyCodeLine{1676     \mbox{\hyperlink{classfield}{field<urowvec>}} thread\_hist(n\_threads);}
\DoxyCodeLine{1677     }
\DoxyCodeLine{1678     \textcolor{keywordflow}{for}(uword t=0; t < n\_threads; ++t)  \{ thread\_hist(t).zeros(N\_gaus); \}}
\DoxyCodeLine{1679     }
\DoxyCodeLine{1680     }
\DoxyCodeLine{1681     \textcolor{keywordflow}{if}(dist\_mode == eucl\_dist)}
\DoxyCodeLine{1682       \{}
\DoxyCodeLine{1683 \textcolor{preprocessor}{      \#pragma omp parallel for schedule(static)}}
\DoxyCodeLine{1684       \textcolor{keywordflow}{for}(uword t=0; t < n\_threads; ++t)}
\DoxyCodeLine{1685         \{}
\DoxyCodeLine{1686         uword* thread\_hist\_mem = thread\_hist(t).memptr();}
\DoxyCodeLine{1687         }
\DoxyCodeLine{1688         \textcolor{keyword}{const} uword start\_index = boundaries.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(0,t);}
\DoxyCodeLine{1689         \textcolor{keyword}{const} uword   end\_index = boundaries.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(1,t);}
\DoxyCodeLine{1690         }
\DoxyCodeLine{1691         \textcolor{keywordflow}{for}(uword i=start\_index; i <= end\_index; ++i)}
\DoxyCodeLine{1692           \{}
\DoxyCodeLine{1693           \textcolor{keyword}{const} eT* X\_colptr = X.colptr(i);}
\DoxyCodeLine{1694           }
\DoxyCodeLine{1695           eT    best\_dist = \mbox{\hyperlink{classDatum}{Datum<eT>::inf}};}
\DoxyCodeLine{1696           uword best\_g    = 0;}
\DoxyCodeLine{1697           }
\DoxyCodeLine{1698           \textcolor{keywordflow}{for}(uword g=0; g < N\_gaus; ++g)}
\DoxyCodeLine{1699             \{}
\DoxyCodeLine{1700             \textcolor{keyword}{const} eT tmp\_dist = distance<eT,1>::eval(N\_dims, X\_colptr, means.colptr(g), X\_colptr);}
\DoxyCodeLine{1701             }
\DoxyCodeLine{1702             \textcolor{keywordflow}{if}(tmp\_dist <= best\_dist)  \{ best\_dist = tmp\_dist;  best\_g = g; \}}
\DoxyCodeLine{1703             \}}
\DoxyCodeLine{1704           }
\DoxyCodeLine{1705           thread\_hist\_mem[best\_g]++;}
\DoxyCodeLine{1706           \}}
\DoxyCodeLine{1707         \}}
\DoxyCodeLine{1708       \}}
\DoxyCodeLine{1709     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1710     \textcolor{keywordflow}{if}(dist\_mode == prob\_dist)}
\DoxyCodeLine{1711       \{}
\DoxyCodeLine{1712       \textcolor{keyword}{const} eT* log\_hefts\_mem = log\_hefts.memptr();}
\DoxyCodeLine{1713       }
\DoxyCodeLine{1714 \textcolor{preprocessor}{      \#pragma omp parallel for schedule(static)}}
\DoxyCodeLine{1715       \textcolor{keywordflow}{for}(uword t=0; t < n\_threads; ++t)}
\DoxyCodeLine{1716         \{}
\DoxyCodeLine{1717         uword* thread\_hist\_mem = thread\_hist(t).memptr();}
\DoxyCodeLine{1718         }
\DoxyCodeLine{1719         \textcolor{keyword}{const} uword start\_index = boundaries.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(0,t);}
\DoxyCodeLine{1720         \textcolor{keyword}{const} uword   end\_index = boundaries.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(1,t);}
\DoxyCodeLine{1721         }
\DoxyCodeLine{1722         \textcolor{keywordflow}{for}(uword i=start\_index; i <= end\_index; ++i)}
\DoxyCodeLine{1723           \{}
\DoxyCodeLine{1724           \textcolor{keyword}{const} eT* X\_colptr = X.colptr(i);}
\DoxyCodeLine{1725             }
\DoxyCodeLine{1726           eT    best\_p = -\/\mbox{\hyperlink{classDatum}{Datum<eT>::inf}};}
\DoxyCodeLine{1727           uword best\_g = 0;}
\DoxyCodeLine{1728           }
\DoxyCodeLine{1729           \textcolor{keywordflow}{for}(uword g=0; g < N\_gaus; ++g)}
\DoxyCodeLine{1730             \{}
\DoxyCodeLine{1731             \textcolor{keyword}{const} eT tmp\_p = internal\_scalar\_log\_p(X\_colptr, g) + log\_hefts\_mem[g];}
\DoxyCodeLine{1732             }
\DoxyCodeLine{1733             \textcolor{keywordflow}{if}(tmp\_p >= best\_p)  \{ best\_p = tmp\_p;  best\_g = g; \}}
\DoxyCodeLine{1734             \}}
\DoxyCodeLine{1735           }
\DoxyCodeLine{1736           thread\_hist\_mem[best\_g]++;}
\DoxyCodeLine{1737           \}}
\DoxyCodeLine{1738         \}}
\DoxyCodeLine{1739       \}}
\DoxyCodeLine{1740     }
\DoxyCodeLine{1741     \textcolor{comment}{// reduction}}
\DoxyCodeLine{1742     hist = thread\_hist(0);}
\DoxyCodeLine{1743     }
\DoxyCodeLine{1744     \textcolor{keywordflow}{for}(uword t=1; t < n\_threads; ++t)}
\DoxyCodeLine{1745       \{}
\DoxyCodeLine{1746       hist += thread\_hist(t);}
\DoxyCodeLine{1747       \}}
\DoxyCodeLine{1748     \}}
\DoxyCodeLine{1749 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{1750     \{}
\DoxyCodeLine{1751     uword* hist\_mem = hist.memptr();}
\DoxyCodeLine{1752     }
\DoxyCodeLine{1753     \textcolor{keywordflow}{if}(dist\_mode == eucl\_dist)}
\DoxyCodeLine{1754       \{}
\DoxyCodeLine{1755       \textcolor{keywordflow}{for}(uword i=0; i<X\_n\_cols; ++i)}
\DoxyCodeLine{1756         \{}
\DoxyCodeLine{1757         \textcolor{keyword}{const} eT* X\_colptr = X.colptr(i);}
\DoxyCodeLine{1758          }
\DoxyCodeLine{1759         eT    best\_dist = \mbox{\hyperlink{classDatum}{Datum<eT>::inf}};}
\DoxyCodeLine{1760         uword best\_g    = 0;}
\DoxyCodeLine{1761         }
\DoxyCodeLine{1762         \textcolor{keywordflow}{for}(uword g=0; g < N\_gaus; ++g)}
\DoxyCodeLine{1763           \{}
\DoxyCodeLine{1764           \textcolor{keyword}{const} eT tmp\_dist = distance<eT,1>::eval(N\_dims, X\_colptr, means.colptr(g), X\_colptr);}
\DoxyCodeLine{1765           }
\DoxyCodeLine{1766           \textcolor{keywordflow}{if}(tmp\_dist <= best\_dist)  \{ best\_dist = tmp\_dist;  best\_g = g; \}}
\DoxyCodeLine{1767           \}}
\DoxyCodeLine{1768         }
\DoxyCodeLine{1769         hist\_mem[best\_g]++;}
\DoxyCodeLine{1770         \}}
\DoxyCodeLine{1771       \}}
\DoxyCodeLine{1772     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1773     \textcolor{keywordflow}{if}(dist\_mode == prob\_dist)}
\DoxyCodeLine{1774       \{}
\DoxyCodeLine{1775       \textcolor{keyword}{const} eT* log\_hefts\_mem = log\_hefts.memptr();}
\DoxyCodeLine{1776       }
\DoxyCodeLine{1777       \textcolor{keywordflow}{for}(uword i=0; i<X\_n\_cols; ++i)}
\DoxyCodeLine{1778         \{}
\DoxyCodeLine{1779         \textcolor{keyword}{const} eT* X\_colptr = X.colptr(i);}
\DoxyCodeLine{1780         }
\DoxyCodeLine{1781         eT    best\_p = -\/\mbox{\hyperlink{classDatum}{Datum<eT>::inf}};}
\DoxyCodeLine{1782         uword best\_g = 0;}
\DoxyCodeLine{1783         }
\DoxyCodeLine{1784         \textcolor{keywordflow}{for}(uword g=0; g < N\_gaus; ++g)}
\DoxyCodeLine{1785           \{}
\DoxyCodeLine{1786           \textcolor{keyword}{const} eT tmp\_p = internal\_scalar\_log\_p(X\_colptr, g) + log\_hefts\_mem[g];}
\DoxyCodeLine{1787           }
\DoxyCodeLine{1788           \textcolor{keywordflow}{if}(tmp\_p >= best\_p)  \{ best\_p = tmp\_p;  best\_g = g; \}}
\DoxyCodeLine{1789           \}}
\DoxyCodeLine{1790         }
\DoxyCodeLine{1791         hist\_mem[best\_g]++;}
\DoxyCodeLine{1792         \}}
\DoxyCodeLine{1793       \}}
\DoxyCodeLine{1794     \}}
\DoxyCodeLine{1795 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{1796   \}}
\DoxyCodeLine{1797 }
\DoxyCodeLine{1798 }
\DoxyCodeLine{1799 }
\DoxyCodeLine{1800 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{1801 \textcolor{keyword}{template}<uword dist\_\textcolor{keywordtype}{id}>}
\DoxyCodeLine{1802 \textcolor{keyword}{inline}}
\DoxyCodeLine{1803 \textcolor{keywordtype}{void}}
\DoxyCodeLine{1804 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::generate\_initial\_means}}(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X, \textcolor{keyword}{const} \mbox{\hyperlink{structgmm__seed__mode}{gmm\_seed\_mode}}\& seed\_mode)}
\DoxyCodeLine{1805   \{}
\DoxyCodeLine{1806   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1807   }
\DoxyCodeLine{1808   \textcolor{keyword}{const} uword N\_dims = means.n\_rows;}
\DoxyCodeLine{1809   \textcolor{keyword}{const} uword N\_gaus = means.n\_cols;}
\DoxyCodeLine{1810   }
\DoxyCodeLine{1811   \textcolor{keywordflow}{if}( (seed\_mode == static\_subset) || (seed\_mode == random\_subset) )}
\DoxyCodeLine{1812     \{}
\DoxyCodeLine{1813     \mbox{\hyperlink{classCol}{uvec}} initial\_indices;}
\DoxyCodeLine{1814     }
\DoxyCodeLine{1815          \textcolor{keywordflow}{if}(seed\_mode == static\_subset)  \{ initial\_indices = linspace<uvec>(0, X.n\_cols-\/1, N\_gaus); \}}
\DoxyCodeLine{1816     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(seed\_mode == random\_subset)  \{ initial\_indices = randperm<uvec>(X.n\_cols, N\_gaus);      \}}
\DoxyCodeLine{1817     }
\DoxyCodeLine{1818     \textcolor{comment}{// initial\_indices.print("{}initial\_indices:"{});}}
\DoxyCodeLine{1819     }
\DoxyCodeLine{1820     \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(means) = X.cols(initial\_indices);}
\DoxyCodeLine{1821     \}}
\DoxyCodeLine{1822   \textcolor{keywordflow}{else}}
\DoxyCodeLine{1823   \textcolor{keywordflow}{if}( (seed\_mode == static\_spread) || (seed\_mode == random\_spread) )}
\DoxyCodeLine{1824     \{}
\DoxyCodeLine{1825     \textcolor{comment}{// going through all of the samples can be extremely time consuming;}}
\DoxyCodeLine{1826     \textcolor{comment}{// instead, if there are enough samples, randomly choose samples with probability 0.1}}
\DoxyCodeLine{1827     }
\DoxyCodeLine{1828     \textcolor{keyword}{const} \textcolor{keywordtype}{bool}  use\_sampling = ((X.n\_cols/uword(100)) > N\_gaus);}
\DoxyCodeLine{1829     \textcolor{keyword}{const} uword step         = (use\_sampling) ? uword(10) : uword(1);}
\DoxyCodeLine{1830     }
\DoxyCodeLine{1831     uword start\_index = 0;}
\DoxyCodeLine{1832     }
\DoxyCodeLine{1833          \textcolor{keywordflow}{if}(seed\_mode == static\_spread)  \{ start\_index = X.n\_cols / 2;                                         \}}
\DoxyCodeLine{1834     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(seed\_mode == random\_spread)  \{ start\_index = as\_scalar(randi<uvec>(1, \mbox{\hyperlink{classdistr__param}{distr\_param}}(0,X.n\_cols-\/1))); \}}
\DoxyCodeLine{1835     }
\DoxyCodeLine{1836     \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(means).col(0) = X.unsafe\_col(start\_index);}
\DoxyCodeLine{1837     }
\DoxyCodeLine{1838     \textcolor{keyword}{const} eT* mah\_aux\_mem = mah\_aux.memptr();}
\DoxyCodeLine{1839     }
\DoxyCodeLine{1840     \mbox{\hyperlink{classrunning__stat}{running\_stat<double>}} rs;}
\DoxyCodeLine{1841     }
\DoxyCodeLine{1842     \textcolor{keywordflow}{for}(uword g=1; g < N\_gaus; ++g)}
\DoxyCodeLine{1843       \{}
\DoxyCodeLine{1844       eT    max\_dist = eT(0);}
\DoxyCodeLine{1845       uword best\_i   = uword(0);}
\DoxyCodeLine{1846       uword start\_i  = uword(0);}
\DoxyCodeLine{1847       }
\DoxyCodeLine{1848       \textcolor{keywordflow}{if}(use\_sampling)}
\DoxyCodeLine{1849         \{}
\DoxyCodeLine{1850         uword start\_i\_proposed = uword(0);}
\DoxyCodeLine{1851         }
\DoxyCodeLine{1852         \textcolor{keywordflow}{if}(seed\_mode == static\_spread)  \{ start\_i\_proposed = g \% uword(10);                               \}}
\DoxyCodeLine{1853         \textcolor{keywordflow}{if}(seed\_mode == random\_spread)  \{ start\_i\_proposed = as\_scalar(randi<uvec>(1, \mbox{\hyperlink{classdistr__param}{distr\_param}}(0,9))); \}}
\DoxyCodeLine{1854         }
\DoxyCodeLine{1855         \textcolor{keywordflow}{if}(start\_i\_proposed < X.n\_cols)  \{ start\_i = start\_i\_proposed; \}}
\DoxyCodeLine{1856         \}}
\DoxyCodeLine{1857       }
\DoxyCodeLine{1858       }
\DoxyCodeLine{1859       \textcolor{keywordflow}{for}(uword i=start\_i; i < X.n\_cols; i += step)}
\DoxyCodeLine{1860         \{}
\DoxyCodeLine{1861         rs.\mbox{\hyperlink{group__running__stat_gab5299a8b23735c18f080c64cbce6863b}{reset}}();}
\DoxyCodeLine{1862         }
\DoxyCodeLine{1863         \textcolor{keyword}{const} eT* X\_colptr = X.colptr(i);}
\DoxyCodeLine{1864         }
\DoxyCodeLine{1865         \textcolor{keywordtype}{bool} ignore\_i = \textcolor{keyword}{false};}
\DoxyCodeLine{1866         }
\DoxyCodeLine{1867         \textcolor{comment}{// find the average distance between sample i and the means so far}}
\DoxyCodeLine{1868         \textcolor{keywordflow}{for}(uword h = 0; h < g; ++h)}
\DoxyCodeLine{1869           \{}
\DoxyCodeLine{1870           \textcolor{keyword}{const} eT dist = distance<eT,dist\_id>::eval(N\_dims, X\_colptr, means.colptr(h), mah\_aux\_mem);}
\DoxyCodeLine{1871           }
\DoxyCodeLine{1872           \textcolor{comment}{// ignore sample already selected as a mean}}
\DoxyCodeLine{1873           \textcolor{keywordflow}{if}(dist == eT(0))  \{ ignore\_i = \textcolor{keyword}{true}; \textcolor{keywordflow}{break}; \}}
\DoxyCodeLine{1874           \textcolor{keywordflow}{else}               \{ rs(dist);               \}}
\DoxyCodeLine{1875           \}}
\DoxyCodeLine{1876         }
\DoxyCodeLine{1877         \textcolor{keywordflow}{if}( (rs.\mbox{\hyperlink{group__running__stat_ga3a67c2c60ce02164f91c4174b51fc61b}{mean}}() >= max\_dist) \&\& (ignore\_i == \textcolor{keyword}{false}))}
\DoxyCodeLine{1878           \{}
\DoxyCodeLine{1879           max\_dist = eT(rs.\mbox{\hyperlink{group__running__stat_ga3a67c2c60ce02164f91c4174b51fc61b}{mean}}()); best\_i = i;}
\DoxyCodeLine{1880           \}}
\DoxyCodeLine{1881         \}}
\DoxyCodeLine{1882       }
\DoxyCodeLine{1883       \textcolor{comment}{// set the mean to the sample that is the furthest away from the means so far}}
\DoxyCodeLine{1884       \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(means).col(g) = X.unsafe\_col(best\_i);}
\DoxyCodeLine{1885       \}}
\DoxyCodeLine{1886     \}}
\DoxyCodeLine{1887   }
\DoxyCodeLine{1888   \textcolor{comment}{// get\_cout\_stream() << "{}generate\_initial\_means():"{} << '\(\backslash\)n';}}
\DoxyCodeLine{1889   \textcolor{comment}{// means.print();}}
\DoxyCodeLine{1890   \}}
\DoxyCodeLine{1891 }
\DoxyCodeLine{1892 }
\DoxyCodeLine{1893 }
\DoxyCodeLine{1894 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{1895 \textcolor{keyword}{template}<uword dist\_\textcolor{keywordtype}{id}>}
\DoxyCodeLine{1896 \textcolor{keyword}{inline}}
\DoxyCodeLine{1897 \textcolor{keywordtype}{void}}
\DoxyCodeLine{1898 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::generate\_initial\_params}}(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X, \textcolor{keyword}{const} eT var\_floor)}
\DoxyCodeLine{1899   \{}
\DoxyCodeLine{1900   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1901   }
\DoxyCodeLine{1902   \textcolor{keyword}{const} uword N\_dims = means.n\_rows;}
\DoxyCodeLine{1903   \textcolor{keyword}{const} uword N\_gaus = means.n\_cols;}
\DoxyCodeLine{1904   }
\DoxyCodeLine{1905   \textcolor{keyword}{const} eT* mah\_aux\_mem = mah\_aux.memptr();}
\DoxyCodeLine{1906   }
\DoxyCodeLine{1907   \textcolor{keyword}{const} uword X\_n\_cols = X.n\_cols;}
\DoxyCodeLine{1908   }
\DoxyCodeLine{1909   \textcolor{keywordflow}{if}(X\_n\_cols == 0)  \{ \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{1910   }
\DoxyCodeLine{1911   \textcolor{comment}{// as the covariances are calculated via accumulators,}}
\DoxyCodeLine{1912   \textcolor{comment}{// the means also need to be calculated via accumulators to ensure numerical consistency}}
\DoxyCodeLine{1913   }
\DoxyCodeLine{1914   \mbox{\hyperlink{classMat}{Mat<eT>}} acc\_means(N\_dims, N\_gaus, \mbox{\hyperlink{structarma__zeros__indicator}{arma\_zeros\_indicator}}());}
\DoxyCodeLine{1915   \mbox{\hyperlink{classMat}{Mat<eT>}} acc\_dcovs(N\_dims, N\_gaus, \mbox{\hyperlink{structarma__zeros__indicator}{arma\_zeros\_indicator}}());}
\DoxyCodeLine{1916   }
\DoxyCodeLine{1917   \mbox{\hyperlink{classRow}{Row<uword>}} acc\_hefts(N\_gaus, \mbox{\hyperlink{structarma__zeros__indicator}{arma\_zeros\_indicator}}());}
\DoxyCodeLine{1918   }
\DoxyCodeLine{1919   uword* acc\_hefts\_mem = acc\_hefts.memptr();}
\DoxyCodeLine{1920   }
\DoxyCodeLine{1921 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_OPENMP)}}
\DoxyCodeLine{1922     \{}
\DoxyCodeLine{1923     \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{umat}} boundaries = internal\_gen\_boundaries(X\_n\_cols);}
\DoxyCodeLine{1924     }
\DoxyCodeLine{1925     \textcolor{keyword}{const} uword n\_threads = boundaries.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}};}
\DoxyCodeLine{1926     }
\DoxyCodeLine{1927     \mbox{\hyperlink{classfield}{field< Mat<eT>}}    > t\_acc\_means(n\_threads);}
\DoxyCodeLine{1928     \mbox{\hyperlink{classfield}{field< Mat<eT>}}    > t\_acc\_dcovs(n\_threads);}
\DoxyCodeLine{1929     \mbox{\hyperlink{classfield}{field< Row<uword>}} > t\_acc\_hefts(n\_threads);}
\DoxyCodeLine{1930     }
\DoxyCodeLine{1931     \textcolor{keywordflow}{for}(uword t=0; t < n\_threads; ++t)}
\DoxyCodeLine{1932       \{}
\DoxyCodeLine{1933       t\_acc\_means(t).zeros(N\_dims, N\_gaus);}
\DoxyCodeLine{1934       t\_acc\_dcovs(t).zeros(N\_dims, N\_gaus);}
\DoxyCodeLine{1935       t\_acc\_hefts(t).zeros(N\_gaus);}
\DoxyCodeLine{1936       \}}
\DoxyCodeLine{1937     }
\DoxyCodeLine{1938 \textcolor{preprocessor}{    \#pragma omp parallel for schedule(static)}}
\DoxyCodeLine{1939     \textcolor{keywordflow}{for}(uword t=0; t < n\_threads; ++t)}
\DoxyCodeLine{1940       \{}
\DoxyCodeLine{1941       uword* t\_acc\_hefts\_mem = t\_acc\_hefts(t).memptr();}
\DoxyCodeLine{1942       }
\DoxyCodeLine{1943       \textcolor{keyword}{const} uword start\_index = boundaries.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(0,t);}
\DoxyCodeLine{1944       \textcolor{keyword}{const} uword   end\_index = boundaries.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(1,t);}
\DoxyCodeLine{1945       }
\DoxyCodeLine{1946       \textcolor{keywordflow}{for}(uword i=start\_index; i <= end\_index; ++i)}
\DoxyCodeLine{1947         \{}
\DoxyCodeLine{1948         \textcolor{keyword}{const} eT* X\_colptr = X.colptr(i);}
\DoxyCodeLine{1949         }
\DoxyCodeLine{1950         eT     min\_dist = \mbox{\hyperlink{classDatum}{Datum<eT>::inf}};}
\DoxyCodeLine{1951         uword  best\_g   = 0;}
\DoxyCodeLine{1952         }
\DoxyCodeLine{1953         \textcolor{keywordflow}{for}(uword g=0; g<N\_gaus; ++g)}
\DoxyCodeLine{1954           \{}
\DoxyCodeLine{1955           \textcolor{keyword}{const} eT dist = distance<eT,dist\_id>::eval(N\_dims, X\_colptr, means.colptr(g), mah\_aux\_mem);}
\DoxyCodeLine{1956           }
\DoxyCodeLine{1957           \textcolor{keywordflow}{if}(dist < min\_dist)  \{ min\_dist = dist;  best\_g = g; \}}
\DoxyCodeLine{1958           \}}
\DoxyCodeLine{1959         }
\DoxyCodeLine{1960         eT* t\_acc\_mean = t\_acc\_means(t).colptr(best\_g);}
\DoxyCodeLine{1961         eT* t\_acc\_dcov = t\_acc\_dcovs(t).colptr(best\_g);}
\DoxyCodeLine{1962         }
\DoxyCodeLine{1963         \textcolor{keywordflow}{for}(uword d=0; d<N\_dims; ++d)}
\DoxyCodeLine{1964           \{}
\DoxyCodeLine{1965           \textcolor{keyword}{const} eT x\_d = X\_colptr[d];}
\DoxyCodeLine{1966           }
\DoxyCodeLine{1967           t\_acc\_mean[d] += x\_d;}
\DoxyCodeLine{1968           t\_acc\_dcov[d] += x\_d*x\_d;}
\DoxyCodeLine{1969           \}}
\DoxyCodeLine{1970         }
\DoxyCodeLine{1971         t\_acc\_hefts\_mem[best\_g]++;}
\DoxyCodeLine{1972         \}}
\DoxyCodeLine{1973       \}}
\DoxyCodeLine{1974     }
\DoxyCodeLine{1975     \textcolor{comment}{// reduction}}
\DoxyCodeLine{1976     acc\_means = t\_acc\_means(0);}
\DoxyCodeLine{1977     acc\_dcovs = t\_acc\_dcovs(0);}
\DoxyCodeLine{1978     acc\_hefts = t\_acc\_hefts(0);}
\DoxyCodeLine{1979     }
\DoxyCodeLine{1980     \textcolor{keywordflow}{for}(uword t=1; t < n\_threads; ++t)}
\DoxyCodeLine{1981       \{}
\DoxyCodeLine{1982       acc\_means += t\_acc\_means(t);}
\DoxyCodeLine{1983       acc\_dcovs += t\_acc\_dcovs(t);}
\DoxyCodeLine{1984       acc\_hefts += t\_acc\_hefts(t);}
\DoxyCodeLine{1985       \}}
\DoxyCodeLine{1986     \}}
\DoxyCodeLine{1987 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{1988     \{}
\DoxyCodeLine{1989     \textcolor{keywordflow}{for}(uword i=0; i<X\_n\_cols; ++i)}
\DoxyCodeLine{1990       \{}
\DoxyCodeLine{1991       \textcolor{keyword}{const} eT* X\_colptr = X.colptr(i);}
\DoxyCodeLine{1992       }
\DoxyCodeLine{1993       eT     min\_dist = \mbox{\hyperlink{classDatum}{Datum<eT>::inf}};}
\DoxyCodeLine{1994       uword  best\_g   = 0;}
\DoxyCodeLine{1995       }
\DoxyCodeLine{1996       \textcolor{keywordflow}{for}(uword g=0; g<N\_gaus; ++g)}
\DoxyCodeLine{1997         \{}
\DoxyCodeLine{1998         \textcolor{keyword}{const} eT dist = distance<eT,dist\_id>::eval(N\_dims, X\_colptr, means.colptr(g), mah\_aux\_mem);}
\DoxyCodeLine{1999         }
\DoxyCodeLine{2000         \textcolor{keywordflow}{if}(dist < min\_dist)  \{ min\_dist = dist;  best\_g = g; \}}
\DoxyCodeLine{2001         \}}
\DoxyCodeLine{2002       }
\DoxyCodeLine{2003       eT* acc\_mean = acc\_means.colptr(best\_g);}
\DoxyCodeLine{2004       eT* acc\_dcov = acc\_dcovs.colptr(best\_g);}
\DoxyCodeLine{2005       }
\DoxyCodeLine{2006       \textcolor{keywordflow}{for}(uword d=0; d<N\_dims; ++d)}
\DoxyCodeLine{2007         \{}
\DoxyCodeLine{2008         \textcolor{keyword}{const} eT x\_d = X\_colptr[d];}
\DoxyCodeLine{2009         }
\DoxyCodeLine{2010         acc\_mean[d] += x\_d;}
\DoxyCodeLine{2011         acc\_dcov[d] += x\_d*x\_d;}
\DoxyCodeLine{2012         \}}
\DoxyCodeLine{2013       }
\DoxyCodeLine{2014       acc\_hefts\_mem[best\_g]++;}
\DoxyCodeLine{2015       \}}
\DoxyCodeLine{2016     \}}
\DoxyCodeLine{2017 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{2018   }
\DoxyCodeLine{2019   eT* hefts\_mem = \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(hefts).memptr();}
\DoxyCodeLine{2020   }
\DoxyCodeLine{2021   \textcolor{keywordflow}{for}(uword g=0; g<N\_gaus; ++g)}
\DoxyCodeLine{2022     \{}
\DoxyCodeLine{2023     \textcolor{keyword}{const} eT*   acc\_mean = acc\_means.colptr(g);}
\DoxyCodeLine{2024     \textcolor{keyword}{const} eT*   acc\_dcov = acc\_dcovs.colptr(g);}
\DoxyCodeLine{2025     \textcolor{keyword}{const} uword acc\_heft = acc\_hefts\_mem[g];}
\DoxyCodeLine{2026     }
\DoxyCodeLine{2027     eT* mean = \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(means).colptr(g);}
\DoxyCodeLine{2028     eT* dcov = \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(dcovs).colptr(g);}
\DoxyCodeLine{2029     }
\DoxyCodeLine{2030     \textcolor{keywordflow}{for}(uword d=0; d<N\_dims; ++d)}
\DoxyCodeLine{2031       \{}
\DoxyCodeLine{2032       \textcolor{keyword}{const} eT tmp = acc\_mean[d] / eT(acc\_heft);}
\DoxyCodeLine{2033       }
\DoxyCodeLine{2034       mean[d] = (acc\_heft >= 1) ? tmp : eT(0);}
\DoxyCodeLine{2035       dcov[d] = (acc\_heft >= 2) ? eT((acc\_dcov[d] / eT(acc\_heft)) -\/ (tmp*tmp)) : eT(var\_floor);}
\DoxyCodeLine{2036       \}}
\DoxyCodeLine{2037     }
\DoxyCodeLine{2038     hefts\_mem[g] = eT(acc\_heft) / eT(X\_n\_cols);}
\DoxyCodeLine{2039     \}}
\DoxyCodeLine{2040   }
\DoxyCodeLine{2041   em\_fix\_params(var\_floor);}
\DoxyCodeLine{2042   \}}
\DoxyCodeLine{2043 }
\DoxyCodeLine{2044 }
\DoxyCodeLine{2045 }
\DoxyCodeLine{2047 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{2048 \textcolor{keyword}{template}<uword dist\_\textcolor{keywordtype}{id}>}
\DoxyCodeLine{2049 \textcolor{keyword}{inline}}
\DoxyCodeLine{2050 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2051 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag_adca7f8f849780bc9ec8077d34daa17ca}{gmm\_diag<eT>::km\_iterate}}(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X, \textcolor{keyword}{const} uword max\_iter, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} verbose, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* signature)}
\DoxyCodeLine{2052   \{}
\DoxyCodeLine{2053   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2054   }
\DoxyCodeLine{2055   \textcolor{keywordflow}{if}(verbose)}
\DoxyCodeLine{2056     \{}
\DoxyCodeLine{2057     get\_cout\_stream().unsetf(ios::showbase);}
\DoxyCodeLine{2058     get\_cout\_stream().unsetf(ios::uppercase);}
\DoxyCodeLine{2059     get\_cout\_stream().unsetf(ios::showpos);}
\DoxyCodeLine{2060     get\_cout\_stream().unsetf(ios::scientific);}
\DoxyCodeLine{2061     }
\DoxyCodeLine{2062     get\_cout\_stream().setf(ios::right);}
\DoxyCodeLine{2063     get\_cout\_stream().setf(ios::fixed);}
\DoxyCodeLine{2064     \}}
\DoxyCodeLine{2065   }
\DoxyCodeLine{2066   \textcolor{keyword}{const} uword X\_n\_cols = X.n\_cols;}
\DoxyCodeLine{2067   }
\DoxyCodeLine{2068   \textcolor{keywordflow}{if}(X\_n\_cols == 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{2069   }
\DoxyCodeLine{2070   \textcolor{keyword}{const} uword N\_dims = means.n\_rows;}
\DoxyCodeLine{2071   \textcolor{keyword}{const} uword N\_gaus = means.n\_cols;}
\DoxyCodeLine{2072   }
\DoxyCodeLine{2073   \textcolor{keyword}{const} eT* mah\_aux\_mem = mah\_aux.memptr();}
\DoxyCodeLine{2074   }
\DoxyCodeLine{2075   \mbox{\hyperlink{classMat}{Mat<eT>}}    acc\_means(N\_dims, N\_gaus, \mbox{\hyperlink{structarma__zeros__indicator}{arma\_zeros\_indicator}}());}
\DoxyCodeLine{2076   \mbox{\hyperlink{classRow}{Row<uword>}} acc\_hefts(        N\_gaus, \mbox{\hyperlink{structarma__zeros__indicator}{arma\_zeros\_indicator}}());}
\DoxyCodeLine{2077   \mbox{\hyperlink{classRow}{Row<uword>}} last\_indx(        N\_gaus, \mbox{\hyperlink{structarma__zeros__indicator}{arma\_zeros\_indicator}}());}
\DoxyCodeLine{2078   }
\DoxyCodeLine{2079   \mbox{\hyperlink{classMat}{Mat<eT>}} new\_means = means;}
\DoxyCodeLine{2080   \mbox{\hyperlink{classMat}{Mat<eT>}} old\_means = means;}
\DoxyCodeLine{2081   }
\DoxyCodeLine{2082   \mbox{\hyperlink{classgmm__priv_1_1running__mean__scalar}{running\_mean\_scalar<eT>}} rs\_delta;}
\DoxyCodeLine{2083   }
\DoxyCodeLine{2084 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_OPENMP)}}
\DoxyCodeLine{2085     \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{umat}} boundaries = internal\_gen\_boundaries(X\_n\_cols);}
\DoxyCodeLine{2086     \textcolor{keyword}{const} uword n\_threads = boundaries.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}};}
\DoxyCodeLine{2087     }
\DoxyCodeLine{2088     \mbox{\hyperlink{classfield}{field< Mat<eT>}}    > t\_acc\_means(n\_threads);}
\DoxyCodeLine{2089     \mbox{\hyperlink{classfield}{field< Row<uword>}} > t\_acc\_hefts(n\_threads);}
\DoxyCodeLine{2090     \mbox{\hyperlink{classfield}{field< Row<uword>}} > t\_last\_indx(n\_threads);}
\DoxyCodeLine{2091 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{2092     \textcolor{keyword}{const} uword n\_threads = 1;}
\DoxyCodeLine{2093 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{2094   }
\DoxyCodeLine{2095   \textcolor{keywordflow}{if}(verbose)  \{ get\_cout\_stream() << signature << \textcolor{stringliteral}{"{}: n\_threads: "{}} << n\_threads  << \textcolor{charliteral}{'\(\backslash\)n'}; get\_cout\_stream().flush(); \}}
\DoxyCodeLine{2096   }
\DoxyCodeLine{2097   \textcolor{keywordflow}{for}(uword iter=1; iter <= max\_iter; ++iter)}
\DoxyCodeLine{2098     \{}
\DoxyCodeLine{2099 \textcolor{preprocessor}{    \#if defined(ARMA\_USE\_OPENMP)}}
\DoxyCodeLine{2100       \{}
\DoxyCodeLine{2101       \textcolor{keywordflow}{for}(uword t=0; t < n\_threads; ++t)}
\DoxyCodeLine{2102         \{}
\DoxyCodeLine{2103         t\_acc\_means(t).zeros(N\_dims, N\_gaus);}
\DoxyCodeLine{2104         t\_acc\_hefts(t).zeros(N\_gaus);}
\DoxyCodeLine{2105         t\_last\_indx(t).zeros(N\_gaus);}
\DoxyCodeLine{2106         \}}
\DoxyCodeLine{2107       }
\DoxyCodeLine{2108 \textcolor{preprocessor}{      \#pragma omp parallel for schedule(static)}}
\DoxyCodeLine{2109       \textcolor{keywordflow}{for}(uword t=0; t < n\_threads; ++t)}
\DoxyCodeLine{2110         \{}
\DoxyCodeLine{2111         \mbox{\hyperlink{classMat}{Mat<eT>}}\& t\_acc\_means\_t   = t\_acc\_means(t);}
\DoxyCodeLine{2112         uword*   t\_acc\_hefts\_mem = t\_acc\_hefts(t).memptr();}
\DoxyCodeLine{2113         uword*   t\_last\_indx\_mem = t\_last\_indx(t).memptr();}
\DoxyCodeLine{2114         }
\DoxyCodeLine{2115         \textcolor{keyword}{const} uword start\_index = boundaries.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(0,t);}
\DoxyCodeLine{2116         \textcolor{keyword}{const} uword   end\_index = boundaries.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(1,t);}
\DoxyCodeLine{2117         }
\DoxyCodeLine{2118         \textcolor{keywordflow}{for}(uword i=start\_index; i <= end\_index; ++i)}
\DoxyCodeLine{2119           \{}
\DoxyCodeLine{2120           \textcolor{keyword}{const} eT* X\_colptr = X.colptr(i);}
\DoxyCodeLine{2121           }
\DoxyCodeLine{2122           eT     min\_dist = \mbox{\hyperlink{classDatum}{Datum<eT>::inf}};}
\DoxyCodeLine{2123           uword  best\_g   = 0;}
\DoxyCodeLine{2124           }
\DoxyCodeLine{2125           \textcolor{keywordflow}{for}(uword g=0; g<N\_gaus; ++g)}
\DoxyCodeLine{2126             \{}
\DoxyCodeLine{2127             \textcolor{keyword}{const} eT dist = \mbox{\hyperlink{structgmm__priv_1_1distance}{distance<eT,dist\_id>::eval}}(N\_dims, X\_colptr, old\_means.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(g), mah\_aux\_mem);}
\DoxyCodeLine{2128             }
\DoxyCodeLine{2129             \textcolor{keywordflow}{if}(dist < min\_dist)  \{ min\_dist = dist;  best\_g = g; \}}
\DoxyCodeLine{2130             \}}
\DoxyCodeLine{2131           }
\DoxyCodeLine{2132           eT* t\_acc\_mean = t\_acc\_means\_t.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(best\_g);}
\DoxyCodeLine{2133           }
\DoxyCodeLine{2134           \textcolor{keywordflow}{for}(uword d=0; d<N\_dims; ++d)  \{ t\_acc\_mean[d] += X\_colptr[d]; \}}
\DoxyCodeLine{2135           }
\DoxyCodeLine{2136           t\_acc\_hefts\_mem[best\_g]++;}
\DoxyCodeLine{2137           t\_last\_indx\_mem[best\_g] = i;}
\DoxyCodeLine{2138           \}}
\DoxyCodeLine{2139         \}}
\DoxyCodeLine{2140       }
\DoxyCodeLine{2141       \textcolor{comment}{// reduction}}
\DoxyCodeLine{2142       }
\DoxyCodeLine{2143       acc\_means = t\_acc\_means(0);}
\DoxyCodeLine{2144       acc\_hefts = t\_acc\_hefts(0);}
\DoxyCodeLine{2145       }
\DoxyCodeLine{2146       \textcolor{keywordflow}{for}(uword t=1; t < n\_threads; ++t)}
\DoxyCodeLine{2147         \{}
\DoxyCodeLine{2148         acc\_means += t\_acc\_means(t);}
\DoxyCodeLine{2149         acc\_hefts += t\_acc\_hefts(t);}
\DoxyCodeLine{2150         \}}
\DoxyCodeLine{2151       }
\DoxyCodeLine{2152       \textcolor{keywordflow}{for}(uword g=0; g < N\_gaus;    ++g)}
\DoxyCodeLine{2153       \textcolor{keywordflow}{for}(uword t=0; t < n\_threads; ++t)}
\DoxyCodeLine{2154         \{}
\DoxyCodeLine{2155         \textcolor{keywordflow}{if}( t\_acc\_hefts(t)(g) >= 1 )  \{ last\_indx(g) = t\_last\_indx(t)(g); \}}
\DoxyCodeLine{2156         \}}
\DoxyCodeLine{2157       \}}
\DoxyCodeLine{2158 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{2159       \{}
\DoxyCodeLine{2160       uword* acc\_hefts\_mem = acc\_hefts.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{2161       uword* last\_indx\_mem = last\_indx.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{2162       }
\DoxyCodeLine{2163       \textcolor{keywordflow}{for}(uword i=0; i < X\_n\_cols; ++i)}
\DoxyCodeLine{2164         \{}
\DoxyCodeLine{2165         \textcolor{keyword}{const} eT* X\_colptr = X.colptr(i);}
\DoxyCodeLine{2166         }
\DoxyCodeLine{2167         eT     min\_dist = \mbox{\hyperlink{classDatum}{Datum<eT>::inf}};}
\DoxyCodeLine{2168         uword  best\_g   = 0;}
\DoxyCodeLine{2169         }
\DoxyCodeLine{2170         \textcolor{keywordflow}{for}(uword g=0; g<N\_gaus; ++g)}
\DoxyCodeLine{2171           \{}
\DoxyCodeLine{2172           \textcolor{keyword}{const} eT dist = \mbox{\hyperlink{structgmm__priv_1_1distance}{distance<eT,dist\_id>::eval}}(N\_dims, X\_colptr, old\_means.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(g), mah\_aux\_mem);}
\DoxyCodeLine{2173           }
\DoxyCodeLine{2174           \textcolor{keywordflow}{if}(dist < min\_dist)  \{ min\_dist = dist;  best\_g = g; \}}
\DoxyCodeLine{2175           \}}
\DoxyCodeLine{2176         }
\DoxyCodeLine{2177         eT* acc\_mean = acc\_means.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(best\_g);}
\DoxyCodeLine{2178         }
\DoxyCodeLine{2179         \textcolor{keywordflow}{for}(uword d=0; d<N\_dims; ++d)  \{ acc\_mean[d] += X\_colptr[d]; \}}
\DoxyCodeLine{2180         }
\DoxyCodeLine{2181         acc\_hefts\_mem[best\_g]++;}
\DoxyCodeLine{2182         last\_indx\_mem[best\_g] = i;}
\DoxyCodeLine{2183         \}}
\DoxyCodeLine{2184       \}}
\DoxyCodeLine{2185 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{2186     }
\DoxyCodeLine{2187     \textcolor{comment}{// generate new means}}
\DoxyCodeLine{2188     }
\DoxyCodeLine{2189     uword* acc\_hefts\_mem = acc\_hefts.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{2190     }
\DoxyCodeLine{2191     \textcolor{keywordflow}{for}(uword g=0; g < N\_gaus; ++g)}
\DoxyCodeLine{2192       \{}
\DoxyCodeLine{2193       \textcolor{keyword}{const} eT*   acc\_mean = acc\_means.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(g);}
\DoxyCodeLine{2194       \textcolor{keyword}{const} uword acc\_heft = acc\_hefts\_mem[g];}
\DoxyCodeLine{2195       }
\DoxyCodeLine{2196       eT* new\_mean = \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(new\_means).colptr(g);}
\DoxyCodeLine{2197   }
\DoxyCodeLine{2198       \textcolor{keywordflow}{for}(uword d=0; d<N\_dims; ++d)}
\DoxyCodeLine{2199         \{}
\DoxyCodeLine{2200         new\_mean[d] = (acc\_heft >= 1) ? (acc\_mean[d] / eT(acc\_heft)) : eT(0);}
\DoxyCodeLine{2201         \}}
\DoxyCodeLine{2202       \}}
\DoxyCodeLine{2203     }
\DoxyCodeLine{2204     }
\DoxyCodeLine{2205     \textcolor{comment}{// heuristics to resurrect dead means}}
\DoxyCodeLine{2206     }
\DoxyCodeLine{2207     \textcolor{keyword}{const} \mbox{\hyperlink{classCol}{uvec}} dead\_gs = find(acc\_hefts == uword(0));}
\DoxyCodeLine{2208     }
\DoxyCodeLine{2209     \textcolor{keywordflow}{if}(dead\_gs.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}} > 0)}
\DoxyCodeLine{2210       \{}
\DoxyCodeLine{2211       \textcolor{keywordflow}{if}(verbose)  \{ get\_cout\_stream() << signature << \textcolor{stringliteral}{"{}: recovering from dead means\(\backslash\)n"{}}; get\_cout\_stream().flush(); \}}
\DoxyCodeLine{2212       }
\DoxyCodeLine{2213       uword* last\_indx\_mem = last\_indx.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{2214     }
\DoxyCodeLine{2215       \textcolor{keyword}{const} \mbox{\hyperlink{classCol}{uvec}} live\_gs = sort( find(acc\_hefts >= uword(2)), \textcolor{stringliteral}{"{}descend"{}} );}
\DoxyCodeLine{2216       }
\DoxyCodeLine{2217       \textcolor{keywordflow}{if}(live\_gs.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}} == 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2218       }
\DoxyCodeLine{2219       uword live\_gs\_count  = 0;}
\DoxyCodeLine{2220       }
\DoxyCodeLine{2221       \textcolor{keywordflow}{for}(uword dead\_gs\_count = 0; dead\_gs\_count < dead\_gs.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}}; ++dead\_gs\_count)}
\DoxyCodeLine{2222         \{}
\DoxyCodeLine{2223         \textcolor{keyword}{const} uword dead\_g\_id = dead\_gs(dead\_gs\_count);}
\DoxyCodeLine{2224         }
\DoxyCodeLine{2225         uword proposed\_i = 0;}
\DoxyCodeLine{2226         }
\DoxyCodeLine{2227         \textcolor{keywordflow}{if}(live\_gs\_count < live\_gs.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}})}
\DoxyCodeLine{2228           \{}
\DoxyCodeLine{2229           \textcolor{keyword}{const} uword live\_g\_id = live\_gs(live\_gs\_count);  ++live\_gs\_count;}
\DoxyCodeLine{2230           }
\DoxyCodeLine{2231           \textcolor{keywordflow}{if}(live\_g\_id == dead\_g\_id)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2232           }
\DoxyCodeLine{2233           \textcolor{comment}{// recover by using a sample from a known good mean}}
\DoxyCodeLine{2234           proposed\_i = last\_indx\_mem[live\_g\_id];}
\DoxyCodeLine{2235           \}}
\DoxyCodeLine{2236         \textcolor{keywordflow}{else}}
\DoxyCodeLine{2237           \{}
\DoxyCodeLine{2238           \textcolor{comment}{// recover by using a randomly seleced sample (last resort)}}
\DoxyCodeLine{2239           proposed\_i = as\_scalar(randi<uvec>(1, \mbox{\hyperlink{classdistr__param}{distr\_param}}(0,X\_n\_cols-\/1)));}
\DoxyCodeLine{2240           \}}
\DoxyCodeLine{2241         }
\DoxyCodeLine{2242         \textcolor{keywordflow}{if}(proposed\_i >= X\_n\_cols)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2243         }
\DoxyCodeLine{2244         new\_means.\mbox{\hyperlink{group__Mat_gab68ba7bbceb5544bbd0f6f00dfe6b328}{col}}(dead\_g\_id) = X.col(proposed\_i);}
\DoxyCodeLine{2245         \}}
\DoxyCodeLine{2246       \}}
\DoxyCodeLine{2247 }
\DoxyCodeLine{2248     rs\_delta.reset();}
\DoxyCodeLine{2249     }
\DoxyCodeLine{2250     \textcolor{keywordflow}{for}(uword g=0; g < N\_gaus; ++g)}
\DoxyCodeLine{2251       \{}
\DoxyCodeLine{2252       rs\_delta( \mbox{\hyperlink{structgmm__priv_1_1distance}{distance<eT,dist\_id>::eval}}(N\_dims, old\_means.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(g), new\_means.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(g), mah\_aux\_mem) );}
\DoxyCodeLine{2253       \}}
\DoxyCodeLine{2254     }
\DoxyCodeLine{2255     \textcolor{keywordflow}{if}(verbose)}
\DoxyCodeLine{2256       \{}
\DoxyCodeLine{2257       get\_cout\_stream() << signature << \textcolor{stringliteral}{"{}: iteration: "{}};}
\DoxyCodeLine{2258       get\_cout\_stream().unsetf(ios::scientific);}
\DoxyCodeLine{2259       get\_cout\_stream().setf(ios::fixed);}
\DoxyCodeLine{2260       get\_cout\_stream().width(std::streamsize(4));}
\DoxyCodeLine{2261       get\_cout\_stream() << iter;}
\DoxyCodeLine{2262       get\_cout\_stream() << \textcolor{stringliteral}{"{}   delta: "{}};}
\DoxyCodeLine{2263       get\_cout\_stream().unsetf(ios::fixed);}
\DoxyCodeLine{2264       \textcolor{comment}{//get\_cout\_stream().setf(ios::scientific);}}
\DoxyCodeLine{2265       get\_cout\_stream() << rs\_delta.mean() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{2266       get\_cout\_stream().flush();}
\DoxyCodeLine{2267       \}}
\DoxyCodeLine{2268     }
\DoxyCodeLine{2269     arma::swap(old\_means, new\_means);}
\DoxyCodeLine{2270     }
\DoxyCodeLine{2271     \textcolor{keywordflow}{if}(rs\_delta.mean() <= \mbox{\hyperlink{classDatum}{Datum<eT>::eps}})  \{ \textcolor{keywordflow}{break}; \}}
\DoxyCodeLine{2272     \}}
\DoxyCodeLine{2273   }
\DoxyCodeLine{2274   \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(means) = old\_means;}
\DoxyCodeLine{2275   }
\DoxyCodeLine{2276   \textcolor{keywordflow}{if}(means.is\_finite() == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2277   }
\DoxyCodeLine{2278   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2279   \}}
\DoxyCodeLine{2280 }
\DoxyCodeLine{2281 }
\DoxyCodeLine{2282 }
\DoxyCodeLine{2284 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{2285 \textcolor{keyword}{inline}}
\DoxyCodeLine{2286 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2287 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag_ad02d944f666dca3cc5a9b1f82f269d3e}{gmm\_diag<eT>::em\_iterate}}(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X, \textcolor{keyword}{const} uword max\_iter, \textcolor{keyword}{const} eT var\_floor, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} verbose)}
\DoxyCodeLine{2288   \{}
\DoxyCodeLine{2289   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2290   }
\DoxyCodeLine{2291   \textcolor{keywordflow}{if}(X.n\_cols == 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{2292   }
\DoxyCodeLine{2293   \textcolor{keyword}{const} uword N\_dims = means.n\_rows;}
\DoxyCodeLine{2294   \textcolor{keyword}{const} uword N\_gaus = means.n\_cols;}
\DoxyCodeLine{2295   }
\DoxyCodeLine{2296   \textcolor{keywordflow}{if}(verbose)}
\DoxyCodeLine{2297     \{}
\DoxyCodeLine{2298     get\_cout\_stream().unsetf(ios::showbase);}
\DoxyCodeLine{2299     get\_cout\_stream().unsetf(ios::uppercase);}
\DoxyCodeLine{2300     get\_cout\_stream().unsetf(ios::showpos);}
\DoxyCodeLine{2301     get\_cout\_stream().unsetf(ios::scientific);}
\DoxyCodeLine{2302     }
\DoxyCodeLine{2303     get\_cout\_stream().setf(ios::right);}
\DoxyCodeLine{2304     get\_cout\_stream().setf(ios::fixed);}
\DoxyCodeLine{2305     \}}
\DoxyCodeLine{2306   }
\DoxyCodeLine{2307   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{umat}} boundaries = internal\_gen\_boundaries(X.n\_cols);}
\DoxyCodeLine{2308   }
\DoxyCodeLine{2309   \textcolor{keyword}{const} uword n\_threads = boundaries.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}};}
\DoxyCodeLine{2310   }
\DoxyCodeLine{2311   \mbox{\hyperlink{classfield}{field< Mat<eT>}} > t\_acc\_means(n\_threads); }
\DoxyCodeLine{2312   \mbox{\hyperlink{classfield}{field< Mat<eT>}} > t\_acc\_dcovs(n\_threads);}
\DoxyCodeLine{2313   }
\DoxyCodeLine{2314   \mbox{\hyperlink{classfield}{field< Col<eT>}} > t\_acc\_norm\_lhoods(n\_threads);}
\DoxyCodeLine{2315   \mbox{\hyperlink{classfield}{field< Col<eT>}} > t\_gaus\_log\_lhoods(n\_threads);}
\DoxyCodeLine{2316   }
\DoxyCodeLine{2317   \mbox{\hyperlink{classCol}{Col<eT>}}          t\_progress\_log\_lhood(n\_threads, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{2318   }
\DoxyCodeLine{2319   \textcolor{keywordflow}{for}(uword t=0; t<n\_threads; t++)}
\DoxyCodeLine{2320     \{}
\DoxyCodeLine{2321     t\_acc\_means[t].\mbox{\hyperlink{group__field_ga0d8cc9b33d72bd17c62f4492f0459ec8}{set\_size}}(N\_dims, N\_gaus);}
\DoxyCodeLine{2322     t\_acc\_dcovs[t].\mbox{\hyperlink{group__field_ga0d8cc9b33d72bd17c62f4492f0459ec8}{set\_size}}(N\_dims, N\_gaus);}
\DoxyCodeLine{2323     }
\DoxyCodeLine{2324     t\_acc\_norm\_lhoods[t].\mbox{\hyperlink{group__field_ga0d8cc9b33d72bd17c62f4492f0459ec8}{set\_size}}(N\_gaus);}
\DoxyCodeLine{2325     t\_gaus\_log\_lhoods[t].\mbox{\hyperlink{group__field_ga0d8cc9b33d72bd17c62f4492f0459ec8}{set\_size}}(N\_gaus);}
\DoxyCodeLine{2326     \}}
\DoxyCodeLine{2327   }
\DoxyCodeLine{2328   }
\DoxyCodeLine{2329   \textcolor{keywordflow}{if}(verbose)}
\DoxyCodeLine{2330     \{}
\DoxyCodeLine{2331     get\_cout\_stream() << \textcolor{stringliteral}{"{}gmm\_diag::learn(): EM: n\_threads: "{}} << n\_threads  << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{2332     \}}
\DoxyCodeLine{2333   }
\DoxyCodeLine{2334   eT old\_avg\_log\_p = -\/\mbox{\hyperlink{classDatum}{Datum<eT>::inf}};}
\DoxyCodeLine{2335   }
\DoxyCodeLine{2336   \textcolor{keywordflow}{for}(uword iter=1; iter <= max\_iter; ++iter)}
\DoxyCodeLine{2337     \{}
\DoxyCodeLine{2338     init\_constants();}
\DoxyCodeLine{2339     }
\DoxyCodeLine{2340     em\_update\_params(X, boundaries, t\_acc\_means, t\_acc\_dcovs, t\_acc\_norm\_lhoods, t\_gaus\_log\_lhoods, t\_progress\_log\_lhood);}
\DoxyCodeLine{2341     }
\DoxyCodeLine{2342     em\_fix\_params(var\_floor);}
\DoxyCodeLine{2343     }
\DoxyCodeLine{2344     \textcolor{keyword}{const} eT new\_avg\_log\_p = \mbox{\hyperlink{group__fn__accu_ga010aa66ecb6b417277db3e21cc10f6e6}{accu}}(t\_progress\_log\_lhood) / eT(t\_progress\_log\_lhood.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}});}
\DoxyCodeLine{2345     }
\DoxyCodeLine{2346     \textcolor{keywordflow}{if}(verbose)}
\DoxyCodeLine{2347       \{}
\DoxyCodeLine{2348       get\_cout\_stream() << \textcolor{stringliteral}{"{}gmm\_diag::learn(): EM: iteration: "{}};}
\DoxyCodeLine{2349       get\_cout\_stream().unsetf(ios::scientific);}
\DoxyCodeLine{2350       get\_cout\_stream().setf(ios::fixed);}
\DoxyCodeLine{2351       get\_cout\_stream().width(std::streamsize(4));}
\DoxyCodeLine{2352       get\_cout\_stream() << iter;}
\DoxyCodeLine{2353       get\_cout\_stream() << \textcolor{stringliteral}{"{}   avg\_log\_p: "{}};}
\DoxyCodeLine{2354       get\_cout\_stream().unsetf(ios::fixed);}
\DoxyCodeLine{2355       \textcolor{comment}{//get\_cout\_stream().setf(ios::scientific);}}
\DoxyCodeLine{2356       get\_cout\_stream() << new\_avg\_log\_p << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{2357       get\_cout\_stream().flush();}
\DoxyCodeLine{2358       \}}
\DoxyCodeLine{2359     }
\DoxyCodeLine{2360     \textcolor{keywordflow}{if}(arma\_isfinite(new\_avg\_log\_p) == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2361     }
\DoxyCodeLine{2362     \textcolor{keywordflow}{if}(std::abs(old\_avg\_log\_p -\/ new\_avg\_log\_p) <= \mbox{\hyperlink{classDatum}{Datum<eT>::eps}})  \{ \textcolor{keywordflow}{break}; \}}
\DoxyCodeLine{2363     }
\DoxyCodeLine{2364     }
\DoxyCodeLine{2365     old\_avg\_log\_p = new\_avg\_log\_p;}
\DoxyCodeLine{2366     \}}
\DoxyCodeLine{2367   }
\DoxyCodeLine{2368   }
\DoxyCodeLine{2369   \textcolor{keywordflow}{if}(\mbox{\hyperlink{group__fn__any_gac40fe1298ebcc7b720fa3ea03f410b06}{any}}(vectorise(dcovs) <= eT(0)))  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2370   \textcolor{keywordflow}{if}(means.is\_finite() == \textcolor{keyword}{false}    )  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2371   \textcolor{keywordflow}{if}(dcovs.is\_finite() == \textcolor{keyword}{false}    )  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2372   \textcolor{keywordflow}{if}(hefts.is\_finite() == \textcolor{keyword}{false}    )  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2373   }
\DoxyCodeLine{2374   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2375   \}}
\DoxyCodeLine{2376 }
\DoxyCodeLine{2377 }
\DoxyCodeLine{2378 }
\DoxyCodeLine{2379 }
\DoxyCodeLine{2380 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{2381 \textcolor{keyword}{inline}}
\DoxyCodeLine{2382 \textcolor{keywordtype}{void}}
\DoxyCodeLine{2383 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::em\_update\_params}}}
\DoxyCodeLine{2384   (}
\DoxyCodeLine{2385   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\&          X,}
\DoxyCodeLine{2386   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{umat}}\&             boundaries,}
\DoxyCodeLine{2387         \mbox{\hyperlink{classfield}{field}}< \mbox{\hyperlink{classMat}{Mat<eT>}} >\& t\_acc\_means,}
\DoxyCodeLine{2388         \mbox{\hyperlink{classfield}{field}}< \mbox{\hyperlink{classMat}{Mat<eT>}} >\& t\_acc\_dcovs,}
\DoxyCodeLine{2389         \mbox{\hyperlink{classfield}{field}}< \mbox{\hyperlink{classCol}{Col<eT>}} >\& t\_acc\_norm\_lhoods,}
\DoxyCodeLine{2390         \mbox{\hyperlink{classfield}{field}}< \mbox{\hyperlink{classCol}{Col<eT>}} >\& t\_gaus\_log\_lhoods,}
\DoxyCodeLine{2391         \mbox{\hyperlink{classCol}{Col<eT>}}\&          t\_progress\_log\_lhood}
\DoxyCodeLine{2392   )}
\DoxyCodeLine{2393   \{}
\DoxyCodeLine{2394   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2395   }
\DoxyCodeLine{2396   \textcolor{keyword}{const} uword n\_threads = boundaries.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}};}
\DoxyCodeLine{2397   }
\DoxyCodeLine{2398   }
\DoxyCodeLine{2399   \textcolor{comment}{// em\_generate\_acc() is the "{}map"{} operation, which produces partial accumulators for means, diagonal covariances and hefts}}
\DoxyCodeLine{2400     }
\DoxyCodeLine{2401 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_OPENMP)}}
\DoxyCodeLine{2402     \{}
\DoxyCodeLine{2403 \textcolor{preprocessor}{    \#pragma omp parallel for schedule(static)}}
\DoxyCodeLine{2404     \textcolor{keywordflow}{for}(uword t=0; t<n\_threads; t++)}
\DoxyCodeLine{2405       \{}
\DoxyCodeLine{2406       \mbox{\hyperlink{classMat}{Mat<eT>}}\& acc\_means          = t\_acc\_means[t];}
\DoxyCodeLine{2407       \mbox{\hyperlink{classMat}{Mat<eT>}}\& acc\_dcovs          = t\_acc\_dcovs[t];}
\DoxyCodeLine{2408       \mbox{\hyperlink{classCol}{Col<eT>}}\& acc\_norm\_lhoods    = t\_acc\_norm\_lhoods[t];}
\DoxyCodeLine{2409       \mbox{\hyperlink{classCol}{Col<eT>}}\& gaus\_log\_lhoods    = t\_gaus\_log\_lhoods[t];}
\DoxyCodeLine{2410       eT\&      progress\_log\_lhood = t\_progress\_log\_lhood[t];}
\DoxyCodeLine{2411       }
\DoxyCodeLine{2412       em\_generate\_acc(X, boundaries.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(0,t), boundaries.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(1,t), acc\_means, acc\_dcovs, acc\_norm\_lhoods, gaus\_log\_lhoods, progress\_log\_lhood);}
\DoxyCodeLine{2413       \}}
\DoxyCodeLine{2414     \}}
\DoxyCodeLine{2415 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{2416     \{}
\DoxyCodeLine{2417     em\_generate\_acc(X, boundaries.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(0,0), boundaries.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(1,0), t\_acc\_means[0], t\_acc\_dcovs[0], t\_acc\_norm\_lhoods[0], t\_gaus\_log\_lhoods[0], t\_progress\_log\_lhood[0]);}
\DoxyCodeLine{2418     \}}
\DoxyCodeLine{2419 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{2420   }
\DoxyCodeLine{2421   \textcolor{keyword}{const} uword N\_dims = means.n\_rows;}
\DoxyCodeLine{2422   \textcolor{keyword}{const} uword N\_gaus = means.n\_cols;}
\DoxyCodeLine{2423   }
\DoxyCodeLine{2424   \mbox{\hyperlink{classMat}{Mat<eT>}}\& final\_acc\_means = t\_acc\_means[0];}
\DoxyCodeLine{2425   \mbox{\hyperlink{classMat}{Mat<eT>}}\& final\_acc\_dcovs = t\_acc\_dcovs[0];}
\DoxyCodeLine{2426   }
\DoxyCodeLine{2427   \mbox{\hyperlink{classCol}{Col<eT>}}\& final\_acc\_norm\_lhoods = t\_acc\_norm\_lhoods[0];}
\DoxyCodeLine{2428   }
\DoxyCodeLine{2429   }
\DoxyCodeLine{2430   \textcolor{comment}{// the "{}reduce"{} operation, which combines the partial accumulators produced by the separate threads}}
\DoxyCodeLine{2431   }
\DoxyCodeLine{2432   \textcolor{keywordflow}{for}(uword t=1; t<n\_threads; t++)}
\DoxyCodeLine{2433     \{}
\DoxyCodeLine{2434     final\_acc\_means += t\_acc\_means[t];}
\DoxyCodeLine{2435     final\_acc\_dcovs += t\_acc\_dcovs[t];}
\DoxyCodeLine{2436     }
\DoxyCodeLine{2437     final\_acc\_norm\_lhoods += t\_acc\_norm\_lhoods[t];}
\DoxyCodeLine{2438     \}}
\DoxyCodeLine{2439   }
\DoxyCodeLine{2440   }
\DoxyCodeLine{2441   eT* hefts\_mem = \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(hefts).memptr();}
\DoxyCodeLine{2442   }
\DoxyCodeLine{2443   }
\DoxyCodeLine{2445   \textcolor{comment}{//for(uword g=0; g < N\_gaus; ++g)}}
\DoxyCodeLine{2446   \textcolor{comment}{//  \{}}
\DoxyCodeLine{2447   \textcolor{comment}{//  const eT acc\_norm\_lhood = (std::max)( final\_acc\_norm\_lhoods[g], std::numeric\_limits<eT>::min() );}}
\DoxyCodeLine{2448   \textcolor{comment}{//  }}
\DoxyCodeLine{2449   \textcolor{comment}{//  eT* mean\_mem = access::rw(means).colptr(g);}}
\DoxyCodeLine{2450   \textcolor{comment}{//  eT* dcov\_mem = access::rw(dcovs).colptr(g);}}
\DoxyCodeLine{2451   \textcolor{comment}{//  }}
\DoxyCodeLine{2452   \textcolor{comment}{//  eT* acc\_mean\_mem = final\_acc\_means.colptr(g);}}
\DoxyCodeLine{2453   \textcolor{comment}{//  eT* acc\_dcov\_mem = final\_acc\_dcovs.colptr(g);}}
\DoxyCodeLine{2454   \textcolor{comment}{//  }}
\DoxyCodeLine{2455   \textcolor{comment}{//  hefts\_mem[g] = acc\_norm\_lhood / eT(X.n\_cols);}}
\DoxyCodeLine{2456   \textcolor{comment}{//  }}
\DoxyCodeLine{2457   \textcolor{comment}{//  for(uword d=0; d < N\_dims; ++d)}}
\DoxyCodeLine{2458   \textcolor{comment}{//    \{}}
\DoxyCodeLine{2459   \textcolor{comment}{//    const eT tmp = acc\_mean\_mem[d] / acc\_norm\_lhood;}}
\DoxyCodeLine{2460   \textcolor{comment}{//    }}
\DoxyCodeLine{2461   \textcolor{comment}{//    mean\_mem[d] = tmp;}}
\DoxyCodeLine{2462   \textcolor{comment}{//    dcov\_mem[d] = acc\_dcov\_mem[d] / acc\_norm\_lhood -\/ tmp*tmp;}}
\DoxyCodeLine{2463   \textcolor{comment}{//    \}}}
\DoxyCodeLine{2464   \textcolor{comment}{//  \}}}
\DoxyCodeLine{2465   }
\DoxyCodeLine{2466   }
\DoxyCodeLine{2467   \textcolor{comment}{// conditionally update each component;  if only a subset of the hefts was updated, em\_fix\_params() will sanitise them}}
\DoxyCodeLine{2468   \textcolor{keywordflow}{for}(uword g=0; g < N\_gaus; ++g)}
\DoxyCodeLine{2469     \{}
\DoxyCodeLine{2470     \textcolor{keyword}{const} eT acc\_norm\_lhood = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})( final\_acc\_norm\_lhoods[g], \mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::numeric\_limits<eT>::min}}() );}
\DoxyCodeLine{2471     }
\DoxyCodeLine{2472     \textcolor{keywordflow}{if}(arma\_isfinite(acc\_norm\_lhood) == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{continue}; \}}
\DoxyCodeLine{2473     }
\DoxyCodeLine{2474     eT* acc\_mean\_mem = final\_acc\_means.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(g);}
\DoxyCodeLine{2475     eT* acc\_dcov\_mem = final\_acc\_dcovs.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(g);}
\DoxyCodeLine{2476     }
\DoxyCodeLine{2477     \textcolor{keywordtype}{bool} ok = \textcolor{keyword}{true};}
\DoxyCodeLine{2478     }
\DoxyCodeLine{2479     \textcolor{keywordflow}{for}(uword d=0; d < N\_dims; ++d)}
\DoxyCodeLine{2480       \{}
\DoxyCodeLine{2481       \textcolor{keyword}{const} eT tmp1 = acc\_mean\_mem[d] / acc\_norm\_lhood;}
\DoxyCodeLine{2482       \textcolor{keyword}{const} eT tmp2 = acc\_dcov\_mem[d] / acc\_norm\_lhood -\/ tmp1*tmp1;}
\DoxyCodeLine{2483       }
\DoxyCodeLine{2484       acc\_mean\_mem[d] = tmp1;}
\DoxyCodeLine{2485       acc\_dcov\_mem[d] = tmp2;}
\DoxyCodeLine{2486       }
\DoxyCodeLine{2487       \textcolor{keywordflow}{if}(arma\_isfinite(tmp2) == \textcolor{keyword}{false})  \{ ok = \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2488       \}}
\DoxyCodeLine{2489     }
\DoxyCodeLine{2490     }
\DoxyCodeLine{2491     \textcolor{keywordflow}{if}(ok)}
\DoxyCodeLine{2492       \{}
\DoxyCodeLine{2493       hefts\_mem[g] = acc\_norm\_lhood / eT(X.n\_cols);}
\DoxyCodeLine{2494       }
\DoxyCodeLine{2495       eT* mean\_mem = \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(means).colptr(g);}
\DoxyCodeLine{2496       eT* dcov\_mem = \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(dcovs).colptr(g);}
\DoxyCodeLine{2497       }
\DoxyCodeLine{2498       \textcolor{keywordflow}{for}(uword d=0; d < N\_dims; ++d)}
\DoxyCodeLine{2499         \{}
\DoxyCodeLine{2500         mean\_mem[d] = acc\_mean\_mem[d];}
\DoxyCodeLine{2501         dcov\_mem[d] = acc\_dcov\_mem[d];}
\DoxyCodeLine{2502         \}}
\DoxyCodeLine{2503       \}}
\DoxyCodeLine{2504     \}}
\DoxyCodeLine{2505   \}}
\DoxyCodeLine{2506 }
\DoxyCodeLine{2507 }
\DoxyCodeLine{2508 }
\DoxyCodeLine{2509 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{2510 \textcolor{keyword}{inline}}
\DoxyCodeLine{2511 \textcolor{keywordtype}{void}}
\DoxyCodeLine{2512 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::em\_generate\_acc}}}
\DoxyCodeLine{2513   (}
\DoxyCodeLine{2514   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X,}
\DoxyCodeLine{2515   \textcolor{keyword}{const} uword    start\_index,}
\DoxyCodeLine{2516   \textcolor{keyword}{const} uword      end\_index,}
\DoxyCodeLine{2517         \mbox{\hyperlink{classMat}{Mat<eT>}}\& acc\_means,}
\DoxyCodeLine{2518         \mbox{\hyperlink{classMat}{Mat<eT>}}\& acc\_dcovs,}
\DoxyCodeLine{2519         \mbox{\hyperlink{classCol}{Col<eT>}}\& acc\_norm\_lhoods,}
\DoxyCodeLine{2520         \mbox{\hyperlink{classCol}{Col<eT>}}\& gaus\_log\_lhoods,}
\DoxyCodeLine{2521         eT\&      progress\_log\_lhood}
\DoxyCodeLine{2522   )\textcolor{keyword}{}}
\DoxyCodeLine{2523 \textcolor{keyword}{  const}}
\DoxyCodeLine{2524 \textcolor{keyword}{  }\{}
\DoxyCodeLine{2525   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2526   }
\DoxyCodeLine{2527   progress\_log\_lhood = eT(0);}
\DoxyCodeLine{2528   }
\DoxyCodeLine{2529   acc\_means.zeros();}
\DoxyCodeLine{2530   acc\_dcovs.zeros();}
\DoxyCodeLine{2531   }
\DoxyCodeLine{2532   acc\_norm\_lhoods.zeros();}
\DoxyCodeLine{2533   gaus\_log\_lhoods.zeros();}
\DoxyCodeLine{2534   }
\DoxyCodeLine{2535   \textcolor{keyword}{const} uword N\_dims = means.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}};}
\DoxyCodeLine{2536   \textcolor{keyword}{const} uword N\_gaus = means.n\_cols;}
\DoxyCodeLine{2537   }
\DoxyCodeLine{2538   \textcolor{keyword}{const} eT* log\_hefts\_mem       = log\_hefts.memptr();}
\DoxyCodeLine{2539         eT* gaus\_log\_lhoods\_mem = gaus\_log\_lhoods.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{2540   }
\DoxyCodeLine{2541   }
\DoxyCodeLine{2542   \textcolor{keywordflow}{for}(uword i=start\_index; i <= end\_index; i++)}
\DoxyCodeLine{2543     \{}
\DoxyCodeLine{2544     \textcolor{keyword}{const} eT* x = X.colptr(i);}
\DoxyCodeLine{2545     }
\DoxyCodeLine{2546     \textcolor{keywordflow}{for}(uword g=0; g < N\_gaus; ++g)}
\DoxyCodeLine{2547       \{}
\DoxyCodeLine{2548       gaus\_log\_lhoods\_mem[g] = internal\_scalar\_log\_p(x, g) + log\_hefts\_mem[g];}
\DoxyCodeLine{2549       \}}
\DoxyCodeLine{2550     }
\DoxyCodeLine{2551     eT log\_lhood\_sum = gaus\_log\_lhoods\_mem[0];}
\DoxyCodeLine{2552     }
\DoxyCodeLine{2553     \textcolor{keywordflow}{for}(uword g=1; g < N\_gaus; ++g)}
\DoxyCodeLine{2554       \{}
\DoxyCodeLine{2555       log\_lhood\_sum = log\_add\_exp(log\_lhood\_sum, gaus\_log\_lhoods\_mem[g]);}
\DoxyCodeLine{2556       \}}
\DoxyCodeLine{2557     }
\DoxyCodeLine{2558     progress\_log\_lhood += log\_lhood\_sum;}
\DoxyCodeLine{2559     }
\DoxyCodeLine{2560     \textcolor{keywordflow}{for}(uword g=0; g < N\_gaus; ++g)}
\DoxyCodeLine{2561       \{}
\DoxyCodeLine{2562       \textcolor{keyword}{const} eT norm\_lhood = std::exp(gaus\_log\_lhoods\_mem[g] -\/ log\_lhood\_sum);}
\DoxyCodeLine{2563       }
\DoxyCodeLine{2564       acc\_norm\_lhoods[g] += norm\_lhood;}
\DoxyCodeLine{2565       }
\DoxyCodeLine{2566       eT* acc\_mean\_mem = acc\_means.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(g);}
\DoxyCodeLine{2567       eT* acc\_dcov\_mem = acc\_dcovs.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(g);}
\DoxyCodeLine{2568       }
\DoxyCodeLine{2569       \textcolor{keywordflow}{for}(uword d=0; d < N\_dims; ++d)}
\DoxyCodeLine{2570         \{}
\DoxyCodeLine{2571         \textcolor{keyword}{const} eT x\_d = x[d];}
\DoxyCodeLine{2572         \textcolor{keyword}{const} eT y\_d = x\_d * norm\_lhood;}
\DoxyCodeLine{2573         }
\DoxyCodeLine{2574         acc\_mean\_mem[d] += y\_d;}
\DoxyCodeLine{2575         acc\_dcov\_mem[d] += y\_d * x\_d;  \textcolor{comment}{// equivalent to x\_d * x\_d * norm\_lhood}}
\DoxyCodeLine{2576         \}}
\DoxyCodeLine{2577       \}}
\DoxyCodeLine{2578     \}}
\DoxyCodeLine{2579   }
\DoxyCodeLine{2580   progress\_log\_lhood /= eT((end\_index -\/ start\_index) + 1);}
\DoxyCodeLine{2581   \}}
\DoxyCodeLine{2582 }
\DoxyCodeLine{2583 }
\DoxyCodeLine{2584 }
\DoxyCodeLine{2585 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{2586 \textcolor{keyword}{inline}}
\DoxyCodeLine{2587 \textcolor{keywordtype}{void}}
\DoxyCodeLine{2588 \mbox{\hyperlink{classgmm__priv_1_1gmm__diag}{gmm\_diag<eT>::em\_fix\_params}}(\textcolor{keyword}{const} eT var\_floor)}
\DoxyCodeLine{2589   \{}
\DoxyCodeLine{2590   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2591   }
\DoxyCodeLine{2592   \textcolor{keyword}{const} uword N\_dims = means.n\_rows;}
\DoxyCodeLine{2593   \textcolor{keyword}{const} uword N\_gaus = means.n\_cols;}
\DoxyCodeLine{2594   }
\DoxyCodeLine{2595   \textcolor{keyword}{const} eT var\_ceiling = \mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::numeric\_limits<eT>::max}}();}
\DoxyCodeLine{2596   }
\DoxyCodeLine{2597   \textcolor{keyword}{const} uword dcovs\_n\_elem = dcovs.n\_elem;}
\DoxyCodeLine{2598         eT*   dcovs\_mem    = \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(dcovs).memptr();}
\DoxyCodeLine{2599   }
\DoxyCodeLine{2600   \textcolor{keywordflow}{for}(uword i=0; i < dcovs\_n\_elem; ++i)}
\DoxyCodeLine{2601     \{}
\DoxyCodeLine{2602     eT\& var\_val = dcovs\_mem[i];}
\DoxyCodeLine{2603     }
\DoxyCodeLine{2604          \textcolor{keywordflow}{if}(var\_val < var\_floor  )  \{ var\_val = var\_floor;   \}}
\DoxyCodeLine{2605     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(var\_val > var\_ceiling)  \{ var\_val = var\_ceiling; \}}
\DoxyCodeLine{2606     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(arma\_isnan(var\_val)  )  \{ var\_val = eT(1);       \}}
\DoxyCodeLine{2607     \}}
\DoxyCodeLine{2608   }
\DoxyCodeLine{2609   }
\DoxyCodeLine{2610   eT* hefts\_mem = \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(hefts).memptr();}
\DoxyCodeLine{2611   }
\DoxyCodeLine{2612   \textcolor{keywordflow}{for}(uword g1=0; g1 < N\_gaus; ++g1)}
\DoxyCodeLine{2613     \{}
\DoxyCodeLine{2614     \textcolor{keywordflow}{if}(hefts\_mem[g1] > eT(0))}
\DoxyCodeLine{2615       \{}
\DoxyCodeLine{2616       \textcolor{keyword}{const} eT* means\_colptr\_g1 = means.colptr(g1);}
\DoxyCodeLine{2617       }
\DoxyCodeLine{2618       \textcolor{keywordflow}{for}(uword g2=(g1+1); g2 < N\_gaus; ++g2)}
\DoxyCodeLine{2619         \{}
\DoxyCodeLine{2620         \textcolor{keywordflow}{if}( (hefts\_mem[g2] > eT(0)) \&\& (std::abs(hefts\_mem[g1] -\/ hefts\_mem[g2]) <= std::numeric\_limits<eT>::epsilon()) )}
\DoxyCodeLine{2621           \{}
\DoxyCodeLine{2622           \textcolor{keyword}{const} eT dist = distance<eT,1>::eval(N\_dims, means\_colptr\_g1, means.colptr(g2), means\_colptr\_g1);}
\DoxyCodeLine{2623           }
\DoxyCodeLine{2624           \textcolor{keywordflow}{if}(dist == eT(0)) \{ hefts\_mem[g2] = eT(0); \}}
\DoxyCodeLine{2625           \}}
\DoxyCodeLine{2626         \}}
\DoxyCodeLine{2627       \}}
\DoxyCodeLine{2628     \}}
\DoxyCodeLine{2629   }
\DoxyCodeLine{2630   \textcolor{keyword}{const} eT heft\_floor   = \mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::numeric\_limits<eT>::min}}();}
\DoxyCodeLine{2631   \textcolor{keyword}{const} eT heft\_initial = eT(1) / eT(N\_gaus);}
\DoxyCodeLine{2632   }
\DoxyCodeLine{2633   \textcolor{keywordflow}{for}(uword i=0; i < N\_gaus; ++i)}
\DoxyCodeLine{2634     \{}
\DoxyCodeLine{2635     eT\& heft\_val = hefts\_mem[i];}
\DoxyCodeLine{2636     }
\DoxyCodeLine{2637          \textcolor{keywordflow}{if}(heft\_val < heft\_floor)  \{ heft\_val = heft\_floor;   \}}
\DoxyCodeLine{2638     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(heft\_val > eT(1)     )  \{ heft\_val = eT(1);        \}}
\DoxyCodeLine{2639     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(arma\_isnan(heft\_val) )  \{ heft\_val = heft\_initial; \}}
\DoxyCodeLine{2640     \}}
\DoxyCodeLine{2641   }
\DoxyCodeLine{2642   \textcolor{keyword}{const} eT heft\_sum = \mbox{\hyperlink{group__fn__accu_ga010aa66ecb6b417277db3e21cc10f6e6}{accu}}(hefts);}
\DoxyCodeLine{2643   }
\DoxyCodeLine{2644   \textcolor{keywordflow}{if}((heft\_sum < (eT(1) -\/ \mbox{\hyperlink{classDatum}{Datum<eT>::eps}})) || (heft\_sum > (eT(1) + \mbox{\hyperlink{classDatum}{Datum<eT>::eps}})))  \{ \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(hefts) /= heft\_sum; \}}
\DoxyCodeLine{2645   \}}
\DoxyCodeLine{2646 }
\DoxyCodeLine{2647 }
\DoxyCodeLine{2648 \} \textcolor{comment}{// namespace gmm\_priv}}
\DoxyCodeLine{2649 }
\DoxyCodeLine{2650 }

\end{DoxyCode}
