\hypertarget{newarp__GenEigsSolver__meat_8hpp_source}{}\doxysection{newarp\+\_\+\+Gen\+Eigs\+Solver\+\_\+meat.\+hpp}
\label{newarp__GenEigsSolver__meat_8hpp_source}\index{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/newarp\_GenEigsSolver\_meat.hpp@{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/newarp\_GenEigsSolver\_meat.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008-\/2016 Conrad Sanderson (http://conradsanderson.id.au)}}
\DoxyCodeLine{2 \textcolor{comment}{// Copyright 2008-\/2016 National ICT Australia (NICTA)}}
\DoxyCodeLine{3 \textcolor{comment}{// }}
\DoxyCodeLine{4 \textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{5 \textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{6 \textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{7 \textcolor{comment}{// http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{8 \textcolor{comment}{// }}
\DoxyCodeLine{9 \textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{10 \textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{11 \textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{12 \textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{13 \textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{14 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{17 \textcolor{keyword}{namespace }newarp}
\DoxyCodeLine{18 \{}
\DoxyCodeLine{19 }
\DoxyCodeLine{20 }
\DoxyCodeLine{21 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT, \textcolor{keywordtype}{int} SelectionRule, \textcolor{keyword}{typename} OpType>}
\DoxyCodeLine{22 \textcolor{keyword}{inline}}
\DoxyCodeLine{23 \textcolor{keywordtype}{void}}
\DoxyCodeLine{24 GenEigsSolver<eT, SelectionRule, OpType>::factorise\_from(uword from\_k, uword to\_m, \textcolor{keyword}{const} \mbox{\hyperlink{classCol}{Col<eT>}}\& fk)}
\DoxyCodeLine{25   \{}
\DoxyCodeLine{26   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{27   }
\DoxyCodeLine{28   \textcolor{keywordflow}{if}(to\_m <= from\_k) \{ \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{29 }
\DoxyCodeLine{30   fac\_f = fk;}
\DoxyCodeLine{31 }
\DoxyCodeLine{32   \mbox{\hyperlink{classCol}{Col<eT>}} w(dim\_n, \mbox{\hyperlink{structarma__zeros__indicator}{arma\_zeros\_indicator}}());}
\DoxyCodeLine{33   eT beta = norm(fac\_f);}
\DoxyCodeLine{34   \textcolor{comment}{// Keep the upperleft k x k submatrix of H and set other elements to 0}}
\DoxyCodeLine{35   fac\_H.tail\_cols(ncv -\/ from\_k).zeros();}
\DoxyCodeLine{36   fac\_H.submat(\mbox{\hyperlink{classspan}{span}}(from\_k, ncv -\/ 1), \mbox{\hyperlink{classspan}{span}}(0, from\_k -\/ 1)).zeros();}
\DoxyCodeLine{37   \textcolor{keywordflow}{for}(uword i = from\_k; i <= to\_m -\/ 1; i++)}
\DoxyCodeLine{38     \{}
\DoxyCodeLine{39     \textcolor{keywordtype}{bool} restart = \textcolor{keyword}{false};}
\DoxyCodeLine{40     \textcolor{comment}{// If beta = 0, then the next V is not full rank}}
\DoxyCodeLine{41     \textcolor{comment}{// We need to generate a new residual vector that is orthogonal}}
\DoxyCodeLine{42     \textcolor{comment}{// to the current V, which we call a restart}}
\DoxyCodeLine{43     \textcolor{keywordflow}{if}(beta < eps)}
\DoxyCodeLine{44       \{}
\DoxyCodeLine{45       \textcolor{comment}{// Generate new random vector for fac\_f}}
\DoxyCodeLine{46       blas\_int idist = 2;}
\DoxyCodeLine{47       blas\_int iseed[4] = \{1, 3, 5, 7\};}
\DoxyCodeLine{48       iseed[0] = (i + 100) \% 4095;}
\DoxyCodeLine{49       blas\_int n = dim\_n;}
\DoxyCodeLine{50       lapack::larnv(\&idist, \&iseed[0], \&n, fac\_f.memptr());}
\DoxyCodeLine{51       \textcolor{comment}{// f <-\/ f -\/ V * V' * f, so that f is orthogonal to V}}
\DoxyCodeLine{52       \mbox{\hyperlink{classMat}{Mat<eT>}} Vs(fac\_V.memptr(), dim\_n, i, \textcolor{keyword}{false}); \textcolor{comment}{// First i columns}}
\DoxyCodeLine{53       \mbox{\hyperlink{classCol}{Col<eT>}} Vf = Vs.t() * fac\_f;}
\DoxyCodeLine{54       fac\_f -\/= Vs * Vf;}
\DoxyCodeLine{55       \textcolor{comment}{// beta <-\/ ||f||}}
\DoxyCodeLine{56       beta = norm(fac\_f);}
\DoxyCodeLine{57 }
\DoxyCodeLine{58       restart = \textcolor{keyword}{true};}
\DoxyCodeLine{59       \}}
\DoxyCodeLine{60 }
\DoxyCodeLine{61     \textcolor{comment}{// v <-\/ f / ||f||}}
\DoxyCodeLine{62     fac\_V.col(i) = fac\_f / beta; \textcolor{comment}{// The (i+1)-\/th column}}
\DoxyCodeLine{63 }
\DoxyCodeLine{64     \textcolor{comment}{// Note that H[i+1, i] equals to the unrestarted beta}}
\DoxyCodeLine{65     \textcolor{keywordflow}{if}(restart) \{ fac\_H(i, i -\/ 1) = 0.0; \} \textcolor{keywordflow}{else} \{ fac\_H(i, i -\/ 1) = beta; \}}
\DoxyCodeLine{66 }
\DoxyCodeLine{67     \textcolor{comment}{// w <-\/ A * v, v = fac\_V.col(i)}}
\DoxyCodeLine{68     op.perform\_op(fac\_V.colptr(i), w.memptr());}
\DoxyCodeLine{69     nmatop++;}
\DoxyCodeLine{70 }
\DoxyCodeLine{71     \textcolor{comment}{// First i+1 columns of V}}
\DoxyCodeLine{72     \mbox{\hyperlink{classMat}{Mat<eT>}} Vs(fac\_V.memptr(), dim\_n, i + 1, \textcolor{keyword}{false});}
\DoxyCodeLine{73     \textcolor{comment}{// h = fac\_H(0:i, i)}}
\DoxyCodeLine{74     \mbox{\hyperlink{classCol}{Col<eT>}} h(fac\_H.colptr(i), i + 1, \textcolor{keyword}{false});}
\DoxyCodeLine{75     \textcolor{comment}{// h <-\/ V' * w}}
\DoxyCodeLine{76     h = Vs.t() * w;}
\DoxyCodeLine{77 }
\DoxyCodeLine{78     \textcolor{comment}{// f <-\/ w -\/ V * h}}
\DoxyCodeLine{79     fac\_f = w -\/ Vs * h;}
\DoxyCodeLine{80     beta = norm(fac\_f);}
\DoxyCodeLine{81 }
\DoxyCodeLine{82     \textcolor{keywordflow}{if}(beta > 0.717 * norm(h)) \{ \textcolor{keywordflow}{continue}; \}}
\DoxyCodeLine{83 }
\DoxyCodeLine{84     \textcolor{comment}{// f/||f|| is going to be the next column of V, so we need to test}}
\DoxyCodeLine{85     \textcolor{comment}{// whether V' * (f/||f||) \string~= 0}}
\DoxyCodeLine{86     \mbox{\hyperlink{classCol}{Col<eT>}} Vf = Vs.t() * fac\_f;}
\DoxyCodeLine{87     \textcolor{comment}{// If not, iteratively correct the residual}}
\DoxyCodeLine{88     uword count = 0;}
\DoxyCodeLine{89     \textcolor{keywordflow}{while}(count < 5 \&\& abs(Vf).\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{max}}() > approx0 * beta)}
\DoxyCodeLine{90       \{}
\DoxyCodeLine{91       \textcolor{comment}{// f <-\/ f -\/ V * Vf}}
\DoxyCodeLine{92       fac\_f -\/= Vs * Vf;}
\DoxyCodeLine{93       \textcolor{comment}{// h <-\/ h + Vf}}
\DoxyCodeLine{94       h += Vf;}
\DoxyCodeLine{95       \textcolor{comment}{// beta <-\/ ||f||}}
\DoxyCodeLine{96       beta = norm(fac\_f);}
\DoxyCodeLine{97 }
\DoxyCodeLine{98       Vf = Vs.t() * fac\_f;}
\DoxyCodeLine{99       count++;}
\DoxyCodeLine{100       \}}
\DoxyCodeLine{101     \}}
\DoxyCodeLine{102   \}}
\DoxyCodeLine{103 }
\DoxyCodeLine{104 }
\DoxyCodeLine{105 }
\DoxyCodeLine{106 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT, \textcolor{keywordtype}{int} SelectionRule, \textcolor{keyword}{typename} OpType>}
\DoxyCodeLine{107 \textcolor{keyword}{inline}}
\DoxyCodeLine{108 \textcolor{keywordtype}{void}}
\DoxyCodeLine{109 GenEigsSolver<eT, SelectionRule, OpType>::restart(uword k)}
\DoxyCodeLine{110   \{}
\DoxyCodeLine{111   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{112   }
\DoxyCodeLine{113   \textcolor{keywordflow}{if}(k >= ncv) \{ \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{114 }
\DoxyCodeLine{115   DoubleShiftQR<eT>     decomp\_ds(ncv);}
\DoxyCodeLine{116   UpperHessenbergQR<eT> decomp;}
\DoxyCodeLine{117   }
\DoxyCodeLine{118   \mbox{\hyperlink{classMat}{Mat<eT>}} Q(ncv, ncv, fill::eye);}
\DoxyCodeLine{119 }
\DoxyCodeLine{120   \textcolor{keywordflow}{for}(uword i = k; i < ncv; i++)}
\DoxyCodeLine{121     \{}
\DoxyCodeLine{122     \textcolor{keywordflow}{if}(cx\_attrib::is\_complex(ritz\_val(i), eT(0)) \&\& (i < (ncv -\/ 1)) \&\& cx\_attrib::is\_conj(ritz\_val(i), ritz\_val(i + 1), eT(0)))}
\DoxyCodeLine{123       \{}
\DoxyCodeLine{124       \textcolor{comment}{// H -\/ mu * I = Q1 * R1}}
\DoxyCodeLine{125       \textcolor{comment}{// H <-\/ R1 * Q1 + mu * I = Q1' * H * Q1}}
\DoxyCodeLine{126       \textcolor{comment}{// H -\/ conj(mu) * I = Q2 * R2}}
\DoxyCodeLine{127       \textcolor{comment}{// H <-\/ R2 * Q2 + conj(mu) * I = Q2' * H * Q2}}
\DoxyCodeLine{128       \textcolor{comment}{//}}
\DoxyCodeLine{129       \textcolor{comment}{// (H -\/ mu * I) * (H -\/ conj(mu) * I) = Q1 * Q2 * R2 * R1 = Q * R}}
\DoxyCodeLine{130       eT s = 2 * ritz\_val(i).real();}
\DoxyCodeLine{131       eT t = std::norm(ritz\_val(i));}
\DoxyCodeLine{132       decomp\_ds.compute(fac\_H, s, t);}
\DoxyCodeLine{133 }
\DoxyCodeLine{134       \textcolor{comment}{// Q -\/> Q * Qi}}
\DoxyCodeLine{135       decomp\_ds.apply\_YQ(Q);}
\DoxyCodeLine{136       \textcolor{comment}{// H -\/> Q'HQ}}
\DoxyCodeLine{137       fac\_H = decomp\_ds.matrix\_QtHQ();}
\DoxyCodeLine{138 }
\DoxyCodeLine{139       i++;}
\DoxyCodeLine{140       \}}
\DoxyCodeLine{141     \textcolor{keywordflow}{else}}
\DoxyCodeLine{142       \{}
\DoxyCodeLine{143       \textcolor{comment}{// QR decomposition of H -\/ mu * I, mu is real}}
\DoxyCodeLine{144       fac\_H.diag() -\/= ritz\_val(i).real();}
\DoxyCodeLine{145       decomp.compute(fac\_H);}
\DoxyCodeLine{146 }
\DoxyCodeLine{147       \textcolor{comment}{// Q -\/> Q * Qi}}
\DoxyCodeLine{148       decomp.apply\_YQ(Q);}
\DoxyCodeLine{149       \textcolor{comment}{// H -\/> Q'HQ = RQ + mu * I}}
\DoxyCodeLine{150       fac\_H = decomp.matrix\_RQ();}
\DoxyCodeLine{151       fac\_H.diag() += ritz\_val(i).real();}
\DoxyCodeLine{152       \}}
\DoxyCodeLine{153     \}}
\DoxyCodeLine{154   }
\DoxyCodeLine{155   \textcolor{comment}{// V -\/> VQ}}
\DoxyCodeLine{156   \textcolor{comment}{// Q has some elements being zero}}
\DoxyCodeLine{157   \textcolor{comment}{// The first (ncv -\/ k + i) elements of the i-\/th column of Q are non-\/zero}}
\DoxyCodeLine{158   \mbox{\hyperlink{classMat}{Mat<eT>}} Vs(dim\_n, k + 1, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{159   uword nnz;}
\DoxyCodeLine{160   \textcolor{keywordflow}{for}(uword i = 0; i < k; i++)}
\DoxyCodeLine{161     \{}
\DoxyCodeLine{162     nnz = ncv -\/ k + i + 1;}
\DoxyCodeLine{163     \mbox{\hyperlink{classMat}{Mat<eT>}} V(fac\_V.memptr(), dim\_n, nnz, \textcolor{keyword}{false});}
\DoxyCodeLine{164     \mbox{\hyperlink{classCol}{Col<eT>}} q(Q.colptr(i), nnz, \textcolor{keyword}{false});}
\DoxyCodeLine{165     \mbox{\hyperlink{classCol}{Col<eT>}} v(Vs.colptr(i), dim\_n, \textcolor{keyword}{false});}
\DoxyCodeLine{166     v = V * q;}
\DoxyCodeLine{167     \}}
\DoxyCodeLine{168   }
\DoxyCodeLine{169   Vs.col(k) = fac\_V * Q.col(k);}
\DoxyCodeLine{170   fac\_V.head\_cols(k + 1) = Vs;}
\DoxyCodeLine{171 }
\DoxyCodeLine{172   \mbox{\hyperlink{classCol}{Col<eT>}} fk = fac\_f * Q(ncv -\/ 1, k -\/ 1) + fac\_V.\mbox{\hyperlink{group__Mat_gab68ba7bbceb5544bbd0f6f00dfe6b328}{col}}(k) * fac\_H(k, k -\/ 1);}
\DoxyCodeLine{173   factorise\_from(k, ncv, fk);}
\DoxyCodeLine{174   retrieve\_ritzpair();}
\DoxyCodeLine{175   \}}
\DoxyCodeLine{176 }
\DoxyCodeLine{177 }
\DoxyCodeLine{178 }
\DoxyCodeLine{179 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT, \textcolor{keywordtype}{int} SelectionRule, \textcolor{keyword}{typename} OpType>}
\DoxyCodeLine{180 \textcolor{keyword}{inline}}
\DoxyCodeLine{181 uword}
\DoxyCodeLine{182 GenEigsSolver<eT, SelectionRule, OpType>::num\_converged(eT tol)}
\DoxyCodeLine{183   \{}
\DoxyCodeLine{184   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{185   }
\DoxyCodeLine{186   \textcolor{comment}{// thresh = tol * max(prec, abs(theta)), theta for ritz value}}
\DoxyCodeLine{187   \textcolor{keyword}{const} eT f\_norm = arma::norm(fac\_f);}
\DoxyCodeLine{188   \textcolor{keywordflow}{for}(uword i = 0; i < nev; i++)}
\DoxyCodeLine{189     \{}
\DoxyCodeLine{190     eT thresh = tol * (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(approx0, std::abs(ritz\_val(i)));}
\DoxyCodeLine{191     eT resid = std::abs(ritz\_est(i)) * f\_norm;}
\DoxyCodeLine{192     ritz\_conv[i] = (resid < thresh);}
\DoxyCodeLine{193     \}}
\DoxyCodeLine{194 }
\DoxyCodeLine{195   \textcolor{keywordflow}{return} std::count(ritz\_conv.begin(), ritz\_conv.end(), \textcolor{keyword}{true});}
\DoxyCodeLine{196   \}}
\DoxyCodeLine{197 }
\DoxyCodeLine{198 }
\DoxyCodeLine{199 }
\DoxyCodeLine{200 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT, \textcolor{keywordtype}{int} SelectionRule, \textcolor{keyword}{typename} OpType>}
\DoxyCodeLine{201 \textcolor{keyword}{inline}}
\DoxyCodeLine{202 uword}
\DoxyCodeLine{203 GenEigsSolver<eT, SelectionRule, OpType>::nev\_adjusted(uword nconv)}
\DoxyCodeLine{204   \{}
\DoxyCodeLine{205   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{206   }
\DoxyCodeLine{207   uword nev\_new = nev;}
\DoxyCodeLine{208 }
\DoxyCodeLine{209   \textcolor{keywordflow}{for}(uword i = nev; i < ncv; i++)}
\DoxyCodeLine{210     \{}
\DoxyCodeLine{211     \textcolor{keywordflow}{if}(std::abs(ritz\_est(i)) < eps) \{ nev\_new++; \}}
\DoxyCodeLine{212     \}}
\DoxyCodeLine{213   \textcolor{comment}{// Adjust nev\_new again, according to dnaup2.f line 660\string~674 in ARPACK}}
\DoxyCodeLine{214   nev\_new += (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(nconv, (ncv -\/ nev\_new) / 2);}
\DoxyCodeLine{215   \textcolor{keywordflow}{if}(nev\_new == 1 \&\& ncv >= 6)}
\DoxyCodeLine{216     \{}
\DoxyCodeLine{217     nev\_new = ncv / 2;}
\DoxyCodeLine{218     \}}
\DoxyCodeLine{219   \textcolor{keywordflow}{else}}
\DoxyCodeLine{220   \textcolor{keywordflow}{if}(nev\_new == 1 \&\& ncv > 3)}
\DoxyCodeLine{221     \{}
\DoxyCodeLine{222     nev\_new = 2;}
\DoxyCodeLine{223     \}}
\DoxyCodeLine{224 }
\DoxyCodeLine{225   \textcolor{keywordflow}{if}(nev\_new > ncv -\/ 2) \{ nev\_new = ncv -\/ 2; \}}
\DoxyCodeLine{226 }
\DoxyCodeLine{227   \textcolor{comment}{// Increase nev by one if ritz\_val[nev -\/ 1] and}}
\DoxyCodeLine{228   \textcolor{comment}{// ritz\_val[nev] are conjugate pairs}}
\DoxyCodeLine{229   \textcolor{keywordflow}{if}(cx\_attrib::is\_complex(ritz\_val(nev\_new -\/ 1), eps) \&\& cx\_attrib::is\_conj(ritz\_val(nev\_new -\/ 1), ritz\_val(nev\_new), eps))}
\DoxyCodeLine{230     \{}
\DoxyCodeLine{231     nev\_new++;}
\DoxyCodeLine{232     \}}
\DoxyCodeLine{233 }
\DoxyCodeLine{234   \textcolor{keywordflow}{return} nev\_new;}
\DoxyCodeLine{235   \}}
\DoxyCodeLine{236 }
\DoxyCodeLine{237 }
\DoxyCodeLine{238 }
\DoxyCodeLine{239 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT, \textcolor{keywordtype}{int} SelectionRule, \textcolor{keyword}{typename} OpType>}
\DoxyCodeLine{240 \textcolor{keyword}{inline}}
\DoxyCodeLine{241 \textcolor{keywordtype}{void}}
\DoxyCodeLine{242 GenEigsSolver<eT, SelectionRule, OpType>::retrieve\_ritzpair()}
\DoxyCodeLine{243   \{}
\DoxyCodeLine{244   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{245   }
\DoxyCodeLine{246   UpperHessenbergEigen<eT> decomp(fac\_H);}
\DoxyCodeLine{247   }
\DoxyCodeLine{248   \mbox{\hyperlink{classCol}{Col< std::complex<eT>}} > evals = decomp.eigenvalues();}
\DoxyCodeLine{249   \mbox{\hyperlink{classMat}{Mat< std::complex<eT>}} > evecs = decomp.eigenvectors();}
\DoxyCodeLine{250   }
\DoxyCodeLine{251   SortEigenvalue< std::complex<eT>, SelectionRule > sorting(evals.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), evals.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}});}
\DoxyCodeLine{252   std::vector<uword> ind = sorting.index();}
\DoxyCodeLine{253   }
\DoxyCodeLine{254   \textcolor{comment}{// Copy the ritz values and vectors to ritz\_val and ritz\_vec, respectively}}
\DoxyCodeLine{255   \textcolor{keywordflow}{for}(uword i = 0; i < ncv; i++)}
\DoxyCodeLine{256     \{}
\DoxyCodeLine{257     ritz\_val(i) = evals(ind[i]);}
\DoxyCodeLine{258     ritz\_est(i) = evecs(ncv -\/ 1, ind[i]);}
\DoxyCodeLine{259     \}}
\DoxyCodeLine{260   \textcolor{keywordflow}{for}(uword i = 0; i < nev; i++)}
\DoxyCodeLine{261     \{}
\DoxyCodeLine{262     ritz\_vec.col(i) = evecs.\mbox{\hyperlink{group__Mat_gab68ba7bbceb5544bbd0f6f00dfe6b328}{col}}(ind[i]);}
\DoxyCodeLine{263     \}}
\DoxyCodeLine{264   \}}
\DoxyCodeLine{265 }
\DoxyCodeLine{266 }
\DoxyCodeLine{267 }
\DoxyCodeLine{268 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT, \textcolor{keywordtype}{int} SelectionRule, \textcolor{keyword}{typename} OpType>}
\DoxyCodeLine{269 \textcolor{keyword}{inline}}
\DoxyCodeLine{270 \textcolor{keywordtype}{void}}
\DoxyCodeLine{271 GenEigsSolver<eT, SelectionRule, OpType>::sort\_ritzpair()}
\DoxyCodeLine{272   \{}
\DoxyCodeLine{273   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{274   }
\DoxyCodeLine{275   \textcolor{comment}{// SortEigenvalue< std::complex<eT>, EigsSelect::LARGEST\_MAGN > sorting(ritz\_val.memptr(), nev);}}
\DoxyCodeLine{276   }
\DoxyCodeLine{277   \textcolor{comment}{// sort Ritz values according to SelectionRule, to be consistent with ARPACK}}
\DoxyCodeLine{278   SortEigenvalue< std::complex<eT>, SelectionRule > sorting(ritz\_val.memptr(), nev);}
\DoxyCodeLine{279   }
\DoxyCodeLine{280   std::vector<uword> ind = sorting.index();}
\DoxyCodeLine{281   }
\DoxyCodeLine{282   \mbox{\hyperlink{classCol}{Col< std::complex<eT>}} > new\_ritz\_val(ncv,      \mbox{\hyperlink{structarma__zeros__indicator}{arma\_zeros\_indicator}}()  );}
\DoxyCodeLine{283   \mbox{\hyperlink{classMat}{Mat< std::complex<eT>}} > new\_ritz\_vec(ncv, nev, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{284   std::vector<bool>       new\_ritz\_conv(nev);}
\DoxyCodeLine{285   }
\DoxyCodeLine{286   \textcolor{keywordflow}{for}(uword i = 0; i < nev; i++)}
\DoxyCodeLine{287     \{}
\DoxyCodeLine{288     new\_ritz\_val(i) = ritz\_val(ind[i]);}
\DoxyCodeLine{289     new\_ritz\_vec.col(i) = ritz\_vec.col(ind[i]);}
\DoxyCodeLine{290     new\_ritz\_conv[i] = ritz\_conv[ind[i]];}
\DoxyCodeLine{291     \}}
\DoxyCodeLine{292   }
\DoxyCodeLine{293   ritz\_val.swap(new\_ritz\_val);}
\DoxyCodeLine{294   ritz\_vec.swap(new\_ritz\_vec);}
\DoxyCodeLine{295   ritz\_conv.swap(new\_ritz\_conv);}
\DoxyCodeLine{296   \}}
\DoxyCodeLine{297 }
\DoxyCodeLine{298 }
\DoxyCodeLine{299 }
\DoxyCodeLine{300 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT, \textcolor{keywordtype}{int} SelectionRule, \textcolor{keyword}{typename} OpType>}
\DoxyCodeLine{301 \textcolor{keyword}{inline}}
\DoxyCodeLine{302 \mbox{\hyperlink{classnewarp_1_1GenEigsSolver_a830bc163b8b3b8048014189728f83f09}{GenEigsSolver<eT, SelectionRule, OpType>::GenEigsSolver}}(\textcolor{keyword}{const} OpType\& \mbox{\hyperlink{structop__}{op\_}}, uword nev\_, uword ncv\_)}
\DoxyCodeLine{303   : op(\mbox{\hyperlink{structop__}{op\_}})}
\DoxyCodeLine{304   , nev(nev\_)}
\DoxyCodeLine{305   , dim\_n(op.n\_rows)}
\DoxyCodeLine{306   , ncv(ncv\_ > dim\_n ? dim\_n : ncv\_)}
\DoxyCodeLine{307   , nmatop(0)}
\DoxyCodeLine{308   , niter(0)}
\DoxyCodeLine{309   , eps(std::numeric\_limits<eT>::epsilon())}
\DoxyCodeLine{310   , approx0(std::pow(eps, eT(2.0) / 3))}
\DoxyCodeLine{311   \{}
\DoxyCodeLine{312   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{313   }
\DoxyCodeLine{314   arma\_debug\_check( (nev\_ < 1 || nev\_ > dim\_n -\/ 2),    \textcolor{stringliteral}{"{}newarp::GenEigsSolver: nev must satisfy 1 <= nev <= n -\/ 2, n is the size of matrix"{}} );}
\DoxyCodeLine{315   arma\_debug\_check( (ncv\_ < nev\_ + 2 || ncv\_ > dim\_n), \textcolor{stringliteral}{"{}newarp::GenEigsSolver: ncv must satisfy nev + 2 <= ncv <= n, n is the size of matrix"{}} );}
\DoxyCodeLine{316   \}}
\DoxyCodeLine{317 }
\DoxyCodeLine{318 }
\DoxyCodeLine{319 }
\DoxyCodeLine{320 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT, \textcolor{keywordtype}{int} SelectionRule, \textcolor{keyword}{typename} OpType>}
\DoxyCodeLine{321 \textcolor{keyword}{inline}}
\DoxyCodeLine{322 \textcolor{keywordtype}{void}}
\DoxyCodeLine{323 \mbox{\hyperlink{classnewarp_1_1GenEigsSolver_a6428da85b23c40f39cc50205100b4f81}{GenEigsSolver<eT, SelectionRule, OpType>::init}}(eT* init\_resid)}
\DoxyCodeLine{324   \{}
\DoxyCodeLine{325   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{326   }
\DoxyCodeLine{327   \textcolor{comment}{// Reset all matrices/vectors to zero}}
\DoxyCodeLine{328   fac\_V.zeros(dim\_n, ncv);}
\DoxyCodeLine{329   fac\_H.zeros(ncv, ncv);}
\DoxyCodeLine{330   fac\_f.zeros(dim\_n);}
\DoxyCodeLine{331   ritz\_val.zeros(ncv);}
\DoxyCodeLine{332   ritz\_vec.zeros(ncv, nev);}
\DoxyCodeLine{333   ritz\_est.zeros(ncv);}
\DoxyCodeLine{334   ritz\_conv.assign(nev, \textcolor{keyword}{false});}
\DoxyCodeLine{335 }
\DoxyCodeLine{336   nmatop = 0;}
\DoxyCodeLine{337   niter = 0;}
\DoxyCodeLine{338 }
\DoxyCodeLine{339   \mbox{\hyperlink{classCol}{Col<eT>}} r(init\_resid, dim\_n, \textcolor{keyword}{false});}
\DoxyCodeLine{340   \textcolor{comment}{// The first column of fac\_V}}
\DoxyCodeLine{341   \mbox{\hyperlink{classCol}{Col<eT>}} v(fac\_V.colptr(0), dim\_n, \textcolor{keyword}{false});}
\DoxyCodeLine{342   eT rnorm = norm(r);}
\DoxyCodeLine{343   \mbox{\hyperlink{group__debug_ga458beb676810b1e43df9f0668359e76f}{arma\_check}}( (rnorm < eps), \textcolor{stringliteral}{"{}newarp::GenEigsSolver::init(): initial residual vector cannot be zero"{}} );}
\DoxyCodeLine{344   v = r / rnorm;}
\DoxyCodeLine{345 }
\DoxyCodeLine{346   \mbox{\hyperlink{classCol}{Col<eT>}} w(dim\_n, \mbox{\hyperlink{structarma__zeros__indicator}{arma\_zeros\_indicator}}());}
\DoxyCodeLine{347   op.perform\_op(v.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}(), w.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}());}
\DoxyCodeLine{348   nmatop++;}
\DoxyCodeLine{349 }
\DoxyCodeLine{350   fac\_H(0, 0) = dot(v, w);}
\DoxyCodeLine{351   fac\_f = w -\/ v * fac\_H(0, 0);}
\DoxyCodeLine{352   \}}
\DoxyCodeLine{353 }
\DoxyCodeLine{354 }
\DoxyCodeLine{355 }
\DoxyCodeLine{356 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT, \textcolor{keywordtype}{int} SelectionRule, \textcolor{keyword}{typename} OpType>}
\DoxyCodeLine{357 \textcolor{keyword}{inline}}
\DoxyCodeLine{358 \textcolor{keywordtype}{void}}
\DoxyCodeLine{359 \mbox{\hyperlink{classnewarp_1_1GenEigsSolver_a6428da85b23c40f39cc50205100b4f81}{GenEigsSolver<eT, SelectionRule, OpType>::init}}()}
\DoxyCodeLine{360   \{}
\DoxyCodeLine{361   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{362   }
\DoxyCodeLine{363   \mbox{\hyperlink{classpodarray}{podarray<eT>}} init\_resid(dim\_n);}
\DoxyCodeLine{364   blas\_int idist = 2;                \textcolor{comment}{// Uniform(-\/1, 1)}}
\DoxyCodeLine{365   blas\_int iseed[4] = \{1, 3, 5, 7\};  \textcolor{comment}{// Fixed random seed}}
\DoxyCodeLine{366   blas\_int n = dim\_n;}
\DoxyCodeLine{367   lapack::larnv(\&idist, \&iseed[0], \&n, init\_resid.memptr());}
\DoxyCodeLine{368   init(init\_resid.memptr());}
\DoxyCodeLine{369   \}}
\DoxyCodeLine{370 }
\DoxyCodeLine{371 }
\DoxyCodeLine{372 }
\DoxyCodeLine{373 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT, \textcolor{keywordtype}{int} SelectionRule, \textcolor{keyword}{typename} OpType>}
\DoxyCodeLine{374 \textcolor{keyword}{inline}}
\DoxyCodeLine{375 uword}
\DoxyCodeLine{376 \mbox{\hyperlink{classnewarp_1_1GenEigsSolver_a74887ae9a3a007651d81b37c83a2a8fa}{GenEigsSolver<eT, SelectionRule, OpType>::compute}}(uword maxit, eT tol)}
\DoxyCodeLine{377   \{}
\DoxyCodeLine{378   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{379   }
\DoxyCodeLine{380   \textcolor{comment}{// The m-\/step Arnoldi factorisation}}
\DoxyCodeLine{381   factorise\_from(1, ncv, fac\_f);}
\DoxyCodeLine{382   retrieve\_ritzpair();}
\DoxyCodeLine{383   \textcolor{comment}{// Restarting}}
\DoxyCodeLine{384   uword i, nconv = 0, nev\_adj;}
\DoxyCodeLine{385   \textcolor{keywordflow}{for}(i = 0; i < maxit; i++)}
\DoxyCodeLine{386     \{}
\DoxyCodeLine{387     nconv = num\_converged(tol);}
\DoxyCodeLine{388     \textcolor{keywordflow}{if}(nconv >= nev) \{ \textcolor{keywordflow}{break}; \}}
\DoxyCodeLine{389 }
\DoxyCodeLine{390     nev\_adj = nev\_adjusted(nconv);}
\DoxyCodeLine{391     restart(nev\_adj);}
\DoxyCodeLine{392     \}}
\DoxyCodeLine{393   \textcolor{comment}{// Sorting results}}
\DoxyCodeLine{394   sort\_ritzpair();}
\DoxyCodeLine{395 }
\DoxyCodeLine{396   niter = i + 1;}
\DoxyCodeLine{397 }
\DoxyCodeLine{398   \textcolor{keywordflow}{return} (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(nev, nconv);}
\DoxyCodeLine{399   \}}
\DoxyCodeLine{400 }
\DoxyCodeLine{401 }
\DoxyCodeLine{402 }
\DoxyCodeLine{403 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT, \textcolor{keywordtype}{int} SelectionRule, \textcolor{keyword}{typename} OpType>}
\DoxyCodeLine{404 \textcolor{keyword}{inline}}
\DoxyCodeLine{405 \mbox{\hyperlink{classCol}{Col< std::complex<eT>}} >}
\DoxyCodeLine{406 \mbox{\hyperlink{classnewarp_1_1GenEigsSolver_a2a784c05989cbd43d23296bb92c35619}{GenEigsSolver<eT, SelectionRule, OpType>::eigenvalues}}()}
\DoxyCodeLine{407   \{}
\DoxyCodeLine{408   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{409   }
\DoxyCodeLine{410   uword nconv = std::count(ritz\_conv.begin(), ritz\_conv.end(), \textcolor{keyword}{true});}
\DoxyCodeLine{411   \mbox{\hyperlink{classCol}{Col< std::complex<eT>}} > res(nconv, \mbox{\hyperlink{structarma__zeros__indicator}{arma\_zeros\_indicator}}());}
\DoxyCodeLine{412   }
\DoxyCodeLine{413   \textcolor{keywordflow}{if}(nconv > 0)}
\DoxyCodeLine{414     \{}
\DoxyCodeLine{415     uword j = 0;}
\DoxyCodeLine{416     \textcolor{keywordflow}{for}(uword i = 0; i < nev; i++)}
\DoxyCodeLine{417       \{}
\DoxyCodeLine{418       \textcolor{keywordflow}{if}(ritz\_conv[i])}
\DoxyCodeLine{419         \{}
\DoxyCodeLine{420         res(j) = ritz\_val(i);}
\DoxyCodeLine{421         j++;}
\DoxyCodeLine{422         \}}
\DoxyCodeLine{423       \}}
\DoxyCodeLine{424     \}}
\DoxyCodeLine{425   }
\DoxyCodeLine{426   \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{427   \}}
\DoxyCodeLine{428 }
\DoxyCodeLine{429 }
\DoxyCodeLine{430 }
\DoxyCodeLine{431 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT, \textcolor{keywordtype}{int} SelectionRule, \textcolor{keyword}{typename} OpType>}
\DoxyCodeLine{432 \textcolor{keyword}{inline}}
\DoxyCodeLine{433 \mbox{\hyperlink{classMat}{Mat< std::complex<eT>}} >}
\DoxyCodeLine{434 \mbox{\hyperlink{classnewarp_1_1GenEigsSolver_a845d3adcbc1e0870f33572942c75c12f}{GenEigsSolver<eT, SelectionRule, OpType>::eigenvectors}}(uword nvec)}
\DoxyCodeLine{435   \{}
\DoxyCodeLine{436   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{437   }
\DoxyCodeLine{438   uword nconv = std::count(ritz\_conv.begin(), ritz\_conv.end(), \textcolor{keyword}{true});}
\DoxyCodeLine{439   nvec = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(nvec, nconv);}
\DoxyCodeLine{440   \mbox{\hyperlink{classMat}{Mat< std::complex<eT>}} > res(dim\_n, nvec);}
\DoxyCodeLine{441   }
\DoxyCodeLine{442   \textcolor{keywordflow}{if}(nvec > 0)}
\DoxyCodeLine{443     \{}
\DoxyCodeLine{444     \mbox{\hyperlink{classMat}{Mat< std::complex<eT>}} > ritz\_vec\_conv(ncv, nvec, \mbox{\hyperlink{structarma__zeros__indicator}{arma\_zeros\_indicator}}());}
\DoxyCodeLine{445     uword j = 0;}
\DoxyCodeLine{446     \textcolor{keywordflow}{for}(uword i = 0; (i < nev) \&\& (j < nvec); i++)}
\DoxyCodeLine{447       \{}
\DoxyCodeLine{448       \textcolor{keywordflow}{if}(ritz\_conv[i])}
\DoxyCodeLine{449         \{}
\DoxyCodeLine{450         ritz\_vec\_conv.\mbox{\hyperlink{group__Mat_gab68ba7bbceb5544bbd0f6f00dfe6b328}{col}}(j) = ritz\_vec.col(i);}
\DoxyCodeLine{451         j++;}
\DoxyCodeLine{452         \}}
\DoxyCodeLine{453       \}}
\DoxyCodeLine{454     }
\DoxyCodeLine{455     res = fac\_V * ritz\_vec\_conv;}
\DoxyCodeLine{456     \}}
\DoxyCodeLine{457   }
\DoxyCodeLine{458   \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{459   \}}
\DoxyCodeLine{460 }
\DoxyCodeLine{461 }
\DoxyCodeLine{462 \}  \textcolor{comment}{// namespace newarp}}

\end{DoxyCode}
