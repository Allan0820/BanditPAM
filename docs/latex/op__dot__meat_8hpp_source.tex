\hypertarget{op__dot__meat_8hpp_source}{}\doxysection{op\+\_\+dot\+\_\+meat.\+hpp}
\label{op__dot__meat_8hpp_source}\index{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/op\_dot\_meat.hpp@{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/op\_dot\_meat.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008-\/2016 Conrad Sanderson (http://conradsanderson.id.au)}}
\DoxyCodeLine{2 \textcolor{comment}{// Copyright 2008-\/2016 National ICT Australia (NICTA)}}
\DoxyCodeLine{3 \textcolor{comment}{// }}
\DoxyCodeLine{4 \textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{5 \textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{6 \textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{7 \textcolor{comment}{// http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{8 \textcolor{comment}{// }}
\DoxyCodeLine{9 \textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{10 \textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{11 \textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{12 \textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{13 \textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{14 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{19 }
\DoxyCodeLine{20 }
\DoxyCodeLine{21 }
\DoxyCodeLine{23 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{24 arma\_inline}
\DoxyCodeLine{25 \textcolor{keyword}{typename} arma\_not\_cx<eT>::result}
\DoxyCodeLine{26 \mbox{\hyperlink{group__op__dot_ga7af686a7089ac5d85b44405385578283}{op\_dot::direct\_dot\_arma}}(\textcolor{keyword}{const} uword n\_elem, \textcolor{keyword}{const} eT* \textcolor{keyword}{const} \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} eT* \textcolor{keyword}{const} \mbox{\hyperlink{structB}{B}})}
\DoxyCodeLine{27   \{}
\DoxyCodeLine{28   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{29   }
\DoxyCodeLine{30 \textcolor{preprocessor}{  \#if defined(\_\_FINITE\_MATH\_ONLY\_\_) \&\& (\_\_FINITE\_MATH\_ONLY\_\_ > 0)}}
\DoxyCodeLine{31     \{}
\DoxyCodeLine{32     eT val = eT(0);}
\DoxyCodeLine{33     }
\DoxyCodeLine{34     \textcolor{keywordflow}{for}(uword i=0; i<n\_elem; ++i)}
\DoxyCodeLine{35       \{}
\DoxyCodeLine{36       val += \mbox{\hyperlink{structA}{A}}[i] * \mbox{\hyperlink{structB}{B}}[i];}
\DoxyCodeLine{37       \}}
\DoxyCodeLine{38     }
\DoxyCodeLine{39     \textcolor{keywordflow}{return} val;}
\DoxyCodeLine{40     \}}
\DoxyCodeLine{41 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{42     \{}
\DoxyCodeLine{43     eT val1 = eT(0);}
\DoxyCodeLine{44     eT val2 = eT(0);}
\DoxyCodeLine{45     }
\DoxyCodeLine{46     uword i, j;}
\DoxyCodeLine{47     }
\DoxyCodeLine{48     \textcolor{keywordflow}{for}(i=0, j=1; j<n\_elem; i+=2, j+=2)}
\DoxyCodeLine{49       \{}
\DoxyCodeLine{50       val1 += \mbox{\hyperlink{structA}{A}}[i] * \mbox{\hyperlink{structB}{B}}[i];}
\DoxyCodeLine{51       val2 += \mbox{\hyperlink{structA}{A}}[j] * \mbox{\hyperlink{structB}{B}}[j];}
\DoxyCodeLine{52       \}}
\DoxyCodeLine{53     }
\DoxyCodeLine{54     \textcolor{keywordflow}{if}(i < n\_elem)}
\DoxyCodeLine{55       \{}
\DoxyCodeLine{56       val1 += \mbox{\hyperlink{structA}{A}}[i] * \mbox{\hyperlink{structB}{B}}[i];}
\DoxyCodeLine{57       \}}
\DoxyCodeLine{58     }
\DoxyCodeLine{59     \textcolor{keywordflow}{return} val1 + val2;}
\DoxyCodeLine{60     \}}
\DoxyCodeLine{61 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{62   \}}
\DoxyCodeLine{63 }
\DoxyCodeLine{64 }
\DoxyCodeLine{65 }
\DoxyCodeLine{67 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{68 arma\_hot}
\DoxyCodeLine{69 \textcolor{keyword}{inline}}
\DoxyCodeLine{70 \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<eT>::result}}}
\DoxyCodeLine{71 \mbox{\hyperlink{group__op__dot_ga7af686a7089ac5d85b44405385578283}{op\_dot::direct\_dot\_arma}}(\textcolor{keyword}{const} uword n\_elem, \textcolor{keyword}{const} eT* \textcolor{keyword}{const} \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} eT* \textcolor{keyword}{const} \mbox{\hyperlink{structB}{B}})}
\DoxyCodeLine{72   \{}
\DoxyCodeLine{73   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{74   }
\DoxyCodeLine{75   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} get\_pod\_type<eT>::result T;}
\DoxyCodeLine{76   }
\DoxyCodeLine{77   T val\_real = T(0);}
\DoxyCodeLine{78   T val\_imag = T(0);}
\DoxyCodeLine{79   }
\DoxyCodeLine{80   \textcolor{keywordflow}{for}(uword i=0; i<n\_elem; ++i)}
\DoxyCodeLine{81     \{}
\DoxyCodeLine{82     \textcolor{keyword}{const} std::complex<T>\& X = \mbox{\hyperlink{structA}{A}}[i];}
\DoxyCodeLine{83     \textcolor{keyword}{const} std::complex<T>\& Y = \mbox{\hyperlink{structB}{B}}[i];}
\DoxyCodeLine{84     }
\DoxyCodeLine{85     \textcolor{keyword}{const} T a = X.real();}
\DoxyCodeLine{86     \textcolor{keyword}{const} T b = X.imag();}
\DoxyCodeLine{87     }
\DoxyCodeLine{88     \textcolor{keyword}{const} T c = Y.real();}
\DoxyCodeLine{89     \textcolor{keyword}{const} T d = Y.imag();}
\DoxyCodeLine{90     }
\DoxyCodeLine{91     val\_real += (a*c) -\/ (b*d);}
\DoxyCodeLine{92     val\_imag += (a*d) + (b*c);}
\DoxyCodeLine{93     \}}
\DoxyCodeLine{94   }
\DoxyCodeLine{95   \textcolor{keywordflow}{return} std::complex<T>(val\_real, val\_imag);}
\DoxyCodeLine{96   \}}
\DoxyCodeLine{97 }
\DoxyCodeLine{98 }
\DoxyCodeLine{99 }
\DoxyCodeLine{101 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{102 arma\_hot}
\DoxyCodeLine{103 \textcolor{keyword}{inline}}
\DoxyCodeLine{104 \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__real__only}{arma\_real\_only<eT>::result}}}
\DoxyCodeLine{105 \mbox{\hyperlink{group__op__dot_gafcc9d4848f5791b21d9a4c755baa6440}{op\_dot::direct\_dot}}(\textcolor{keyword}{const} uword n\_elem, \textcolor{keyword}{const} eT* \textcolor{keyword}{const} \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} eT* \textcolor{keyword}{const} \mbox{\hyperlink{structB}{B}})}
\DoxyCodeLine{106   \{}
\DoxyCodeLine{107   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{108   }
\DoxyCodeLine{109   \textcolor{keywordflow}{if}( n\_elem <= 32u )}
\DoxyCodeLine{110     \{}
\DoxyCodeLine{111     \textcolor{keywordflow}{return} \mbox{\hyperlink{group__op__dot_ga7af686a7089ac5d85b44405385578283}{op\_dot::direct\_dot\_arma}}(n\_elem, \mbox{\hyperlink{structA}{A}}, \mbox{\hyperlink{structB}{B}});}
\DoxyCodeLine{112     \}}
\DoxyCodeLine{113   \textcolor{keywordflow}{else}}
\DoxyCodeLine{114     \{}
\DoxyCodeLine{115 \textcolor{preprocessor}{    \#if defined(ARMA\_USE\_ATLAS)}}
\DoxyCodeLine{116       \{}
\DoxyCodeLine{117       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}atlas::cblas\_dot()"{}});}
\DoxyCodeLine{118       }
\DoxyCodeLine{119       \textcolor{keywordflow}{return} atlas::cblas\_dot(n\_elem, \mbox{\hyperlink{structA}{A}}, \mbox{\hyperlink{structB}{B}});}
\DoxyCodeLine{120       \}}
\DoxyCodeLine{121 \textcolor{preprocessor}{    \#elif defined(ARMA\_USE\_BLAS)}}
\DoxyCodeLine{122       \{}
\DoxyCodeLine{123       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}blas::dot()"{}});}
\DoxyCodeLine{124       }
\DoxyCodeLine{125       \textcolor{keywordflow}{return} blas::dot(n\_elem, \mbox{\hyperlink{structA}{A}}, \mbox{\hyperlink{structB}{B}});}
\DoxyCodeLine{126       \}}
\DoxyCodeLine{127 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{128       \{}
\DoxyCodeLine{129       \textcolor{keywordflow}{return} \mbox{\hyperlink{group__op__dot_ga7af686a7089ac5d85b44405385578283}{op\_dot::direct\_dot\_arma}}(n\_elem, \mbox{\hyperlink{structA}{A}}, \mbox{\hyperlink{structB}{B}});}
\DoxyCodeLine{130       \}}
\DoxyCodeLine{131 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{132     \}}
\DoxyCodeLine{133   \}}
\DoxyCodeLine{134 }
\DoxyCodeLine{135 }
\DoxyCodeLine{136 }
\DoxyCodeLine{138 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{139 \textcolor{keyword}{inline}}
\DoxyCodeLine{140 arma\_hot}
\DoxyCodeLine{141 \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<eT>::result}}}
\DoxyCodeLine{142 \mbox{\hyperlink{group__op__dot_gafcc9d4848f5791b21d9a4c755baa6440}{op\_dot::direct\_dot}}(\textcolor{keyword}{const} uword n\_elem, \textcolor{keyword}{const} eT* \textcolor{keyword}{const} \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} eT* \textcolor{keyword}{const} \mbox{\hyperlink{structB}{B}})}
\DoxyCodeLine{143   \{}
\DoxyCodeLine{144   \textcolor{keywordflow}{if}( n\_elem <= 16u )}
\DoxyCodeLine{145     \{}
\DoxyCodeLine{146     \textcolor{keywordflow}{return} \mbox{\hyperlink{group__op__dot_ga7af686a7089ac5d85b44405385578283}{op\_dot::direct\_dot\_arma}}(n\_elem, \mbox{\hyperlink{structA}{A}}, \mbox{\hyperlink{structB}{B}});}
\DoxyCodeLine{147     \}}
\DoxyCodeLine{148   \textcolor{keywordflow}{else}}
\DoxyCodeLine{149     \{}
\DoxyCodeLine{150 \textcolor{preprocessor}{    \#if defined(ARMA\_USE\_ATLAS)}}
\DoxyCodeLine{151       \{}
\DoxyCodeLine{152       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}atlas::cblas\_cx\_dot()"{}});}
\DoxyCodeLine{153       }
\DoxyCodeLine{154       \textcolor{keywordflow}{return} atlas::cblas\_cx\_dot(n\_elem, \mbox{\hyperlink{structA}{A}}, \mbox{\hyperlink{structB}{B}});}
\DoxyCodeLine{155       \}}
\DoxyCodeLine{156 \textcolor{preprocessor}{    \#elif defined(ARMA\_USE\_BLAS)}}
\DoxyCodeLine{157       \{}
\DoxyCodeLine{158       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}blas::dot()"{}});}
\DoxyCodeLine{159       }
\DoxyCodeLine{160       \textcolor{keywordflow}{return} blas::dot(n\_elem, \mbox{\hyperlink{structA}{A}}, \mbox{\hyperlink{structB}{B}});}
\DoxyCodeLine{161       \}}
\DoxyCodeLine{162 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{163       \{}
\DoxyCodeLine{164       \textcolor{keywordflow}{return} \mbox{\hyperlink{group__op__dot_ga7af686a7089ac5d85b44405385578283}{op\_dot::direct\_dot\_arma}}(n\_elem, \mbox{\hyperlink{structA}{A}}, \mbox{\hyperlink{structB}{B}});}
\DoxyCodeLine{165       \}}
\DoxyCodeLine{166 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{167     \}}
\DoxyCodeLine{168   \}}
\DoxyCodeLine{169 }
\DoxyCodeLine{170 }
\DoxyCodeLine{171 }
\DoxyCodeLine{173 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{174 arma\_hot}
\DoxyCodeLine{175 \textcolor{keyword}{inline}}
\DoxyCodeLine{176 \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__integral__only}{arma\_integral\_only<eT>::result}}}
\DoxyCodeLine{177 \mbox{\hyperlink{group__op__dot_gafcc9d4848f5791b21d9a4c755baa6440}{op\_dot::direct\_dot}}(\textcolor{keyword}{const} uword n\_elem, \textcolor{keyword}{const} eT* \textcolor{keyword}{const} \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} eT* \textcolor{keyword}{const} \mbox{\hyperlink{structB}{B}})}
\DoxyCodeLine{178   \{}
\DoxyCodeLine{179   \textcolor{keywordflow}{return} \mbox{\hyperlink{group__op__dot_ga7af686a7089ac5d85b44405385578283}{op\_dot::direct\_dot\_arma}}(n\_elem, \mbox{\hyperlink{structA}{A}}, \mbox{\hyperlink{structB}{B}});}
\DoxyCodeLine{180   \}}
\DoxyCodeLine{181 }
\DoxyCodeLine{182 }
\DoxyCodeLine{183 }
\DoxyCodeLine{184 }
\DoxyCodeLine{186 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{187 arma\_hot}
\DoxyCodeLine{188 \textcolor{keyword}{inline}}
\DoxyCodeLine{189 eT}
\DoxyCodeLine{190 \mbox{\hyperlink{group__op__dot_gafcc9d4848f5791b21d9a4c755baa6440}{op\_dot::direct\_dot}}(\textcolor{keyword}{const} uword n\_elem, \textcolor{keyword}{const} eT* \textcolor{keyword}{const} \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} eT* \textcolor{keyword}{const} \mbox{\hyperlink{structB}{B}}, \textcolor{keyword}{const} eT* C)}
\DoxyCodeLine{191   \{}
\DoxyCodeLine{192   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{193   }
\DoxyCodeLine{194   eT val = eT(0);}
\DoxyCodeLine{195   }
\DoxyCodeLine{196   \textcolor{keywordflow}{for}(uword i=0; i<n\_elem; ++i)}
\DoxyCodeLine{197     \{}
\DoxyCodeLine{198     val += \mbox{\hyperlink{structA}{A}}[i] * \mbox{\hyperlink{structB}{B}}[i] * C[i];}
\DoxyCodeLine{199     \}}
\DoxyCodeLine{200 }
\DoxyCodeLine{201   \textcolor{keywordflow}{return} val;}
\DoxyCodeLine{202   \}}
\DoxyCodeLine{203 }
\DoxyCodeLine{204 }
\DoxyCodeLine{205 }
\DoxyCodeLine{206 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{207 arma\_hot}
\DoxyCodeLine{208 \textcolor{keyword}{inline}}
\DoxyCodeLine{209 \textcolor{keyword}{typename} T1::elem\_type}
\DoxyCodeLine{210 op\_dot::apply(\textcolor{keyword}{const} T1\& X, \textcolor{keyword}{const} T2\& Y)}
\DoxyCodeLine{211   \{}
\DoxyCodeLine{212   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{213   }
\DoxyCodeLine{214   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_at = (\mbox{\hyperlink{classProxy}{Proxy<T1>::use\_at}}) || (\mbox{\hyperlink{classProxy}{Proxy<T2>::use\_at}});}
\DoxyCodeLine{215   }
\DoxyCodeLine{216   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} have\_direct\_mem = (\mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>::has\_orig\_mem}}) \&\& (\mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T2>::has\_orig\_mem}});}
\DoxyCodeLine{217   }
\DoxyCodeLine{218   \textcolor{keywordflow}{if}(use\_at || have\_direct\_mem)}
\DoxyCodeLine{219     \{}
\DoxyCodeLine{220     \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} \mbox{\hyperlink{structA}{A}}(X);}
\DoxyCodeLine{221     \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T2>}} \mbox{\hyperlink{structB}{B}}(Y);}
\DoxyCodeLine{222     }
\DoxyCodeLine{223     arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.M.n\_elem != \mbox{\hyperlink{structB}{B}}.M.n\_elem), \textcolor{stringliteral}{"{}dot(): objects must have the same number of elements"{}} );}
\DoxyCodeLine{224     }
\DoxyCodeLine{225     \textcolor{keywordflow}{return} \mbox{\hyperlink{group__op__dot_gafcc9d4848f5791b21d9a4c755baa6440}{op\_dot::direct\_dot}}(\mbox{\hyperlink{structA}{A}}.M.n\_elem, \mbox{\hyperlink{structA}{A}}.M.memptr(), \mbox{\hyperlink{structB}{B}}.M.memptr());}
\DoxyCodeLine{226     \}}
\DoxyCodeLine{227   \textcolor{keywordflow}{else}}
\DoxyCodeLine{228     \{}
\DoxyCodeLine{229     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__subview__row}{is\_subview\_row<T1>::value}} \&\& \mbox{\hyperlink{structis__subview__row}{is\_subview\_row<T2>::value}})}
\DoxyCodeLine{230       \{}
\DoxyCodeLine{231       \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{232       }
\DoxyCodeLine{233       \textcolor{keyword}{const} \mbox{\hyperlink{classsubview__row}{subview\_row<eT>}}\& \mbox{\hyperlink{structA}{A}} = \textcolor{keyword}{reinterpret\_cast<} \textcolor{keyword}{const }\mbox{\hyperlink{classsubview__row}{subview\_row<eT>}}\& \textcolor{keyword}{>}(X);}
\DoxyCodeLine{234       \textcolor{keyword}{const} \mbox{\hyperlink{classsubview__row}{subview\_row<eT>}}\& \mbox{\hyperlink{structB}{B}} = \textcolor{keyword}{reinterpret\_cast<} \textcolor{keyword}{const }\mbox{\hyperlink{classsubview__row}{subview\_row<eT>}}\& \textcolor{keyword}{>}(Y);}
\DoxyCodeLine{235       }
\DoxyCodeLine{236       \textcolor{keywordflow}{if}( (\mbox{\hyperlink{structA}{A}}.m.n\_rows == 1) \&\& (\mbox{\hyperlink{structB}{B}}.m.n\_rows == 1) )}
\DoxyCodeLine{237         \{}
\DoxyCodeLine{238         arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.n\_elem != \mbox{\hyperlink{structB}{B}}.n\_elem), \textcolor{stringliteral}{"{}dot(): objects must have the same number of elements"{}} );}
\DoxyCodeLine{239         }
\DoxyCodeLine{240         \textcolor{keyword}{const} eT* A\_mem = \mbox{\hyperlink{structA}{A}}.m.memptr();}
\DoxyCodeLine{241         \textcolor{keyword}{const} eT* B\_mem = \mbox{\hyperlink{structB}{B}}.m.memptr();}
\DoxyCodeLine{242         }
\DoxyCodeLine{243         \textcolor{keywordflow}{return} \mbox{\hyperlink{group__op__dot_gafcc9d4848f5791b21d9a4c755baa6440}{op\_dot::direct\_dot}}(\mbox{\hyperlink{structA}{A}}.n\_elem, \&A\_mem[\mbox{\hyperlink{structA}{A}}.aux\_col1], \&B\_mem[\mbox{\hyperlink{structB}{B}}.aux\_col1]);}
\DoxyCodeLine{244         \}}
\DoxyCodeLine{245       \}}
\DoxyCodeLine{246     }
\DoxyCodeLine{247     \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} PA(X);}
\DoxyCodeLine{248     \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T2>}} PB(Y);}
\DoxyCodeLine{249     }
\DoxyCodeLine{250     arma\_debug\_check( (PA.get\_n\_elem() != PB.get\_n\_elem()), \textcolor{stringliteral}{"{}dot(): objects must have the same number of elements"{}} );}
\DoxyCodeLine{251     }
\DoxyCodeLine{252     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__Mat}{is\_Mat}}<\textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::stored\_type}}>::value \&\& \mbox{\hyperlink{structis__Mat}{is\_Mat}}<\textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T2>::stored\_type}}>::value)}
\DoxyCodeLine{253       \{}
\DoxyCodeLine{254       \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<typename Proxy<T1>::stored\_type}}> \mbox{\hyperlink{structA}{A}}(PA.Q);}
\DoxyCodeLine{255       \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<typename Proxy<T2>::stored\_type}}> \mbox{\hyperlink{structB}{B}}(PB.Q);}
\DoxyCodeLine{256       }
\DoxyCodeLine{257       \textcolor{keywordflow}{return} \mbox{\hyperlink{group__op__dot_gafcc9d4848f5791b21d9a4c755baa6440}{op\_dot::direct\_dot}}(\mbox{\hyperlink{structA}{A}}.M.n\_elem, \mbox{\hyperlink{structA}{A}}.M.memptr(), \mbox{\hyperlink{structB}{B}}.M.memptr());}
\DoxyCodeLine{258       \}}
\DoxyCodeLine{259     }
\DoxyCodeLine{260     \textcolor{keywordflow}{return} op\_dot::apply\_proxy(PA,PB);}
\DoxyCodeLine{261     \}}
\DoxyCodeLine{262   \}}
\DoxyCodeLine{263 }
\DoxyCodeLine{264 }
\DoxyCodeLine{265 }
\DoxyCodeLine{266 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{267 arma\_hot}
\DoxyCodeLine{268 \textcolor{keyword}{inline}}
\DoxyCodeLine{269 \textcolor{keyword}{typename} arma\_not\_cx<typename T1::elem\_type>::result}
\DoxyCodeLine{270 op\_dot::apply\_proxy(\textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}}\& PA, \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T2>}}\& PB)}
\DoxyCodeLine{271   \{}
\DoxyCodeLine{272   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{273   }
\DoxyCodeLine{274   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type      eT;}
\DoxyCodeLine{275   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::ea\_type}} ea\_type1;}
\DoxyCodeLine{276   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T2>::ea\_type}} ea\_type2;}
\DoxyCodeLine{277   }
\DoxyCodeLine{278   \textcolor{keyword}{const} uword N = PA.get\_n\_elem();}
\DoxyCodeLine{279   }
\DoxyCodeLine{280   ea\_type1 \mbox{\hyperlink{structA}{A}} = PA.get\_ea();}
\DoxyCodeLine{281   ea\_type2 \mbox{\hyperlink{structB}{B}} = PB.get\_ea();}
\DoxyCodeLine{282   }
\DoxyCodeLine{283   eT val1 = eT(0);}
\DoxyCodeLine{284   eT val2 = eT(0);}
\DoxyCodeLine{285   }
\DoxyCodeLine{286   uword i,j;}
\DoxyCodeLine{287   }
\DoxyCodeLine{288   \textcolor{keywordflow}{for}(i=0, j=1; j<N; i+=2, j+=2)}
\DoxyCodeLine{289     \{}
\DoxyCodeLine{290     val1 += \mbox{\hyperlink{structA}{A}}[i] * \mbox{\hyperlink{structB}{B}}[i];}
\DoxyCodeLine{291     val2 += \mbox{\hyperlink{structA}{A}}[j] * \mbox{\hyperlink{structB}{B}}[j];}
\DoxyCodeLine{292     \}}
\DoxyCodeLine{293   }
\DoxyCodeLine{294   \textcolor{keywordflow}{if}(i < N)}
\DoxyCodeLine{295     \{}
\DoxyCodeLine{296     val1 += \mbox{\hyperlink{structA}{A}}[i] * \mbox{\hyperlink{structB}{B}}[i];}
\DoxyCodeLine{297     \}}
\DoxyCodeLine{298   }
\DoxyCodeLine{299   \textcolor{keywordflow}{return} val1 + val2;}
\DoxyCodeLine{300   \}}
\DoxyCodeLine{301 }
\DoxyCodeLine{302 }
\DoxyCodeLine{303 }
\DoxyCodeLine{304 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{305 arma\_hot}
\DoxyCodeLine{306 \textcolor{keyword}{inline}}
\DoxyCodeLine{307 \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<typename T1::elem\_type>::result}}}
\DoxyCodeLine{308 op\_dot::apply\_proxy(\textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}}\& PA, \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T2>}}\& PB)}
\DoxyCodeLine{309   \{}
\DoxyCodeLine{310   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{311   }
\DoxyCodeLine{312   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type            eT;}
\DoxyCodeLine{313   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} get\_pod\_type<eT>::result  T;}
\DoxyCodeLine{314   }
\DoxyCodeLine{315   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::ea\_type}} ea\_type1;}
\DoxyCodeLine{316   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T2>::ea\_type}} ea\_type2;}
\DoxyCodeLine{317   }
\DoxyCodeLine{318   \textcolor{keyword}{const} uword N = PA.get\_n\_elem();}
\DoxyCodeLine{319   }
\DoxyCodeLine{320   ea\_type1 \mbox{\hyperlink{structA}{A}} = PA.get\_ea();}
\DoxyCodeLine{321   ea\_type2 \mbox{\hyperlink{structB}{B}} = PB.get\_ea();}
\DoxyCodeLine{322   }
\DoxyCodeLine{323   T val\_real = T(0);}
\DoxyCodeLine{324   T val\_imag = T(0);}
\DoxyCodeLine{325   }
\DoxyCodeLine{326   \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)}
\DoxyCodeLine{327     \{}
\DoxyCodeLine{328     \textcolor{keyword}{const} std::complex<T> xx = \mbox{\hyperlink{structA}{A}}[i];}
\DoxyCodeLine{329     \textcolor{keyword}{const} std::complex<T> yy = \mbox{\hyperlink{structB}{B}}[i];}
\DoxyCodeLine{330     }
\DoxyCodeLine{331     \textcolor{keyword}{const} T a = xx.real();}
\DoxyCodeLine{332     \textcolor{keyword}{const} T b = xx.imag();}
\DoxyCodeLine{333     }
\DoxyCodeLine{334     \textcolor{keyword}{const} T c = yy.real();}
\DoxyCodeLine{335     \textcolor{keyword}{const} T d = yy.imag();}
\DoxyCodeLine{336     }
\DoxyCodeLine{337     val\_real += (a*c) -\/ (b*d);}
\DoxyCodeLine{338     val\_imag += (a*d) + (b*c);}
\DoxyCodeLine{339     \}}
\DoxyCodeLine{340   }
\DoxyCodeLine{341   \textcolor{keywordflow}{return} std::complex<T>(val\_real, val\_imag);}
\DoxyCodeLine{342   \}}
\DoxyCodeLine{343 }
\DoxyCodeLine{344 }
\DoxyCodeLine{345 }
\DoxyCodeLine{346 \textcolor{comment}{//}}
\DoxyCodeLine{347 \textcolor{comment}{// op\_norm\_dot}}
\DoxyCodeLine{348 }
\DoxyCodeLine{349 }
\DoxyCodeLine{350 }
\DoxyCodeLine{351 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{352 arma\_hot}
\DoxyCodeLine{353 \textcolor{keyword}{inline}}
\DoxyCodeLine{354 \textcolor{keyword}{typename} T1::elem\_type}
\DoxyCodeLine{355 op\_norm\_dot::apply(\textcolor{keyword}{const} T1\& X, \textcolor{keyword}{const} T2\& Y)}
\DoxyCodeLine{356   \{}
\DoxyCodeLine{357   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{358   }
\DoxyCodeLine{359   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{360   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type   T;}
\DoxyCodeLine{361   }
\DoxyCodeLine{362   \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} tmp1(X);}
\DoxyCodeLine{363   \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T2>}} tmp2(Y);}
\DoxyCodeLine{364   }
\DoxyCodeLine{365   \textcolor{keyword}{const} \mbox{\hyperlink{classCol}{Col<eT>}} \mbox{\hyperlink{structA}{A}}( \textcolor{keyword}{const\_cast<}eT*\textcolor{keyword}{>}(tmp1.M.memptr()), tmp1.M.n\_elem, \textcolor{keyword}{false} );}
\DoxyCodeLine{366   \textcolor{keyword}{const} \mbox{\hyperlink{classCol}{Col<eT>}} \mbox{\hyperlink{structB}{B}}( \textcolor{keyword}{const\_cast<}eT*\textcolor{keyword}{>}(tmp2.M.memptr()), tmp2.M.n\_elem, \textcolor{keyword}{false} );}
\DoxyCodeLine{367   }
\DoxyCodeLine{368   arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.n\_elem != \mbox{\hyperlink{structB}{B}}.n\_elem), \textcolor{stringliteral}{"{}norm\_dot(): objects must have the same number of elements"{}} );}
\DoxyCodeLine{369   }
\DoxyCodeLine{370   \textcolor{keyword}{const} T denom = norm(\mbox{\hyperlink{structA}{A}},2) * norm(\mbox{\hyperlink{structB}{B}},2);}
\DoxyCodeLine{371   }
\DoxyCodeLine{372   \textcolor{keywordflow}{return} (denom != T(0)) ? ( op\_dot::apply(\mbox{\hyperlink{structA}{A}},\mbox{\hyperlink{structB}{B}}) / denom ) : eT(0);}
\DoxyCodeLine{373   \}}
\DoxyCodeLine{374 }
\DoxyCodeLine{375 }
\DoxyCodeLine{376 }
\DoxyCodeLine{377 \textcolor{comment}{//}}
\DoxyCodeLine{378 \textcolor{comment}{// op\_cdot}}
\DoxyCodeLine{379 }
\DoxyCodeLine{380 }
\DoxyCodeLine{381 }
\DoxyCodeLine{382 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{383 arma\_hot}
\DoxyCodeLine{384 \textcolor{keyword}{inline}}
\DoxyCodeLine{385 eT}
\DoxyCodeLine{386 op\_cdot::direct\_cdot\_arma(\textcolor{keyword}{const} uword n\_elem, \textcolor{keyword}{const} eT* \textcolor{keyword}{const} \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} eT* \textcolor{keyword}{const} \mbox{\hyperlink{structB}{B}})}
\DoxyCodeLine{387   \{}
\DoxyCodeLine{388   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{389   }
\DoxyCodeLine{390   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} get\_pod\_type<eT>::result T;}
\DoxyCodeLine{391   }
\DoxyCodeLine{392   T val\_real = T(0);}
\DoxyCodeLine{393   T val\_imag = T(0);}
\DoxyCodeLine{394   }
\DoxyCodeLine{395   \textcolor{keywordflow}{for}(uword i=0; i<n\_elem; ++i)}
\DoxyCodeLine{396     \{}
\DoxyCodeLine{397     \textcolor{keyword}{const} std::complex<T>\& X = \mbox{\hyperlink{structA}{A}}[i];}
\DoxyCodeLine{398     \textcolor{keyword}{const} std::complex<T>\& Y = \mbox{\hyperlink{structB}{B}}[i];}
\DoxyCodeLine{399     }
\DoxyCodeLine{400     \textcolor{keyword}{const} T a = X.real();}
\DoxyCodeLine{401     \textcolor{keyword}{const} T b = X.imag();}
\DoxyCodeLine{402     }
\DoxyCodeLine{403     \textcolor{keyword}{const} T c = Y.real();}
\DoxyCodeLine{404     \textcolor{keyword}{const} T d = Y.imag();}
\DoxyCodeLine{405     }
\DoxyCodeLine{406     val\_real += (a*c) + (b*d);}
\DoxyCodeLine{407     val\_imag += (a*d) -\/ (b*c);}
\DoxyCodeLine{408     \}}
\DoxyCodeLine{409   }
\DoxyCodeLine{410   \textcolor{keywordflow}{return} std::complex<T>(val\_real, val\_imag);}
\DoxyCodeLine{411   \}}
\DoxyCodeLine{412 }
\DoxyCodeLine{413 }
\DoxyCodeLine{414 }
\DoxyCodeLine{415 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{416 arma\_hot}
\DoxyCodeLine{417 \textcolor{keyword}{inline}}
\DoxyCodeLine{418 eT}
\DoxyCodeLine{419 op\_cdot::direct\_cdot(\textcolor{keyword}{const} uword n\_elem, \textcolor{keyword}{const} eT* \textcolor{keyword}{const} \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} eT* \textcolor{keyword}{const} \mbox{\hyperlink{structB}{B}})}
\DoxyCodeLine{420   \{}
\DoxyCodeLine{421   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{422   }
\DoxyCodeLine{423   \textcolor{keywordflow}{if}( n\_elem <= 32u )}
\DoxyCodeLine{424     \{}
\DoxyCodeLine{425     \textcolor{keywordflow}{return} op\_cdot::direct\_cdot\_arma(n\_elem, \mbox{\hyperlink{structA}{A}}, \mbox{\hyperlink{structB}{B}});}
\DoxyCodeLine{426     \}}
\DoxyCodeLine{427   \textcolor{keywordflow}{else}}
\DoxyCodeLine{428     \{}
\DoxyCodeLine{429 \textcolor{preprocessor}{    \#if defined(ARMA\_USE\_BLAS)}}
\DoxyCodeLine{430       \{}
\DoxyCodeLine{431       arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}blas::gemv()"{}});}
\DoxyCodeLine{432       }
\DoxyCodeLine{433       \textcolor{comment}{// using gemv() workaround due to compatibility issues with cdotc() and zdotc()}}
\DoxyCodeLine{434       }
\DoxyCodeLine{435       \textcolor{keyword}{const} \textcolor{keywordtype}{char} trans   = \textcolor{charliteral}{'C'};}
\DoxyCodeLine{436       }
\DoxyCodeLine{437       \textcolor{keyword}{const} blas\_int m   = blas\_int(n\_elem);}
\DoxyCodeLine{438       \textcolor{keyword}{const} blas\_int n   = 1;}
\DoxyCodeLine{439       \textcolor{comment}{//const blas\_int lda = (n\_elem > 0) ? blas\_int(n\_elem) : blas\_int(1);}}
\DoxyCodeLine{440       \textcolor{keyword}{const} blas\_int inc = 1;}
\DoxyCodeLine{441       }
\DoxyCodeLine{442       \textcolor{keyword}{const} eT alpha     = eT(1);}
\DoxyCodeLine{443       \textcolor{keyword}{const} eT beta      = eT(0);}
\DoxyCodeLine{444       }
\DoxyCodeLine{445       eT result[2];  \textcolor{comment}{// paranoia: using two elements instead of one}}
\DoxyCodeLine{446       }
\DoxyCodeLine{447       \textcolor{comment}{//blas::gemv(\&trans, \&m, \&n, \&alpha, A, \&lda, B, \&inc, \&beta, \&result[0], \&inc);}}
\DoxyCodeLine{448       blas::gemv(\&trans, \&m, \&n, \&alpha, \mbox{\hyperlink{structA}{A}}, \&m, \mbox{\hyperlink{structB}{B}}, \&inc, \&beta, \&result[0], \&inc);}
\DoxyCodeLine{449       }
\DoxyCodeLine{450       \textcolor{keywordflow}{return} result[0];}
\DoxyCodeLine{451       \}}
\DoxyCodeLine{452 \textcolor{preprocessor}{    \#elif defined(ARMA\_USE\_ATLAS)}}
\DoxyCodeLine{453       \{}
\DoxyCodeLine{454       \textcolor{comment}{// TODO: use dedicated atlas functions cblas\_cdotc\_sub() and cblas\_zdotc\_sub() and retune threshold}}
\DoxyCodeLine{455 }
\DoxyCodeLine{456       \textcolor{keywordflow}{return} op\_cdot::direct\_cdot\_arma(n\_elem, \mbox{\hyperlink{structA}{A}}, \mbox{\hyperlink{structB}{B}});}
\DoxyCodeLine{457       \}}
\DoxyCodeLine{458 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{459       \{}
\DoxyCodeLine{460       \textcolor{keywordflow}{return} op\_cdot::direct\_cdot\_arma(n\_elem, \mbox{\hyperlink{structA}{A}}, \mbox{\hyperlink{structB}{B}});}
\DoxyCodeLine{461       \}}
\DoxyCodeLine{462 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{463     \}}
\DoxyCodeLine{464   \}}
\DoxyCodeLine{465 }
\DoxyCodeLine{466 }
\DoxyCodeLine{467 }
\DoxyCodeLine{468 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{469 arma\_hot}
\DoxyCodeLine{470 \textcolor{keyword}{inline}}
\DoxyCodeLine{471 \textcolor{keyword}{typename} T1::elem\_type}
\DoxyCodeLine{472 op\_cdot::apply(\textcolor{keyword}{const} T1\& X, \textcolor{keyword}{const} T2\& Y)}
\DoxyCodeLine{473   \{}
\DoxyCodeLine{474   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{475   }
\DoxyCodeLine{476   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__Mat}{is\_Mat<T1>::value}} \&\& \mbox{\hyperlink{structis__Mat}{is\_Mat<T2>::value}})}
\DoxyCodeLine{477     \{}
\DoxyCodeLine{478     \textcolor{keywordflow}{return} op\_cdot::apply\_unwrap(X,Y);}
\DoxyCodeLine{479     \}}
\DoxyCodeLine{480   \textcolor{keywordflow}{else}}
\DoxyCodeLine{481     \{}
\DoxyCodeLine{482     \textcolor{keywordflow}{return} op\_cdot::apply\_proxy(X,Y);}
\DoxyCodeLine{483     \}}
\DoxyCodeLine{484   \}}
\DoxyCodeLine{485 }
\DoxyCodeLine{486 }
\DoxyCodeLine{487 }
\DoxyCodeLine{488 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{489 arma\_hot}
\DoxyCodeLine{490 \textcolor{keyword}{inline}}
\DoxyCodeLine{491 \textcolor{keyword}{typename} T1::elem\_type}
\DoxyCodeLine{492 op\_cdot::apply\_unwrap(\textcolor{keyword}{const} T1\& X, \textcolor{keyword}{const} T2\& Y)}
\DoxyCodeLine{493   \{}
\DoxyCodeLine{494   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{495   }
\DoxyCodeLine{496   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{497   }
\DoxyCodeLine{498   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap}{unwrap<T1>}} tmp1(X);}
\DoxyCodeLine{499   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap}{unwrap<T2>}} tmp2(Y);}
\DoxyCodeLine{500   }
\DoxyCodeLine{501   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}} = tmp1.M;}
\DoxyCodeLine{502   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structB}{B}} = tmp2.M;}
\DoxyCodeLine{503   }
\DoxyCodeLine{504   arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.n\_elem != \mbox{\hyperlink{structB}{B}}.n\_elem), \textcolor{stringliteral}{"{}cdot(): objects must have the same number of elements"{}} );}
\DoxyCodeLine{505   }
\DoxyCodeLine{506   \textcolor{keywordflow}{return} op\_cdot::direct\_cdot( \mbox{\hyperlink{structA}{A}}.n\_elem, \mbox{\hyperlink{structA}{A}}.mem, \mbox{\hyperlink{structB}{B}}.mem );}
\DoxyCodeLine{507   \}}
\DoxyCodeLine{508 }
\DoxyCodeLine{509 }
\DoxyCodeLine{510 }
\DoxyCodeLine{511 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{512 arma\_hot}
\DoxyCodeLine{513 \textcolor{keyword}{inline}}
\DoxyCodeLine{514 \textcolor{keyword}{typename} T1::elem\_type}
\DoxyCodeLine{515 op\_cdot::apply\_proxy(\textcolor{keyword}{const} T1\& X, \textcolor{keyword}{const} T2\& Y)}
\DoxyCodeLine{516   \{}
\DoxyCodeLine{517   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{518   }
\DoxyCodeLine{519   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type            eT;}
\DoxyCodeLine{520   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} get\_pod\_type<eT>::result  T;}
\DoxyCodeLine{521   }
\DoxyCodeLine{522   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T1>::ea\_type}} ea\_type1;}
\DoxyCodeLine{523   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{classProxy}{Proxy<T2>::ea\_type}} ea\_type2;}
\DoxyCodeLine{524   }
\DoxyCodeLine{525   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_at = (\mbox{\hyperlink{classProxy}{Proxy<T1>::use\_at}}) || (\mbox{\hyperlink{classProxy}{Proxy<T2>::use\_at}});}
\DoxyCodeLine{526   }
\DoxyCodeLine{527   \textcolor{keywordflow}{if}(use\_at == \textcolor{keyword}{false})}
\DoxyCodeLine{528     \{}
\DoxyCodeLine{529     \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} PA(X);}
\DoxyCodeLine{530     \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T2>}} PB(Y);}
\DoxyCodeLine{531     }
\DoxyCodeLine{532     \textcolor{keyword}{const} uword N = PA.get\_n\_elem();}
\DoxyCodeLine{533     }
\DoxyCodeLine{534     arma\_debug\_check( (N != PB.get\_n\_elem()), \textcolor{stringliteral}{"{}cdot(): objects must have the same number of elements"{}} );}
\DoxyCodeLine{535     }
\DoxyCodeLine{536     ea\_type1 \mbox{\hyperlink{structA}{A}} = PA.get\_ea();}
\DoxyCodeLine{537     ea\_type2 \mbox{\hyperlink{structB}{B}} = PB.get\_ea();}
\DoxyCodeLine{538     }
\DoxyCodeLine{539     T val\_real = T(0);}
\DoxyCodeLine{540     T val\_imag = T(0);}
\DoxyCodeLine{541     }
\DoxyCodeLine{542     \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)}
\DoxyCodeLine{543       \{}
\DoxyCodeLine{544       \textcolor{keyword}{const} std::complex<T> AA = \mbox{\hyperlink{structA}{A}}[i];}
\DoxyCodeLine{545       \textcolor{keyword}{const} std::complex<T> BB = \mbox{\hyperlink{structB}{B}}[i];}
\DoxyCodeLine{546       }
\DoxyCodeLine{547       \textcolor{keyword}{const} T a = AA.real();}
\DoxyCodeLine{548       \textcolor{keyword}{const} T b = AA.imag();}
\DoxyCodeLine{549       }
\DoxyCodeLine{550       \textcolor{keyword}{const} T c = BB.real();}
\DoxyCodeLine{551       \textcolor{keyword}{const} T d = BB.imag();}
\DoxyCodeLine{552       }
\DoxyCodeLine{553       val\_real += (a*c) + (b*d);}
\DoxyCodeLine{554       val\_imag += (a*d) -\/ (b*c);}
\DoxyCodeLine{555       \}}
\DoxyCodeLine{556     }
\DoxyCodeLine{557     \textcolor{keywordflow}{return} std::complex<T>(val\_real, val\_imag);}
\DoxyCodeLine{558     \}}
\DoxyCodeLine{559   \textcolor{keywordflow}{else}}
\DoxyCodeLine{560     \{}
\DoxyCodeLine{561     \textcolor{keywordflow}{return} op\_cdot::apply\_unwrap( X, Y );}
\DoxyCodeLine{562     \}}
\DoxyCodeLine{563   \}}
\DoxyCodeLine{564 }
\DoxyCodeLine{565 }
\DoxyCodeLine{566 }
\DoxyCodeLine{567 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{568 arma\_hot}
\DoxyCodeLine{569 \textcolor{keyword}{inline}}
\DoxyCodeLine{570 \textcolor{keyword}{typename} promote\_type<typename T1::elem\_type, typename T2::elem\_type>::result}
\DoxyCodeLine{571 op\_dot\_mixed::apply(\textcolor{keyword}{const} T1\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} T2\& \mbox{\hyperlink{structB}{B}})}
\DoxyCodeLine{572   \{}
\DoxyCodeLine{573   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{574   }
\DoxyCodeLine{575   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type in\_eT1;}
\DoxyCodeLine{576   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T2::elem\_type in\_eT2;}
\DoxyCodeLine{577   }
\DoxyCodeLine{578   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} promote\_type<in\_eT1, in\_eT2>::result out\_eT;}
\DoxyCodeLine{579   }
\DoxyCodeLine{580   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T1>}} PA(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{581   \textcolor{keyword}{const} \mbox{\hyperlink{classProxy}{Proxy<T2>}} PB(\mbox{\hyperlink{structB}{B}});}
\DoxyCodeLine{582   }
\DoxyCodeLine{583   \textcolor{keyword}{const} uword N = PA.get\_n\_elem();}
\DoxyCodeLine{584   }
\DoxyCodeLine{585   arma\_debug\_check( (N != PB.get\_n\_elem()), \textcolor{stringliteral}{"{}dot(): objects must have the same number of elements"{}} );}
\DoxyCodeLine{586   }
\DoxyCodeLine{587   out\_eT acc = out\_eT(0);}
\DoxyCodeLine{588   }
\DoxyCodeLine{589   \textcolor{keywordflow}{for}(uword i=0; i < N; ++i)}
\DoxyCodeLine{590     \{}
\DoxyCodeLine{591     acc += \mbox{\hyperlink{structupgrade__val}{upgrade\_val<in\_eT1,in\_eT2>::apply}}(PA[i]) * \mbox{\hyperlink{structupgrade__val}{upgrade\_val<in\_eT1,in\_eT2>::apply}}(PB[i]);}
\DoxyCodeLine{592     \}}
\DoxyCodeLine{593   }
\DoxyCodeLine{594   \textcolor{keywordflow}{return} acc;}
\DoxyCodeLine{595   \}}
\DoxyCodeLine{596 }
\DoxyCodeLine{597 }
\DoxyCodeLine{598 }

\end{DoxyCode}
