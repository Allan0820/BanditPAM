\hypertarget{op__logmat__meat_8hpp_source}{}\doxysection{op\+\_\+logmat\+\_\+meat.\+hpp}
\label{op__logmat__meat_8hpp_source}\index{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/op\_logmat\_meat.hpp@{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/op\_logmat\_meat.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008-\/2016 Conrad Sanderson (http://conradsanderson.id.au)}}
\DoxyCodeLine{2 \textcolor{comment}{// Copyright 2008-\/2016 National ICT Australia (NICTA)}}
\DoxyCodeLine{3 \textcolor{comment}{// }}
\DoxyCodeLine{4 \textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{5 \textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{6 \textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{7 \textcolor{comment}{// http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{8 \textcolor{comment}{// }}
\DoxyCodeLine{9 \textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{10 \textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{11 \textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{12 \textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{13 \textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{14 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{19 }
\DoxyCodeLine{20 }
\DoxyCodeLine{21 \textcolor{comment}{// Partly based on algorithm 11.9 (inverse scaling and squaring algorithm with Schur decomposition) in:}}
\DoxyCodeLine{22 \textcolor{comment}{// Nicholas J. Higham.}}
\DoxyCodeLine{23 \textcolor{comment}{// Functions of Matrices: Theory and Computation.}}
\DoxyCodeLine{24 \textcolor{comment}{// SIAM, 2008.}}
\DoxyCodeLine{25 \textcolor{comment}{// ISBN 978-\/0-\/89871-\/646-\/7}}
\DoxyCodeLine{26 }
\DoxyCodeLine{27 }
\DoxyCodeLine{28 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{29 \textcolor{keyword}{inline}}
\DoxyCodeLine{30 \textcolor{keywordtype}{void}}
\DoxyCodeLine{31 op\_logmat::apply(\mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::elem\_type> >\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classmtOp}{mtOp}}<std::complex<typename T1::elem\_type>,T1,\mbox{\hyperlink{classop__logmat}{op\_logmat}}>\& in)}
\DoxyCodeLine{32   \{}
\DoxyCodeLine{33   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{34   }
\DoxyCodeLine{35   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} status = op\_logmat::apply\_direct(out, in.m, in.aux\_uword\_a);}
\DoxyCodeLine{36   }
\DoxyCodeLine{37   \textcolor{keywordflow}{if}(status == \textcolor{keyword}{false})}
\DoxyCodeLine{38     \{}
\DoxyCodeLine{39     out.soft\_reset();}
\DoxyCodeLine{40     arma\_stop\_runtime\_error(\textcolor{stringliteral}{"{}logmat(): transformation failed"{}});}
\DoxyCodeLine{41     \}}
\DoxyCodeLine{42   \}}
\DoxyCodeLine{43 }
\DoxyCodeLine{44 }
\DoxyCodeLine{45 }
\DoxyCodeLine{46 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{47 \textcolor{keyword}{inline}}
\DoxyCodeLine{48 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{49 op\_logmat::apply\_direct(\mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::elem\_type> >\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T1,op\_diagmat>}}\& expr, \textcolor{keyword}{const} uword)}
\DoxyCodeLine{50   \{}
\DoxyCodeLine{51   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{52   }
\DoxyCodeLine{53   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type T;}
\DoxyCodeLine{54   }
\DoxyCodeLine{55   \textcolor{keyword}{const} \mbox{\hyperlink{classdiagmat__proxy}{diagmat\_proxy<T1>}} P(expr.\mbox{\hyperlink{classOp_af7ab7221b6e233cdd38b9f9b69f301ce}{m}});}
\DoxyCodeLine{56   }
\DoxyCodeLine{57   arma\_debug\_check( (P.n\_rows != P.n\_cols), \textcolor{stringliteral}{"{}logmat(): given matrix must be square sized"{}} );}
\DoxyCodeLine{58   }
\DoxyCodeLine{59   \textcolor{keyword}{const} uword N = P.n\_rows;}
\DoxyCodeLine{60   }
\DoxyCodeLine{61   out.zeros(N,N);  \textcolor{comment}{// aliasing can't happen as op\_logmat is defined as cx\_mat = op(mat)}}
\DoxyCodeLine{62   }
\DoxyCodeLine{63   \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)}
\DoxyCodeLine{64     \{}
\DoxyCodeLine{65     \textcolor{keyword}{const} T val = P[i];}
\DoxyCodeLine{66     }
\DoxyCodeLine{67     \textcolor{keywordflow}{if}(val >= T(0))}
\DoxyCodeLine{68       \{}
\DoxyCodeLine{69       out.at(i,i) = std::log(val);}
\DoxyCodeLine{70       \}}
\DoxyCodeLine{71     \textcolor{keywordflow}{else}}
\DoxyCodeLine{72       \{}
\DoxyCodeLine{73       out.at(i,i) = std::log( std::complex<T>(val) );}
\DoxyCodeLine{74       \}}
\DoxyCodeLine{75     \}}
\DoxyCodeLine{76   }
\DoxyCodeLine{77   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{78   \}}
\DoxyCodeLine{79 }
\DoxyCodeLine{80 }
\DoxyCodeLine{81 }
\DoxyCodeLine{82 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{83 \textcolor{keyword}{inline}}
\DoxyCodeLine{84 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{85 op\_logmat::apply\_direct(\mbox{\hyperlink{classMat}{Mat}}< std::complex<typename T1::elem\_type> >\& out, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::elem\_type,T1>}}\& expr, \textcolor{keyword}{const} uword n\_iters)}
\DoxyCodeLine{86   \{}
\DoxyCodeLine{87   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{88   }
\DoxyCodeLine{89   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type       in\_T;}
\DoxyCodeLine{90   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<in\_T> out\_T;}
\DoxyCodeLine{91   }
\DoxyCodeLine{92   \textcolor{keyword}{const} \mbox{\hyperlink{structquasi__unwrap}{quasi\_unwrap<T1>}} expr\_unwrap(expr.get\_ref());}
\DoxyCodeLine{93   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<in\_T>}}\& \mbox{\hyperlink{structA}{A}}   = expr\_unwrap.M;}
\DoxyCodeLine{94   }
\DoxyCodeLine{95   arma\_debug\_check( (\mbox{\hyperlink{structA}{A}}.is\_square() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}logmat(): given matrix must be square sized"{}} );}
\DoxyCodeLine{96   }
\DoxyCodeLine{97   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.n\_elem == 0)}
\DoxyCodeLine{98     \{}
\DoxyCodeLine{99     out.reset();}
\DoxyCodeLine{100     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{101     \}}
\DoxyCodeLine{102   \textcolor{keywordflow}{else}}
\DoxyCodeLine{103   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.n\_elem == 1)}
\DoxyCodeLine{104     \{}
\DoxyCodeLine{105     out.set\_size(1,1);}
\DoxyCodeLine{106     out[0] = std::log( std::complex<in\_T>( \mbox{\hyperlink{structA}{A}}[0] ) );}
\DoxyCodeLine{107     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{108     \}}
\DoxyCodeLine{109   }
\DoxyCodeLine{110   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_diagmat())}
\DoxyCodeLine{111     \{}
\DoxyCodeLine{112     \textcolor{keyword}{const} uword N = \mbox{\hyperlink{structA}{A}}.n\_rows;}
\DoxyCodeLine{113     }
\DoxyCodeLine{114     out.zeros(N,N);  \textcolor{comment}{// aliasing can't happen as op\_logmat is defined as cx\_mat = op(mat)}}
\DoxyCodeLine{115     }
\DoxyCodeLine{116     \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)}
\DoxyCodeLine{117       \{}
\DoxyCodeLine{118       \textcolor{keyword}{const} in\_T val = \mbox{\hyperlink{structA}{A}}.at(i,i);}
\DoxyCodeLine{119       }
\DoxyCodeLine{120       \textcolor{keywordflow}{if}(val >= in\_T(0))}
\DoxyCodeLine{121         \{}
\DoxyCodeLine{122         out.at(i,i) = std::log(val);}
\DoxyCodeLine{123         \}}
\DoxyCodeLine{124       \textcolor{keywordflow}{else}}
\DoxyCodeLine{125         \{}
\DoxyCodeLine{126         out.at(i,i) = std::log( out\_T(val) );}
\DoxyCodeLine{127         \}}
\DoxyCodeLine{128       \}}
\DoxyCodeLine{129     }
\DoxyCodeLine{130     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{131     \}}
\DoxyCodeLine{132   }
\DoxyCodeLine{133 \textcolor{preprocessor}{  \#if defined(ARMA\_OPTIMISE\_SYMPD)}}
\DoxyCodeLine{134     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} try\_sympd = sympd\_helper::guess\_sympd\_anysize(\mbox{\hyperlink{structA}{A}});}
\DoxyCodeLine{135 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{136     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} try\_sympd = \textcolor{keyword}{false};}
\DoxyCodeLine{137 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{138   }
\DoxyCodeLine{139   \textcolor{keywordflow}{if}(try\_sympd)}
\DoxyCodeLine{140     \{}
\DoxyCodeLine{141     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}op\_logmat: attempting sympd optimisation"{}});}
\DoxyCodeLine{142     }
\DoxyCodeLine{143     \textcolor{comment}{// if matrix A is sympd, all its eigenvalues are positive}}
\DoxyCodeLine{144     }
\DoxyCodeLine{145     \mbox{\hyperlink{classCol}{Col<in\_T>}} eigval;}
\DoxyCodeLine{146     \mbox{\hyperlink{classMat}{Mat<in\_T>}} eigvec;}
\DoxyCodeLine{147     }
\DoxyCodeLine{148     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} eig\_status = \mbox{\hyperlink{group__fn__eig__sym_gac55fe3206226539aa46643bc8ac9abe2}{eig\_sym\_helper}}(eigval, eigvec, \mbox{\hyperlink{structA}{A}}, \textcolor{charliteral}{'d'}, \textcolor{stringliteral}{"{}logmat()"{}});}
\DoxyCodeLine{149     }
\DoxyCodeLine{150     \textcolor{keywordflow}{if}(eig\_status)}
\DoxyCodeLine{151       \{}
\DoxyCodeLine{152       \textcolor{comment}{// ensure each eigenvalue is > 0}}
\DoxyCodeLine{153       }
\DoxyCodeLine{154       \textcolor{keyword}{const} uword N          = eigval.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}};}
\DoxyCodeLine{155       \textcolor{keyword}{const} in\_T* eigval\_mem = eigval.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{156       }
\DoxyCodeLine{157       \textcolor{keywordtype}{bool} all\_pos = \textcolor{keyword}{true};}
\DoxyCodeLine{158       }
\DoxyCodeLine{159       \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)  \{ all\_pos = (eigval\_mem[i] <= in\_T(0)) ? \textcolor{keyword}{false} : all\_pos; \}}
\DoxyCodeLine{160       }
\DoxyCodeLine{161       \textcolor{keywordflow}{if}(all\_pos)}
\DoxyCodeLine{162         \{}
\DoxyCodeLine{163         eigval = log(eigval);}
\DoxyCodeLine{164         }
\DoxyCodeLine{165         out = \mbox{\hyperlink{classconv__to}{conv\_to< Mat<out\_T>}} >::from( eigvec * \mbox{\hyperlink{group__fn__diagmat_ga8bb70dfa94511eb84368ef6107dd030e}{diagmat}}(eigval) * eigvec.t() );}
\DoxyCodeLine{166         }
\DoxyCodeLine{167         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{168         \}}
\DoxyCodeLine{169       \}}
\DoxyCodeLine{170     }
\DoxyCodeLine{171     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}op\_logmat: sympd optimisation failed"{}});}
\DoxyCodeLine{172     }
\DoxyCodeLine{173     \textcolor{comment}{// fallthrough if eigen decomposition failed or an eigenvalue is zero}}
\DoxyCodeLine{174     \}}
\DoxyCodeLine{175   }
\DoxyCodeLine{176   }
\DoxyCodeLine{177   \mbox{\hyperlink{classMat}{Mat<out\_T>}} S(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());}
\DoxyCodeLine{178   }
\DoxyCodeLine{179   \textcolor{keyword}{const}  in\_T* Amem = \mbox{\hyperlink{structA}{A}}.memptr();}
\DoxyCodeLine{180         out\_T* Smem = S.memptr();}
\DoxyCodeLine{181   }
\DoxyCodeLine{182   \textcolor{keyword}{const} uword n\_elem = \mbox{\hyperlink{structA}{A}}.n\_elem;}
\DoxyCodeLine{183   }
\DoxyCodeLine{184   \textcolor{keywordflow}{for}(uword i=0; i<n\_elem; ++i)}
\DoxyCodeLine{185     \{}
\DoxyCodeLine{186     Smem[i] = std::complex<in\_T>( Amem[i] );}
\DoxyCodeLine{187     \}}
\DoxyCodeLine{188   }
\DoxyCodeLine{189   \textcolor{keywordflow}{return} op\_logmat\_cx::apply\_common(out, S, n\_iters);}
\DoxyCodeLine{190   \}}
\DoxyCodeLine{191 }
\DoxyCodeLine{192 }
\DoxyCodeLine{193 }
\DoxyCodeLine{194 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{195 \textcolor{keyword}{inline}}
\DoxyCodeLine{196 \textcolor{keywordtype}{void}}
\DoxyCodeLine{197 op\_logmat\_cx::apply(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T1,op\_logmat\_cx>}}\& in)}
\DoxyCodeLine{198   \{}
\DoxyCodeLine{199   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{200   }
\DoxyCodeLine{201   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} status = op\_logmat\_cx::apply\_direct(out, in.\mbox{\hyperlink{classOp_af7ab7221b6e233cdd38b9f9b69f301ce}{m}}, in.\mbox{\hyperlink{classOp_a197cb9330fe0d72c976d6223514c4bd6}{aux\_uword\_a}});}
\DoxyCodeLine{202   }
\DoxyCodeLine{203   \textcolor{keywordflow}{if}(status == \textcolor{keyword}{false})}
\DoxyCodeLine{204     \{}
\DoxyCodeLine{205     out.soft\_reset();}
\DoxyCodeLine{206     arma\_stop\_runtime\_error(\textcolor{stringliteral}{"{}logmat(): transformation failed"{}});}
\DoxyCodeLine{207     \}}
\DoxyCodeLine{208   \}}
\DoxyCodeLine{209 }
\DoxyCodeLine{210 }
\DoxyCodeLine{211 }
\DoxyCodeLine{212 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{213 \textcolor{keyword}{inline}}
\DoxyCodeLine{214 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{215 op\_logmat\_cx::apply\_direct(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T1,op\_diagmat>}}\& expr, \textcolor{keyword}{const} uword)}
\DoxyCodeLine{216   \{}
\DoxyCodeLine{217   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{218   }
\DoxyCodeLine{219   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{220   }
\DoxyCodeLine{221   \textcolor{keyword}{const} \mbox{\hyperlink{classdiagmat__proxy}{diagmat\_proxy<T1>}} P(expr.\mbox{\hyperlink{classOp_af7ab7221b6e233cdd38b9f9b69f301ce}{m}});}
\DoxyCodeLine{222   }
\DoxyCodeLine{223   \textcolor{keywordtype}{bool} status = \textcolor{keyword}{false};}
\DoxyCodeLine{224   }
\DoxyCodeLine{225   \textcolor{keywordflow}{if}(P.is\_alias(out))}
\DoxyCodeLine{226     \{}
\DoxyCodeLine{227     \mbox{\hyperlink{classMat}{Mat<eT>}} tmp;}
\DoxyCodeLine{228     }
\DoxyCodeLine{229     status = op\_logmat\_cx::apply\_direct\_noalias(tmp, P);}
\DoxyCodeLine{230     }
\DoxyCodeLine{231     out.\mbox{\hyperlink{group__Mat_gaff06a75771f96605f7cc4f8c6b3fceb7}{steal\_mem}}(tmp);}
\DoxyCodeLine{232     \}}
\DoxyCodeLine{233   \textcolor{keywordflow}{else}}
\DoxyCodeLine{234     \{}
\DoxyCodeLine{235     status = op\_logmat\_cx::apply\_direct\_noalias(out, P);}
\DoxyCodeLine{236     \}}
\DoxyCodeLine{237   }
\DoxyCodeLine{238   \textcolor{keywordflow}{return} status;}
\DoxyCodeLine{239   \}}
\DoxyCodeLine{240 }
\DoxyCodeLine{241 }
\DoxyCodeLine{242 }
\DoxyCodeLine{243 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{244 \textcolor{keyword}{inline}}
\DoxyCodeLine{245 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{246 op\_logmat\_cx::apply\_direct\_noalias(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classdiagmat__proxy}{diagmat\_proxy<T1>}}\& P)}
\DoxyCodeLine{247   \{}
\DoxyCodeLine{248   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{249   }
\DoxyCodeLine{250   arma\_debug\_check( (P.n\_rows != P.n\_cols), \textcolor{stringliteral}{"{}logmat(): given matrix must be square sized"{}} );}
\DoxyCodeLine{251   }
\DoxyCodeLine{252   \textcolor{keyword}{const} uword N = P.n\_rows;}
\DoxyCodeLine{253   }
\DoxyCodeLine{254   out.zeros(N,N);}
\DoxyCodeLine{255   }
\DoxyCodeLine{256   \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)}
\DoxyCodeLine{257     \{}
\DoxyCodeLine{258     out.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,i) = std::log(P[i]);}
\DoxyCodeLine{259     \}}
\DoxyCodeLine{260   }
\DoxyCodeLine{261   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{262   \}}
\DoxyCodeLine{263 }
\DoxyCodeLine{264 }
\DoxyCodeLine{265 }
\DoxyCodeLine{266 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{267 \textcolor{keyword}{inline}}
\DoxyCodeLine{268 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{269 op\_logmat\_cx::apply\_direct(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::elem\_type,T1>}}\& expr, \textcolor{keyword}{const} uword n\_iters)}
\DoxyCodeLine{270   \{}
\DoxyCodeLine{271   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{272   }
\DoxyCodeLine{273   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type   T;}
\DoxyCodeLine{274   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{275   }
\DoxyCodeLine{276   \mbox{\hyperlink{classMat}{Mat<eT>}} S = expr.get\_ref();}
\DoxyCodeLine{277   }
\DoxyCodeLine{278   arma\_debug\_check( (S.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}} != S.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}}), \textcolor{stringliteral}{"{}logmat(): given matrix must be square sized"{}} );}
\DoxyCodeLine{279   }
\DoxyCodeLine{280   \textcolor{keywordflow}{if}(S.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}} == 0)}
\DoxyCodeLine{281     \{}
\DoxyCodeLine{282     out.reset();}
\DoxyCodeLine{283     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{284     \}}
\DoxyCodeLine{285   \textcolor{keywordflow}{else}}
\DoxyCodeLine{286   \textcolor{keywordflow}{if}(S.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}} == 1)}
\DoxyCodeLine{287     \{}
\DoxyCodeLine{288     out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(1,1);}
\DoxyCodeLine{289     out[0] = std::log(S[0]);}
\DoxyCodeLine{290     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{291     \}}
\DoxyCodeLine{292   }
\DoxyCodeLine{293   \textcolor{keywordflow}{if}(S.is\_diagmat())}
\DoxyCodeLine{294     \{}
\DoxyCodeLine{295     \textcolor{keyword}{const} uword N = S.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}};}
\DoxyCodeLine{296     }
\DoxyCodeLine{297     out.zeros(N,N);  \textcolor{comment}{// aliasing can't happen as S is generated}}
\DoxyCodeLine{298     }
\DoxyCodeLine{299     \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)  \{ out.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,i) = std::log( S.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(i,i) ); \}}
\DoxyCodeLine{300     }
\DoxyCodeLine{301     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{302     \}}
\DoxyCodeLine{303   }
\DoxyCodeLine{304 \textcolor{preprocessor}{  \#if defined(ARMA\_OPTIMISE\_SYMPD)}}
\DoxyCodeLine{305     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} try\_sympd = sympd\_helper::guess\_sympd\_anysize(S);}
\DoxyCodeLine{306 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{307     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} try\_sympd = \textcolor{keyword}{false};}
\DoxyCodeLine{308 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{309   }
\DoxyCodeLine{310   \textcolor{keywordflow}{if}(try\_sympd)}
\DoxyCodeLine{311     \{}
\DoxyCodeLine{312     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}op\_logmat\_cx: attempting sympd optimisation"{}});}
\DoxyCodeLine{313     }
\DoxyCodeLine{314     \textcolor{comment}{// if matrix S is sympd, all its eigenvalues are positive}}
\DoxyCodeLine{315     }
\DoxyCodeLine{316     \mbox{\hyperlink{classCol}{Col< T>}} eigval;}
\DoxyCodeLine{317     \mbox{\hyperlink{classMat}{Mat<eT>}} eigvec;}
\DoxyCodeLine{318     }
\DoxyCodeLine{319     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} eig\_status = \mbox{\hyperlink{group__fn__eig__sym_gac55fe3206226539aa46643bc8ac9abe2}{eig\_sym\_helper}}(eigval, eigvec, S, \textcolor{charliteral}{'d'}, \textcolor{stringliteral}{"{}logmat()"{}});}
\DoxyCodeLine{320     }
\DoxyCodeLine{321     \textcolor{keywordflow}{if}(eig\_status)}
\DoxyCodeLine{322       \{}
\DoxyCodeLine{323       \textcolor{comment}{// ensure each eigenvalue is > 0}}
\DoxyCodeLine{324       }
\DoxyCodeLine{325       \textcolor{keyword}{const} uword N          = eigval.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}};}
\DoxyCodeLine{326       \textcolor{keyword}{const} T*    eigval\_mem = eigval.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{327       }
\DoxyCodeLine{328       \textcolor{keywordtype}{bool} all\_pos = \textcolor{keyword}{true};}
\DoxyCodeLine{329       }
\DoxyCodeLine{330       \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)  \{ all\_pos = (eigval\_mem[i] <= T(0)) ? \textcolor{keyword}{false} : all\_pos; \}}
\DoxyCodeLine{331       }
\DoxyCodeLine{332       \textcolor{keywordflow}{if}(all\_pos)}
\DoxyCodeLine{333         \{}
\DoxyCodeLine{334         eigval = log(eigval);}
\DoxyCodeLine{335         }
\DoxyCodeLine{336         out = eigvec * \mbox{\hyperlink{group__fn__diagmat_ga8bb70dfa94511eb84368ef6107dd030e}{diagmat}}(eigval) * eigvec.t();}
\DoxyCodeLine{337         }
\DoxyCodeLine{338         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{339         \}}
\DoxyCodeLine{340       \}}
\DoxyCodeLine{341     }
\DoxyCodeLine{342     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}op\_logmat\_cx: sympd optimisation failed"{}});}
\DoxyCodeLine{343     }
\DoxyCodeLine{344     \textcolor{comment}{// fallthrough if eigen decomposition failed or an eigenvalue is zero}}
\DoxyCodeLine{345     \}}
\DoxyCodeLine{346   }
\DoxyCodeLine{347   \textcolor{keywordflow}{return} op\_logmat\_cx::apply\_common(out, S, n\_iters);}
\DoxyCodeLine{348   \}}
\DoxyCodeLine{349 }
\DoxyCodeLine{350 }
\DoxyCodeLine{351 }
\DoxyCodeLine{352 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{353 \textcolor{keyword}{inline}}
\DoxyCodeLine{354 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{355 op\_logmat\_cx::apply\_common(\mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& out, \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& S, \textcolor{keyword}{const} uword n\_iters)}
\DoxyCodeLine{356   \{}
\DoxyCodeLine{357   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{358   }
\DoxyCodeLine{359   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<T> eT;}
\DoxyCodeLine{360   }
\DoxyCodeLine{361   \mbox{\hyperlink{classMat}{Mat<eT>}} U;}
\DoxyCodeLine{362   }
\DoxyCodeLine{363   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} schur\_ok = auxlib::schur(U,S);}
\DoxyCodeLine{364   }
\DoxyCodeLine{365   \textcolor{keywordflow}{if}(schur\_ok == \textcolor{keyword}{false})  \{ arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}logmat(): schur decomposition failed"{}}); \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{366   }
\DoxyCodeLine{367 \textcolor{comment}{//double theta[] = \{ 1.10e-\/5, 1.82e-\/3, 1.62e-\/2,               5.39e-\/2,               1.14e-\/1,               1.87e-\/1,               2.64e-\/1              \};}}
\DoxyCodeLine{368   \textcolor{keywordtype}{double} theta[] = \{ 0.0,     0.0,     1.6206284795015624e-\/2, 5.3873532631381171e-\/2, 1.1352802267628681e-\/1, 1.8662860613541288e-\/1, 2.642960831111435e-\/1 \};}
\DoxyCodeLine{369   \textcolor{comment}{// theta[0] and theta[1] not really used}}
\DoxyCodeLine{370   }
\DoxyCodeLine{371   \textcolor{keyword}{const} uword N = S.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}};}
\DoxyCodeLine{372   }
\DoxyCodeLine{373   uword p = 0;}
\DoxyCodeLine{374   uword m = 6;}
\DoxyCodeLine{375   }
\DoxyCodeLine{376   uword iter = 0;}
\DoxyCodeLine{377   }
\DoxyCodeLine{378   \textcolor{keywordflow}{while}(iter < n\_iters)}
\DoxyCodeLine{379     \{}
\DoxyCodeLine{380     \textcolor{keyword}{const} T tau = norm( (S -\/ eye< \mbox{\hyperlink{classMat}{Mat<eT>}} >(N,N)), 1 );}
\DoxyCodeLine{381     }
\DoxyCodeLine{382     \textcolor{keywordflow}{if}(tau <= theta[6])}
\DoxyCodeLine{383       \{}
\DoxyCodeLine{384       p++;}
\DoxyCodeLine{385       }
\DoxyCodeLine{386       uword j1 = 0;}
\DoxyCodeLine{387       uword j2 = 0;}
\DoxyCodeLine{388       }
\DoxyCodeLine{389       \textcolor{keywordflow}{for}(uword i=2; i<=6; ++i)  \{ \textcolor{keywordflow}{if}( tau      <= theta[i])  \{ j1 = i; \textcolor{keywordflow}{break}; \} \}}
\DoxyCodeLine{390       \textcolor{keywordflow}{for}(uword i=2; i<=6; ++i)  \{ \textcolor{keywordflow}{if}((tau/2.0) <= theta[i])  \{ j2 = i; \textcolor{keywordflow}{break}; \} \}}
\DoxyCodeLine{391       }
\DoxyCodeLine{392       \textcolor{comment}{// sanity check, for development purposes only}}
\DoxyCodeLine{393       arma\_debug\_check( (j2 > j1), \textcolor{stringliteral}{"{}internal error: op\_logmat::apply\_direct(): j2 > j1"{}} );}
\DoxyCodeLine{394       }
\DoxyCodeLine{395       \textcolor{keywordflow}{if}( ((j1 -\/ j2) <= 1) || (p == 2) )  \{ m = j1; \textcolor{keywordflow}{break}; \}}
\DoxyCodeLine{396       \}}
\DoxyCodeLine{397     }
\DoxyCodeLine{398     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} sqrtmat\_ok = op\_sqrtmat\_cx::apply\_direct(S,S);}
\DoxyCodeLine{399     }
\DoxyCodeLine{400     \textcolor{keywordflow}{if}(sqrtmat\_ok == \textcolor{keyword}{false})  \{ arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}logmat(): sqrtmat() failed"{}}); \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{401     }
\DoxyCodeLine{402     iter++;}
\DoxyCodeLine{403     \}}
\DoxyCodeLine{404   }
\DoxyCodeLine{405   \textcolor{keywordflow}{if}(iter >= n\_iters)  \{ arma\_debug\_warn\_level(2, \textcolor{stringliteral}{"{}logmat(): reached max iterations without full convergence"{}}); \}}
\DoxyCodeLine{406   }
\DoxyCodeLine{407   S.\mbox{\hyperlink{group__Mat_ga8ab6c07980e1d4c1d90eb3eb7850a2a4}{diag}}() -\/= eT(1);}
\DoxyCodeLine{408   }
\DoxyCodeLine{409   \textcolor{keywordflow}{if}(m >= 1)}
\DoxyCodeLine{410     \{}
\DoxyCodeLine{411     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} helper\_ok = op\_logmat\_cx::helper(S,m);}
\DoxyCodeLine{412     }
\DoxyCodeLine{413     \textcolor{keywordflow}{if}(helper\_ok == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{414     \}}
\DoxyCodeLine{415   }
\DoxyCodeLine{416   out = U * S * U.t();}
\DoxyCodeLine{417   }
\DoxyCodeLine{418   out *= eT(eop\_aux::pow(\textcolor{keywordtype}{double}(2), \textcolor{keywordtype}{double}(iter)));}
\DoxyCodeLine{419   }
\DoxyCodeLine{420   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{421   \}}
\DoxyCodeLine{422 }
\DoxyCodeLine{423 }
\DoxyCodeLine{424 }
\DoxyCodeLine{425 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{426 \textcolor{keyword}{inline}}
\DoxyCodeLine{427 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{428 op\_logmat\_cx::helper(\mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} uword m)}
\DoxyCodeLine{429   \{}
\DoxyCodeLine{430   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{431   }
\DoxyCodeLine{432   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_finite() == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{433   }
\DoxyCodeLine{434   \textcolor{keyword}{const} \mbox{\hyperlink{classCol}{vec}} indices = regspace<vec>(1,m-\/1);}
\DoxyCodeLine{435   }
\DoxyCodeLine{436   \mbox{\hyperlink{classMat}{mat}} tmp(m, m, \mbox{\hyperlink{structarma__zeros__indicator}{arma\_zeros\_indicator}}());}
\DoxyCodeLine{437   }
\DoxyCodeLine{438   tmp.diag(-\/1) = indices / sqrt(square(2.0*indices) -\/ 1.0);}
\DoxyCodeLine{439   tmp.diag(+1) = indices / sqrt(square(2.0*indices) -\/ 1.0);}
\DoxyCodeLine{440   }
\DoxyCodeLine{441   \mbox{\hyperlink{classCol}{vec}} eigval;}
\DoxyCodeLine{442   \mbox{\hyperlink{classMat}{mat}} eigvec;}
\DoxyCodeLine{443   }
\DoxyCodeLine{444   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} eig\_ok = \mbox{\hyperlink{group__fn__eig__sym_gac55fe3206226539aa46643bc8ac9abe2}{eig\_sym\_helper}}(eigval, eigvec, tmp, \textcolor{charliteral}{'d'}, \textcolor{stringliteral}{"{}logmat()"{}});}
\DoxyCodeLine{445   }
\DoxyCodeLine{446   \textcolor{keywordflow}{if}(eig\_ok == \textcolor{keyword}{false})  \{ arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}logmat(): eig\_sym() failed"{}}); \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{447   }
\DoxyCodeLine{448   \textcolor{keyword}{const} \mbox{\hyperlink{classCol}{vec}} nodes   = (eigval + 1.0) / 2.0;}
\DoxyCodeLine{449   \textcolor{keyword}{const} \mbox{\hyperlink{classCol}{vec}} weights = square(eigvec.\mbox{\hyperlink{group__Mat_ga2f654dd9a790e8fd6b07b026adbc0bd7}{row}}(0).t());}
\DoxyCodeLine{450   }
\DoxyCodeLine{451   \textcolor{keyword}{const} uword N = \mbox{\hyperlink{structA}{A}}.n\_rows;}
\DoxyCodeLine{452   }
\DoxyCodeLine{453   \mbox{\hyperlink{classMat}{Mat<eT>}} \mbox{\hyperlink{structB}{B}}(N, N, \mbox{\hyperlink{structarma__zeros__indicator}{arma\_zeros\_indicator}}());}
\DoxyCodeLine{454   }
\DoxyCodeLine{455   \mbox{\hyperlink{classMat}{Mat<eT>}} X;}
\DoxyCodeLine{456   }
\DoxyCodeLine{457   \textcolor{keywordflow}{for}(uword i=0; i < m; ++i)}
\DoxyCodeLine{458     \{}
\DoxyCodeLine{459     \textcolor{comment}{// B += weights(i) * solve( (nodes(i)*A + eye< Mat<eT> >(N,N)), A );}}
\DoxyCodeLine{460     }
\DoxyCodeLine{461     \textcolor{comment}{//const bool solve\_ok = solve( X, (nodes(i)*A + eye< Mat<eT> >(N,N)), A, solve\_opts::fast );}}
\DoxyCodeLine{462     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} solve\_ok = solve( X, trimatu(nodes(i)*\mbox{\hyperlink{structA}{A}} + eye< \mbox{\hyperlink{classMat}{Mat<eT>}} >(N,N)), \mbox{\hyperlink{structA}{A}}, solve\_opts::no\_approx );}
\DoxyCodeLine{463     }
\DoxyCodeLine{464     \textcolor{keywordflow}{if}(solve\_ok == \textcolor{keyword}{false})  \{ arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}logmat(): solve() failed"{}}); \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{465     }
\DoxyCodeLine{466     \mbox{\hyperlink{structB}{B}} += weights(i) * X;}
\DoxyCodeLine{467     \}}
\DoxyCodeLine{468   }
\DoxyCodeLine{469   \mbox{\hyperlink{structA}{A}} = \mbox{\hyperlink{structB}{B}};}
\DoxyCodeLine{470   }
\DoxyCodeLine{471   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{472   \}}
\DoxyCodeLine{473 }
\DoxyCodeLine{474 }
\DoxyCodeLine{475 }
\DoxyCodeLine{476 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{477 \textcolor{keyword}{inline}}
\DoxyCodeLine{478 \textcolor{keywordtype}{void}}
\DoxyCodeLine{479 op\_logmat\_sympd::apply(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classOp}{Op<T1,op\_logmat\_sympd>}}\& in)}
\DoxyCodeLine{480   \{}
\DoxyCodeLine{481   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{482   }
\DoxyCodeLine{483   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} status = op\_logmat\_sympd::apply\_direct(out, in.\mbox{\hyperlink{classOp_af7ab7221b6e233cdd38b9f9b69f301ce}{m}});}
\DoxyCodeLine{484   }
\DoxyCodeLine{485   \textcolor{keywordflow}{if}(status == \textcolor{keyword}{false})}
\DoxyCodeLine{486     \{}
\DoxyCodeLine{487     out.soft\_reset();}
\DoxyCodeLine{488     arma\_stop\_runtime\_error(\textcolor{stringliteral}{"{}logmat\_sympd(): transformation failed"{}});}
\DoxyCodeLine{489     \}}
\DoxyCodeLine{490   \}}
\DoxyCodeLine{491 }
\DoxyCodeLine{492 }
\DoxyCodeLine{493 }
\DoxyCodeLine{494 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{495 \textcolor{keyword}{inline}}
\DoxyCodeLine{496 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{497 op\_logmat\_sympd::apply\_direct(\mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{structBase}{Base<typename T1::elem\_type,T1>}}\& expr)}
\DoxyCodeLine{498   \{}
\DoxyCodeLine{499   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{500   }
\DoxyCodeLine{501 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_LAPACK)}}
\DoxyCodeLine{502     \{}
\DoxyCodeLine{503     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type   T;}
\DoxyCodeLine{504     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{505     }
\DoxyCodeLine{506     \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap}{unwrap<T1>}}   U(expr.get\_ref());}
\DoxyCodeLine{507     \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& X = U.M;}
\DoxyCodeLine{508     }
\DoxyCodeLine{509     arma\_debug\_check( (X.is\_square() == \textcolor{keyword}{false}), \textcolor{stringliteral}{"{}logmat\_sympd(): given matrix must be square sized"{}} );}
\DoxyCodeLine{510     }
\DoxyCodeLine{511     \mbox{\hyperlink{classCol}{Col< T>}} eigval;}
\DoxyCodeLine{512     \mbox{\hyperlink{classMat}{Mat<eT>}} eigvec;}
\DoxyCodeLine{513     }
\DoxyCodeLine{514     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} status = \mbox{\hyperlink{group__fn__eig__sym_gac55fe3206226539aa46643bc8ac9abe2}{eig\_sym\_helper}}(eigval, eigvec, X, \textcolor{charliteral}{'d'}, \textcolor{stringliteral}{"{}logmat\_sympd()"{}});}
\DoxyCodeLine{515     }
\DoxyCodeLine{516     \textcolor{keywordflow}{if}(status == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{517     }
\DoxyCodeLine{518     \textcolor{keyword}{const} uword N          = eigval.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}};}
\DoxyCodeLine{519     \textcolor{keyword}{const} T*    eigval\_mem = eigval.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{520     }
\DoxyCodeLine{521     \textcolor{keywordtype}{bool} all\_pos = \textcolor{keyword}{true};}
\DoxyCodeLine{522     }
\DoxyCodeLine{523     \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)  \{ all\_pos = (eigval\_mem[i] <= T(0)) ? \textcolor{keyword}{false} : all\_pos; \}}
\DoxyCodeLine{524     }
\DoxyCodeLine{525     \textcolor{keywordflow}{if}(all\_pos == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{526     }
\DoxyCodeLine{527     eigval = log(eigval);}
\DoxyCodeLine{528     }
\DoxyCodeLine{529     out = eigvec * \mbox{\hyperlink{group__fn__diagmat_ga8bb70dfa94511eb84368ef6107dd030e}{diagmat}}(eigval) * eigvec.t();}
\DoxyCodeLine{530     }
\DoxyCodeLine{531     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{532     \}}
\DoxyCodeLine{533 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{534     \{}
\DoxyCodeLine{535     arma\_ignore(out);}
\DoxyCodeLine{536     arma\_ignore(expr);}
\DoxyCodeLine{537     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}logmat\_sympd(): use of LAPACK must be enabled"{}});}
\DoxyCodeLine{538     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{539     \}}
\DoxyCodeLine{540 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{541   \}}
\DoxyCodeLine{542 }
\DoxyCodeLine{543 }
\DoxyCodeLine{544 }

\end{DoxyCode}
