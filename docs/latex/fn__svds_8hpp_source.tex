\hypertarget{fn__svds_8hpp_source}{}\doxysection{fn\+\_\+svds.\+hpp}
\label{fn__svds_8hpp_source}\index{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/fn\_svds.hpp@{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/fn\_svds.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008-\/2016 Conrad Sanderson (http://conradsanderson.id.au)}}
\DoxyCodeLine{2 \textcolor{comment}{// Copyright 2008-\/2016 National ICT Australia (NICTA)}}
\DoxyCodeLine{3 \textcolor{comment}{// }}
\DoxyCodeLine{4 \textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{5 \textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{6 \textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{7 \textcolor{comment}{// http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{8 \textcolor{comment}{// }}
\DoxyCodeLine{9 \textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{10 \textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{11 \textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{12 \textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{13 \textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{14 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{19 }
\DoxyCodeLine{20 }
\DoxyCodeLine{21 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{22 \textcolor{keyword}{inline}}
\DoxyCodeLine{23 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{24 svds\_helper}
\DoxyCodeLine{25   (}
\DoxyCodeLine{26            \mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\&    U,}
\DoxyCodeLine{27            \mbox{\hyperlink{classCol}{Col<typename T1::pod\_type >}}\&    S,}
\DoxyCodeLine{28            \mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\&    V,}
\DoxyCodeLine{29   \textcolor{keyword}{const} \mbox{\hyperlink{structSpBase}{SpBase<typename T1::elem\_type,T1>}}\& X,}
\DoxyCodeLine{30   \textcolor{keyword}{const} uword                              k,}
\DoxyCodeLine{31   \textcolor{keyword}{const} \textcolor{keyword}{typename} T1::pod\_type              tol,}
\DoxyCodeLine{32   \textcolor{keyword}{const} \textcolor{keywordtype}{bool}                               calc\_UV,}
\DoxyCodeLine{33   \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__real__only}{arma\_real\_only<typename T1::elem\_type>::result}}* junk = \textcolor{keyword}{nullptr}}
\DoxyCodeLine{34   )}
\DoxyCodeLine{35   \{}
\DoxyCodeLine{36   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{37   arma\_ignore(junk);}
\DoxyCodeLine{38   }
\DoxyCodeLine{39   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{40   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type   T;}
\DoxyCodeLine{41   }
\DoxyCodeLine{42   arma\_debug\_check}
\DoxyCodeLine{43     (}
\DoxyCodeLine{44     ( ((\textcolor{keywordtype}{void}*)(\&U) == (\textcolor{keywordtype}{void}*)(\&S)) || (\&U == \&V) || ((\textcolor{keywordtype}{void}*)(\&S) == (\textcolor{keywordtype}{void}*)(\&V)) ),}
\DoxyCodeLine{45     \textcolor{stringliteral}{"{}svds(): two or more output objects are the same object"{}}}
\DoxyCodeLine{46     );}
\DoxyCodeLine{47   }
\DoxyCodeLine{48   arma\_debug\_check( (tol < T(0)), \textcolor{stringliteral}{"{}svds(): tol must be >= 0"{}} );}
\DoxyCodeLine{49   }
\DoxyCodeLine{50   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap__spmat}{unwrap\_spmat<T1>}} tmp(X.get\_ref());}
\DoxyCodeLine{51   \textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& \mbox{\hyperlink{structA}{A}} =   tmp.M;}
\DoxyCodeLine{52   }
\DoxyCodeLine{53   \textcolor{keyword}{const} uword kk = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})( (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_cols), k );}
\DoxyCodeLine{54   }
\DoxyCodeLine{55   \textcolor{keyword}{const} T A\_max = (\mbox{\hyperlink{structA}{A}}.n\_nonzero > 0) ? T(\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{max}}(abs(\mbox{\hyperlink{classCol}{Col<eT>}}(\textcolor{keyword}{const\_cast<}eT*\textcolor{keyword}{>}(\mbox{\hyperlink{structA}{A}}.values), \mbox{\hyperlink{structA}{A}}.n\_nonzero, \textcolor{keyword}{false})))) : T(0);}
\DoxyCodeLine{56   }
\DoxyCodeLine{57   \textcolor{keywordflow}{if}(A\_max == T(0))}
\DoxyCodeLine{58     \{}
\DoxyCodeLine{59     \textcolor{comment}{// TODO: use reset instead ?}}
\DoxyCodeLine{60     S.zeros(kk);}
\DoxyCodeLine{61     }
\DoxyCodeLine{62     \textcolor{keywordflow}{if}(calc\_UV)}
\DoxyCodeLine{63       \{}
\DoxyCodeLine{64       U.eye(\mbox{\hyperlink{structA}{A}}.n\_rows, kk);}
\DoxyCodeLine{65       V.eye(\mbox{\hyperlink{structA}{A}}.n\_cols, kk);}
\DoxyCodeLine{66       \}}
\DoxyCodeLine{67     \}}
\DoxyCodeLine{68   \textcolor{keywordflow}{else}}
\DoxyCodeLine{69     \{}
\DoxyCodeLine{70     \mbox{\hyperlink{classSpMat}{SpMat<eT>}} C( (\mbox{\hyperlink{structA}{A}}.n\_rows + \mbox{\hyperlink{structA}{A}}.n\_cols), (\mbox{\hyperlink{structA}{A}}.n\_rows + \mbox{\hyperlink{structA}{A}}.n\_cols) );}
\DoxyCodeLine{71     }
\DoxyCodeLine{72     \mbox{\hyperlink{classSpMat}{SpMat<eT>}} \mbox{\hyperlink{structB}{B}}  = \mbox{\hyperlink{structA}{A}} / A\_max;}
\DoxyCodeLine{73     \mbox{\hyperlink{classSpMat}{SpMat<eT>}} Bt = \mbox{\hyperlink{structB}{B}}.t();}
\DoxyCodeLine{74     }
\DoxyCodeLine{75     C(0, \mbox{\hyperlink{structA}{A}}.n\_rows, arma::size(\mbox{\hyperlink{structB}{B}}) ) = \mbox{\hyperlink{structB}{B}};}
\DoxyCodeLine{76     C(\mbox{\hyperlink{structA}{A}}.n\_rows, 0, arma::size(Bt)) = Bt;}
\DoxyCodeLine{77     }
\DoxyCodeLine{78     Bt.reset();}
\DoxyCodeLine{79     \mbox{\hyperlink{structB}{B}}.reset();}
\DoxyCodeLine{80     }
\DoxyCodeLine{81     \mbox{\hyperlink{classCol}{Col<eT>}} eigval;}
\DoxyCodeLine{82     \mbox{\hyperlink{classMat}{Mat<eT>}} eigvec;}
\DoxyCodeLine{83     }
\DoxyCodeLine{84     \mbox{\hyperlink{structeigs__opts}{eigs\_opts}} opts;}
\DoxyCodeLine{85     opts.tol = (tol / \mbox{\hyperlink{classDatum}{Datum<T>::sqrt2}});}
\DoxyCodeLine{86     }
\DoxyCodeLine{87     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} status = \mbox{\hyperlink{group__fn__eigs__sym_ga405f5c456c5060fec9c6bc9298cba29a}{eigs\_sym}}(eigval, eigvec, C, kk, \textcolor{stringliteral}{"{}la"{}}, opts);}
\DoxyCodeLine{88     }
\DoxyCodeLine{89     \textcolor{keywordflow}{if}(status == \textcolor{keyword}{false})}
\DoxyCodeLine{90       \{}
\DoxyCodeLine{91       U.soft\_reset();}
\DoxyCodeLine{92       S.soft\_reset();}
\DoxyCodeLine{93       V.soft\_reset();}
\DoxyCodeLine{94       }
\DoxyCodeLine{95       \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{96       \}}
\DoxyCodeLine{97     }
\DoxyCodeLine{98     \textcolor{keyword}{const} T A\_norm = \mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{max}}(eigval);}
\DoxyCodeLine{99     }
\DoxyCodeLine{100     \textcolor{keyword}{const} T tol2 = tol / \mbox{\hyperlink{classDatum}{Datum<T>::sqrt2}} * A\_norm;}
\DoxyCodeLine{101     }
\DoxyCodeLine{102     \mbox{\hyperlink{classCol}{uvec}} indices = find(eigval > tol2);}
\DoxyCodeLine{103     }
\DoxyCodeLine{104     \textcolor{keywordflow}{if}(indices.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}} > kk)}
\DoxyCodeLine{105       \{}
\DoxyCodeLine{106       indices = indices.subvec(0,kk-\/1);}
\DoxyCodeLine{107       \}}
\DoxyCodeLine{108     \textcolor{keywordflow}{else}}
\DoxyCodeLine{109     \textcolor{keywordflow}{if}(indices.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}} < kk)}
\DoxyCodeLine{110       \{}
\DoxyCodeLine{111       \textcolor{keyword}{const} \mbox{\hyperlink{classCol}{uvec}} indices2 = find(abs(eigval) <= tol2);}
\DoxyCodeLine{112       }
\DoxyCodeLine{113       \textcolor{keyword}{const} uword N\_extra = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})( indices2.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}}, (kk -\/ indices.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}}) );}
\DoxyCodeLine{114       }
\DoxyCodeLine{115       \textcolor{keywordflow}{if}(N\_extra > 0)  \{ indices = join\_cols(indices, indices2.subvec(0,N\_extra-\/1)); \}}
\DoxyCodeLine{116       \}}
\DoxyCodeLine{117     }
\DoxyCodeLine{118     \textcolor{keyword}{const} \mbox{\hyperlink{classCol}{uvec}} sorted\_indices = sort\_index(eigval, \textcolor{stringliteral}{"{}descend"{}});}
\DoxyCodeLine{119     }
\DoxyCodeLine{120     S = eigval.elem(sorted\_indices);  S *= A\_max;}
\DoxyCodeLine{121     }
\DoxyCodeLine{122     \textcolor{keywordflow}{if}(calc\_UV)}
\DoxyCodeLine{123       \{}
\DoxyCodeLine{124       \mbox{\hyperlink{classCol}{uvec}} U\_row\_indices(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());  \textcolor{keywordflow}{for}(uword i=0; i < \mbox{\hyperlink{structA}{A}}.n\_rows; ++i)  \{ U\_row\_indices[i] = i;            \}}
\DoxyCodeLine{125       \mbox{\hyperlink{classCol}{uvec}} V\_row\_indices(\mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());  \textcolor{keywordflow}{for}(uword i=0; i < \mbox{\hyperlink{structA}{A}}.n\_cols; ++i)  \{ V\_row\_indices[i] = i + \mbox{\hyperlink{structA}{A}}.n\_rows; \}}
\DoxyCodeLine{126       }
\DoxyCodeLine{127       U = \mbox{\hyperlink{classDatum}{Datum<T>::sqrt2}} * eigvec(U\_row\_indices, sorted\_indices);}
\DoxyCodeLine{128       V = \mbox{\hyperlink{classDatum}{Datum<T>::sqrt2}} * eigvec(V\_row\_indices, sorted\_indices);}
\DoxyCodeLine{129       \}}
\DoxyCodeLine{130     \}}
\DoxyCodeLine{131   }
\DoxyCodeLine{132   \textcolor{keywordflow}{if}(S.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}} < k)  \{ arma\_debug\_warn\_level(1, \textcolor{stringliteral}{"{}svds(): found fewer singular values than specified"{}}); \}}
\DoxyCodeLine{133   }
\DoxyCodeLine{134   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{135   \}}
\DoxyCodeLine{136 }
\DoxyCodeLine{137 }
\DoxyCodeLine{138 }
\DoxyCodeLine{139 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{140 \textcolor{keyword}{inline}}
\DoxyCodeLine{141 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{142 svds\_helper}
\DoxyCodeLine{143   (}
\DoxyCodeLine{144            \mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\&    U,}
\DoxyCodeLine{145            \mbox{\hyperlink{classCol}{Col<typename T1::pod\_type >}}\&    S,}
\DoxyCodeLine{146            \mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\&    V,}
\DoxyCodeLine{147   \textcolor{keyword}{const} \mbox{\hyperlink{structSpBase}{SpBase<typename T1::elem\_type,T1>}}\& X,}
\DoxyCodeLine{148   \textcolor{keyword}{const} uword                              k,}
\DoxyCodeLine{149   \textcolor{keyword}{const} \textcolor{keyword}{typename} T1::pod\_type              tol,}
\DoxyCodeLine{150   \textcolor{keyword}{const} \textcolor{keywordtype}{bool}                               calc\_UV,}
\DoxyCodeLine{151   \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__cx__only}{arma\_cx\_only<typename T1::elem\_type>::result}}* junk = \textcolor{keyword}{nullptr}}
\DoxyCodeLine{152   )}
\DoxyCodeLine{153   \{}
\DoxyCodeLine{154   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{155   arma\_ignore(junk);}
\DoxyCodeLine{156   }
\DoxyCodeLine{157   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{158   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::pod\_type   T;}
\DoxyCodeLine{159   }
\DoxyCodeLine{160   \textcolor{keywordflow}{if}(arma\_config::arpack == \textcolor{keyword}{false})}
\DoxyCodeLine{161     \{}
\DoxyCodeLine{162     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}svds(): use of ARPACK must be enabled for decomposition of complex matrices"{}});}
\DoxyCodeLine{163     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{164     \}}
\DoxyCodeLine{165   }
\DoxyCodeLine{166   arma\_debug\_check}
\DoxyCodeLine{167     (}
\DoxyCodeLine{168     ( ((\textcolor{keywordtype}{void}*)(\&U) == (\textcolor{keywordtype}{void}*)(\&S)) || (\&U == \&V) || ((\textcolor{keywordtype}{void}*)(\&S) == (\textcolor{keywordtype}{void}*)(\&V)) ),}
\DoxyCodeLine{169     \textcolor{stringliteral}{"{}svds(): two or more output objects are the same object"{}}}
\DoxyCodeLine{170     );}
\DoxyCodeLine{171   }
\DoxyCodeLine{172   arma\_debug\_check( (tol < T(0)), \textcolor{stringliteral}{"{}svds(): tol must be >= 0"{}} );}
\DoxyCodeLine{173   }
\DoxyCodeLine{174   \textcolor{keyword}{const} \mbox{\hyperlink{structunwrap__spmat}{unwrap\_spmat<T1>}} tmp(X.get\_ref());}
\DoxyCodeLine{175   \textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& \mbox{\hyperlink{structA}{A}} =   tmp.M;}
\DoxyCodeLine{176   }
\DoxyCodeLine{177   \textcolor{keyword}{const} uword kk = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})( (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_cols), k );}
\DoxyCodeLine{178   }
\DoxyCodeLine{179   \textcolor{keyword}{const} T A\_max = (\mbox{\hyperlink{structA}{A}}.n\_nonzero > 0) ? T(\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{max}}(abs(\mbox{\hyperlink{classCol}{Col<eT>}}(\textcolor{keyword}{const\_cast<}eT*\textcolor{keyword}{>}(\mbox{\hyperlink{structA}{A}}.values), \mbox{\hyperlink{structA}{A}}.n\_nonzero, \textcolor{keyword}{false})))) : T(0);}
\DoxyCodeLine{180   }
\DoxyCodeLine{181   \textcolor{keywordflow}{if}(A\_max == T(0))}
\DoxyCodeLine{182     \{}
\DoxyCodeLine{183     \textcolor{comment}{// TODO: use reset instead ?}}
\DoxyCodeLine{184     S.zeros(kk);}
\DoxyCodeLine{185     }
\DoxyCodeLine{186     \textcolor{keywordflow}{if}(calc\_UV)}
\DoxyCodeLine{187       \{}
\DoxyCodeLine{188       U.eye(\mbox{\hyperlink{structA}{A}}.n\_rows, kk);}
\DoxyCodeLine{189       V.eye(\mbox{\hyperlink{structA}{A}}.n\_cols, kk);}
\DoxyCodeLine{190       \}}
\DoxyCodeLine{191     \}}
\DoxyCodeLine{192   \textcolor{keywordflow}{else}}
\DoxyCodeLine{193     \{}
\DoxyCodeLine{194     \mbox{\hyperlink{classSpMat}{SpMat<eT>}} C( (\mbox{\hyperlink{structA}{A}}.n\_rows + \mbox{\hyperlink{structA}{A}}.n\_cols), (\mbox{\hyperlink{structA}{A}}.n\_rows + \mbox{\hyperlink{structA}{A}}.n\_cols) );}
\DoxyCodeLine{195     }
\DoxyCodeLine{196     \mbox{\hyperlink{classSpMat}{SpMat<eT>}} \mbox{\hyperlink{structB}{B}}  = \mbox{\hyperlink{structA}{A}} / A\_max;}
\DoxyCodeLine{197     \mbox{\hyperlink{classSpMat}{SpMat<eT>}} Bt = \mbox{\hyperlink{structB}{B}}.t();}
\DoxyCodeLine{198     }
\DoxyCodeLine{199     C(0, \mbox{\hyperlink{structA}{A}}.n\_rows, arma::size(\mbox{\hyperlink{structB}{B}}) ) = \mbox{\hyperlink{structB}{B}};}
\DoxyCodeLine{200     C(\mbox{\hyperlink{structA}{A}}.n\_rows, 0, arma::size(Bt)) = Bt;}
\DoxyCodeLine{201     }
\DoxyCodeLine{202     Bt.reset();}
\DoxyCodeLine{203     \mbox{\hyperlink{structB}{B}}.reset();}
\DoxyCodeLine{204     }
\DoxyCodeLine{205     \mbox{\hyperlink{classCol}{Col<eT>}} eigval\_tmp;}
\DoxyCodeLine{206     \mbox{\hyperlink{classMat}{Mat<eT>}} eigvec;}
\DoxyCodeLine{207     }
\DoxyCodeLine{208     \mbox{\hyperlink{structeigs__opts}{eigs\_opts}} opts;}
\DoxyCodeLine{209     opts.tol = (tol / \mbox{\hyperlink{classDatum}{Datum<T>::sqrt2}});}
\DoxyCodeLine{210     }
\DoxyCodeLine{211     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} status = \mbox{\hyperlink{group__fn__eigs__gen_ga94f118aacabd28f5227877627f2edb64}{eigs\_gen}}(eigval\_tmp, eigvec, C, kk, \textcolor{stringliteral}{"{}lr"{}}, opts);}
\DoxyCodeLine{212     }
\DoxyCodeLine{213     \textcolor{keywordflow}{if}(status == \textcolor{keyword}{false})}
\DoxyCodeLine{214       \{}
\DoxyCodeLine{215       U.soft\_reset();}
\DoxyCodeLine{216       S.soft\_reset();}
\DoxyCodeLine{217       V.soft\_reset();}
\DoxyCodeLine{218       }
\DoxyCodeLine{219       \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{220       \}}
\DoxyCodeLine{221     }
\DoxyCodeLine{222     \textcolor{keyword}{const} \mbox{\hyperlink{classCol}{Col<T>}} eigval = real(eigval\_tmp);}
\DoxyCodeLine{223     }
\DoxyCodeLine{224     \textcolor{keyword}{const} T A\_norm = \mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{max}}(eigval);}
\DoxyCodeLine{225     }
\DoxyCodeLine{226     \textcolor{keyword}{const} T tol2 = tol / \mbox{\hyperlink{classDatum}{Datum<T>::sqrt2}} * A\_norm;}
\DoxyCodeLine{227     }
\DoxyCodeLine{228     \mbox{\hyperlink{classCol}{uvec}} indices = find(eigval > tol2);}
\DoxyCodeLine{229     }
\DoxyCodeLine{230     \textcolor{keywordflow}{if}(indices.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}} > kk)}
\DoxyCodeLine{231       \{}
\DoxyCodeLine{232       indices = indices.subvec(0,kk-\/1);}
\DoxyCodeLine{233       \}}
\DoxyCodeLine{234     \textcolor{keywordflow}{else}}
\DoxyCodeLine{235     \textcolor{keywordflow}{if}(indices.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}} < kk)}
\DoxyCodeLine{236       \{}
\DoxyCodeLine{237       \textcolor{keyword}{const} \mbox{\hyperlink{classCol}{uvec}} indices2 = find(abs(eigval) <= tol2);}
\DoxyCodeLine{238       }
\DoxyCodeLine{239       \textcolor{keyword}{const} uword N\_extra = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})( indices2.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}}, (kk -\/ indices.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}}) );}
\DoxyCodeLine{240       }
\DoxyCodeLine{241       \textcolor{keywordflow}{if}(N\_extra > 0)  \{ indices = join\_cols(indices, indices2.subvec(0,N\_extra-\/1)); \}}
\DoxyCodeLine{242       \}}
\DoxyCodeLine{243     }
\DoxyCodeLine{244     \textcolor{keyword}{const} \mbox{\hyperlink{classCol}{uvec}} sorted\_indices = sort\_index(eigval, \textcolor{stringliteral}{"{}descend"{}});}
\DoxyCodeLine{245     }
\DoxyCodeLine{246     S = eigval.elem(sorted\_indices);  S *= A\_max;}
\DoxyCodeLine{247     }
\DoxyCodeLine{248     \textcolor{keywordflow}{if}(calc\_UV)}
\DoxyCodeLine{249       \{}
\DoxyCodeLine{250       \mbox{\hyperlink{classCol}{uvec}} U\_row\_indices(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());  \textcolor{keywordflow}{for}(uword i=0; i < \mbox{\hyperlink{structA}{A}}.n\_rows; ++i)  \{ U\_row\_indices[i] = i;            \}}
\DoxyCodeLine{251       \mbox{\hyperlink{classCol}{uvec}} V\_row\_indices(\mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structarma__nozeros__indicator}{arma\_nozeros\_indicator}}());  \textcolor{keywordflow}{for}(uword i=0; i < \mbox{\hyperlink{structA}{A}}.n\_cols; ++i)  \{ V\_row\_indices[i] = i + \mbox{\hyperlink{structA}{A}}.n\_rows; \}}
\DoxyCodeLine{252       }
\DoxyCodeLine{253       U = \mbox{\hyperlink{classDatum}{Datum<T>::sqrt2}} * eigvec(U\_row\_indices, sorted\_indices);}
\DoxyCodeLine{254       V = \mbox{\hyperlink{classDatum}{Datum<T>::sqrt2}} * eigvec(V\_row\_indices, sorted\_indices);}
\DoxyCodeLine{255       \}}
\DoxyCodeLine{256     \}}
\DoxyCodeLine{257   }
\DoxyCodeLine{258   \textcolor{keywordflow}{if}(S.\mbox{\hyperlink{classMat_a89f0d40af94b6521edd06645a0d68fd4}{n\_elem}} < k)  \{ arma\_debug\_warn\_level(1, \textcolor{stringliteral}{"{}svds(): found fewer singular values than specified"{}}); \}}
\DoxyCodeLine{259   }
\DoxyCodeLine{260   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{261   \}}
\DoxyCodeLine{262 }
\DoxyCodeLine{263 }
\DoxyCodeLine{264 }
\DoxyCodeLine{266 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{267 \textcolor{keyword}{inline}}
\DoxyCodeLine{268 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{269 \mbox{\hyperlink{group__fn__svds_gaab9a129b57b35d5b47244c04103b04d1}{svds}}}
\DoxyCodeLine{270   (}
\DoxyCodeLine{271            \mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\&    U,}
\DoxyCodeLine{272            \mbox{\hyperlink{classCol}{Col<typename T1::pod\_type >}}\&    S,}
\DoxyCodeLine{273            \mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}}\&    V,}
\DoxyCodeLine{274   \textcolor{keyword}{const} \mbox{\hyperlink{structSpBase}{SpBase<typename T1::elem\_type,T1>}}\& X,}
\DoxyCodeLine{275   \textcolor{keyword}{const} uword                              k,}
\DoxyCodeLine{276   \textcolor{keyword}{const} \textcolor{keyword}{typename} T1::pod\_type              tol  = 0.0,}
\DoxyCodeLine{277   \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__real__or__cx__only}{arma\_real\_or\_cx\_only<typename T1::elem\_type>::result}}* junk = \textcolor{keyword}{nullptr}}
\DoxyCodeLine{278   )}
\DoxyCodeLine{279   \{}
\DoxyCodeLine{280   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{281   arma\_ignore(junk);}
\DoxyCodeLine{282   }
\DoxyCodeLine{283   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} status = svds\_helper(U, S, V, X.get\_ref(), k, tol, \textcolor{keyword}{true});}
\DoxyCodeLine{284   }
\DoxyCodeLine{285   \textcolor{keywordflow}{if}(status == \textcolor{keyword}{false})  \{ arma\_debug\_warn\_level(3, \textcolor{stringliteral}{"{}svds(): decomposition failed"{}}); \}}
\DoxyCodeLine{286 }
\DoxyCodeLine{287   \textcolor{keywordflow}{return} status;}
\DoxyCodeLine{288   \}}
\DoxyCodeLine{289 }
\DoxyCodeLine{290 }
\DoxyCodeLine{291 }
\DoxyCodeLine{293 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{294 \textcolor{keyword}{inline}}
\DoxyCodeLine{295 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{296 \mbox{\hyperlink{group__fn__svds_gaab9a129b57b35d5b47244c04103b04d1}{svds}}}
\DoxyCodeLine{297   (}
\DoxyCodeLine{298            \mbox{\hyperlink{classCol}{Col<typename T1::pod\_type >}}\&    S,}
\DoxyCodeLine{299   \textcolor{keyword}{const} \mbox{\hyperlink{structSpBase}{SpBase<typename T1::elem\_type,T1>}}\& X,}
\DoxyCodeLine{300   \textcolor{keyword}{const} uword                              k,}
\DoxyCodeLine{301   \textcolor{keyword}{const} \textcolor{keyword}{typename} T1::pod\_type              tol  = 0.0,}
\DoxyCodeLine{302   \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__real__or__cx__only}{arma\_real\_or\_cx\_only<typename T1::elem\_type>::result}}* junk = \textcolor{keyword}{nullptr}}
\DoxyCodeLine{303   )}
\DoxyCodeLine{304   \{}
\DoxyCodeLine{305   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{306   arma\_ignore(junk);}
\DoxyCodeLine{307   }
\DoxyCodeLine{308   \mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}} U;}
\DoxyCodeLine{309   \mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}} V;}
\DoxyCodeLine{310   }
\DoxyCodeLine{311   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} status = svds\_helper(U, S, V, X.get\_ref(), k, tol, \textcolor{keyword}{false});}
\DoxyCodeLine{312   }
\DoxyCodeLine{313   \textcolor{keywordflow}{if}(status == \textcolor{keyword}{false})  \{ arma\_debug\_warn\_level(3, \textcolor{stringliteral}{"{}svds(): decomposition failed"{}}); \}}
\DoxyCodeLine{314   }
\DoxyCodeLine{315   \textcolor{keywordflow}{return} status;}
\DoxyCodeLine{316   \}}
\DoxyCodeLine{317 }
\DoxyCodeLine{318 }
\DoxyCodeLine{319 }
\DoxyCodeLine{321 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{322 arma\_warn\_unused}
\DoxyCodeLine{323 \textcolor{keyword}{inline}}
\DoxyCodeLine{324 \mbox{\hyperlink{classCol}{Col<typename T1::pod\_type>}}}
\DoxyCodeLine{325 \mbox{\hyperlink{group__fn__svds_gaab9a129b57b35d5b47244c04103b04d1}{svds}}}
\DoxyCodeLine{326   (}
\DoxyCodeLine{327   \textcolor{keyword}{const} \mbox{\hyperlink{structSpBase}{SpBase<typename T1::elem\_type,T1>}}\& X,}
\DoxyCodeLine{328   \textcolor{keyword}{const} uword                              k,}
\DoxyCodeLine{329   \textcolor{keyword}{const} \textcolor{keyword}{typename} T1::pod\_type              tol  = 0.0,}
\DoxyCodeLine{330   \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structarma__real__or__cx__only}{arma\_real\_or\_cx\_only<typename T1::elem\_type>::result}}* junk = \textcolor{keyword}{nullptr}}
\DoxyCodeLine{331   )}
\DoxyCodeLine{332   \{}
\DoxyCodeLine{333   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{334   arma\_ignore(junk);}
\DoxyCodeLine{335   }
\DoxyCodeLine{336   \mbox{\hyperlink{classCol}{Col<typename T1::pod\_type>}}  S;}
\DoxyCodeLine{337 }
\DoxyCodeLine{338   \mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}} U;}
\DoxyCodeLine{339   \mbox{\hyperlink{classMat}{Mat<typename T1::elem\_type>}} V;}
\DoxyCodeLine{340   }
\DoxyCodeLine{341   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} status = svds\_helper(U, S, V, X.get\_ref(), k, tol, \textcolor{keyword}{false});}
\DoxyCodeLine{342   }
\DoxyCodeLine{343   \textcolor{keywordflow}{if}(status == \textcolor{keyword}{false})  \{ arma\_stop\_runtime\_error(\textcolor{stringliteral}{"{}svds(): decomposition failed"{}}); \}}
\DoxyCodeLine{344   }
\DoxyCodeLine{345   \textcolor{keywordflow}{return} S;}
\DoxyCodeLine{346   \}}
\DoxyCodeLine{347 }
\DoxyCodeLine{348 }
\DoxyCodeLine{349 }

\end{DoxyCode}
