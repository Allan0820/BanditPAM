\hypertarget{band__helper_8hpp_source}{}\doxysection{band\+\_\+helper.\+hpp}
\label{band__helper_8hpp_source}\index{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/band\_helper.hpp@{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/band\_helper.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008-\/2016 Conrad Sanderson (http://conradsanderson.id.au)}}
\DoxyCodeLine{2 \textcolor{comment}{// Copyright 2008-\/2016 National ICT Australia (NICTA)}}
\DoxyCodeLine{3 \textcolor{comment}{// }}
\DoxyCodeLine{4 \textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{5 \textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{6 \textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{7 \textcolor{comment}{// http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{8 \textcolor{comment}{// }}
\DoxyCodeLine{9 \textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{10 \textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{11 \textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{12 \textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{13 \textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{14 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{19 }
\DoxyCodeLine{20 }
\DoxyCodeLine{21 \textcolor{keyword}{namespace }band\_helper}
\DoxyCodeLine{22 \{}
\DoxyCodeLine{23 }
\DoxyCodeLine{24 }
\DoxyCodeLine{25 }
\DoxyCodeLine{26 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{27 \textcolor{keyword}{inline}}
\DoxyCodeLine{28 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{29 is\_band(uword\& out\_KL, uword\& out\_KU, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} uword N\_min)}
\DoxyCodeLine{30   \{}
\DoxyCodeLine{31   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{32   }
\DoxyCodeLine{33   \textcolor{comment}{// NOTE: assuming that A has a square size}}
\DoxyCodeLine{34   \textcolor{comment}{// NOTE: assuming that N\_min is >= 4}}
\DoxyCodeLine{35   }
\DoxyCodeLine{36   \textcolor{keyword}{const} uword N = \mbox{\hyperlink{structA}{A}}.n\_rows;}
\DoxyCodeLine{37   }
\DoxyCodeLine{38   \textcolor{keywordflow}{if}(N < N\_min)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{39   }
\DoxyCodeLine{40   \textcolor{comment}{// first, quickly check bottom-\/left and top-\/right corners}}
\DoxyCodeLine{41   }
\DoxyCodeLine{42   \textcolor{keyword}{const} eT eT\_zero = eT(0);}
\DoxyCodeLine{43   }
\DoxyCodeLine{44   \textcolor{keyword}{const} eT* A\_col0 = \mbox{\hyperlink{structA}{A}}.memptr();}
\DoxyCodeLine{45   \textcolor{keyword}{const} eT* A\_col1 = A\_col0 + N;}
\DoxyCodeLine{46   }
\DoxyCodeLine{47   \textcolor{keywordflow}{if}( (A\_col0[N-\/2] != eT\_zero) || (A\_col0[N-\/1] != eT\_zero) || (A\_col1[N-\/2] != eT\_zero) || (A\_col1[N-\/1] != eT\_zero) )  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{48   }
\DoxyCodeLine{49   \textcolor{keyword}{const} eT* A\_colNm2 = \mbox{\hyperlink{structA}{A}}.colptr(N-\/2);}
\DoxyCodeLine{50   \textcolor{keyword}{const} eT* A\_colNm1 = A\_colNm2 + N;}
\DoxyCodeLine{51   }
\DoxyCodeLine{52   \textcolor{keywordflow}{if}( (A\_colNm2[0] != eT\_zero) || (A\_colNm2[1] != eT\_zero) || (A\_colNm1[0] != eT\_zero) || (A\_colNm1[1] != eT\_zero) )  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{53   }
\DoxyCodeLine{54   \textcolor{comment}{// if we reached this point, go through the entire matrix to work out number of subdiagonals and superdiagonals}}
\DoxyCodeLine{55   }
\DoxyCodeLine{56   \textcolor{keyword}{const} uword n\_nonzero\_threshold = (N*N)/4;  \textcolor{comment}{// empirically determined}}
\DoxyCodeLine{57   }
\DoxyCodeLine{58   uword KL = 0;  \textcolor{comment}{// number of   subdiagonals}}
\DoxyCodeLine{59   uword KU = 0;  \textcolor{comment}{// number of superdiagonals}}
\DoxyCodeLine{60   }
\DoxyCodeLine{61   \textcolor{keyword}{const} eT* A\_colptr = \mbox{\hyperlink{structA}{A}}.memptr();}
\DoxyCodeLine{62   }
\DoxyCodeLine{63   \textcolor{keywordflow}{for}(uword col=0; col < N; ++col)}
\DoxyCodeLine{64     \{}
\DoxyCodeLine{65     uword first\_nonzero\_row = col;}
\DoxyCodeLine{66     uword  last\_nonzero\_row = col;}
\DoxyCodeLine{67     }
\DoxyCodeLine{68     \textcolor{keywordflow}{for}(uword row=0; row < col; ++row)}
\DoxyCodeLine{69       \{}
\DoxyCodeLine{70       \textcolor{keywordflow}{if}( A\_colptr[row] != eT\_zero )  \{ first\_nonzero\_row = row; \textcolor{keywordflow}{break}; \}}
\DoxyCodeLine{71       \}}
\DoxyCodeLine{72     }
\DoxyCodeLine{73     \textcolor{keywordflow}{for}(uword row=(col+1); row < N; ++row)}
\DoxyCodeLine{74       \{}
\DoxyCodeLine{75       last\_nonzero\_row = (A\_colptr[row] != eT\_zero) ? row : last\_nonzero\_row;}
\DoxyCodeLine{76       \}}
\DoxyCodeLine{77     }
\DoxyCodeLine{78     \textcolor{keyword}{const} uword L\_count = last\_nonzero\_row -\/ col;}
\DoxyCodeLine{79     \textcolor{keyword}{const} uword U\_count = col -\/ first\_nonzero\_row;}
\DoxyCodeLine{80     }
\DoxyCodeLine{81     \textcolor{keywordflow}{if}( (L\_count > KL) || (U\_count > KU) )}
\DoxyCodeLine{82       \{}
\DoxyCodeLine{83       KL = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(KL, L\_count);}
\DoxyCodeLine{84       KU = (\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::max}})(KU, U\_count);}
\DoxyCodeLine{85       }
\DoxyCodeLine{86       \textcolor{keyword}{const} uword n\_nonzero = N*(KL+KU+1) -\/ (KL*(KL+1) + KU*(KU+1))/2;}
\DoxyCodeLine{87       }
\DoxyCodeLine{88       \textcolor{comment}{// return as soon as we know that it's not worth analysing the matrix any further}}
\DoxyCodeLine{89       }
\DoxyCodeLine{90       \textcolor{keywordflow}{if}(n\_nonzero > n\_nonzero\_threshold)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{91       \}}
\DoxyCodeLine{92     }
\DoxyCodeLine{93     A\_colptr += N;}
\DoxyCodeLine{94     \}}
\DoxyCodeLine{95   }
\DoxyCodeLine{96   out\_KL = KL;}
\DoxyCodeLine{97   out\_KU = KU;}
\DoxyCodeLine{98   }
\DoxyCodeLine{99   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{100   \}}
\DoxyCodeLine{101 }
\DoxyCodeLine{102 }
\DoxyCodeLine{103 }
\DoxyCodeLine{104 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{105 \textcolor{keyword}{inline}}
\DoxyCodeLine{106 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{107 is\_band\_lower(uword\& out\_KD, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} uword N\_min)}
\DoxyCodeLine{108   \{}
\DoxyCodeLine{109   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{110   }
\DoxyCodeLine{111   \textcolor{comment}{// NOTE: assuming that A has a square size}}
\DoxyCodeLine{112   \textcolor{comment}{// NOTE: assuming that N\_min is >= 4}}
\DoxyCodeLine{113   }
\DoxyCodeLine{114   \textcolor{keyword}{const} uword N = \mbox{\hyperlink{structA}{A}}.n\_rows;}
\DoxyCodeLine{115   }
\DoxyCodeLine{116   \textcolor{keywordflow}{if}(N < N\_min)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{117   }
\DoxyCodeLine{118   \textcolor{comment}{// first, quickly check bottom-\/left corner}}
\DoxyCodeLine{119   }
\DoxyCodeLine{120   \textcolor{keyword}{const} eT eT\_zero = eT(0);}
\DoxyCodeLine{121   }
\DoxyCodeLine{122   \textcolor{keyword}{const} eT* A\_col0 = \mbox{\hyperlink{structA}{A}}.memptr();}
\DoxyCodeLine{123   \textcolor{keyword}{const} eT* A\_col1 = A\_col0 + N;}
\DoxyCodeLine{124   }
\DoxyCodeLine{125   \textcolor{keywordflow}{if}( (A\_col0[N-\/2] != eT\_zero) || (A\_col0[N-\/1] != eT\_zero) || (A\_col1[N-\/2] != eT\_zero) || (A\_col1[N-\/1] != eT\_zero) )  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{126   }
\DoxyCodeLine{127   \textcolor{comment}{// if we reached this point, go through the bottom triangle to work out number of subdiagonals}}
\DoxyCodeLine{128   }
\DoxyCodeLine{129   \textcolor{keyword}{const} uword n\_nonzero\_threshold = ( N*N -\/ (N*(N-\/1))/2 ) / 4;  \textcolor{comment}{// empirically determined}}
\DoxyCodeLine{130   }
\DoxyCodeLine{131   uword KL = 0;  \textcolor{comment}{// number of subdiagonals}}
\DoxyCodeLine{132   }
\DoxyCodeLine{133   \textcolor{keyword}{const} eT* A\_colptr = \mbox{\hyperlink{structA}{A}}.memptr();}
\DoxyCodeLine{134   }
\DoxyCodeLine{135   \textcolor{keywordflow}{for}(uword col=0; col < N; ++col)}
\DoxyCodeLine{136     \{}
\DoxyCodeLine{137     uword last\_nonzero\_row = col;}
\DoxyCodeLine{138     }
\DoxyCodeLine{139     \textcolor{keywordflow}{for}(uword row=(col+1); row < N; ++row)}
\DoxyCodeLine{140       \{}
\DoxyCodeLine{141       last\_nonzero\_row = (A\_colptr[row] != eT\_zero) ? row : last\_nonzero\_row;}
\DoxyCodeLine{142       \}}
\DoxyCodeLine{143     }
\DoxyCodeLine{144     \textcolor{keyword}{const} uword L\_count = last\_nonzero\_row -\/ col;}
\DoxyCodeLine{145     }
\DoxyCodeLine{146     \textcolor{keywordflow}{if}(L\_count > KL)}
\DoxyCodeLine{147       \{}
\DoxyCodeLine{148       KL = L\_count;}
\DoxyCodeLine{149       }
\DoxyCodeLine{150       \textcolor{keyword}{const} uword n\_nonzero = N*(KL+1) -\/ (KL*(KL+1))/2;}
\DoxyCodeLine{151       }
\DoxyCodeLine{152       \textcolor{comment}{// return as soon as we know that it's not worth analysing the matrix any further}}
\DoxyCodeLine{153       }
\DoxyCodeLine{154       \textcolor{keywordflow}{if}(n\_nonzero > n\_nonzero\_threshold)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{155       \}}
\DoxyCodeLine{156     }
\DoxyCodeLine{157     A\_colptr += N;}
\DoxyCodeLine{158     \}}
\DoxyCodeLine{159   }
\DoxyCodeLine{160   out\_KD = KL;}
\DoxyCodeLine{161   }
\DoxyCodeLine{162   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{163   \}}
\DoxyCodeLine{164 }
\DoxyCodeLine{165 }
\DoxyCodeLine{166 }
\DoxyCodeLine{167 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{168 \textcolor{keyword}{inline}}
\DoxyCodeLine{169 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{170 is\_band\_upper(uword\& out\_KD, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} uword N\_min)}
\DoxyCodeLine{171   \{}
\DoxyCodeLine{172   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{173   }
\DoxyCodeLine{174   \textcolor{comment}{// NOTE: assuming that A has a square size}}
\DoxyCodeLine{175   \textcolor{comment}{// NOTE: assuming that N\_min is >= 4}}
\DoxyCodeLine{176   }
\DoxyCodeLine{177   \textcolor{keyword}{const} uword N = \mbox{\hyperlink{structA}{A}}.n\_rows;}
\DoxyCodeLine{178   }
\DoxyCodeLine{179   \textcolor{keywordflow}{if}(N < N\_min)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{180   }
\DoxyCodeLine{181   \textcolor{comment}{// first, quickly check top-\/right corner}}
\DoxyCodeLine{182   }
\DoxyCodeLine{183   \textcolor{keyword}{const} eT eT\_zero = eT(0);}
\DoxyCodeLine{184   }
\DoxyCodeLine{185   \textcolor{keyword}{const} eT* A\_colNm2 = \mbox{\hyperlink{structA}{A}}.colptr(N-\/2);}
\DoxyCodeLine{186   \textcolor{keyword}{const} eT* A\_colNm1 = A\_colNm2 + N;}
\DoxyCodeLine{187   }
\DoxyCodeLine{188   \textcolor{keywordflow}{if}( (A\_colNm2[0] != eT\_zero) || (A\_colNm2[1] != eT\_zero) || (A\_colNm1[0] != eT\_zero) || (A\_colNm1[1] != eT\_zero) )  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{189   }
\DoxyCodeLine{190   \textcolor{comment}{// if we reached this point, go through the entire matrix to work out number of superdiagonals}}
\DoxyCodeLine{191   }
\DoxyCodeLine{192   \textcolor{keyword}{const} uword n\_nonzero\_threshold = ( N*N -\/ (N*(N-\/1))/2 ) / 4;  \textcolor{comment}{// empirically determined}}
\DoxyCodeLine{193   }
\DoxyCodeLine{194   uword KU = 0;  \textcolor{comment}{// number of superdiagonals}}
\DoxyCodeLine{195   }
\DoxyCodeLine{196   \textcolor{keyword}{const} eT* A\_colptr = \mbox{\hyperlink{structA}{A}}.memptr();}
\DoxyCodeLine{197   }
\DoxyCodeLine{198   \textcolor{keywordflow}{for}(uword col=0; col < N; ++col)}
\DoxyCodeLine{199     \{}
\DoxyCodeLine{200     uword first\_nonzero\_row = col;}
\DoxyCodeLine{201     }
\DoxyCodeLine{202     \textcolor{keywordflow}{for}(uword row=0; row < col; ++row)}
\DoxyCodeLine{203       \{}
\DoxyCodeLine{204       \textcolor{keywordflow}{if}( A\_colptr[row] != eT\_zero )  \{ first\_nonzero\_row = row; \textcolor{keywordflow}{break}; \}}
\DoxyCodeLine{205       \}}
\DoxyCodeLine{206     }
\DoxyCodeLine{207     \textcolor{keyword}{const} uword U\_count = col -\/ first\_nonzero\_row;}
\DoxyCodeLine{208     }
\DoxyCodeLine{209     \textcolor{keywordflow}{if}(U\_count > KU)}
\DoxyCodeLine{210       \{}
\DoxyCodeLine{211       KU = U\_count;}
\DoxyCodeLine{212       }
\DoxyCodeLine{213       \textcolor{keyword}{const} uword n\_nonzero = N*(KU+1) -\/ (KU*(KU+1))/2;}
\DoxyCodeLine{214       }
\DoxyCodeLine{215       \textcolor{comment}{// return as soon as we know that it's not worth analysing the matrix any further}}
\DoxyCodeLine{216       }
\DoxyCodeLine{217       \textcolor{keywordflow}{if}(n\_nonzero > n\_nonzero\_threshold)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{218       \}}
\DoxyCodeLine{219     }
\DoxyCodeLine{220     A\_colptr += N;}
\DoxyCodeLine{221     \}}
\DoxyCodeLine{222   }
\DoxyCodeLine{223   out\_KD = KU;}
\DoxyCodeLine{224   }
\DoxyCodeLine{225   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{226   \}}
\DoxyCodeLine{227 }
\DoxyCodeLine{228 }
\DoxyCodeLine{229 }
\DoxyCodeLine{230 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{231 \textcolor{keyword}{inline}}
\DoxyCodeLine{232 \textcolor{keywordtype}{void}}
\DoxyCodeLine{233 compress(\mbox{\hyperlink{classMat}{Mat<eT>}}\& AB, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} uword KL, \textcolor{keyword}{const} uword KU, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_offset)}
\DoxyCodeLine{234   \{}
\DoxyCodeLine{235   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{236   }
\DoxyCodeLine{237   \textcolor{comment}{// NOTE: assuming that A has a square size}}
\DoxyCodeLine{238   }
\DoxyCodeLine{239   \textcolor{comment}{// band matrix storage format}}
\DoxyCodeLine{240   \textcolor{comment}{// http://www.netlib.org/lapack/lug/node124.html  }}
\DoxyCodeLine{241   }
\DoxyCodeLine{242   \textcolor{comment}{// for ?gbsv,  matrix AB size: 2*KL+KU+1 x N; band representation of A stored in rows KL+1 to 2*KL+KU+1  (note: fortran counts from 1)}}
\DoxyCodeLine{243   \textcolor{comment}{// for ?gbsvx, matrix AB size:   KL+KU+1 x N; band representaiton of A stored in rows    1 to   KL+KU+1  (note: fortran counts from 1)}}
\DoxyCodeLine{244   \textcolor{comment}{//}}
\DoxyCodeLine{245   \textcolor{comment}{// the +1 in the above formulas is to take into account the main diagonal}}
\DoxyCodeLine{246   }
\DoxyCodeLine{247   \textcolor{keyword}{const} uword AB\_n\_rows = (use\_offset) ? uword(2*KL + KU + 1) : uword(KL + KU + 1);}
\DoxyCodeLine{248   \textcolor{keyword}{const} uword N         = \mbox{\hyperlink{structA}{A}}.n\_rows;}
\DoxyCodeLine{249   }
\DoxyCodeLine{250   AB.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(AB\_n\_rows, N);}
\DoxyCodeLine{251   }
\DoxyCodeLine{252   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.is\_empty())  \{ AB.zeros(); \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{253   }
\DoxyCodeLine{254   \textcolor{keywordflow}{if}(AB\_n\_rows == uword(1))}
\DoxyCodeLine{255     \{}
\DoxyCodeLine{256     eT* AB\_mem = AB.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{257     }
\DoxyCodeLine{258     \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)  \{ AB\_mem[i] = \mbox{\hyperlink{structA}{A}}.at(i,i); \}}
\DoxyCodeLine{259     \}}
\DoxyCodeLine{260   \textcolor{keywordflow}{else}}
\DoxyCodeLine{261     \{}
\DoxyCodeLine{262     AB.zeros();  \textcolor{comment}{// paranoia}}
\DoxyCodeLine{263     }
\DoxyCodeLine{264     \textcolor{keywordflow}{for}(uword j=0; j < N; ++j)}
\DoxyCodeLine{265       \{}
\DoxyCodeLine{266       \textcolor{keyword}{const} uword A\_row\_start = (j > KU) ? uword(j -\/ KU) : uword(0);}
\DoxyCodeLine{267       \textcolor{keyword}{const} uword A\_row\_endp1 = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(N, j+KL+1);}
\DoxyCodeLine{268       }
\DoxyCodeLine{269       \textcolor{keyword}{const} uword length = A\_row\_endp1 -\/ A\_row\_start;}
\DoxyCodeLine{270       }
\DoxyCodeLine{271       \textcolor{keyword}{const} uword AB\_row\_start = (KU > j) ? (KU -\/ j) : uword(0);}
\DoxyCodeLine{272       }
\DoxyCodeLine{273       \textcolor{keyword}{const} eT*  A\_colptr =  \mbox{\hyperlink{structA}{A}}.colptr(j) +  A\_row\_start;}
\DoxyCodeLine{274             eT* AB\_colptr = AB.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(j) + AB\_row\_start + ( (use\_offset) ? KL : uword(0) );}
\DoxyCodeLine{275       }
\DoxyCodeLine{276       arrayops::copy( AB\_colptr, A\_colptr, length );}
\DoxyCodeLine{277       \}}
\DoxyCodeLine{278     \}}
\DoxyCodeLine{279   \}}
\DoxyCodeLine{280 }
\DoxyCodeLine{281 }
\DoxyCodeLine{282 }
\DoxyCodeLine{283 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{284 \textcolor{keyword}{inline}}
\DoxyCodeLine{285 \textcolor{keywordtype}{void}}
\DoxyCodeLine{286 uncompress(\mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& AB, \textcolor{keyword}{const} uword KL, \textcolor{keyword}{const} uword KU, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_offset)}
\DoxyCodeLine{287   \{}
\DoxyCodeLine{288   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{289   }
\DoxyCodeLine{290   \textcolor{keyword}{const} uword AB\_n\_rows = AB.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}};}
\DoxyCodeLine{291   \textcolor{keyword}{const} uword N         = AB.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}};}
\DoxyCodeLine{292   }
\DoxyCodeLine{293   arma\_debug\_check( (AB\_n\_rows != ((use\_offset) ? uword(2*KL + KU + 1) : uword(KL + KU + 1))), \textcolor{stringliteral}{"{}band\_helper::uncompress(): detected inconsistency"{}} );}
\DoxyCodeLine{294   }
\DoxyCodeLine{295   \mbox{\hyperlink{structA}{A}}.zeros(N,N);  \textcolor{comment}{// assuming there is no aliasing between A and AB}}
\DoxyCodeLine{296   }
\DoxyCodeLine{297   \textcolor{keywordflow}{if}(AB\_n\_rows == uword(1))}
\DoxyCodeLine{298     \{}
\DoxyCodeLine{299     \textcolor{keyword}{const} eT* AB\_mem = AB.\mbox{\hyperlink{group__Mat_gad5b1b46a9288e04128aa11c99cc2b444}{memptr}}();}
\DoxyCodeLine{300     }
\DoxyCodeLine{301     \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)  \{ \mbox{\hyperlink{structA}{A}}.at(i,i) = AB\_mem[i]; \}}
\DoxyCodeLine{302     \}}
\DoxyCodeLine{303   \textcolor{keywordflow}{else}}
\DoxyCodeLine{304     \{}
\DoxyCodeLine{305     \textcolor{keywordflow}{for}(uword j=0; j < N; ++j)}
\DoxyCodeLine{306       \{}
\DoxyCodeLine{307       \textcolor{keyword}{const} uword A\_row\_start = (j > KU) ? uword(j -\/ KU) : uword(0);}
\DoxyCodeLine{308       \textcolor{keyword}{const} uword A\_row\_endp1 = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(N, j+KL+1);}
\DoxyCodeLine{309       }
\DoxyCodeLine{310       \textcolor{keyword}{const} uword length = A\_row\_endp1 -\/ A\_row\_start;}
\DoxyCodeLine{311       }
\DoxyCodeLine{312       \textcolor{keyword}{const} uword AB\_row\_start = (KU > j) ? (KU -\/ j) : uword(0);}
\DoxyCodeLine{313       }
\DoxyCodeLine{314       \textcolor{keyword}{const} eT* AB\_colptr = AB.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(j) + AB\_row\_start + ( (use\_offset) ? KL : uword(0) );}
\DoxyCodeLine{315             eT*  A\_colptr =  \mbox{\hyperlink{structA}{A}}.colptr(j) +  A\_row\_start;}
\DoxyCodeLine{316       }
\DoxyCodeLine{317       arrayops::copy( A\_colptr, AB\_colptr, length );}
\DoxyCodeLine{318       \}}
\DoxyCodeLine{319     \}}
\DoxyCodeLine{320   \}}
\DoxyCodeLine{321 }
\DoxyCodeLine{322 }
\DoxyCodeLine{323 }
\DoxyCodeLine{324 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{325 \textcolor{keyword}{inline}}
\DoxyCodeLine{326 \textcolor{keywordtype}{void}}
\DoxyCodeLine{327 extract\_tridiag(\mbox{\hyperlink{classMat}{Mat<eT>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structA}{A}})}
\DoxyCodeLine{328   \{}
\DoxyCodeLine{329   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{330   }
\DoxyCodeLine{331   \textcolor{comment}{// NOTE: assuming that A has a square size and is at least 2x2}}
\DoxyCodeLine{332   }
\DoxyCodeLine{333   \textcolor{keyword}{const} uword N = \mbox{\hyperlink{structA}{A}}.n\_rows;}
\DoxyCodeLine{334   }
\DoxyCodeLine{335   out.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(N, 3);  \textcolor{comment}{// assuming there is no aliasing between 'out' and 'A'}}
\DoxyCodeLine{336   }
\DoxyCodeLine{337   \textcolor{keywordflow}{if}(N < 2)  \{ \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{338   }
\DoxyCodeLine{339   eT* DL = out.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(0);}
\DoxyCodeLine{340   eT* DD = out.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(1);}
\DoxyCodeLine{341   eT* DU = out.\mbox{\hyperlink{group__Mat_gad6a294c2ed4726f7b4b95e750ddfeb7a}{colptr}}(2);}
\DoxyCodeLine{342   }
\DoxyCodeLine{343   DD[0] = \mbox{\hyperlink{structA}{A}}[0];}
\DoxyCodeLine{344   DL[0] = \mbox{\hyperlink{structA}{A}}[1];}
\DoxyCodeLine{345   }
\DoxyCodeLine{346   \textcolor{keyword}{const} uword Nm1 = N-\/1;}
\DoxyCodeLine{347   \textcolor{keyword}{const} uword Nm2 = N-\/2;}
\DoxyCodeLine{348   }
\DoxyCodeLine{349   \textcolor{keywordflow}{for}(uword i=0; i < Nm2; ++i)}
\DoxyCodeLine{350     \{}
\DoxyCodeLine{351     \textcolor{keyword}{const} uword ip1 = i+1;}
\DoxyCodeLine{352     }
\DoxyCodeLine{353     \textcolor{keyword}{const} eT* data = \&(\mbox{\hyperlink{structA}{A}}.at(i, ip1));}
\DoxyCodeLine{354     }
\DoxyCodeLine{355     \textcolor{keyword}{const} eT tmp0 = data[0];}
\DoxyCodeLine{356     \textcolor{keyword}{const} eT tmp1 = data[1];}
\DoxyCodeLine{357     \textcolor{keyword}{const} eT tmp2 = data[2];}
\DoxyCodeLine{358     }
\DoxyCodeLine{359     DL[ip1] = tmp2;}
\DoxyCodeLine{360     DD[ip1] = tmp1;}
\DoxyCodeLine{361     DU[i  ] = tmp0;}
\DoxyCodeLine{362     \}}
\DoxyCodeLine{363   }
\DoxyCodeLine{364   \textcolor{keyword}{const} eT* data = \&(\mbox{\hyperlink{structA}{A}}.at(Nm2, Nm1));}
\DoxyCodeLine{365   }
\DoxyCodeLine{366   DL[Nm1] = 0;}
\DoxyCodeLine{367   DU[Nm2] = data[0];}
\DoxyCodeLine{368   DU[Nm1] = 0;}
\DoxyCodeLine{369   DD[Nm1] = data[1]; }
\DoxyCodeLine{370   \}}
\DoxyCodeLine{371 }
\DoxyCodeLine{372 }
\DoxyCodeLine{373 }
\DoxyCodeLine{374 \}  \textcolor{comment}{// end of namespace band\_helper}}
\DoxyCodeLine{375 }
\DoxyCodeLine{376 }

\end{DoxyCode}
