\hypertarget{diskio__meat_8hpp_source}{}\doxysection{diskio\+\_\+meat.\+hpp}
\label{diskio__meat_8hpp_source}\index{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/diskio\_meat.hpp@{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/diskio\_meat.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008-\/2016 Conrad Sanderson (http://conradsanderson.id.au)}}
\DoxyCodeLine{2 \textcolor{comment}{// Copyright 2008-\/2016 National ICT Australia (NICTA)}}
\DoxyCodeLine{3 \textcolor{comment}{// }}
\DoxyCodeLine{4 \textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{5 \textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{6 \textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{7 \textcolor{comment}{// http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{8 \textcolor{comment}{// }}
\DoxyCodeLine{9 \textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{10 \textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{11 \textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{12 \textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{13 \textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{14 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{19 }
\DoxyCodeLine{20 }
\DoxyCodeLine{26 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{27 \textcolor{keyword}{inline}}
\DoxyCodeLine{28 arma\_cold}
\DoxyCodeLine{29 std::string}
\DoxyCodeLine{30 \mbox{\hyperlink{group__diskio_ga7adb78317f164fa19978566b3bf3f216}{diskio::gen\_txt\_header}}(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\&)}
\DoxyCodeLine{31   \{}
\DoxyCodeLine{32   arma\_type\_check(( \mbox{\hyperlink{structis__supported__elem__type}{is\_supported\_elem\_type<eT>::value}} == \textcolor{keyword}{false} ));}
\DoxyCodeLine{33   }
\DoxyCodeLine{34   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_MAT\_TXT\_IU001 = \textcolor{stringliteral}{"{}ARMA\_MAT\_TXT\_IU001"{}};}
\DoxyCodeLine{35   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_MAT\_TXT\_IS001 = \textcolor{stringliteral}{"{}ARMA\_MAT\_TXT\_IS001"{}};}
\DoxyCodeLine{36   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_MAT\_TXT\_IU002 = \textcolor{stringliteral}{"{}ARMA\_MAT\_TXT\_IU002"{}};}
\DoxyCodeLine{37   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_MAT\_TXT\_IS002 = \textcolor{stringliteral}{"{}ARMA\_MAT\_TXT\_IS002"{}};}
\DoxyCodeLine{38   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_MAT\_TXT\_IU004 = \textcolor{stringliteral}{"{}ARMA\_MAT\_TXT\_IU004"{}};}
\DoxyCodeLine{39   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_MAT\_TXT\_IS004 = \textcolor{stringliteral}{"{}ARMA\_MAT\_TXT\_IS004"{}};}
\DoxyCodeLine{40   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_MAT\_TXT\_IU008 = \textcolor{stringliteral}{"{}ARMA\_MAT\_TXT\_IU008"{}};}
\DoxyCodeLine{41   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_MAT\_TXT\_IS008 = \textcolor{stringliteral}{"{}ARMA\_MAT\_TXT\_IS008"{}};}
\DoxyCodeLine{42   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_MAT\_TXT\_FN004 = \textcolor{stringliteral}{"{}ARMA\_MAT\_TXT\_FN004"{}};}
\DoxyCodeLine{43   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_MAT\_TXT\_FN008 = \textcolor{stringliteral}{"{}ARMA\_MAT\_TXT\_FN008"{}};}
\DoxyCodeLine{44   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_MAT\_TXT\_FC008 = \textcolor{stringliteral}{"{}ARMA\_MAT\_TXT\_FC008"{}};}
\DoxyCodeLine{45   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_MAT\_TXT\_FC016 = \textcolor{stringliteral}{"{}ARMA\_MAT\_TXT\_FC016"{}};}
\DoxyCodeLine{46   }
\DoxyCodeLine{47   \textcolor{keywordtype}{char}* header = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{48   }
\DoxyCodeLine{49        \textcolor{keywordflow}{if}(       \mbox{\hyperlink{structis__u8}{is\_u8<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_MAT\_TXT\_IU001); \}}
\DoxyCodeLine{50   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(       \mbox{\hyperlink{structis__s8}{is\_s8<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_MAT\_TXT\_IS001); \}}
\DoxyCodeLine{51   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(      \mbox{\hyperlink{structis__u16}{is\_u16<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_MAT\_TXT\_IU002); \}}
\DoxyCodeLine{52   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(      \mbox{\hyperlink{structis__s16}{is\_s16<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_MAT\_TXT\_IS002); \}}
\DoxyCodeLine{53   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(      \mbox{\hyperlink{structis__u32}{is\_u32<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_MAT\_TXT\_IU004); \}}
\DoxyCodeLine{54   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(      \mbox{\hyperlink{structis__s32}{is\_s32<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_MAT\_TXT\_IS004); \}}
\DoxyCodeLine{55   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(      \mbox{\hyperlink{structis__u64}{is\_u64<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_MAT\_TXT\_IU008); \}}
\DoxyCodeLine{56   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(      \mbox{\hyperlink{structis__s64}{is\_s64<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_MAT\_TXT\_IS008); \}}
\DoxyCodeLine{57   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__ulng__t__32}{is\_ulng\_t\_32<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_MAT\_TXT\_IU004); \}}
\DoxyCodeLine{58   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__slng__t__32}{is\_slng\_t\_32<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_MAT\_TXT\_IS004); \}}
\DoxyCodeLine{59   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__ulng__t__64}{is\_ulng\_t\_64<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_MAT\_TXT\_IU008); \}}
\DoxyCodeLine{60   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__slng__t__64}{is\_slng\_t\_64<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_MAT\_TXT\_IS008); \}}
\DoxyCodeLine{61   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(    \mbox{\hyperlink{structis__float}{is\_float<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_MAT\_TXT\_FN004); \}}
\DoxyCodeLine{62   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(   \mbox{\hyperlink{structis__double}{is\_double<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_MAT\_TXT\_FN008); \}}
\DoxyCodeLine{63   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( \mbox{\hyperlink{structis__cx__float}{is\_cx\_float<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_MAT\_TXT\_FC008); \}}
\DoxyCodeLine{64   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__cx__double}{is\_cx\_double<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_MAT\_TXT\_FC016); \}}
\DoxyCodeLine{65   }
\DoxyCodeLine{66   \textcolor{keywordflow}{return} std::string(header);}
\DoxyCodeLine{67   \}}
\DoxyCodeLine{68 }
\DoxyCodeLine{69 }
\DoxyCodeLine{70 }
\DoxyCodeLine{76 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{77 \textcolor{keyword}{inline}}
\DoxyCodeLine{78 arma\_cold}
\DoxyCodeLine{79 std::string}
\DoxyCodeLine{80 \mbox{\hyperlink{group__diskio_ga143c823196ccbd640cf831526cd4933e}{diskio::gen\_bin\_header}}(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\&)}
\DoxyCodeLine{81   \{}
\DoxyCodeLine{82   arma\_type\_check(( \mbox{\hyperlink{structis__supported__elem__type}{is\_supported\_elem\_type<eT>::value}} == \textcolor{keyword}{false} ));}
\DoxyCodeLine{83   }
\DoxyCodeLine{84   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_MAT\_BIN\_IU001 = \textcolor{stringliteral}{"{}ARMA\_MAT\_BIN\_IU001"{}};}
\DoxyCodeLine{85   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_MAT\_BIN\_IS001 = \textcolor{stringliteral}{"{}ARMA\_MAT\_BIN\_IS001"{}};}
\DoxyCodeLine{86   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_MAT\_BIN\_IU002 = \textcolor{stringliteral}{"{}ARMA\_MAT\_BIN\_IU002"{}};}
\DoxyCodeLine{87   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_MAT\_BIN\_IS002 = \textcolor{stringliteral}{"{}ARMA\_MAT\_BIN\_IS002"{}};}
\DoxyCodeLine{88   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_MAT\_BIN\_IU004 = \textcolor{stringliteral}{"{}ARMA\_MAT\_BIN\_IU004"{}};}
\DoxyCodeLine{89   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_MAT\_BIN\_IS004 = \textcolor{stringliteral}{"{}ARMA\_MAT\_BIN\_IS004"{}};}
\DoxyCodeLine{90   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_MAT\_BIN\_IU008 = \textcolor{stringliteral}{"{}ARMA\_MAT\_BIN\_IU008"{}};}
\DoxyCodeLine{91   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_MAT\_BIN\_IS008 = \textcolor{stringliteral}{"{}ARMA\_MAT\_BIN\_IS008"{}};}
\DoxyCodeLine{92   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_MAT\_BIN\_FN004 = \textcolor{stringliteral}{"{}ARMA\_MAT\_BIN\_FN004"{}};}
\DoxyCodeLine{93   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_MAT\_BIN\_FN008 = \textcolor{stringliteral}{"{}ARMA\_MAT\_BIN\_FN008"{}};}
\DoxyCodeLine{94   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_MAT\_BIN\_FC008 = \textcolor{stringliteral}{"{}ARMA\_MAT\_BIN\_FC008"{}};}
\DoxyCodeLine{95   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_MAT\_BIN\_FC016 = \textcolor{stringliteral}{"{}ARMA\_MAT\_BIN\_FC016"{}};  }
\DoxyCodeLine{96   }
\DoxyCodeLine{97   \textcolor{keywordtype}{char}* header = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{98   }
\DoxyCodeLine{99        \textcolor{keywordflow}{if}(       \mbox{\hyperlink{structis__u8}{is\_u8<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_MAT\_BIN\_IU001); \}}
\DoxyCodeLine{100   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(       \mbox{\hyperlink{structis__s8}{is\_s8<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_MAT\_BIN\_IS001); \}}
\DoxyCodeLine{101   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(      \mbox{\hyperlink{structis__u16}{is\_u16<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_MAT\_BIN\_IU002); \}}
\DoxyCodeLine{102   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(      \mbox{\hyperlink{structis__s16}{is\_s16<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_MAT\_BIN\_IS002); \}}
\DoxyCodeLine{103   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(      \mbox{\hyperlink{structis__u32}{is\_u32<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_MAT\_BIN\_IU004); \}}
\DoxyCodeLine{104   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(      \mbox{\hyperlink{structis__s32}{is\_s32<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_MAT\_BIN\_IS004); \}}
\DoxyCodeLine{105   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(      \mbox{\hyperlink{structis__u64}{is\_u64<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_MAT\_BIN\_IU008); \}}
\DoxyCodeLine{106   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(      \mbox{\hyperlink{structis__s64}{is\_s64<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_MAT\_BIN\_IS008); \}}
\DoxyCodeLine{107   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__ulng__t__32}{is\_ulng\_t\_32<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_MAT\_BIN\_IU004); \}}
\DoxyCodeLine{108   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__slng__t__32}{is\_slng\_t\_32<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_MAT\_BIN\_IS004); \}}
\DoxyCodeLine{109   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__ulng__t__64}{is\_ulng\_t\_64<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_MAT\_BIN\_IU008); \}}
\DoxyCodeLine{110   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__slng__t__64}{is\_slng\_t\_64<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_MAT\_BIN\_IS008); \}}
\DoxyCodeLine{111   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(    \mbox{\hyperlink{structis__float}{is\_float<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_MAT\_BIN\_FN004); \}}
\DoxyCodeLine{112   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(   \mbox{\hyperlink{structis__double}{is\_double<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_MAT\_BIN\_FN008); \}}
\DoxyCodeLine{113   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( \mbox{\hyperlink{structis__cx__float}{is\_cx\_float<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_MAT\_BIN\_FC008); \}}
\DoxyCodeLine{114   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__cx__double}{is\_cx\_double<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_MAT\_BIN\_FC016); \}}
\DoxyCodeLine{115   }
\DoxyCodeLine{116   \textcolor{keywordflow}{return} std::string(header);}
\DoxyCodeLine{117   \}}
\DoxyCodeLine{118 }
\DoxyCodeLine{119 }
\DoxyCodeLine{120 }
\DoxyCodeLine{126 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{127 \textcolor{keyword}{inline}}
\DoxyCodeLine{128 arma\_cold}
\DoxyCodeLine{129 std::string}
\DoxyCodeLine{130 \mbox{\hyperlink{group__diskio_ga143c823196ccbd640cf831526cd4933e}{diskio::gen\_bin\_header}}(\textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}}\&)}
\DoxyCodeLine{131   \{}
\DoxyCodeLine{132   arma\_type\_check(( \mbox{\hyperlink{structis__supported__elem__type}{is\_supported\_elem\_type<eT>::value}} == \textcolor{keyword}{false} ));}
\DoxyCodeLine{133   }
\DoxyCodeLine{134   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_SPM\_BIN\_IU001 = \textcolor{stringliteral}{"{}ARMA\_SPM\_BIN\_IU001"{}};}
\DoxyCodeLine{135   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_SPM\_BIN\_IS001 = \textcolor{stringliteral}{"{}ARMA\_SPM\_BIN\_IS001"{}};}
\DoxyCodeLine{136   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_SPM\_BIN\_IU002 = \textcolor{stringliteral}{"{}ARMA\_SPM\_BIN\_IU002"{}};}
\DoxyCodeLine{137   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_SPM\_BIN\_IS002 = \textcolor{stringliteral}{"{}ARMA\_SPM\_BIN\_IS002"{}};}
\DoxyCodeLine{138   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_SPM\_BIN\_IU004 = \textcolor{stringliteral}{"{}ARMA\_SPM\_BIN\_IU004"{}};}
\DoxyCodeLine{139   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_SPM\_BIN\_IS004 = \textcolor{stringliteral}{"{}ARMA\_SPM\_BIN\_IS004"{}};}
\DoxyCodeLine{140   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_SPM\_BIN\_IU008 = \textcolor{stringliteral}{"{}ARMA\_SPM\_BIN\_IU008"{}};}
\DoxyCodeLine{141   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_SPM\_BIN\_IS008 = \textcolor{stringliteral}{"{}ARMA\_SPM\_BIN\_IS008"{}};}
\DoxyCodeLine{142   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_SPM\_BIN\_FN004 = \textcolor{stringliteral}{"{}ARMA\_SPM\_BIN\_FN004"{}};}
\DoxyCodeLine{143   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_SPM\_BIN\_FN008 = \textcolor{stringliteral}{"{}ARMA\_SPM\_BIN\_FN008"{}};}
\DoxyCodeLine{144   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_SPM\_BIN\_FC008 = \textcolor{stringliteral}{"{}ARMA\_SPM\_BIN\_FC008"{}};}
\DoxyCodeLine{145   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_SPM\_BIN\_FC016 = \textcolor{stringliteral}{"{}ARMA\_SPM\_BIN\_FC016"{}};  }
\DoxyCodeLine{146   }
\DoxyCodeLine{147   \textcolor{keywordtype}{char}* header = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{148   }
\DoxyCodeLine{149        \textcolor{keywordflow}{if}(       \mbox{\hyperlink{structis__u8}{is\_u8<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_SPM\_BIN\_IU001); \}}
\DoxyCodeLine{150   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(       \mbox{\hyperlink{structis__s8}{is\_s8<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_SPM\_BIN\_IS001); \}}
\DoxyCodeLine{151   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(      \mbox{\hyperlink{structis__u16}{is\_u16<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_SPM\_BIN\_IU002); \}}
\DoxyCodeLine{152   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(      \mbox{\hyperlink{structis__s16}{is\_s16<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_SPM\_BIN\_IS002); \}}
\DoxyCodeLine{153   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(      \mbox{\hyperlink{structis__u32}{is\_u32<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_SPM\_BIN\_IU004); \}}
\DoxyCodeLine{154   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(      \mbox{\hyperlink{structis__s32}{is\_s32<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_SPM\_BIN\_IS004); \}}
\DoxyCodeLine{155   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(      \mbox{\hyperlink{structis__u64}{is\_u64<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_SPM\_BIN\_IU008); \}}
\DoxyCodeLine{156   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(      \mbox{\hyperlink{structis__s64}{is\_s64<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_SPM\_BIN\_IS008); \}}
\DoxyCodeLine{157   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__ulng__t__32}{is\_ulng\_t\_32<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_SPM\_BIN\_IU004); \}}
\DoxyCodeLine{158   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__slng__t__32}{is\_slng\_t\_32<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_SPM\_BIN\_IS004); \}}
\DoxyCodeLine{159   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__ulng__t__64}{is\_ulng\_t\_64<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_SPM\_BIN\_IU008); \}}
\DoxyCodeLine{160   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__slng__t__64}{is\_slng\_t\_64<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_SPM\_BIN\_IS008); \}}
\DoxyCodeLine{161   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(    \mbox{\hyperlink{structis__float}{is\_float<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_SPM\_BIN\_FN004); \}}
\DoxyCodeLine{162   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(   \mbox{\hyperlink{structis__double}{is\_double<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_SPM\_BIN\_FN008); \}}
\DoxyCodeLine{163   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( \mbox{\hyperlink{structis__cx__float}{is\_cx\_float<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_SPM\_BIN\_FC008); \}}
\DoxyCodeLine{164   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__cx__double}{is\_cx\_double<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_SPM\_BIN\_FC016); \}}
\DoxyCodeLine{165   }
\DoxyCodeLine{166   \textcolor{keywordflow}{return} std::string(header);}
\DoxyCodeLine{167   \}}
\DoxyCodeLine{168 }
\DoxyCodeLine{169 }
\DoxyCodeLine{175 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{176 \textcolor{keyword}{inline}}
\DoxyCodeLine{177 arma\_cold}
\DoxyCodeLine{178 std::string}
\DoxyCodeLine{179 \mbox{\hyperlink{group__diskio_ga7adb78317f164fa19978566b3bf3f216}{diskio::gen\_txt\_header}}(\textcolor{keyword}{const} \mbox{\hyperlink{classCube}{Cube<eT>}}\&)}
\DoxyCodeLine{180   \{}
\DoxyCodeLine{181   arma\_type\_check(( \mbox{\hyperlink{structis__supported__elem__type}{is\_supported\_elem\_type<eT>::value}} == \textcolor{keyword}{false} ));}
\DoxyCodeLine{182 }
\DoxyCodeLine{183   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_CUB\_TXT\_IU001 = \textcolor{stringliteral}{"{}ARMA\_CUB\_TXT\_IU001"{}};}
\DoxyCodeLine{184   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_CUB\_TXT\_IS001 = \textcolor{stringliteral}{"{}ARMA\_CUB\_TXT\_IS001"{}};}
\DoxyCodeLine{185   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_CUB\_TXT\_IU002 = \textcolor{stringliteral}{"{}ARMA\_CUB\_TXT\_IU002"{}};}
\DoxyCodeLine{186   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_CUB\_TXT\_IS002 = \textcolor{stringliteral}{"{}ARMA\_CUB\_TXT\_IS002"{}};}
\DoxyCodeLine{187   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_CUB\_TXT\_IU004 = \textcolor{stringliteral}{"{}ARMA\_CUB\_TXT\_IU004"{}};}
\DoxyCodeLine{188   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_CUB\_TXT\_IS004 = \textcolor{stringliteral}{"{}ARMA\_CUB\_TXT\_IS004"{}};}
\DoxyCodeLine{189   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_CUB\_TXT\_IU008 = \textcolor{stringliteral}{"{}ARMA\_CUB\_TXT\_IU008"{}};}
\DoxyCodeLine{190   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_CUB\_TXT\_IS008 = \textcolor{stringliteral}{"{}ARMA\_CUB\_TXT\_IS008"{}};}
\DoxyCodeLine{191   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_CUB\_TXT\_FN004 = \textcolor{stringliteral}{"{}ARMA\_CUB\_TXT\_FN004"{}};}
\DoxyCodeLine{192   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_CUB\_TXT\_FN008 = \textcolor{stringliteral}{"{}ARMA\_CUB\_TXT\_FN008"{}};}
\DoxyCodeLine{193   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_CUB\_TXT\_FC008 = \textcolor{stringliteral}{"{}ARMA\_CUB\_TXT\_FC008"{}};}
\DoxyCodeLine{194   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_CUB\_TXT\_FC016 = \textcolor{stringliteral}{"{}ARMA\_CUB\_TXT\_FC016"{}};}
\DoxyCodeLine{195   }
\DoxyCodeLine{196   \textcolor{keywordtype}{char}* header = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{197   }
\DoxyCodeLine{198        \textcolor{keywordflow}{if}(       \mbox{\hyperlink{structis__u8}{is\_u8<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_CUB\_TXT\_IU001); \}}
\DoxyCodeLine{199   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(       \mbox{\hyperlink{structis__s8}{is\_s8<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_CUB\_TXT\_IS001); \}}
\DoxyCodeLine{200   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(      \mbox{\hyperlink{structis__u16}{is\_u16<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_CUB\_TXT\_IU002); \}}
\DoxyCodeLine{201   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(      \mbox{\hyperlink{structis__s16}{is\_s16<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_CUB\_TXT\_IS002); \}}
\DoxyCodeLine{202   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(      \mbox{\hyperlink{structis__u32}{is\_u32<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_CUB\_TXT\_IU004); \}}
\DoxyCodeLine{203   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(      \mbox{\hyperlink{structis__s32}{is\_s32<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_CUB\_TXT\_IS004); \}}
\DoxyCodeLine{204   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(      \mbox{\hyperlink{structis__u64}{is\_u64<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_CUB\_TXT\_IU008); \}}
\DoxyCodeLine{205   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(      \mbox{\hyperlink{structis__s64}{is\_s64<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_CUB\_TXT\_IS008); \}}
\DoxyCodeLine{206   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__ulng__t__32}{is\_ulng\_t\_32<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_CUB\_TXT\_IU004); \}}
\DoxyCodeLine{207   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__slng__t__32}{is\_slng\_t\_32<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_CUB\_TXT\_IS004); \}}
\DoxyCodeLine{208   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__ulng__t__64}{is\_ulng\_t\_64<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_CUB\_TXT\_IU008); \}}
\DoxyCodeLine{209   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__slng__t__64}{is\_slng\_t\_64<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_CUB\_TXT\_IS008); \}}
\DoxyCodeLine{210   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(    \mbox{\hyperlink{structis__float}{is\_float<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_CUB\_TXT\_FN004); \}}
\DoxyCodeLine{211   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(   \mbox{\hyperlink{structis__double}{is\_double<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_CUB\_TXT\_FN008); \}}
\DoxyCodeLine{212   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( \mbox{\hyperlink{structis__cx__float}{is\_cx\_float<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_CUB\_TXT\_FC008); \}}
\DoxyCodeLine{213   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__cx__double}{is\_cx\_double<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_CUB\_TXT\_FC016); \}}
\DoxyCodeLine{214   }
\DoxyCodeLine{215   \textcolor{keywordflow}{return} std::string(header);}
\DoxyCodeLine{216   \}}
\DoxyCodeLine{217 }
\DoxyCodeLine{218 }
\DoxyCodeLine{219 }
\DoxyCodeLine{225 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{226 \textcolor{keyword}{inline}}
\DoxyCodeLine{227 arma\_cold}
\DoxyCodeLine{228 std::string}
\DoxyCodeLine{229 \mbox{\hyperlink{group__diskio_ga143c823196ccbd640cf831526cd4933e}{diskio::gen\_bin\_header}}(\textcolor{keyword}{const} \mbox{\hyperlink{classCube}{Cube<eT>}}\&)}
\DoxyCodeLine{230   \{}
\DoxyCodeLine{231   arma\_type\_check(( \mbox{\hyperlink{structis__supported__elem__type}{is\_supported\_elem\_type<eT>::value}} == \textcolor{keyword}{false} ));}
\DoxyCodeLine{232   }
\DoxyCodeLine{233   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_CUB\_BIN\_IU001 = \textcolor{stringliteral}{"{}ARMA\_CUB\_BIN\_IU001"{}};}
\DoxyCodeLine{234   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_CUB\_BIN\_IS001 = \textcolor{stringliteral}{"{}ARMA\_CUB\_BIN\_IS001"{}};}
\DoxyCodeLine{235   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_CUB\_BIN\_IU002 = \textcolor{stringliteral}{"{}ARMA\_CUB\_BIN\_IU002"{}};}
\DoxyCodeLine{236   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_CUB\_BIN\_IS002 = \textcolor{stringliteral}{"{}ARMA\_CUB\_BIN\_IS002"{}};}
\DoxyCodeLine{237   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_CUB\_BIN\_IU004 = \textcolor{stringliteral}{"{}ARMA\_CUB\_BIN\_IU004"{}};}
\DoxyCodeLine{238   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_CUB\_BIN\_IS004 = \textcolor{stringliteral}{"{}ARMA\_CUB\_BIN\_IS004"{}};}
\DoxyCodeLine{239   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_CUB\_BIN\_IU008 = \textcolor{stringliteral}{"{}ARMA\_CUB\_BIN\_IU008"{}};}
\DoxyCodeLine{240   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_CUB\_BIN\_IS008 = \textcolor{stringliteral}{"{}ARMA\_CUB\_BIN\_IS008"{}};}
\DoxyCodeLine{241   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_CUB\_BIN\_FN004 = \textcolor{stringliteral}{"{}ARMA\_CUB\_BIN\_FN004"{}};}
\DoxyCodeLine{242   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_CUB\_BIN\_FN008 = \textcolor{stringliteral}{"{}ARMA\_CUB\_BIN\_FN008"{}};}
\DoxyCodeLine{243   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_CUB\_BIN\_FC008 = \textcolor{stringliteral}{"{}ARMA\_CUB\_BIN\_FC008"{}};}
\DoxyCodeLine{244   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_CUB\_BIN\_FC016 = \textcolor{stringliteral}{"{}ARMA\_CUB\_BIN\_FC016"{}};}
\DoxyCodeLine{245   }
\DoxyCodeLine{246   \textcolor{keywordtype}{char}* header = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{247   }
\DoxyCodeLine{248        \textcolor{keywordflow}{if}(       \mbox{\hyperlink{structis__u8}{is\_u8<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_CUB\_BIN\_IU001); \}}
\DoxyCodeLine{249   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(       \mbox{\hyperlink{structis__s8}{is\_s8<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_CUB\_BIN\_IS001); \}}
\DoxyCodeLine{250   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(      \mbox{\hyperlink{structis__u16}{is\_u16<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_CUB\_BIN\_IU002); \}}
\DoxyCodeLine{251   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(      \mbox{\hyperlink{structis__s16}{is\_s16<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_CUB\_BIN\_IS002); \}}
\DoxyCodeLine{252   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(      \mbox{\hyperlink{structis__u32}{is\_u32<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_CUB\_BIN\_IU004); \}}
\DoxyCodeLine{253   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(      \mbox{\hyperlink{structis__s32}{is\_s32<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_CUB\_BIN\_IS004); \}}
\DoxyCodeLine{254   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(      \mbox{\hyperlink{structis__u64}{is\_u64<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_CUB\_BIN\_IU008); \}}
\DoxyCodeLine{255   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(      \mbox{\hyperlink{structis__s64}{is\_s64<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_CUB\_BIN\_IS008); \}}
\DoxyCodeLine{256   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__ulng__t__32}{is\_ulng\_t\_32<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_CUB\_BIN\_IU004); \}}
\DoxyCodeLine{257   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__slng__t__32}{is\_slng\_t\_32<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_CUB\_BIN\_IS004); \}}
\DoxyCodeLine{258   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__ulng__t__64}{is\_ulng\_t\_64<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_CUB\_BIN\_IU008); \}}
\DoxyCodeLine{259   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__slng__t__64}{is\_slng\_t\_64<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_CUB\_BIN\_IS008); \}}
\DoxyCodeLine{260   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(    \mbox{\hyperlink{structis__float}{is\_float<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_CUB\_BIN\_FN004); \}}
\DoxyCodeLine{261   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(   \mbox{\hyperlink{structis__double}{is\_double<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_CUB\_BIN\_FN008); \}}
\DoxyCodeLine{262   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( \mbox{\hyperlink{structis__cx__float}{is\_cx\_float<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_CUB\_BIN\_FC008); \}}
\DoxyCodeLine{263   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__cx__double}{is\_cx\_double<eT>::value}})  \{ header = \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(ARMA\_CUB\_BIN\_FC016); \}}
\DoxyCodeLine{264   }
\DoxyCodeLine{265   \textcolor{keywordflow}{return} std::string(header);}
\DoxyCodeLine{266   \}}
\DoxyCodeLine{267 }
\DoxyCodeLine{268 }
\DoxyCodeLine{269 }
\DoxyCodeLine{270 \textcolor{keyword}{inline}}
\DoxyCodeLine{271 arma\_deprecated}
\DoxyCodeLine{272 \mbox{\hyperlink{group__diskio_ga0de594dadb1bc493ecc618520a2d260e}{file\_type}}}
\DoxyCodeLine{273 diskio::guess\_file\_type(std::istream\& f)}
\DoxyCodeLine{274   \{}
\DoxyCodeLine{275   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{276   }
\DoxyCodeLine{277   \textcolor{keywordflow}{return} diskio::guess\_file\_type\_internal(f);}
\DoxyCodeLine{278   \}}
\DoxyCodeLine{279 }
\DoxyCodeLine{280 }
\DoxyCodeLine{281 }
\DoxyCodeLine{282 \textcolor{keyword}{inline}}
\DoxyCodeLine{283 arma\_cold}
\DoxyCodeLine{284 \mbox{\hyperlink{group__diskio_ga0de594dadb1bc493ecc618520a2d260e}{file\_type}}}
\DoxyCodeLine{285 diskio::guess\_file\_type\_internal(std::istream\& f)}
\DoxyCodeLine{286   \{}
\DoxyCodeLine{287   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{288   }
\DoxyCodeLine{289   f.clear();}
\DoxyCodeLine{290   \textcolor{keyword}{const} std::fstream::pos\_type pos1 = f.tellg();}
\DoxyCodeLine{291   }
\DoxyCodeLine{292   f.clear();}
\DoxyCodeLine{293   f.seekg(0, ios::end);}
\DoxyCodeLine{294   }
\DoxyCodeLine{295   f.clear();}
\DoxyCodeLine{296   \textcolor{keyword}{const} std::fstream::pos\_type pos2 = f.tellg();}
\DoxyCodeLine{297   }
\DoxyCodeLine{298   \textcolor{keyword}{const} uword N\_max = ( (pos1 >= 0) \&\& (pos2 >= 0) \&\& (pos2 > pos1) ) ? uword(pos2 -\/ pos1) : uword(0);}
\DoxyCodeLine{299   }
\DoxyCodeLine{300   f.clear();}
\DoxyCodeLine{301   f.seekg(pos1);}
\DoxyCodeLine{302   }
\DoxyCodeLine{303   \textcolor{keywordflow}{if}(N\_max == 0)  \{ \textcolor{keywordflow}{return} file\_type\_unknown; \}}
\DoxyCodeLine{304   }
\DoxyCodeLine{305   \textcolor{keyword}{const} uword N\_use = (\mbox{\hyperlink{group__fn__min_gac69a480b4c714f7ecbb0620aaa757c8a}{std::min}})(N\_max, uword(4096));}
\DoxyCodeLine{306   }
\DoxyCodeLine{307   \mbox{\hyperlink{classpodarray}{podarray<unsigned char>}} data(N\_use);}
\DoxyCodeLine{308   data.zeros();}
\DoxyCodeLine{309   }
\DoxyCodeLine{310   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}* data\_mem = data.memptr();}
\DoxyCodeLine{311   }
\DoxyCodeLine{312   f.clear();}
\DoxyCodeLine{313   f.read( \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(data\_mem), std::streamsize(N\_use) );}
\DoxyCodeLine{314   }
\DoxyCodeLine{315   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} load\_okay = f.good();}
\DoxyCodeLine{316   }
\DoxyCodeLine{317   f.clear();}
\DoxyCodeLine{318   f.seekg(pos1);}
\DoxyCodeLine{319   }
\DoxyCodeLine{320   \textcolor{keywordflow}{if}(load\_okay == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} file\_type\_unknown; \}}
\DoxyCodeLine{321   }
\DoxyCodeLine{322   \textcolor{keywordtype}{bool} has\_binary  = \textcolor{keyword}{false};}
\DoxyCodeLine{323   \textcolor{keywordtype}{bool} has\_bracket = \textcolor{keyword}{false};}
\DoxyCodeLine{324   \textcolor{keywordtype}{bool} has\_comma   = \textcolor{keyword}{false};}
\DoxyCodeLine{325   }
\DoxyCodeLine{326   \textcolor{keywordflow}{for}(uword i=0; i<N\_use; ++i)}
\DoxyCodeLine{327     \{}
\DoxyCodeLine{328     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} val = data\_mem[i];}
\DoxyCodeLine{329     }
\DoxyCodeLine{330     \textcolor{keywordflow}{if}( (val <=   8) || (val >= 123) )  \{ has\_binary  = \textcolor{keyword}{true}; \textcolor{keywordflow}{break}; \}  \textcolor{comment}{// the range checking can be made more elaborate}}
\DoxyCodeLine{331     }
\DoxyCodeLine{332     \textcolor{keywordflow}{if}( (val == \textcolor{charliteral}{'('}) || (val == \textcolor{charliteral}{')'}) )  \{ has\_bracket = \textcolor{keyword}{true};        \}}
\DoxyCodeLine{333     }
\DoxyCodeLine{334     \textcolor{keywordflow}{if}( (val == \textcolor{charliteral}{','})                 )  \{ has\_comma   = \textcolor{keyword}{true};        \}}
\DoxyCodeLine{335     \}}
\DoxyCodeLine{336   }
\DoxyCodeLine{337   \textcolor{keywordflow}{if}(has\_binary)  \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{group__diskio_gga0de594dadb1bc493ecc618520a2d260eac7c03701d8a6949bd83abea1ecce583d}{raw\_binary}}; \}}
\DoxyCodeLine{338   }
\DoxyCodeLine{339   \textcolor{keywordflow}{if}(has\_comma \&\& (has\_bracket == \textcolor{keyword}{false}))  \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{group__diskio_gga0de594dadb1bc493ecc618520a2d260eab4d2490e1c12932d1332e7ce8af72736}{csv\_ascii}}; \}}
\DoxyCodeLine{340   }
\DoxyCodeLine{341   \textcolor{keywordflow}{return} \mbox{\hyperlink{group__diskio_gga0de594dadb1bc493ecc618520a2d260ea7963e321f4e9acbc17ee7bb89759c726}{raw\_ascii}};}
\DoxyCodeLine{342   \}}
\DoxyCodeLine{343 }
\DoxyCodeLine{344 }
\DoxyCodeLine{345 }
\DoxyCodeLine{348 \textcolor{keyword}{inline}}
\DoxyCodeLine{349 arma\_cold}
\DoxyCodeLine{350 std::string}
\DoxyCodeLine{351 \mbox{\hyperlink{group__diskio_gad32fa08afe53746650c31071f88eacab}{diskio::gen\_tmp\_name}}(\textcolor{keyword}{const} std::string\& x)}
\DoxyCodeLine{352   \{}
\DoxyCodeLine{353   \textcolor{keyword}{union }\{ uword val; \textcolor{keywordtype}{void}* ptr; \} u;}
\DoxyCodeLine{354   }
\DoxyCodeLine{355   u.val = uword(0);}
\DoxyCodeLine{356   u.ptr = \textcolor{keyword}{const\_cast<}std::string*\textcolor{keyword}{>}(\&x);}
\DoxyCodeLine{357   }
\DoxyCodeLine{358   \textcolor{keyword}{const} u16 a = u16( (u.val >> 8)   \& 0xFFFF );}
\DoxyCodeLine{359   \textcolor{keyword}{const} u16 b = u16( (std::clock()) \& 0xFFFF );}
\DoxyCodeLine{360   }
\DoxyCodeLine{361   std::ostringstream ss;}
\DoxyCodeLine{362   }
\DoxyCodeLine{363   ss << x << \textcolor{stringliteral}{"{}.tmp\_"{}};}
\DoxyCodeLine{364   }
\DoxyCodeLine{365   ss.setf(std::ios\_base::hex, std::ios\_base::basefield);}
\DoxyCodeLine{366   }
\DoxyCodeLine{367   ss.width(4);}
\DoxyCodeLine{368   ss.fill(\textcolor{charliteral}{'0'});}
\DoxyCodeLine{369   ss << a;}
\DoxyCodeLine{370   }
\DoxyCodeLine{371   ss.width(4);}
\DoxyCodeLine{372   ss.fill(\textcolor{charliteral}{'0'});}
\DoxyCodeLine{373   ss << b;}
\DoxyCodeLine{374   }
\DoxyCodeLine{375   \textcolor{keywordflow}{return} ss.str();}
\DoxyCodeLine{376   \}}
\DoxyCodeLine{377 }
\DoxyCodeLine{378 }
\DoxyCodeLine{379 }
\DoxyCodeLine{385 \textcolor{keyword}{inline}}
\DoxyCodeLine{386 arma\_cold}
\DoxyCodeLine{387 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{388 \mbox{\hyperlink{group__diskio_gafbccd611e1fec1b6044f81460415d8d3}{diskio::safe\_rename}}(\textcolor{keyword}{const} std::string\& old\_name, \textcolor{keyword}{const} std::string\& new\_name)}
\DoxyCodeLine{389   \{}
\DoxyCodeLine{390   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* new\_name\_c\_str = new\_name.c\_str();}
\DoxyCodeLine{391   }
\DoxyCodeLine{392   std::fstream f(new\_name\_c\_str, std::fstream::out | std::fstream::app);}
\DoxyCodeLine{393   f.put(\textcolor{charliteral}{' '});}
\DoxyCodeLine{394   }
\DoxyCodeLine{395   \textcolor{keywordflow}{if}(f.good()) \{ f.close(); \} \textcolor{keywordflow}{else} \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{396   }
\DoxyCodeLine{397   \textcolor{keywordflow}{if}(std::remove(                  new\_name\_c\_str) != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{398   \textcolor{keywordflow}{if}(std::rename(old\_name.c\_str(), new\_name\_c\_str) != 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{399   }
\DoxyCodeLine{400   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{401   \}}
\DoxyCodeLine{402 }
\DoxyCodeLine{403 }
\DoxyCodeLine{404 }
\DoxyCodeLine{405 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{406 \textcolor{keyword}{inline}}
\DoxyCodeLine{407 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{408 diskio::convert\_token(eT\& val, \textcolor{keyword}{const} std::string\& token)}
\DoxyCodeLine{409   \{}
\DoxyCodeLine{410   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} N = size\_t(token.length());}
\DoxyCodeLine{411   }
\DoxyCodeLine{412   \textcolor{keywordflow}{if}(N == 0)  \{ val = eT(0); \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{413   }
\DoxyCodeLine{414   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* \mbox{\hyperlink{classstr}{str}} = token.c\_str();}
\DoxyCodeLine{415   }
\DoxyCodeLine{416   \textcolor{keywordflow}{if}( (N == 3) || (N == 4) )}
\DoxyCodeLine{417     \{}
\DoxyCodeLine{418     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} neg = (\mbox{\hyperlink{classstr}{str}}[0] == \textcolor{charliteral}{'-\/'});}
\DoxyCodeLine{419     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} pos = (\mbox{\hyperlink{classstr}{str}}[0] == \textcolor{charliteral}{'+'});}
\DoxyCodeLine{420     }
\DoxyCodeLine{421     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} offset = ( (neg || pos) \&\& (N == 4) ) ? 1 : 0;}
\DoxyCodeLine{422     }
\DoxyCodeLine{423     \textcolor{keyword}{const} \textcolor{keywordtype}{char} sig\_a = \mbox{\hyperlink{classstr}{str}}[offset  ];}
\DoxyCodeLine{424     \textcolor{keyword}{const} \textcolor{keywordtype}{char} sig\_b = \mbox{\hyperlink{classstr}{str}}[offset+1];}
\DoxyCodeLine{425     \textcolor{keyword}{const} \textcolor{keywordtype}{char} sig\_c = \mbox{\hyperlink{classstr}{str}}[offset+2];}
\DoxyCodeLine{426     }
\DoxyCodeLine{427     \textcolor{keywordflow}{if}( ((sig\_a == \textcolor{charliteral}{'i'}) || (sig\_a == \textcolor{charliteral}{'I'})) \&\& ((sig\_b == \textcolor{charliteral}{'n'}) || (sig\_b == \textcolor{charliteral}{'N'})) \&\& ((sig\_c == \textcolor{charliteral}{'f'}) || (sig\_c == \textcolor{charliteral}{'F'})) )}
\DoxyCodeLine{428       \{}
\DoxyCodeLine{429       val = neg ? \mbox{\hyperlink{classcond__rel}{cond\_rel< is\_signed<eT>::value}} >::make\_neg(\mbox{\hyperlink{classDatum}{Datum<eT>::inf}}) : \mbox{\hyperlink{classDatum}{Datum}}<eT>::inf;}
\DoxyCodeLine{430       }
\DoxyCodeLine{431       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{432       \}}
\DoxyCodeLine{433     \textcolor{keywordflow}{else}}
\DoxyCodeLine{434     \textcolor{keywordflow}{if}( ((sig\_a == \textcolor{charliteral}{'n'}) || (sig\_a == \textcolor{charliteral}{'N'})) \&\& ((sig\_b == \textcolor{charliteral}{'a'}) || (sig\_b == \textcolor{charliteral}{'A'})) \&\& ((sig\_c == \textcolor{charliteral}{'n'}) || (sig\_c == \textcolor{charliteral}{'N'})) )}
\DoxyCodeLine{435       \{}
\DoxyCodeLine{436       val = \mbox{\hyperlink{classDatum}{Datum<eT>::nan}};}
\DoxyCodeLine{437       }
\DoxyCodeLine{438       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{439       \}}
\DoxyCodeLine{440     \}}
\DoxyCodeLine{441   }
\DoxyCodeLine{442   }
\DoxyCodeLine{443   \textcolor{keywordtype}{char}* endptr = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{444   }
\DoxyCodeLine{445   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__real}{is\_real<eT>::value}})}
\DoxyCodeLine{446     \{}
\DoxyCodeLine{447     val = eT( std::strtod(\mbox{\hyperlink{classstr}{str}}, \&endptr) );}
\DoxyCodeLine{448     \}}
\DoxyCodeLine{449   \textcolor{keywordflow}{else}}
\DoxyCodeLine{450     \{}
\DoxyCodeLine{451     \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__signed}{is\_signed<eT>::value}})}
\DoxyCodeLine{452       \{}
\DoxyCodeLine{453       \textcolor{comment}{// signed integer}}
\DoxyCodeLine{454       }
\DoxyCodeLine{455       val = eT( std::strtoll(\mbox{\hyperlink{classstr}{str}}, \&endptr, 10) );}
\DoxyCodeLine{456       \}}
\DoxyCodeLine{457     \textcolor{keywordflow}{else}}
\DoxyCodeLine{458       \{}
\DoxyCodeLine{459       \textcolor{comment}{// unsigned integer}}
\DoxyCodeLine{460       }
\DoxyCodeLine{461       \textcolor{keywordflow}{if}(\mbox{\hyperlink{classstr}{str}}[0] == \textcolor{charliteral}{'-\/'})  \{ val = eT(0);  \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{462       }
\DoxyCodeLine{463       val = eT( std::strtoull(\mbox{\hyperlink{classstr}{str}}, \&endptr, 10) );}
\DoxyCodeLine{464       \}}
\DoxyCodeLine{465     \}}
\DoxyCodeLine{466   }
\DoxyCodeLine{467   \textcolor{keywordflow}{if}(\mbox{\hyperlink{classstr}{str}} == endptr)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{468   }
\DoxyCodeLine{469   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{470   \}}
\DoxyCodeLine{471 }
\DoxyCodeLine{472 }
\DoxyCodeLine{473 }
\DoxyCodeLine{474 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{475 \textcolor{keyword}{inline}}
\DoxyCodeLine{476 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{477 diskio::convert\_token(std::complex<T>\& val, \textcolor{keyword}{const} std::string\& token)}
\DoxyCodeLine{478   \{}
\DoxyCodeLine{479   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} N   = size\_t(token.length());}
\DoxyCodeLine{480   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} Nm1 = N-\/1;}
\DoxyCodeLine{481   }
\DoxyCodeLine{482   \textcolor{keywordflow}{if}(N == 0)  \{ val = std::complex<T>(0); \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{483   }
\DoxyCodeLine{484   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* \mbox{\hyperlink{classstr}{str}} = token.c\_str();}
\DoxyCodeLine{485   }
\DoxyCodeLine{486   \textcolor{comment}{// valid complex number formats:}}
\DoxyCodeLine{487   \textcolor{comment}{// (real,imag)}}
\DoxyCodeLine{488   \textcolor{comment}{// (real)}}
\DoxyCodeLine{489   \textcolor{comment}{// ()}}
\DoxyCodeLine{490   }
\DoxyCodeLine{491   \textcolor{keywordflow}{if}( (token[0] != \textcolor{charliteral}{'('}) || (token[Nm1] != \textcolor{charliteral}{')'}) )}
\DoxyCodeLine{492     \{}
\DoxyCodeLine{493     \textcolor{comment}{// no brackets, so treat the token as a non-\/complex number}}
\DoxyCodeLine{494     }
\DoxyCodeLine{495     T val\_real;}
\DoxyCodeLine{496     }
\DoxyCodeLine{497     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} state = diskio::convert\_token(val\_real, token);  \textcolor{comment}{// use the non-\/complex version of this function}}
\DoxyCodeLine{498     }
\DoxyCodeLine{499     val = std::complex<T>(val\_real);}
\DoxyCodeLine{500     }
\DoxyCodeLine{501     \textcolor{keywordflow}{return} state;}
\DoxyCodeLine{502     \}}
\DoxyCodeLine{503   }
\DoxyCodeLine{504   \textcolor{comment}{// does the token contain only the () brackets?}}
\DoxyCodeLine{505   \textcolor{keywordflow}{if}(N <= 2)  \{ val = std::complex<T>(0); \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{506   }
\DoxyCodeLine{507   \textcolor{keywordtype}{size\_t} comma\_loc   = 0;}
\DoxyCodeLine{508   \textcolor{keywordtype}{bool}   comma\_found = \textcolor{keyword}{false};}
\DoxyCodeLine{509   }
\DoxyCodeLine{510   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i=0; i<N; ++i)  \{ \textcolor{keywordflow}{if}(\mbox{\hyperlink{classstr}{str}}[i] == \textcolor{charliteral}{','})  \{ comma\_loc = i; comma\_found = \textcolor{keyword}{true}; \textcolor{keywordflow}{break}; \} \}}
\DoxyCodeLine{511   }
\DoxyCodeLine{512   \textcolor{keywordtype}{bool} state = \textcolor{keyword}{false};}
\DoxyCodeLine{513   }
\DoxyCodeLine{514   \textcolor{keywordflow}{if}(comma\_found == \textcolor{keyword}{false})}
\DoxyCodeLine{515     \{}
\DoxyCodeLine{516     \textcolor{comment}{// only the real part is available}}
\DoxyCodeLine{517     }
\DoxyCodeLine{518     \textcolor{keyword}{const} std::string token\_real( \&(\mbox{\hyperlink{classstr}{str}}[1]), (Nm1 -\/ 1) );}
\DoxyCodeLine{519     }
\DoxyCodeLine{520     T val\_real;}
\DoxyCodeLine{521     }
\DoxyCodeLine{522     state = diskio::convert\_token(val\_real, token\_real);  \textcolor{comment}{// use the non-\/complex version of this function}}
\DoxyCodeLine{523     }
\DoxyCodeLine{524     val = std::complex<T>(val\_real);}
\DoxyCodeLine{525     \}}
\DoxyCodeLine{526   \textcolor{keywordflow}{else}}
\DoxyCodeLine{527     \{}
\DoxyCodeLine{528     \textcolor{keyword}{const} std::string token\_real( \&(\mbox{\hyperlink{classstr}{str}}[1]),           (comma\_loc -\/ 1      ) );}
\DoxyCodeLine{529     \textcolor{keyword}{const} std::string token\_imag( \&(\mbox{\hyperlink{classstr}{str}}[comma\_loc+1]), (Nm1 -\/ 1 -\/ comma\_loc) );}
\DoxyCodeLine{530     }
\DoxyCodeLine{531     T val\_real;}
\DoxyCodeLine{532     T val\_imag;}
\DoxyCodeLine{533     }
\DoxyCodeLine{534     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} state\_real = diskio::convert\_token(val\_real, token\_real);}
\DoxyCodeLine{535     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} state\_imag = diskio::convert\_token(val\_imag, token\_imag);}
\DoxyCodeLine{536     }
\DoxyCodeLine{537     state = (state\_real \&\& state\_imag);}
\DoxyCodeLine{538     }
\DoxyCodeLine{539     val = std::complex<T>(val\_real, val\_imag);}
\DoxyCodeLine{540     \}}
\DoxyCodeLine{541   }
\DoxyCodeLine{542   \textcolor{keywordflow}{return} state;}
\DoxyCodeLine{543   \}}
\DoxyCodeLine{544 }
\DoxyCodeLine{545 }
\DoxyCodeLine{546 }
\DoxyCodeLine{547 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{548 \textcolor{keyword}{inline}}
\DoxyCodeLine{549 std::streamsize}
\DoxyCodeLine{550 diskio::prepare\_stream(std::ostream\& f)}
\DoxyCodeLine{551   \{}
\DoxyCodeLine{552   std::streamsize cell\_width = f.width();}
\DoxyCodeLine{553   }
\DoxyCodeLine{554   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__real}{is\_real<eT>::value}})}
\DoxyCodeLine{555     \{}
\DoxyCodeLine{556     f.unsetf(ios::fixed);}
\DoxyCodeLine{557     f.setf(ios::scientific);}
\DoxyCodeLine{558     f.fill(\textcolor{charliteral}{' '});}
\DoxyCodeLine{559     }
\DoxyCodeLine{560     f.precision(16);}
\DoxyCodeLine{561     cell\_width = 24;}
\DoxyCodeLine{562     }
\DoxyCodeLine{563     \textcolor{comment}{// NOTE: for 'float' the optimum settings are f.precision(8) and cell\_width = 15}}
\DoxyCodeLine{564     \textcolor{comment}{// NOTE: however, to avoid introducing errors in case single precision data is loaded as double precision,}}
\DoxyCodeLine{565     \textcolor{comment}{// NOTE: the same settings must be used for both 'float' and 'double'}}
\DoxyCodeLine{566     \}}
\DoxyCodeLine{567   \textcolor{keywordflow}{else}}
\DoxyCodeLine{568   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__cx}{is\_cx<eT>::value}})}
\DoxyCodeLine{569     \{}
\DoxyCodeLine{570     f.unsetf(ios::fixed);}
\DoxyCodeLine{571     f.setf(ios::scientific);}
\DoxyCodeLine{572     }
\DoxyCodeLine{573     f.precision(16);}
\DoxyCodeLine{574     \}}
\DoxyCodeLine{575   }
\DoxyCodeLine{576   \textcolor{keywordflow}{return} cell\_width;}
\DoxyCodeLine{577   \}}
\DoxyCodeLine{578   }
\DoxyCodeLine{579 }
\DoxyCodeLine{580 }
\DoxyCodeLine{581 }
\DoxyCodeLine{584 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{585 \textcolor{keyword}{inline}}
\DoxyCodeLine{586 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{587 \mbox{\hyperlink{group__diskio_ga0e3f9c9fad9eefa6ef90ebab6516d684}{diskio::save\_raw\_ascii}}(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& x, \textcolor{keyword}{const} std::string\& final\_name)}
\DoxyCodeLine{588   \{}
\DoxyCodeLine{589   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{590   }
\DoxyCodeLine{591   \textcolor{keyword}{const} std::string tmp\_name = \mbox{\hyperlink{group__diskio_gad32fa08afe53746650c31071f88eacab}{diskio::gen\_tmp\_name}}(final\_name);}
\DoxyCodeLine{592   }
\DoxyCodeLine{593   std::fstream f(tmp\_name.c\_str(), std::fstream::out);}
\DoxyCodeLine{594   }
\DoxyCodeLine{595   \textcolor{keywordtype}{bool} save\_okay = f.is\_open();}
\DoxyCodeLine{596   }
\DoxyCodeLine{597   \textcolor{keywordflow}{if}(save\_okay)}
\DoxyCodeLine{598     \{}
\DoxyCodeLine{599     save\_okay = \mbox{\hyperlink{group__diskio_ga0e3f9c9fad9eefa6ef90ebab6516d684}{diskio::save\_raw\_ascii}}(x, f);}
\DoxyCodeLine{600     }
\DoxyCodeLine{601     f.flush();}
\DoxyCodeLine{602     f.close();}
\DoxyCodeLine{603     }
\DoxyCodeLine{604     \textcolor{keywordflow}{if}(save\_okay)  \{ save\_okay = \mbox{\hyperlink{group__diskio_gafbccd611e1fec1b6044f81460415d8d3}{diskio::safe\_rename}}(tmp\_name, final\_name); \}}
\DoxyCodeLine{605     \}}
\DoxyCodeLine{606   }
\DoxyCodeLine{607   \textcolor{keywordflow}{return} save\_okay;}
\DoxyCodeLine{608   \}}
\DoxyCodeLine{609 }
\DoxyCodeLine{610 }
\DoxyCodeLine{611 }
\DoxyCodeLine{614 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{615 \textcolor{keyword}{inline}}
\DoxyCodeLine{616 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{617 \mbox{\hyperlink{group__diskio_ga0e3f9c9fad9eefa6ef90ebab6516d684}{diskio::save\_raw\_ascii}}(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& x, std::ostream\& f)}
\DoxyCodeLine{618   \{}
\DoxyCodeLine{619   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{620   }
\DoxyCodeLine{621   \textcolor{keyword}{const} \mbox{\hyperlink{classarma__ostream__state}{arma\_ostream\_state}} stream\_state(f);}
\DoxyCodeLine{622   }
\DoxyCodeLine{623   \textcolor{keyword}{const} std::streamsize cell\_width = diskio::prepare\_stream<eT>(f);}
\DoxyCodeLine{624   }
\DoxyCodeLine{625   \textcolor{keywordflow}{for}(uword row=0; row < x.n\_rows; ++row)}
\DoxyCodeLine{626     \{}
\DoxyCodeLine{627     \textcolor{keywordflow}{for}(uword col=0; col < x.n\_cols; ++col)}
\DoxyCodeLine{628       \{}
\DoxyCodeLine{629       f.put(\textcolor{charliteral}{' '});}
\DoxyCodeLine{630       }
\DoxyCodeLine{631       \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__real}{is\_real<eT>::value}})  \{ f.width(cell\_width); \}}
\DoxyCodeLine{632       }
\DoxyCodeLine{633       arma\_ostream::raw\_print\_elem(f, x.at(row,col));}
\DoxyCodeLine{634       \}}
\DoxyCodeLine{635     }
\DoxyCodeLine{636     f.put(\textcolor{charliteral}{'\(\backslash\)n'});}
\DoxyCodeLine{637     \}}
\DoxyCodeLine{638   }
\DoxyCodeLine{639   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} save\_okay = f.good();}
\DoxyCodeLine{640   }
\DoxyCodeLine{641   stream\_state.restore(f);}
\DoxyCodeLine{642   }
\DoxyCodeLine{643   \textcolor{keywordflow}{return} save\_okay;}
\DoxyCodeLine{644   \}}
\DoxyCodeLine{645 }
\DoxyCodeLine{646 }
\DoxyCodeLine{647 }
\DoxyCodeLine{649 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{650 \textcolor{keyword}{inline}}
\DoxyCodeLine{651 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{652 \mbox{\hyperlink{group__diskio_ga20b30004864f1e5dc31d8afb38377fdd}{diskio::save\_raw\_binary}}(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& x, \textcolor{keyword}{const} std::string\& final\_name)}
\DoxyCodeLine{653   \{}
\DoxyCodeLine{654   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{655   }
\DoxyCodeLine{656   \textcolor{keyword}{const} std::string tmp\_name = \mbox{\hyperlink{group__diskio_gad32fa08afe53746650c31071f88eacab}{diskio::gen\_tmp\_name}}(final\_name);}
\DoxyCodeLine{657   }
\DoxyCodeLine{658   std::ofstream f(tmp\_name.c\_str(), std::fstream::binary);}
\DoxyCodeLine{659   }
\DoxyCodeLine{660   \textcolor{keywordtype}{bool} save\_okay = f.is\_open();}
\DoxyCodeLine{661   }
\DoxyCodeLine{662   \textcolor{keywordflow}{if}(save\_okay)}
\DoxyCodeLine{663     \{}
\DoxyCodeLine{664     save\_okay = \mbox{\hyperlink{group__diskio_ga20b30004864f1e5dc31d8afb38377fdd}{diskio::save\_raw\_binary}}(x, f);}
\DoxyCodeLine{665     }
\DoxyCodeLine{666     f.flush();}
\DoxyCodeLine{667     f.close();}
\DoxyCodeLine{668     }
\DoxyCodeLine{669     \textcolor{keywordflow}{if}(save\_okay)  \{ save\_okay = \mbox{\hyperlink{group__diskio_gafbccd611e1fec1b6044f81460415d8d3}{diskio::safe\_rename}}(tmp\_name, final\_name); \}}
\DoxyCodeLine{670     \}}
\DoxyCodeLine{671   }
\DoxyCodeLine{672   \textcolor{keywordflow}{return} save\_okay;}
\DoxyCodeLine{673   \}}
\DoxyCodeLine{674 }
\DoxyCodeLine{675 }
\DoxyCodeLine{676 }
\DoxyCodeLine{677 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{678 \textcolor{keyword}{inline}}
\DoxyCodeLine{679 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{680 \mbox{\hyperlink{group__diskio_ga20b30004864f1e5dc31d8afb38377fdd}{diskio::save\_raw\_binary}}(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& x, std::ostream\& f)}
\DoxyCodeLine{681   \{}
\DoxyCodeLine{682   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{683   }
\DoxyCodeLine{684   f.write( \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(x.mem), std::streamsize(x.n\_elem*\textcolor{keyword}{sizeof}(eT)) );}
\DoxyCodeLine{685   }
\DoxyCodeLine{686   \textcolor{keywordflow}{return} f.good();}
\DoxyCodeLine{687   \}}
\DoxyCodeLine{688 }
\DoxyCodeLine{689 }
\DoxyCodeLine{690 }
\DoxyCodeLine{693 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{694 \textcolor{keyword}{inline}}
\DoxyCodeLine{695 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{696 \mbox{\hyperlink{group__diskio_ga159785ddd277a6ce0589c9b7621e1387}{diskio::save\_arma\_ascii}}(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& x, \textcolor{keyword}{const} std::string\& final\_name)}
\DoxyCodeLine{697   \{}
\DoxyCodeLine{698   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{699   }
\DoxyCodeLine{700   \textcolor{keyword}{const} std::string tmp\_name = \mbox{\hyperlink{group__diskio_gad32fa08afe53746650c31071f88eacab}{diskio::gen\_tmp\_name}}(final\_name);}
\DoxyCodeLine{701   }
\DoxyCodeLine{702   std::ofstream f(tmp\_name.c\_str());}
\DoxyCodeLine{703   }
\DoxyCodeLine{704   \textcolor{keywordtype}{bool} save\_okay = f.is\_open();}
\DoxyCodeLine{705   }
\DoxyCodeLine{706   \textcolor{keywordflow}{if}(save\_okay)}
\DoxyCodeLine{707     \{}
\DoxyCodeLine{708     save\_okay = \mbox{\hyperlink{group__diskio_ga159785ddd277a6ce0589c9b7621e1387}{diskio::save\_arma\_ascii}}(x, f);}
\DoxyCodeLine{709     }
\DoxyCodeLine{710     f.flush();}
\DoxyCodeLine{711     f.close();}
\DoxyCodeLine{712     }
\DoxyCodeLine{713     \textcolor{keywordflow}{if}(save\_okay)  \{ save\_okay = \mbox{\hyperlink{group__diskio_gafbccd611e1fec1b6044f81460415d8d3}{diskio::safe\_rename}}(tmp\_name, final\_name); \}}
\DoxyCodeLine{714     \}}
\DoxyCodeLine{715   }
\DoxyCodeLine{716   \textcolor{keywordflow}{return} save\_okay;}
\DoxyCodeLine{717   \}}
\DoxyCodeLine{718 }
\DoxyCodeLine{719 }
\DoxyCodeLine{720 }
\DoxyCodeLine{723 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{724 \textcolor{keyword}{inline}}
\DoxyCodeLine{725 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{726 \mbox{\hyperlink{group__diskio_ga159785ddd277a6ce0589c9b7621e1387}{diskio::save\_arma\_ascii}}(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& x, std::ostream\& f)}
\DoxyCodeLine{727   \{}
\DoxyCodeLine{728   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{729   }
\DoxyCodeLine{730   \textcolor{keyword}{const} \mbox{\hyperlink{classarma__ostream__state}{arma\_ostream\_state}} stream\_state(f);}
\DoxyCodeLine{731   }
\DoxyCodeLine{732   f << \mbox{\hyperlink{group__diskio_ga7adb78317f164fa19978566b3bf3f216}{diskio::gen\_txt\_header}}(x) << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{733   f << x.n\_rows << \textcolor{charliteral}{' '} << x.n\_cols << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{734   }
\DoxyCodeLine{735   \textcolor{keyword}{const} std::streamsize cell\_width = diskio::prepare\_stream<eT>(f);}
\DoxyCodeLine{736   }
\DoxyCodeLine{737   \textcolor{keywordflow}{for}(uword row=0; row < x.n\_rows; ++row)}
\DoxyCodeLine{738     \{}
\DoxyCodeLine{739     \textcolor{keywordflow}{for}(uword col=0; col < x.n\_cols; ++col)}
\DoxyCodeLine{740       \{}
\DoxyCodeLine{741       f.put(\textcolor{charliteral}{' '});}
\DoxyCodeLine{742       }
\DoxyCodeLine{743       \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__real}{is\_real<eT>::value}})  \{ f.width(cell\_width); \}}
\DoxyCodeLine{744       }
\DoxyCodeLine{745       arma\_ostream::raw\_print\_elem(f, x.at(row,col));}
\DoxyCodeLine{746       \}}
\DoxyCodeLine{747     }
\DoxyCodeLine{748     f.put(\textcolor{charliteral}{'\(\backslash\)n'});}
\DoxyCodeLine{749     \}}
\DoxyCodeLine{750   }
\DoxyCodeLine{751   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} save\_okay = f.good();}
\DoxyCodeLine{752   }
\DoxyCodeLine{753   stream\_state.restore(f);}
\DoxyCodeLine{754   }
\DoxyCodeLine{755   \textcolor{keywordflow}{return} save\_okay;}
\DoxyCodeLine{756   \}}
\DoxyCodeLine{757 }
\DoxyCodeLine{758 }
\DoxyCodeLine{759 }
\DoxyCodeLine{761 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{762 \textcolor{keyword}{inline}}
\DoxyCodeLine{763 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{764 \mbox{\hyperlink{group__diskio_gab2874c9ce3947ee2bda6176591bdc26b}{diskio::save\_csv\_ascii}}(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& x, \textcolor{keyword}{const} std::string\& final\_name, \textcolor{keyword}{const} \mbox{\hyperlink{classfield}{field<std::string>}}\& header, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} with\_header)}
\DoxyCodeLine{765   \{}
\DoxyCodeLine{766   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{767   }
\DoxyCodeLine{768   \textcolor{keyword}{const} std::string tmp\_name = \mbox{\hyperlink{group__diskio_gad32fa08afe53746650c31071f88eacab}{diskio::gen\_tmp\_name}}(final\_name);}
\DoxyCodeLine{769   }
\DoxyCodeLine{770   std::ofstream f(tmp\_name.c\_str());}
\DoxyCodeLine{771   }
\DoxyCodeLine{772   \textcolor{keywordtype}{bool} save\_okay = f.is\_open();}
\DoxyCodeLine{773   }
\DoxyCodeLine{774   \textcolor{keywordflow}{if}(save\_okay == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{775   }
\DoxyCodeLine{776   \textcolor{keywordflow}{if}(with\_header)}
\DoxyCodeLine{777     \{}
\DoxyCodeLine{778     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}diskio::save\_csv\_ascii(): writing header"{}});}
\DoxyCodeLine{779     }
\DoxyCodeLine{780     \textcolor{keywordflow}{for}(uword i=0; i < header.\mbox{\hyperlink{classfield_ab81d4115f84d73a4118dedf0194b3e3c}{n\_elem}}; ++i)}
\DoxyCodeLine{781       \{}
\DoxyCodeLine{782       f << header.\mbox{\hyperlink{group__field_gad86418c0a65bb58844812b995560cffe}{at}}(i);}
\DoxyCodeLine{783       }
\DoxyCodeLine{784       \textcolor{keywordflow}{if}(i != (header.\mbox{\hyperlink{classfield_ab81d4115f84d73a4118dedf0194b3e3c}{n\_elem}}-\/1))  \{ f.put(\textcolor{charliteral}{','}); \}}
\DoxyCodeLine{785       \}}
\DoxyCodeLine{786     }
\DoxyCodeLine{787     f.put(\textcolor{charliteral}{'\(\backslash\)n'});}
\DoxyCodeLine{788     }
\DoxyCodeLine{789     save\_okay = f.good();}
\DoxyCodeLine{790     \}}
\DoxyCodeLine{791   }
\DoxyCodeLine{792   \textcolor{keywordflow}{if}(save\_okay)  \{ save\_okay = \mbox{\hyperlink{group__diskio_gab2874c9ce3947ee2bda6176591bdc26b}{diskio::save\_csv\_ascii}}(x, f); \}}
\DoxyCodeLine{793   }
\DoxyCodeLine{794   f.flush();}
\DoxyCodeLine{795   f.close();}
\DoxyCodeLine{796   }
\DoxyCodeLine{797   \textcolor{keywordflow}{if}(save\_okay)  \{ save\_okay = \mbox{\hyperlink{group__diskio_gafbccd611e1fec1b6044f81460415d8d3}{diskio::safe\_rename}}(tmp\_name, final\_name); \}}
\DoxyCodeLine{798   }
\DoxyCodeLine{799   \textcolor{keywordflow}{return} save\_okay;}
\DoxyCodeLine{800   \}}
\DoxyCodeLine{801 }
\DoxyCodeLine{802 }
\DoxyCodeLine{803 }
\DoxyCodeLine{805 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{806 \textcolor{keyword}{inline}}
\DoxyCodeLine{807 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{808 \mbox{\hyperlink{group__diskio_gab2874c9ce3947ee2bda6176591bdc26b}{diskio::save\_csv\_ascii}}(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& x, std::ostream\& f)}
\DoxyCodeLine{809   \{}
\DoxyCodeLine{810   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{811   }
\DoxyCodeLine{812   \textcolor{keyword}{const} \mbox{\hyperlink{classarma__ostream__state}{arma\_ostream\_state}} stream\_state(f);}
\DoxyCodeLine{813   }
\DoxyCodeLine{814   diskio::prepare\_stream<eT>(f);}
\DoxyCodeLine{815   }
\DoxyCodeLine{816   uword x\_n\_rows = x.n\_rows;}
\DoxyCodeLine{817   uword x\_n\_cols = x.n\_cols;}
\DoxyCodeLine{818   }
\DoxyCodeLine{819   \textcolor{keywordflow}{for}(uword row=0; row < x\_n\_rows; ++row)}
\DoxyCodeLine{820     \{}
\DoxyCodeLine{821     \textcolor{keywordflow}{for}(uword col=0; col < x\_n\_cols; ++col)}
\DoxyCodeLine{822       \{}
\DoxyCodeLine{823       arma\_ostream::raw\_print\_elem(f, x.at(row,col));}
\DoxyCodeLine{824       }
\DoxyCodeLine{825       \textcolor{keywordflow}{if}( col < (x\_n\_cols-\/1) )  \{ f.put(\textcolor{charliteral}{','}); \}}
\DoxyCodeLine{826       \}}
\DoxyCodeLine{827     }
\DoxyCodeLine{828     f.put(\textcolor{charliteral}{'\(\backslash\)n'});}
\DoxyCodeLine{829     \}}
\DoxyCodeLine{830   }
\DoxyCodeLine{831   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} save\_okay = f.good();}
\DoxyCodeLine{832   }
\DoxyCodeLine{833   stream\_state.restore(f);}
\DoxyCodeLine{834   }
\DoxyCodeLine{835   \textcolor{keywordflow}{return} save\_okay;}
\DoxyCodeLine{836   \}}
\DoxyCodeLine{837 }
\DoxyCodeLine{838 }
\DoxyCodeLine{839 }
\DoxyCodeLine{841 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{842 \textcolor{keyword}{inline}}
\DoxyCodeLine{843 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{844 \mbox{\hyperlink{group__diskio_gab2874c9ce3947ee2bda6176591bdc26b}{diskio::save\_csv\_ascii}}(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& x, std::ostream\& f)}
\DoxyCodeLine{845   \{}
\DoxyCodeLine{846   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{847   }
\DoxyCodeLine{848   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<T> eT;}
\DoxyCodeLine{849   }
\DoxyCodeLine{850   \textcolor{keyword}{const} \mbox{\hyperlink{classarma__ostream__state}{arma\_ostream\_state}} stream\_state(f);}
\DoxyCodeLine{851   }
\DoxyCodeLine{852   diskio::prepare\_stream<eT>(f);}
\DoxyCodeLine{853   }
\DoxyCodeLine{854   uword x\_n\_rows = x.n\_rows;}
\DoxyCodeLine{855   uword x\_n\_cols = x.n\_cols;}
\DoxyCodeLine{856   }
\DoxyCodeLine{857   \textcolor{keywordflow}{for}(uword row=0; row < x\_n\_rows; ++row)}
\DoxyCodeLine{858     \{}
\DoxyCodeLine{859     \textcolor{keywordflow}{for}(uword col=0; col < x\_n\_cols; ++col)}
\DoxyCodeLine{860       \{}
\DoxyCodeLine{861       \textcolor{keyword}{const} eT\& val = x.at(row,col);}
\DoxyCodeLine{862       }
\DoxyCodeLine{863       \textcolor{keyword}{const} T    tmp\_r     = std::real(val);}
\DoxyCodeLine{864       \textcolor{keyword}{const} T    tmp\_i     = std::imag(val);}
\DoxyCodeLine{865       \textcolor{keyword}{const} T    tmp\_i\_abs = (tmp\_i < T(0)) ? T(-\/tmp\_i) : T(tmp\_i);}
\DoxyCodeLine{866       \textcolor{keyword}{const} \textcolor{keywordtype}{char} tmp\_sign  = (tmp\_i < T(0)) ? \textcolor{keywordtype}{char}(\textcolor{charliteral}{'-\/'}) : char(\textcolor{charliteral}{'+'});}
\DoxyCodeLine{867       }
\DoxyCodeLine{868       arma\_ostream::raw\_print\_elem(f, tmp\_r    );}
\DoxyCodeLine{869       f.put(tmp\_sign);}
\DoxyCodeLine{870       arma\_ostream::raw\_print\_elem(f, tmp\_i\_abs);}
\DoxyCodeLine{871       f.put(\textcolor{charliteral}{'i'});}
\DoxyCodeLine{872       }
\DoxyCodeLine{873       \textcolor{keywordflow}{if}( col < (x\_n\_cols-\/1) )  \{ f.put(\textcolor{charliteral}{','}); \}}
\DoxyCodeLine{874       \}}
\DoxyCodeLine{875     }
\DoxyCodeLine{876     f.put(\textcolor{charliteral}{'\(\backslash\)n'});}
\DoxyCodeLine{877     \}}
\DoxyCodeLine{878   }
\DoxyCodeLine{879   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} save\_okay = f.good();}
\DoxyCodeLine{880   }
\DoxyCodeLine{881   stream\_state.restore(f);}
\DoxyCodeLine{882   }
\DoxyCodeLine{883   \textcolor{keywordflow}{return} save\_okay;}
\DoxyCodeLine{884   \}}
\DoxyCodeLine{885 }
\DoxyCodeLine{886 }
\DoxyCodeLine{887 }
\DoxyCodeLine{888 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{889 \textcolor{keyword}{inline}}
\DoxyCodeLine{890 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{891 diskio::save\_coord\_ascii(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& x, \textcolor{keyword}{const} std::string\& final\_name)}
\DoxyCodeLine{892   \{}
\DoxyCodeLine{893   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{894   }
\DoxyCodeLine{895   \textcolor{keyword}{const} std::string tmp\_name = \mbox{\hyperlink{group__diskio_gad32fa08afe53746650c31071f88eacab}{diskio::gen\_tmp\_name}}(final\_name);}
\DoxyCodeLine{896   }
\DoxyCodeLine{897   std::ofstream f(tmp\_name.c\_str());}
\DoxyCodeLine{898   }
\DoxyCodeLine{899   \textcolor{keywordtype}{bool} save\_okay = f.is\_open();}
\DoxyCodeLine{900   }
\DoxyCodeLine{901   \textcolor{keywordflow}{if}(save\_okay)}
\DoxyCodeLine{902     \{}
\DoxyCodeLine{903     save\_okay = diskio::save\_coord\_ascii(x, f);}
\DoxyCodeLine{904     }
\DoxyCodeLine{905     f.flush();}
\DoxyCodeLine{906     f.close();}
\DoxyCodeLine{907     }
\DoxyCodeLine{908     \textcolor{keywordflow}{if}(save\_okay)  \{ save\_okay = \mbox{\hyperlink{group__diskio_gafbccd611e1fec1b6044f81460415d8d3}{diskio::safe\_rename}}(tmp\_name, final\_name); \}}
\DoxyCodeLine{909     \}}
\DoxyCodeLine{910   }
\DoxyCodeLine{911   \textcolor{keywordflow}{return} save\_okay;}
\DoxyCodeLine{912   \}}
\DoxyCodeLine{913 }
\DoxyCodeLine{914 }
\DoxyCodeLine{915 }
\DoxyCodeLine{916 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{917 \textcolor{keyword}{inline}}
\DoxyCodeLine{918 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{919 diskio::save\_coord\_ascii(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& x, std::ostream\& f)}
\DoxyCodeLine{920   \{}
\DoxyCodeLine{921   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{922   }
\DoxyCodeLine{923   \textcolor{keyword}{const} \mbox{\hyperlink{classarma__ostream__state}{arma\_ostream\_state}} stream\_state(f);}
\DoxyCodeLine{924   }
\DoxyCodeLine{925   diskio::prepare\_stream<eT>(f);}
\DoxyCodeLine{926   }
\DoxyCodeLine{927   \textcolor{keywordflow}{for}(uword col=0; col < x.n\_cols; ++col)}
\DoxyCodeLine{928   \textcolor{keywordflow}{for}(uword row=0; row < x.n\_rows; ++row)}
\DoxyCodeLine{929     \{}
\DoxyCodeLine{930     \textcolor{keyword}{const} eT val = x.at(row,col);}
\DoxyCodeLine{931     }
\DoxyCodeLine{932     \textcolor{keywordflow}{if}(val != eT(0))}
\DoxyCodeLine{933       \{}
\DoxyCodeLine{934       f << row << \textcolor{charliteral}{' '} << col << \textcolor{charliteral}{' '} << val << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{935       \}}
\DoxyCodeLine{936     \}}
\DoxyCodeLine{937   }
\DoxyCodeLine{938   \textcolor{comment}{// make sure it's possible to figure out the matrix size later}}
\DoxyCodeLine{939   \textcolor{keywordflow}{if}( (x.n\_rows > 0) \&\& (x.n\_cols > 0) )}
\DoxyCodeLine{940     \{}
\DoxyCodeLine{941     \textcolor{keyword}{const} uword max\_row = (x.n\_rows > 0) ? x.n\_rows-\/1 : 0;}
\DoxyCodeLine{942     \textcolor{keyword}{const} uword max\_col = (x.n\_cols > 0) ? x.n\_cols-\/1 : 0;}
\DoxyCodeLine{943     }
\DoxyCodeLine{944     \textcolor{keywordflow}{if}( x.at(max\_row, max\_col) == eT(0) )}
\DoxyCodeLine{945       \{}
\DoxyCodeLine{946       f << max\_row << \textcolor{charliteral}{' '} << max\_col << \textcolor{stringliteral}{"{} 0\(\backslash\)n"{}};}
\DoxyCodeLine{947       \}}
\DoxyCodeLine{948     \}}
\DoxyCodeLine{949   }
\DoxyCodeLine{950   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} save\_okay = f.good();}
\DoxyCodeLine{951   }
\DoxyCodeLine{952   stream\_state.restore(f);}
\DoxyCodeLine{953   }
\DoxyCodeLine{954   \textcolor{keywordflow}{return} save\_okay;}
\DoxyCodeLine{955   \}}
\DoxyCodeLine{956 }
\DoxyCodeLine{957 }
\DoxyCodeLine{958 }
\DoxyCodeLine{959 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{960 \textcolor{keyword}{inline}}
\DoxyCodeLine{961 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{962 diskio::save\_coord\_ascii(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& x, std::ostream\& f)}
\DoxyCodeLine{963   \{}
\DoxyCodeLine{964   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{965   }
\DoxyCodeLine{966   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<T> eT;}
\DoxyCodeLine{967   }
\DoxyCodeLine{968   \textcolor{keyword}{const} \mbox{\hyperlink{classarma__ostream__state}{arma\_ostream\_state}} stream\_state(f);}
\DoxyCodeLine{969   }
\DoxyCodeLine{970   diskio::prepare\_stream<eT>(f);}
\DoxyCodeLine{971   }
\DoxyCodeLine{972   \textcolor{keyword}{const} eT eT\_zero = eT(0);}
\DoxyCodeLine{973   }
\DoxyCodeLine{974   \textcolor{keywordflow}{for}(uword col=0; col < x.n\_cols; ++col)}
\DoxyCodeLine{975   \textcolor{keywordflow}{for}(uword row=0; row < x.n\_rows; ++row)}
\DoxyCodeLine{976     \{}
\DoxyCodeLine{977     \textcolor{keyword}{const} eT val = x.at(row,col);}
\DoxyCodeLine{978     }
\DoxyCodeLine{979     \textcolor{keywordflow}{if}(val != eT\_zero)}
\DoxyCodeLine{980       \{}
\DoxyCodeLine{981       f << row << \textcolor{charliteral}{' '} << col << \textcolor{charliteral}{' '} << val.real() << \textcolor{charliteral}{' '} << val.imag() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{982       \}}
\DoxyCodeLine{983     \}}
\DoxyCodeLine{984   }
\DoxyCodeLine{985   \textcolor{comment}{// make sure it's possible to figure out the matrix size later}}
\DoxyCodeLine{986   \textcolor{keywordflow}{if}( (x.n\_rows > 0) \&\& (x.n\_cols > 0) )}
\DoxyCodeLine{987     \{}
\DoxyCodeLine{988     \textcolor{keyword}{const} uword max\_row = (x.n\_rows > 0) ? x.n\_rows-\/1 : 0;}
\DoxyCodeLine{989     \textcolor{keyword}{const} uword max\_col = (x.n\_cols > 0) ? x.n\_cols-\/1 : 0;}
\DoxyCodeLine{990     }
\DoxyCodeLine{991     \textcolor{keywordflow}{if}( x.at(max\_row, max\_col) == eT\_zero )}
\DoxyCodeLine{992       \{}
\DoxyCodeLine{993       f << max\_row << \textcolor{charliteral}{' '} << max\_col << \textcolor{stringliteral}{"{} 0 0\(\backslash\)n"{}};}
\DoxyCodeLine{994       \}}
\DoxyCodeLine{995     \}}
\DoxyCodeLine{996   }
\DoxyCodeLine{997   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} save\_okay = f.good();}
\DoxyCodeLine{998   }
\DoxyCodeLine{999   stream\_state.restore(f);}
\DoxyCodeLine{1000   }
\DoxyCodeLine{1001   \textcolor{keywordflow}{return} save\_okay;}
\DoxyCodeLine{1002   \}}
\DoxyCodeLine{1003 }
\DoxyCodeLine{1004 }
\DoxyCodeLine{1005 }
\DoxyCodeLine{1008 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{1009 \textcolor{keyword}{inline}}
\DoxyCodeLine{1010 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{1011 \mbox{\hyperlink{group__diskio_ga831707949f1f222d23e15603832e079b}{diskio::save\_arma\_binary}}(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& x, \textcolor{keyword}{const} std::string\& final\_name)}
\DoxyCodeLine{1012   \{}
\DoxyCodeLine{1013   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1014   }
\DoxyCodeLine{1015   \textcolor{keyword}{const} std::string tmp\_name = \mbox{\hyperlink{group__diskio_gad32fa08afe53746650c31071f88eacab}{diskio::gen\_tmp\_name}}(final\_name);}
\DoxyCodeLine{1016   }
\DoxyCodeLine{1017   std::ofstream f(tmp\_name.c\_str(), std::fstream::binary);}
\DoxyCodeLine{1018   }
\DoxyCodeLine{1019   \textcolor{keywordtype}{bool} save\_okay = f.is\_open();}
\DoxyCodeLine{1020   }
\DoxyCodeLine{1021   \textcolor{keywordflow}{if}(save\_okay)}
\DoxyCodeLine{1022     \{}
\DoxyCodeLine{1023     save\_okay = \mbox{\hyperlink{group__diskio_ga831707949f1f222d23e15603832e079b}{diskio::save\_arma\_binary}}(x, f);}
\DoxyCodeLine{1024     }
\DoxyCodeLine{1025     f.flush();}
\DoxyCodeLine{1026     f.close();}
\DoxyCodeLine{1027     }
\DoxyCodeLine{1028     \textcolor{keywordflow}{if}(save\_okay)  \{ save\_okay = \mbox{\hyperlink{group__diskio_gafbccd611e1fec1b6044f81460415d8d3}{diskio::safe\_rename}}(tmp\_name, final\_name); \}}
\DoxyCodeLine{1029     \}}
\DoxyCodeLine{1030   }
\DoxyCodeLine{1031   \textcolor{keywordflow}{return} save\_okay;}
\DoxyCodeLine{1032   \}}
\DoxyCodeLine{1033 }
\DoxyCodeLine{1034 }
\DoxyCodeLine{1035 }
\DoxyCodeLine{1038 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{1039 \textcolor{keyword}{inline}}
\DoxyCodeLine{1040 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{1041 \mbox{\hyperlink{group__diskio_ga831707949f1f222d23e15603832e079b}{diskio::save\_arma\_binary}}(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& x, std::ostream\& f)}
\DoxyCodeLine{1042   \{}
\DoxyCodeLine{1043   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1044   }
\DoxyCodeLine{1045   f << \mbox{\hyperlink{group__diskio_ga143c823196ccbd640cf831526cd4933e}{diskio::gen\_bin\_header}}(x) << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{1046   f << x.n\_rows << \textcolor{charliteral}{' '} << x.n\_cols << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{1047   }
\DoxyCodeLine{1048   f.write( \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(x.mem), std::streamsize(x.n\_elem*\textcolor{keyword}{sizeof}(eT)) );}
\DoxyCodeLine{1049   }
\DoxyCodeLine{1050   \textcolor{keywordflow}{return} f.good();}
\DoxyCodeLine{1051   \}}
\DoxyCodeLine{1052 }
\DoxyCodeLine{1053 }
\DoxyCodeLine{1054 }
\DoxyCodeLine{1056 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{1057 \textcolor{keyword}{inline}}
\DoxyCodeLine{1058 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{1059 \mbox{\hyperlink{group__diskio_gaa583b747821a55bc3fec6aa95c549ddb}{diskio::save\_pgm\_binary}}(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& x, \textcolor{keyword}{const} std::string\& final\_name)}
\DoxyCodeLine{1060   \{}
\DoxyCodeLine{1061   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1062   }
\DoxyCodeLine{1063   \textcolor{keyword}{const} std::string tmp\_name = \mbox{\hyperlink{group__diskio_gad32fa08afe53746650c31071f88eacab}{diskio::gen\_tmp\_name}}(final\_name);}
\DoxyCodeLine{1064   }
\DoxyCodeLine{1065   std::fstream f(tmp\_name.c\_str(), std::fstream::out | std::fstream::binary);}
\DoxyCodeLine{1066   }
\DoxyCodeLine{1067   \textcolor{keywordtype}{bool} save\_okay = f.is\_open();}
\DoxyCodeLine{1068   }
\DoxyCodeLine{1069   \textcolor{keywordflow}{if}(save\_okay)}
\DoxyCodeLine{1070     \{}
\DoxyCodeLine{1071     save\_okay = \mbox{\hyperlink{group__diskio_gaa583b747821a55bc3fec6aa95c549ddb}{diskio::save\_pgm\_binary}}(x, f);}
\DoxyCodeLine{1072     }
\DoxyCodeLine{1073     f.flush();}
\DoxyCodeLine{1074     f.close();}
\DoxyCodeLine{1075     }
\DoxyCodeLine{1076     \textcolor{keywordflow}{if}(save\_okay)  \{ save\_okay = \mbox{\hyperlink{group__diskio_gafbccd611e1fec1b6044f81460415d8d3}{diskio::safe\_rename}}(tmp\_name, final\_name); \}}
\DoxyCodeLine{1077     \}}
\DoxyCodeLine{1078   }
\DoxyCodeLine{1079   \textcolor{keywordflow}{return} save\_okay;}
\DoxyCodeLine{1080   \}}
\DoxyCodeLine{1081 }
\DoxyCodeLine{1082 }
\DoxyCodeLine{1083 }
\DoxyCodeLine{1084 \textcolor{comment}{//}}
\DoxyCodeLine{1085 \textcolor{comment}{// TODO:}}
\DoxyCodeLine{1086 \textcolor{comment}{// add functionality to save the image in a normalised format,}}
\DoxyCodeLine{1087 \textcolor{comment}{// i.e. scaled so that every value falls in the [0,255] range.}}
\DoxyCodeLine{1088 }
\DoxyCodeLine{1090 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{1091 \textcolor{keyword}{inline}}
\DoxyCodeLine{1092 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{1093 \mbox{\hyperlink{group__diskio_gaa583b747821a55bc3fec6aa95c549ddb}{diskio::save\_pgm\_binary}}(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& x, std::ostream\& f)}
\DoxyCodeLine{1094   \{}
\DoxyCodeLine{1095   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1096   }
\DoxyCodeLine{1097   f << \textcolor{stringliteral}{"{}P5"{}} << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{1098   f << x.n\_cols << \textcolor{charliteral}{' '} << x.n\_rows << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{1099   f << 255 << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{1100   }
\DoxyCodeLine{1101   \textcolor{keyword}{const} uword n\_elem = x.n\_rows * x.n\_cols;}
\DoxyCodeLine{1102   \mbox{\hyperlink{classpodarray}{podarray<u8>}} tmp(n\_elem);}
\DoxyCodeLine{1103   }
\DoxyCodeLine{1104   uword i = 0;}
\DoxyCodeLine{1105   }
\DoxyCodeLine{1106   \textcolor{keywordflow}{for}(uword row=0; row < x.n\_rows; ++row)}
\DoxyCodeLine{1107   \textcolor{keywordflow}{for}(uword col=0; col < x.n\_cols; ++col)}
\DoxyCodeLine{1108     \{}
\DoxyCodeLine{1109     tmp[i] = u8( x.at(row,col) );  \textcolor{comment}{// TODO: add round() ?}}
\DoxyCodeLine{1110     ++i;}
\DoxyCodeLine{1111     \}}
\DoxyCodeLine{1112   }
\DoxyCodeLine{1113   f.write(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(tmp.\mbox{\hyperlink{classpodarray_a3235dffb0bca72b5aa2f6f7d2c696601}{mem}}), std::streamsize(n\_elem) );}
\DoxyCodeLine{1114   }
\DoxyCodeLine{1115   \textcolor{keywordflow}{return} f.good();}
\DoxyCodeLine{1116   \}}
\DoxyCodeLine{1117 }
\DoxyCodeLine{1118 }
\DoxyCodeLine{1119 }
\DoxyCodeLine{1121 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1122 \textcolor{keyword}{inline}}
\DoxyCodeLine{1123 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{1124 \mbox{\hyperlink{group__diskio_gaa583b747821a55bc3fec6aa95c549ddb}{diskio::save\_pgm\_binary}}(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& x, \textcolor{keyword}{const} std::string\& final\_name)}
\DoxyCodeLine{1125   \{}
\DoxyCodeLine{1126   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1127   }
\DoxyCodeLine{1128   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{uchar\_mat}} tmp = \mbox{\hyperlink{classconv__to}{conv\_to<uchar\_mat>::from}}(x);}
\DoxyCodeLine{1129   }
\DoxyCodeLine{1130   \textcolor{keywordflow}{return} \mbox{\hyperlink{group__diskio_gaa583b747821a55bc3fec6aa95c549ddb}{diskio::save\_pgm\_binary}}(tmp, final\_name);}
\DoxyCodeLine{1131   \}}
\DoxyCodeLine{1132 }
\DoxyCodeLine{1133 }
\DoxyCodeLine{1134 }
\DoxyCodeLine{1136 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1137 \textcolor{keyword}{inline}}
\DoxyCodeLine{1138 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{1139 \mbox{\hyperlink{group__diskio_gaa583b747821a55bc3fec6aa95c549ddb}{diskio::save\_pgm\_binary}}(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& x, std::ostream\& f)}
\DoxyCodeLine{1140   \{}
\DoxyCodeLine{1141   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1142   }
\DoxyCodeLine{1143   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{uchar\_mat}} tmp = \mbox{\hyperlink{classconv__to}{conv\_to<uchar\_mat>::from}}(x);}
\DoxyCodeLine{1144   }
\DoxyCodeLine{1145   \textcolor{keywordflow}{return} \mbox{\hyperlink{group__diskio_gaa583b747821a55bc3fec6aa95c549ddb}{diskio::save\_pgm\_binary}}(tmp, f);}
\DoxyCodeLine{1146   \}}
\DoxyCodeLine{1147 }
\DoxyCodeLine{1148 }
\DoxyCodeLine{1149 }
\DoxyCodeLine{1151 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{1152 \textcolor{keyword}{inline} }
\DoxyCodeLine{1153 \textcolor{keywordtype}{bool} }
\DoxyCodeLine{1154 \mbox{\hyperlink{group__diskio_ga03e86aa742db1ee0860e2eee480c0a63}{diskio::save\_hdf5\_binary}}(\textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& x, \textcolor{keyword}{const} \mbox{\hyperlink{structhdf5__name}{hdf5\_name}}\& spec, std::string\& err\_msg)}
\DoxyCodeLine{1155   \{}
\DoxyCodeLine{1156   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1157   }
\DoxyCodeLine{1158 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_HDF5)}}
\DoxyCodeLine{1159     \{}
\DoxyCodeLine{1160     hdf5\_misc::hdf5\_suspend\_printing\_errors hdf5\_print\_suspender;}
\DoxyCodeLine{1161     }
\DoxyCodeLine{1162     \textcolor{keywordtype}{bool} save\_okay = \textcolor{keyword}{false};}
\DoxyCodeLine{1163     }
\DoxyCodeLine{1164     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} append  = bool(spec.opts.flags \& hdf5\_opts::flag\_append);}
\DoxyCodeLine{1165     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} replace = bool(spec.opts.flags \& hdf5\_opts::flag\_replace);}
\DoxyCodeLine{1166     }
\DoxyCodeLine{1167     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_existing\_file = ((append || replace) \&\& (arma\_H5Fis\_hdf5(spec.filename.c\_str()) > 0));}
\DoxyCodeLine{1168     }
\DoxyCodeLine{1169     \textcolor{keyword}{const} std::string tmp\_name = (use\_existing\_file) ? std::string() : \mbox{\hyperlink{group__diskio_gad32fa08afe53746650c31071f88eacab}{diskio::gen\_tmp\_name}}(spec.filename);}
\DoxyCodeLine{1170     }
\DoxyCodeLine{1171     \textcolor{comment}{// Set up the file according to HDF5's preferences}}
\DoxyCodeLine{1172     hid\_t file = (use\_existing\_file) ? arma\_H5Fopen(spec.filename.c\_str(), H5F\_ACC\_RDWR, H5P\_DEFAULT) : arma\_H5Fcreate(tmp\_name.c\_str(), H5F\_ACC\_TRUNC, H5P\_DEFAULT, H5P\_DEFAULT);}
\DoxyCodeLine{1173     }
\DoxyCodeLine{1174     \textcolor{keywordflow}{if}(file < 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1175     }
\DoxyCodeLine{1176     \textcolor{comment}{// We need to create a dataset, datatype, and dataspace}}
\DoxyCodeLine{1177     hsize\_t dims[2];}
\DoxyCodeLine{1178     dims[1] = x.n\_rows;}
\DoxyCodeLine{1179     dims[0] = x.n\_cols;}
\DoxyCodeLine{1180     }
\DoxyCodeLine{1181     hid\_t dataspace = arma\_H5Screate\_simple(2, dims, NULL);   \textcolor{comment}{// treat the matrix as a 2d array dataspace}}
\DoxyCodeLine{1182     hid\_t datatype  = hdf5\_misc::get\_hdf5\_type<eT>();}
\DoxyCodeLine{1183     }
\DoxyCodeLine{1184     \textcolor{comment}{// If this returned something invalid, well, it's time to crash.}}
\DoxyCodeLine{1185     \mbox{\hyperlink{group__debug_ga458beb676810b1e43df9f0668359e76f}{arma\_check}}(datatype == -\/1, \textcolor{stringliteral}{"{}Mat::save(): unknown datatype for HDF5"{}});}
\DoxyCodeLine{1186     }
\DoxyCodeLine{1187     \textcolor{comment}{// MATLAB forces the users to specify a name at save time for HDF5;}}
\DoxyCodeLine{1188     \textcolor{comment}{// Octave will use the default of 'dataset' unless otherwise specified.}}
\DoxyCodeLine{1189     \textcolor{comment}{// If the user hasn't specified a dataset name, we will use 'dataset'}}
\DoxyCodeLine{1190     \textcolor{comment}{// We may have to split out the group name from the dataset name.}}
\DoxyCodeLine{1191     std::vector<hid\_t> groups;}
\DoxyCodeLine{1192     std::string full\_name = spec.dsname;}
\DoxyCodeLine{1193     \textcolor{keywordtype}{size\_t} loc;}
\DoxyCodeLine{1194     \textcolor{keywordflow}{while}((loc = full\_name.find(\textcolor{stringliteral}{"{}/"{}})) != std::string::npos)}
\DoxyCodeLine{1195       \{}
\DoxyCodeLine{1196       \textcolor{comment}{// Create another group...}}
\DoxyCodeLine{1197       \textcolor{keywordflow}{if}(loc != 0) \textcolor{comment}{// Ignore the first /, if there is a leading /.}}
\DoxyCodeLine{1198         \{}
\DoxyCodeLine{1199         hid\_t gid = arma\_H5Gcreate((groups.size() == 0) ? file : groups[groups.size() -\/ 1], full\_name.substr(0, loc).c\_str(), H5P\_DEFAULT, H5P\_DEFAULT, H5P\_DEFAULT);}
\DoxyCodeLine{1200         }
\DoxyCodeLine{1201         \textcolor{keywordflow}{if}((gid < 0) \&\& use\_existing\_file)}
\DoxyCodeLine{1202           \{}
\DoxyCodeLine{1203           gid = arma\_H5Gopen((groups.size() == 0) ? file : groups[groups.size() -\/ 1], full\_name.substr(0, loc).c\_str(), H5P\_DEFAULT);}
\DoxyCodeLine{1204           \}}
\DoxyCodeLine{1205         }
\DoxyCodeLine{1206         groups.push\_back(gid);}
\DoxyCodeLine{1207         \}}
\DoxyCodeLine{1208       }
\DoxyCodeLine{1209       full\_name = full\_name.substr(loc + 1);}
\DoxyCodeLine{1210       \}}
\DoxyCodeLine{1211     }
\DoxyCodeLine{1212     \textcolor{keyword}{const} std::string dataset\_name = full\_name.empty() ? std::string(\textcolor{stringliteral}{"{}dataset"{}}) : full\_name;}
\DoxyCodeLine{1213     }
\DoxyCodeLine{1214     \textcolor{keyword}{const} hid\_t last\_group = (groups.size() == 0) ? file : groups[groups.size() -\/ 1];}
\DoxyCodeLine{1215     }
\DoxyCodeLine{1216     \textcolor{keywordflow}{if}(use\_existing\_file \&\& replace)}
\DoxyCodeLine{1217       \{}
\DoxyCodeLine{1218       arma\_H5Ldelete(last\_group, dataset\_name.c\_str(), H5P\_DEFAULT);}
\DoxyCodeLine{1219       \textcolor{comment}{// NOTE: H5Ldelete() in HDF5 v1.8 doesn't reclaim the deleted space; use h5repack to reclaim space: h5repack oldfile.h5 newfile.h5}}
\DoxyCodeLine{1220       \textcolor{comment}{// NOTE: has this behaviour changed in HDF5 1.10 ?}}
\DoxyCodeLine{1221       \textcolor{comment}{// NOTE: https://lists.hdfgroup.org/pipermail/hdf-\/forum\_lists.hdfgroup.org/2017-\/August/010482.html}}
\DoxyCodeLine{1222       \textcolor{comment}{// NOTE: https://lists.hdfgroup.org/pipermail/hdf-\/forum\_lists.hdfgroup.org/2017-\/August/010486.html}}
\DoxyCodeLine{1223       \}}
\DoxyCodeLine{1224     }
\DoxyCodeLine{1225     hid\_t dataset = arma\_H5Dcreate(last\_group, dataset\_name.c\_str(), datatype, dataspace, H5P\_DEFAULT, H5P\_DEFAULT, H5P\_DEFAULT);}
\DoxyCodeLine{1226     }
\DoxyCodeLine{1227     \textcolor{keywordflow}{if}(dataset < 0)}
\DoxyCodeLine{1228       \{}
\DoxyCodeLine{1229       save\_okay = \textcolor{keyword}{false};}
\DoxyCodeLine{1230       }
\DoxyCodeLine{1231       err\_msg = \textcolor{stringliteral}{"{}couldn't create dataset"{}};}
\DoxyCodeLine{1232       \}}
\DoxyCodeLine{1233     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1234       \{}
\DoxyCodeLine{1235       save\_okay = (arma\_H5Dwrite(dataset, datatype, H5S\_ALL, H5S\_ALL, H5P\_DEFAULT, x.mem) >= 0);}
\DoxyCodeLine{1236       }
\DoxyCodeLine{1237       arma\_H5Dclose(dataset);}
\DoxyCodeLine{1238       \}}
\DoxyCodeLine{1239     }
\DoxyCodeLine{1240     arma\_H5Tclose(datatype);}
\DoxyCodeLine{1241     arma\_H5Sclose(dataspace);}
\DoxyCodeLine{1242     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i = 0; i < groups.size(); ++i)  \{ arma\_H5Gclose(groups[i]); \}}
\DoxyCodeLine{1243     arma\_H5Fclose(file);}
\DoxyCodeLine{1244     }
\DoxyCodeLine{1245     \textcolor{keywordflow}{if}((use\_existing\_file == \textcolor{keyword}{false}) \&\& (save\_okay == \textcolor{keyword}{true}))  \{ save\_okay = \mbox{\hyperlink{group__diskio_gafbccd611e1fec1b6044f81460415d8d3}{diskio::safe\_rename}}(tmp\_name, spec.filename); \}}
\DoxyCodeLine{1246     }
\DoxyCodeLine{1247     \textcolor{keywordflow}{return} save\_okay;}
\DoxyCodeLine{1248     \}}
\DoxyCodeLine{1249 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{1250     \{}
\DoxyCodeLine{1251     arma\_ignore(x);}
\DoxyCodeLine{1252     arma\_ignore(spec);}
\DoxyCodeLine{1253     arma\_ignore(err\_msg);}
\DoxyCodeLine{1254     }
\DoxyCodeLine{1255     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}Mat::save(): use of HDF5 must be enabled"{}});}
\DoxyCodeLine{1256     }
\DoxyCodeLine{1257     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1258     \}}
\DoxyCodeLine{1259 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{1260   \}}
\DoxyCodeLine{1261 }
\DoxyCodeLine{1262 }
\DoxyCodeLine{1263 }
\DoxyCodeLine{1267 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{1268 \textcolor{keyword}{inline}}
\DoxyCodeLine{1269 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{1270 \mbox{\hyperlink{group__diskio_gab4a891389f7af45143d69e1e13e02fde}{diskio::load\_raw\_ascii}}(\mbox{\hyperlink{classMat}{Mat<eT>}}\& x, \textcolor{keyword}{const} std::string\& \mbox{\hyperlink{structname}{name}}, std::string\& err\_msg)}
\DoxyCodeLine{1271   \{}
\DoxyCodeLine{1272   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1273   }
\DoxyCodeLine{1274   std::fstream f;}
\DoxyCodeLine{1275   f.open(\mbox{\hyperlink{structname}{name}}.c\_str(), std::fstream::in);}
\DoxyCodeLine{1276   }
\DoxyCodeLine{1277   \textcolor{keywordtype}{bool} load\_okay = f.is\_open();}
\DoxyCodeLine{1278   }
\DoxyCodeLine{1279   \textcolor{keywordflow}{if}(load\_okay)}
\DoxyCodeLine{1280     \{}
\DoxyCodeLine{1281     load\_okay = \mbox{\hyperlink{group__diskio_gab4a891389f7af45143d69e1e13e02fde}{diskio::load\_raw\_ascii}}(x, f, err\_msg);}
\DoxyCodeLine{1282     f.close();}
\DoxyCodeLine{1283     \}}
\DoxyCodeLine{1284   }
\DoxyCodeLine{1285   \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{1286   \}}
\DoxyCodeLine{1287 }
\DoxyCodeLine{1288 }
\DoxyCodeLine{1289 }
\DoxyCodeLine{1293 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{1294 \textcolor{keyword}{inline}}
\DoxyCodeLine{1295 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{1296 \mbox{\hyperlink{group__diskio_gab4a891389f7af45143d69e1e13e02fde}{diskio::load\_raw\_ascii}}(\mbox{\hyperlink{classMat}{Mat<eT>}}\& x, std::istream\& f, std::string\& err\_msg)}
\DoxyCodeLine{1297   \{}
\DoxyCodeLine{1298   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1299   }
\DoxyCodeLine{1300   \textcolor{keywordtype}{bool} load\_okay = f.good();}
\DoxyCodeLine{1301   }
\DoxyCodeLine{1302   f.clear();}
\DoxyCodeLine{1303   \textcolor{keyword}{const} std::fstream::pos\_type pos1 = f.tellg();}
\DoxyCodeLine{1304   }
\DoxyCodeLine{1305   \textcolor{comment}{//}}
\DoxyCodeLine{1306   \textcolor{comment}{// work out the size}}
\DoxyCodeLine{1307   }
\DoxyCodeLine{1308   uword f\_n\_rows = 0;}
\DoxyCodeLine{1309   uword f\_n\_cols = 0;}
\DoxyCodeLine{1310   }
\DoxyCodeLine{1311   \textcolor{keywordtype}{bool} f\_n\_cols\_found = \textcolor{keyword}{false};}
\DoxyCodeLine{1312   }
\DoxyCodeLine{1313   std::string       line\_string;}
\DoxyCodeLine{1314   std::stringstream line\_stream;}
\DoxyCodeLine{1315   }
\DoxyCodeLine{1316   std::string token;}
\DoxyCodeLine{1317   }
\DoxyCodeLine{1318   \textcolor{keywordflow}{while}( f.good() \&\& load\_okay )}
\DoxyCodeLine{1319     \{}
\DoxyCodeLine{1320     std::getline(f, line\_string);}
\DoxyCodeLine{1321     }
\DoxyCodeLine{1322     \textcolor{comment}{// TODO: does it make sense to stop processing the file if an empty line is found ?}}
\DoxyCodeLine{1323     \textcolor{keywordflow}{if}(line\_string.size() == 0)  \{ \textcolor{keywordflow}{break}; \}}
\DoxyCodeLine{1324     }
\DoxyCodeLine{1325     line\_stream.clear();}
\DoxyCodeLine{1326     line\_stream.str(line\_string);}
\DoxyCodeLine{1327     }
\DoxyCodeLine{1328     uword line\_n\_cols = 0;}
\DoxyCodeLine{1329     }
\DoxyCodeLine{1330     \textcolor{keywordflow}{while}(line\_stream >> token)  \{ ++line\_n\_cols; \}}
\DoxyCodeLine{1331     }
\DoxyCodeLine{1332     \textcolor{keywordflow}{if}(f\_n\_cols\_found == \textcolor{keyword}{false})}
\DoxyCodeLine{1333       \{}
\DoxyCodeLine{1334       f\_n\_cols       = line\_n\_cols;}
\DoxyCodeLine{1335       f\_n\_cols\_found = \textcolor{keyword}{true};}
\DoxyCodeLine{1336       \}}
\DoxyCodeLine{1337     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1338       \{}
\DoxyCodeLine{1339       \textcolor{keywordflow}{if}(line\_n\_cols != f\_n\_cols)}
\DoxyCodeLine{1340         \{}
\DoxyCodeLine{1341         load\_okay = \textcolor{keyword}{false};}
\DoxyCodeLine{1342         err\_msg = \textcolor{stringliteral}{"{}inconsistent number of columns"{}};}
\DoxyCodeLine{1343         \}}
\DoxyCodeLine{1344       \}}
\DoxyCodeLine{1345     }
\DoxyCodeLine{1346     ++f\_n\_rows;}
\DoxyCodeLine{1347     \}}
\DoxyCodeLine{1348   }
\DoxyCodeLine{1349   }
\DoxyCodeLine{1350   \textcolor{keywordflow}{if}(load\_okay)}
\DoxyCodeLine{1351     \{}
\DoxyCodeLine{1352     f.clear();}
\DoxyCodeLine{1353     f.seekg(pos1);}
\DoxyCodeLine{1354     }
\DoxyCodeLine{1355     \textcolor{keywordflow}{try} \{ x.set\_size(f\_n\_rows, f\_n\_cols); \} \textcolor{keywordflow}{catch}(...) \{ err\_msg = \textcolor{stringliteral}{"{}not enough memory"{}}; \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1356     }
\DoxyCodeLine{1357     \textcolor{keywordflow}{for}(uword row=0; ((row < x.n\_rows) \&\& load\_okay); ++row)}
\DoxyCodeLine{1358     \textcolor{keywordflow}{for}(uword col=0; ((col < x.n\_cols) \&\& load\_okay); ++col)}
\DoxyCodeLine{1359       \{}
\DoxyCodeLine{1360       f >> token;}
\DoxyCodeLine{1361       }
\DoxyCodeLine{1362       \textcolor{keywordflow}{if}(diskio::convert\_token(x.at(row,col), token) == \textcolor{keyword}{false})}
\DoxyCodeLine{1363         \{}
\DoxyCodeLine{1364         load\_okay = \textcolor{keyword}{false};}
\DoxyCodeLine{1365         err\_msg = \textcolor{stringliteral}{"{}couldn't interpret data"{}};}
\DoxyCodeLine{1366         \}}
\DoxyCodeLine{1367       \}}
\DoxyCodeLine{1368     \}}
\DoxyCodeLine{1369   }
\DoxyCodeLine{1370   }
\DoxyCodeLine{1371   \textcolor{comment}{// an empty file indicates an empty matrix}}
\DoxyCodeLine{1372   \textcolor{keywordflow}{if}( (f\_n\_cols\_found == \textcolor{keyword}{false}) \&\& (load\_okay == \textcolor{keyword}{true}) )  \{ x.reset(); \}}
\DoxyCodeLine{1373   }
\DoxyCodeLine{1374   }
\DoxyCodeLine{1375   \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{1376   \}}
\DoxyCodeLine{1377 }
\DoxyCodeLine{1378 }
\DoxyCodeLine{1379 }
\DoxyCodeLine{1382 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{1383 \textcolor{keyword}{inline}}
\DoxyCodeLine{1384 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{1385 \mbox{\hyperlink{group__diskio_ga758d71eceff8f867d38619aa52ddf40b}{diskio::load\_raw\_binary}}(\mbox{\hyperlink{classMat}{Mat<eT>}}\& x, \textcolor{keyword}{const} std::string\& \mbox{\hyperlink{structname}{name}}, std::string\& err\_msg)}
\DoxyCodeLine{1386   \{}
\DoxyCodeLine{1387   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1388   }
\DoxyCodeLine{1389   std::ifstream f;}
\DoxyCodeLine{1390   f.open(\mbox{\hyperlink{structname}{name}}.c\_str(), std::fstream::binary);}
\DoxyCodeLine{1391   }
\DoxyCodeLine{1392   \textcolor{keywordtype}{bool} load\_okay = f.is\_open();}
\DoxyCodeLine{1393   }
\DoxyCodeLine{1394   \textcolor{keywordflow}{if}(load\_okay)}
\DoxyCodeLine{1395     \{}
\DoxyCodeLine{1396     load\_okay = \mbox{\hyperlink{group__diskio_ga758d71eceff8f867d38619aa52ddf40b}{diskio::load\_raw\_binary}}(x, f, err\_msg);}
\DoxyCodeLine{1397     f.close();}
\DoxyCodeLine{1398     \}}
\DoxyCodeLine{1399   }
\DoxyCodeLine{1400   \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{1401   \}}
\DoxyCodeLine{1402 }
\DoxyCodeLine{1403 }
\DoxyCodeLine{1404 }
\DoxyCodeLine{1405 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{1406 \textcolor{keyword}{inline}}
\DoxyCodeLine{1407 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{1408 \mbox{\hyperlink{group__diskio_ga758d71eceff8f867d38619aa52ddf40b}{diskio::load\_raw\_binary}}(\mbox{\hyperlink{classMat}{Mat<eT>}}\& x, std::istream\& f, std::string\& err\_msg)}
\DoxyCodeLine{1409   \{}
\DoxyCodeLine{1410   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1411   }
\DoxyCodeLine{1412   f.clear();}
\DoxyCodeLine{1413   \textcolor{keyword}{const} std::streampos pos1 = f.tellg();}
\DoxyCodeLine{1414   }
\DoxyCodeLine{1415   f.clear();}
\DoxyCodeLine{1416   f.seekg(0, ios::end);}
\DoxyCodeLine{1417 }
\DoxyCodeLine{1418   f.clear();}
\DoxyCodeLine{1419   \textcolor{keyword}{const} std::streampos pos2 = f.tellg();}
\DoxyCodeLine{1420   }
\DoxyCodeLine{1421   \textcolor{keyword}{const} uword N = ( (pos1 >= 0) \&\& (pos2 >= 0) ) ? uword(pos2 -\/ pos1) : 0;}
\DoxyCodeLine{1422   }
\DoxyCodeLine{1423   f.clear();}
\DoxyCodeLine{1424   \textcolor{comment}{//f.seekg(0, ios::beg);}}
\DoxyCodeLine{1425   f.seekg(pos1);}
\DoxyCodeLine{1426   }
\DoxyCodeLine{1427   \textcolor{keywordflow}{try} \{ x.set\_size(N / uword(\textcolor{keyword}{sizeof}(eT)), 1); \} \textcolor{keywordflow}{catch}(...) \{ err\_msg = \textcolor{stringliteral}{"{}not enough memory"{}}; \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1428   }
\DoxyCodeLine{1429   f.clear();}
\DoxyCodeLine{1430   f.read( \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char} *\textcolor{keyword}{>}(x.memptr()), std::streamsize(x.n\_elem * uword(\textcolor{keyword}{sizeof}(eT))) );}
\DoxyCodeLine{1431   }
\DoxyCodeLine{1432   \textcolor{keywordflow}{return} f.good();}
\DoxyCodeLine{1433   \}}
\DoxyCodeLine{1434 }
\DoxyCodeLine{1435 }
\DoxyCodeLine{1436 }
\DoxyCodeLine{1439 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{1440 \textcolor{keyword}{inline}}
\DoxyCodeLine{1441 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{1442 \mbox{\hyperlink{group__diskio_ga84c9da5c70180743ecc7918230a06d98}{diskio::load\_arma\_ascii}}(\mbox{\hyperlink{classMat}{Mat<eT>}}\& x, \textcolor{keyword}{const} std::string\& \mbox{\hyperlink{structname}{name}}, std::string\& err\_msg)}
\DoxyCodeLine{1443   \{}
\DoxyCodeLine{1444   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1445   }
\DoxyCodeLine{1446   std::ifstream f(\mbox{\hyperlink{structname}{name}}.c\_str());}
\DoxyCodeLine{1447   }
\DoxyCodeLine{1448   \textcolor{keywordtype}{bool} load\_okay = f.is\_open();}
\DoxyCodeLine{1449   }
\DoxyCodeLine{1450   \textcolor{keywordflow}{if}(load\_okay)}
\DoxyCodeLine{1451     \{}
\DoxyCodeLine{1452     load\_okay = \mbox{\hyperlink{group__diskio_ga84c9da5c70180743ecc7918230a06d98}{diskio::load\_arma\_ascii}}(x, f, err\_msg);}
\DoxyCodeLine{1453     f.close();}
\DoxyCodeLine{1454     \}}
\DoxyCodeLine{1455   }
\DoxyCodeLine{1456   \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{1457   \}}
\DoxyCodeLine{1458 }
\DoxyCodeLine{1459 }
\DoxyCodeLine{1460 }
\DoxyCodeLine{1463 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{1464 \textcolor{keyword}{inline}}
\DoxyCodeLine{1465 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{1466 \mbox{\hyperlink{group__diskio_ga84c9da5c70180743ecc7918230a06d98}{diskio::load\_arma\_ascii}}(\mbox{\hyperlink{classMat}{Mat<eT>}}\& x, std::istream\& f, std::string\& err\_msg)}
\DoxyCodeLine{1467   \{}
\DoxyCodeLine{1468   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1469   }
\DoxyCodeLine{1470   std::streampos pos = f.tellg();}
\DoxyCodeLine{1471   }
\DoxyCodeLine{1472   \textcolor{keywordtype}{bool} load\_okay = \textcolor{keyword}{true};}
\DoxyCodeLine{1473   }
\DoxyCodeLine{1474   std::string f\_header;}
\DoxyCodeLine{1475   uword       f\_n\_rows;}
\DoxyCodeLine{1476   uword       f\_n\_cols;}
\DoxyCodeLine{1477   }
\DoxyCodeLine{1478   f >> f\_header;}
\DoxyCodeLine{1479   f >> f\_n\_rows;}
\DoxyCodeLine{1480   f >> f\_n\_cols;}
\DoxyCodeLine{1481   }
\DoxyCodeLine{1482   \textcolor{keywordflow}{if}(f\_header == \mbox{\hyperlink{group__diskio_ga7adb78317f164fa19978566b3bf3f216}{diskio::gen\_txt\_header}}(x))}
\DoxyCodeLine{1483     \{}
\DoxyCodeLine{1484     \textcolor{keywordflow}{try} \{ x.zeros(f\_n\_rows, f\_n\_cols); \} \textcolor{keywordflow}{catch}(...) \{ err\_msg = \textcolor{stringliteral}{"{}not enough memory"{}}; \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1485     }
\DoxyCodeLine{1486     std::string token;}
\DoxyCodeLine{1487     }
\DoxyCodeLine{1488     \textcolor{keywordflow}{for}(uword row=0; row < x.n\_rows; ++row)}
\DoxyCodeLine{1489     \textcolor{keywordflow}{for}(uword col=0; col < x.n\_cols; ++col)}
\DoxyCodeLine{1490       \{}
\DoxyCodeLine{1491       f >> token;}
\DoxyCodeLine{1492       }
\DoxyCodeLine{1493       diskio::convert\_token( x.at(row,col), token );}
\DoxyCodeLine{1494       \}}
\DoxyCodeLine{1495     }
\DoxyCodeLine{1496     load\_okay = f.good();}
\DoxyCodeLine{1497     \}}
\DoxyCodeLine{1498   \textcolor{keywordflow}{else}}
\DoxyCodeLine{1499     \{}
\DoxyCodeLine{1500     load\_okay = \textcolor{keyword}{false};}
\DoxyCodeLine{1501     err\_msg = \textcolor{stringliteral}{"{}incorrect header"{}};}
\DoxyCodeLine{1502     \}}
\DoxyCodeLine{1503   }
\DoxyCodeLine{1504   }
\DoxyCodeLine{1505   \textcolor{comment}{// allow automatic conversion of u32/s32 matrices into u64/s64 matrices}}
\DoxyCodeLine{1506   }
\DoxyCodeLine{1507   \textcolor{keywordflow}{if}(load\_okay == \textcolor{keyword}{false})}
\DoxyCodeLine{1508     \{}
\DoxyCodeLine{1509     \textcolor{keywordflow}{if}( (\textcolor{keyword}{sizeof}(eT) == 8) \&\& \mbox{\hyperlink{structis__same__type}{is\_same\_type<uword,eT>::yes}} )}
\DoxyCodeLine{1510       \{}
\DoxyCodeLine{1511       \mbox{\hyperlink{classMat}{Mat<u32>}}    tmp;}
\DoxyCodeLine{1512       std::string junk;}
\DoxyCodeLine{1513       }
\DoxyCodeLine{1514       f.\mbox{\hyperlink{group__Mat_ga3dbb05713ff59d9e4dc6e9381f84ff03}{clear}}();}
\DoxyCodeLine{1515       f.seekg(pos);}
\DoxyCodeLine{1516       }
\DoxyCodeLine{1517       load\_okay = \mbox{\hyperlink{group__diskio_ga84c9da5c70180743ecc7918230a06d98}{diskio::load\_arma\_ascii}}(tmp, f, junk);}
\DoxyCodeLine{1518       }
\DoxyCodeLine{1519       \textcolor{keywordflow}{if}(load\_okay)  \{ x = \mbox{\hyperlink{classconv__to}{conv\_to< Mat<eT>}} >::from(tmp); \}}
\DoxyCodeLine{1520       \}}
\DoxyCodeLine{1521     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1522     \textcolor{keywordflow}{if}( (\textcolor{keyword}{sizeof}(eT) == 8) \&\& \mbox{\hyperlink{structis__same__type}{is\_same\_type<sword,eT>::yes}} )}
\DoxyCodeLine{1523       \{}
\DoxyCodeLine{1524       \mbox{\hyperlink{classMat}{Mat<s32>}}    tmp;}
\DoxyCodeLine{1525       std::string junk;}
\DoxyCodeLine{1526       }
\DoxyCodeLine{1527       f.\mbox{\hyperlink{group__Mat_ga3dbb05713ff59d9e4dc6e9381f84ff03}{clear}}();}
\DoxyCodeLine{1528       f.seekg(pos);}
\DoxyCodeLine{1529       }
\DoxyCodeLine{1530       load\_okay = \mbox{\hyperlink{group__diskio_ga84c9da5c70180743ecc7918230a06d98}{diskio::load\_arma\_ascii}}(tmp, f, junk);}
\DoxyCodeLine{1531       }
\DoxyCodeLine{1532       \textcolor{keywordflow}{if}(load\_okay)  \{ x = \mbox{\hyperlink{classconv__to}{conv\_to< Mat<eT>}} >::from(tmp); \}}
\DoxyCodeLine{1533       \}}
\DoxyCodeLine{1534     \}}
\DoxyCodeLine{1535   }
\DoxyCodeLine{1536   \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{1537   \}}
\DoxyCodeLine{1538 }
\DoxyCodeLine{1539 }
\DoxyCodeLine{1540 }
\DoxyCodeLine{1542 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{1543 \textcolor{keyword}{inline}}
\DoxyCodeLine{1544 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{1545 \mbox{\hyperlink{group__diskio_gae8a45a3f816b0b5b1e699d3d9f309491}{diskio::load\_csv\_ascii}}(\mbox{\hyperlink{classMat}{Mat<eT>}}\& x, \textcolor{keyword}{const} std::string\& \mbox{\hyperlink{structname}{name}}, std::string\& err\_msg, \mbox{\hyperlink{classfield}{field<std::string>}}\& header, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} with\_header)}
\DoxyCodeLine{1546   \{}
\DoxyCodeLine{1547   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1548   }
\DoxyCodeLine{1549   std::fstream f;}
\DoxyCodeLine{1550   f.open(\mbox{\hyperlink{structname}{name}}.c\_str(), std::fstream::in);}
\DoxyCodeLine{1551   }
\DoxyCodeLine{1552   \textcolor{keywordtype}{bool} load\_okay = f.is\_open();}
\DoxyCodeLine{1553   }
\DoxyCodeLine{1554   \textcolor{keywordflow}{if}(load\_okay == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1555   }
\DoxyCodeLine{1556   \textcolor{keywordflow}{if}(with\_header)}
\DoxyCodeLine{1557     \{}
\DoxyCodeLine{1558     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}diskio::load\_csv\_ascii(): reading header"{}});}
\DoxyCodeLine{1559     }
\DoxyCodeLine{1560     std::string              header\_line;}
\DoxyCodeLine{1561     std::stringstream        header\_stream;}
\DoxyCodeLine{1562     std::vector<std::string> header\_tokens;}
\DoxyCodeLine{1563     }
\DoxyCodeLine{1564     std::getline(f, header\_line);}
\DoxyCodeLine{1565     }
\DoxyCodeLine{1566     load\_okay = f.good();}
\DoxyCodeLine{1567     }
\DoxyCodeLine{1568     \textcolor{keywordflow}{if}(load\_okay)}
\DoxyCodeLine{1569       \{}
\DoxyCodeLine{1570       std::string token;}
\DoxyCodeLine{1571       }
\DoxyCodeLine{1572       header\_stream.clear();}
\DoxyCodeLine{1573       header\_stream.str(header\_line);}
\DoxyCodeLine{1574       }
\DoxyCodeLine{1575       uword header\_n\_tokens = 0;}
\DoxyCodeLine{1576       }
\DoxyCodeLine{1577       \textcolor{keywordflow}{while}(header\_stream.good())}
\DoxyCodeLine{1578         \{}
\DoxyCodeLine{1579         std::getline(header\_stream, token, \textcolor{charliteral}{','});}
\DoxyCodeLine{1580         ++header\_n\_tokens;}
\DoxyCodeLine{1581         header\_tokens.push\_back(token);}
\DoxyCodeLine{1582         \}}
\DoxyCodeLine{1583       }
\DoxyCodeLine{1584       \textcolor{keywordflow}{if}(header\_n\_tokens == uword(0))}
\DoxyCodeLine{1585         \{}
\DoxyCodeLine{1586         header.\mbox{\hyperlink{group__field_gac9dc9ea2b0eb588746b147e2e25d48db}{reset}}();}
\DoxyCodeLine{1587         \}}
\DoxyCodeLine{1588       \textcolor{keywordflow}{else}}
\DoxyCodeLine{1589         \{}
\DoxyCodeLine{1590         header.\mbox{\hyperlink{group__field_ga0d8cc9b33d72bd17c62f4492f0459ec8}{set\_size}}(1,header\_n\_tokens);}
\DoxyCodeLine{1591         }
\DoxyCodeLine{1592         \textcolor{keywordflow}{for}(uword i=0; i < header\_n\_tokens; ++i)  \{ header.\mbox{\hyperlink{group__field_gad86418c0a65bb58844812b995560cffe}{at}}(i) = header\_tokens[i]; \}}
\DoxyCodeLine{1593         \}}
\DoxyCodeLine{1594       \}}
\DoxyCodeLine{1595     \}}
\DoxyCodeLine{1596   }
\DoxyCodeLine{1597   \textcolor{keywordflow}{if}(load\_okay)}
\DoxyCodeLine{1598     \{}
\DoxyCodeLine{1599     load\_okay = \mbox{\hyperlink{group__diskio_gae8a45a3f816b0b5b1e699d3d9f309491}{diskio::load\_csv\_ascii}}(x, f, err\_msg);}
\DoxyCodeLine{1600     \}}
\DoxyCodeLine{1601   }
\DoxyCodeLine{1602   f.close();}
\DoxyCodeLine{1603   }
\DoxyCodeLine{1604   \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{1605   \}}
\DoxyCodeLine{1606 }
\DoxyCodeLine{1607 }
\DoxyCodeLine{1608 }
\DoxyCodeLine{1610 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{1611 \textcolor{keyword}{inline}}
\DoxyCodeLine{1612 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{1613 \mbox{\hyperlink{group__diskio_gae8a45a3f816b0b5b1e699d3d9f309491}{diskio::load\_csv\_ascii}}(\mbox{\hyperlink{classMat}{Mat<eT>}}\& x, std::istream\& f, std::string\& err\_msg)}
\DoxyCodeLine{1614   \{}
\DoxyCodeLine{1615   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1616   }
\DoxyCodeLine{1617   \textcolor{comment}{// TODO: replace with more efficient implementation}}
\DoxyCodeLine{1618   }
\DoxyCodeLine{1619   \textcolor{keywordflow}{if}(f.good() == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1620   }
\DoxyCodeLine{1621   f.clear();}
\DoxyCodeLine{1622   \textcolor{keyword}{const} std::fstream::pos\_type pos1 = f.tellg();}
\DoxyCodeLine{1623   }
\DoxyCodeLine{1624   \textcolor{comment}{//}}
\DoxyCodeLine{1625   \textcolor{comment}{// work out the size}}
\DoxyCodeLine{1626   }
\DoxyCodeLine{1627   uword f\_n\_rows = 0;}
\DoxyCodeLine{1628   uword f\_n\_cols = 0;}
\DoxyCodeLine{1629   }
\DoxyCodeLine{1630   std::string       line\_string;}
\DoxyCodeLine{1631   std::stringstream line\_stream;}
\DoxyCodeLine{1632   }
\DoxyCodeLine{1633   std::string token;}
\DoxyCodeLine{1634   }
\DoxyCodeLine{1635   \textcolor{keywordflow}{while}(f.good())}
\DoxyCodeLine{1636     \{}
\DoxyCodeLine{1637     std::getline(f, line\_string);}
\DoxyCodeLine{1638     }
\DoxyCodeLine{1639     \textcolor{keywordflow}{if}(line\_string.size() == 0)  \{ \textcolor{keywordflow}{break}; \}}
\DoxyCodeLine{1640     }
\DoxyCodeLine{1641     line\_stream.clear();}
\DoxyCodeLine{1642     line\_stream.str(line\_string);}
\DoxyCodeLine{1643     }
\DoxyCodeLine{1644     uword line\_n\_cols = 0;}
\DoxyCodeLine{1645     }
\DoxyCodeLine{1646     \textcolor{keywordflow}{while}(line\_stream.good())}
\DoxyCodeLine{1647       \{}
\DoxyCodeLine{1648       std::getline(line\_stream, token, \textcolor{charliteral}{','});}
\DoxyCodeLine{1649       ++line\_n\_cols;}
\DoxyCodeLine{1650       \}}
\DoxyCodeLine{1651     }
\DoxyCodeLine{1652     \textcolor{keywordflow}{if}(f\_n\_cols < line\_n\_cols)  \{ f\_n\_cols = line\_n\_cols; \}}
\DoxyCodeLine{1653     }
\DoxyCodeLine{1654     ++f\_n\_rows;}
\DoxyCodeLine{1655     \}}
\DoxyCodeLine{1656   }
\DoxyCodeLine{1657   f.clear();}
\DoxyCodeLine{1658   f.seekg(pos1);}
\DoxyCodeLine{1659   }
\DoxyCodeLine{1660   \textcolor{keywordflow}{try} \{ x.zeros(f\_n\_rows, f\_n\_cols); \} \textcolor{keywordflow}{catch}(...) \{ err\_msg = \textcolor{stringliteral}{"{}not enough memory"{}}; \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1661   }
\DoxyCodeLine{1662   uword row = 0;}
\DoxyCodeLine{1663   }
\DoxyCodeLine{1664   \textcolor{keywordflow}{while}(f.good())}
\DoxyCodeLine{1665     \{}
\DoxyCodeLine{1666     std::getline(f, line\_string);}
\DoxyCodeLine{1667     }
\DoxyCodeLine{1668     \textcolor{keywordflow}{if}(line\_string.size() == 0)  \{ \textcolor{keywordflow}{break}; \}}
\DoxyCodeLine{1669     }
\DoxyCodeLine{1670     line\_stream.clear();}
\DoxyCodeLine{1671     line\_stream.str(line\_string);}
\DoxyCodeLine{1672     }
\DoxyCodeLine{1673     uword col = 0;}
\DoxyCodeLine{1674     }
\DoxyCodeLine{1675     \textcolor{keywordflow}{while}(line\_stream.good())}
\DoxyCodeLine{1676       \{}
\DoxyCodeLine{1677       std::getline(line\_stream, token, \textcolor{charliteral}{','});}
\DoxyCodeLine{1678       }
\DoxyCodeLine{1679       diskio::convert\_token( x.at(row,col), token );}
\DoxyCodeLine{1680       }
\DoxyCodeLine{1681       ++col;}
\DoxyCodeLine{1682       \}}
\DoxyCodeLine{1683     }
\DoxyCodeLine{1684     ++row;}
\DoxyCodeLine{1685     \}}
\DoxyCodeLine{1686   }
\DoxyCodeLine{1687   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1688   \}}
\DoxyCodeLine{1689 }
\DoxyCodeLine{1690 }
\DoxyCodeLine{1691 }
\DoxyCodeLine{1693 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1694 \textcolor{keyword}{inline}}
\DoxyCodeLine{1695 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{1696 \mbox{\hyperlink{group__diskio_gae8a45a3f816b0b5b1e699d3d9f309491}{diskio::load\_csv\_ascii}}(\mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& x, std::istream\& f, std::string\& err\_msg)}
\DoxyCodeLine{1697   \{}
\DoxyCodeLine{1698   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1699   }
\DoxyCodeLine{1700   \textcolor{comment}{// TODO: replace with more efficient implementation}}
\DoxyCodeLine{1701   }
\DoxyCodeLine{1702   \textcolor{keywordflow}{if}(f.good() == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1703   }
\DoxyCodeLine{1704   f.clear();}
\DoxyCodeLine{1705   \textcolor{keyword}{const} std::fstream::pos\_type pos1 = f.tellg();}
\DoxyCodeLine{1706   }
\DoxyCodeLine{1707   \textcolor{comment}{//}}
\DoxyCodeLine{1708   \textcolor{comment}{// work out the size}}
\DoxyCodeLine{1709   }
\DoxyCodeLine{1710   uword f\_n\_rows = 0;}
\DoxyCodeLine{1711   uword f\_n\_cols = 0;}
\DoxyCodeLine{1712   }
\DoxyCodeLine{1713   std::string       line\_string;}
\DoxyCodeLine{1714   std::stringstream line\_stream;}
\DoxyCodeLine{1715   }
\DoxyCodeLine{1716   std::string token;}
\DoxyCodeLine{1717   }
\DoxyCodeLine{1718   \textcolor{keywordflow}{while}(f.good())}
\DoxyCodeLine{1719     \{}
\DoxyCodeLine{1720     std::getline(f, line\_string);}
\DoxyCodeLine{1721     }
\DoxyCodeLine{1722     \textcolor{keywordflow}{if}(line\_string.size() == 0)  \{ \textcolor{keywordflow}{break}; \}}
\DoxyCodeLine{1723     }
\DoxyCodeLine{1724     line\_stream.clear();}
\DoxyCodeLine{1725     line\_stream.str(line\_string);}
\DoxyCodeLine{1726     }
\DoxyCodeLine{1727     uword line\_n\_cols = 0;}
\DoxyCodeLine{1728     }
\DoxyCodeLine{1729     \textcolor{keywordflow}{while}(line\_stream.good())}
\DoxyCodeLine{1730       \{}
\DoxyCodeLine{1731       std::getline(line\_stream, token, \textcolor{charliteral}{','});}
\DoxyCodeLine{1732       ++line\_n\_cols;}
\DoxyCodeLine{1733       \}}
\DoxyCodeLine{1734     }
\DoxyCodeLine{1735     \textcolor{keywordflow}{if}(f\_n\_cols < line\_n\_cols)  \{ f\_n\_cols = line\_n\_cols; \}}
\DoxyCodeLine{1736     }
\DoxyCodeLine{1737     ++f\_n\_rows;}
\DoxyCodeLine{1738     \}}
\DoxyCodeLine{1739   }
\DoxyCodeLine{1740   f.clear();}
\DoxyCodeLine{1741   f.seekg(pos1);}
\DoxyCodeLine{1742   }
\DoxyCodeLine{1743   \textcolor{keywordflow}{try} \{ x.zeros(f\_n\_rows, f\_n\_cols); \} \textcolor{keywordflow}{catch}(...) \{ err\_msg = \textcolor{stringliteral}{"{}not enough memory"{}}; \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1744   }
\DoxyCodeLine{1745   uword row = 0;}
\DoxyCodeLine{1746   }
\DoxyCodeLine{1747   std::string str\_real;}
\DoxyCodeLine{1748   std::string str\_imag;}
\DoxyCodeLine{1749   }
\DoxyCodeLine{1750   \textcolor{keywordflow}{while}(f.good())}
\DoxyCodeLine{1751     \{}
\DoxyCodeLine{1752     std::getline(f, line\_string);}
\DoxyCodeLine{1753     }
\DoxyCodeLine{1754     \textcolor{keywordflow}{if}(line\_string.size() == 0)  \{ \textcolor{keywordflow}{break}; \}}
\DoxyCodeLine{1755     }
\DoxyCodeLine{1756     line\_stream.clear();}
\DoxyCodeLine{1757     line\_stream.str(line\_string);}
\DoxyCodeLine{1758     }
\DoxyCodeLine{1759     uword col = 0;}
\DoxyCodeLine{1760     }
\DoxyCodeLine{1761     \textcolor{keywordflow}{while}(line\_stream.good())}
\DoxyCodeLine{1762       \{}
\DoxyCodeLine{1763       std::getline(line\_stream, token, \textcolor{charliteral}{','});}
\DoxyCodeLine{1764       }
\DoxyCodeLine{1765       \textcolor{comment}{// remove spaces and tabs}}
\DoxyCodeLine{1766       \textcolor{keywordflow}{if}(token.length() > 0)}
\DoxyCodeLine{1767         \{}
\DoxyCodeLine{1768         \textcolor{keyword}{const} \textcolor{keywordtype}{char} c\_front = token.front();}
\DoxyCodeLine{1769         \textcolor{keyword}{const} \textcolor{keywordtype}{char} c\_back  = token.back();}
\DoxyCodeLine{1770         }
\DoxyCodeLine{1771         \textcolor{keywordflow}{if}( (c\_front == \textcolor{charliteral}{' '}) || (c\_front == \textcolor{charliteral}{'\(\backslash\)t'}) || (c\_back == \textcolor{charliteral}{' '}) || (c\_back == \textcolor{charliteral}{'\(\backslash\)t'}) )}
\DoxyCodeLine{1772           \{}
\DoxyCodeLine{1773           token.erase(std::remove\_if(token.begin(), token.end(), [](\textcolor{keywordtype}{char} c) \{ return ((c == \textcolor{stringliteral}{' '}) || (c == \textcolor{stringliteral}{'\(\backslash\)t'})); \}), token.end());}
\DoxyCodeLine{1774           \}}
\DoxyCodeLine{1775         \}}
\DoxyCodeLine{1776       }
\DoxyCodeLine{1777       \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} token\_len = size\_t( token.length() );}
\DoxyCodeLine{1778       }
\DoxyCodeLine{1779       \textcolor{keywordflow}{if}(token\_len == 0)  \{ col++; \textcolor{keywordflow}{continue}; \}}
\DoxyCodeLine{1780       }
\DoxyCodeLine{1781       \textcolor{comment}{// handle special cases: inf and nan, without the imaginary part}}
\DoxyCodeLine{1782       \textcolor{keywordflow}{if}( (token\_len == 3) || (token\_len == 4) )}
\DoxyCodeLine{1783         \{}
\DoxyCodeLine{1784         \textcolor{keyword}{const} \textcolor{keywordtype}{char}* \mbox{\hyperlink{classstr}{str}} = token.c\_str();}
\DoxyCodeLine{1785         }
\DoxyCodeLine{1786         \textcolor{keyword}{const} \textcolor{keywordtype}{bool} neg = (\mbox{\hyperlink{classstr}{str}}[0] == \textcolor{charliteral}{'-\/'});}
\DoxyCodeLine{1787         \textcolor{keyword}{const} \textcolor{keywordtype}{bool} pos = (\mbox{\hyperlink{classstr}{str}}[0] == \textcolor{charliteral}{'+'});}
\DoxyCodeLine{1788         }
\DoxyCodeLine{1789         \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} offset = ( (neg || pos) \&\& (token\_len == 4) ) ? 1 : 0;}
\DoxyCodeLine{1790         }
\DoxyCodeLine{1791         \textcolor{keyword}{const} \textcolor{keywordtype}{char} sig\_a = \mbox{\hyperlink{classstr}{str}}[offset  ];}
\DoxyCodeLine{1792         \textcolor{keyword}{const} \textcolor{keywordtype}{char} sig\_b = \mbox{\hyperlink{classstr}{str}}[offset+1];}
\DoxyCodeLine{1793         \textcolor{keyword}{const} \textcolor{keywordtype}{char} sig\_c = \mbox{\hyperlink{classstr}{str}}[offset+2];}
\DoxyCodeLine{1794         }
\DoxyCodeLine{1795         \textcolor{keywordtype}{bool} found\_val\_real = \textcolor{keyword}{false};}
\DoxyCodeLine{1796         T          val\_real = T(0);}
\DoxyCodeLine{1797         }
\DoxyCodeLine{1798         \textcolor{keywordflow}{if}( ((sig\_a == \textcolor{charliteral}{'i'}) || (sig\_a == \textcolor{charliteral}{'I'})) \&\& ((sig\_b == \textcolor{charliteral}{'n'}) || (sig\_b == \textcolor{charliteral}{'N'})) \&\& ((sig\_c == \textcolor{charliteral}{'f'}) || (sig\_c == \textcolor{charliteral}{'F'})) )}
\DoxyCodeLine{1799           \{}
\DoxyCodeLine{1800           val\_real = (neg) ? -\/(\mbox{\hyperlink{classDatum}{Datum<T>::inf}}) : \mbox{\hyperlink{classDatum}{Datum<T>::inf}};}
\DoxyCodeLine{1801           }
\DoxyCodeLine{1802           found\_val\_real = \textcolor{keyword}{true};}
\DoxyCodeLine{1803           \}}
\DoxyCodeLine{1804         \textcolor{keywordflow}{else}}
\DoxyCodeLine{1805         \textcolor{keywordflow}{if}( ((sig\_a == \textcolor{charliteral}{'n'}) || (sig\_a == \textcolor{charliteral}{'N'})) \&\& ((sig\_b == \textcolor{charliteral}{'a'}) || (sig\_b == \textcolor{charliteral}{'A'})) \&\& ((sig\_c == \textcolor{charliteral}{'n'}) || (sig\_c == \textcolor{charliteral}{'N'})) )}
\DoxyCodeLine{1806           \{}
\DoxyCodeLine{1807           val\_real = \mbox{\hyperlink{classDatum}{Datum<T>::nan}};}
\DoxyCodeLine{1808           }
\DoxyCodeLine{1809           found\_val\_real = \textcolor{keyword}{true};}
\DoxyCodeLine{1810           \}}
\DoxyCodeLine{1811         }
\DoxyCodeLine{1812         \textcolor{keywordflow}{if}(found\_val\_real)}
\DoxyCodeLine{1813           \{}
\DoxyCodeLine{1814           x.at(row,col) = std::complex<T>(val\_real, T(0));}
\DoxyCodeLine{1815           }
\DoxyCodeLine{1816           col++; \textcolor{keywordflow}{continue};  \textcolor{comment}{// get next token}}
\DoxyCodeLine{1817           \}}
\DoxyCodeLine{1818         \}}
\DoxyCodeLine{1819       }
\DoxyCodeLine{1820       \textcolor{keywordtype}{bool} found\_x = \textcolor{keyword}{false};}
\DoxyCodeLine{1821       std::string::size\_type loc\_x = 0;  \textcolor{comment}{// location of the separator (+ or -\/) between the real and imaginary part}}
\DoxyCodeLine{1822       }
\DoxyCodeLine{1823       std::string::size\_type loc\_i = token.find\_last\_of(\textcolor{charliteral}{'i'});  \textcolor{comment}{// location of the imaginary part indicator}}
\DoxyCodeLine{1824       }
\DoxyCodeLine{1825       \textcolor{keywordflow}{if}(loc\_i == std::string::npos)}
\DoxyCodeLine{1826         \{}
\DoxyCodeLine{1827         str\_real = token;}
\DoxyCodeLine{1828         str\_imag.clear();}
\DoxyCodeLine{1829         \}}
\DoxyCodeLine{1830       \textcolor{keywordflow}{else}}
\DoxyCodeLine{1831         \{}
\DoxyCodeLine{1832         \textcolor{keywordtype}{bool} found\_plus  = \textcolor{keyword}{false};}
\DoxyCodeLine{1833         \textcolor{keywordtype}{bool} found\_minus = \textcolor{keyword}{false};}
\DoxyCodeLine{1834         }
\DoxyCodeLine{1835         std::string::size\_type loc\_plus = token.find\_last\_of(\textcolor{charliteral}{'+'});}
\DoxyCodeLine{1836         }
\DoxyCodeLine{1837         \textcolor{keywordflow}{if}(loc\_plus != std::string::npos)}
\DoxyCodeLine{1838           \{}
\DoxyCodeLine{1839           \textcolor{keywordflow}{if}(loc\_plus >= 1)}
\DoxyCodeLine{1840             \{}
\DoxyCodeLine{1841             \textcolor{keyword}{const} \textcolor{keywordtype}{char} prev\_char = token.at(loc\_plus-\/1);}
\DoxyCodeLine{1842             }
\DoxyCodeLine{1843             \textcolor{comment}{// make sure we're not looking at the sign of the exponent}}
\DoxyCodeLine{1844             \textcolor{keywordflow}{if}( (prev\_char != \textcolor{charliteral}{'e'}) \&\& (prev\_char != \textcolor{charliteral}{'E'}) )}
\DoxyCodeLine{1845               \{}
\DoxyCodeLine{1846               found\_plus = \textcolor{keyword}{true};}
\DoxyCodeLine{1847               \}}
\DoxyCodeLine{1848             \textcolor{keywordflow}{else}}
\DoxyCodeLine{1849               \{}
\DoxyCodeLine{1850               \textcolor{comment}{// search again, omitting the exponent}}
\DoxyCodeLine{1851               loc\_plus = token.find\_last\_of(\textcolor{charliteral}{'+'}, loc\_plus-\/1);}
\DoxyCodeLine{1852               }
\DoxyCodeLine{1853               \textcolor{keywordflow}{if}(loc\_plus != std::string::npos)  \{ found\_plus = \textcolor{keyword}{true}; \}}
\DoxyCodeLine{1854               \}}
\DoxyCodeLine{1855             \}}
\DoxyCodeLine{1856           \textcolor{keywordflow}{else}}
\DoxyCodeLine{1857             \{}
\DoxyCodeLine{1858             \textcolor{comment}{// loc\_plus == 0, meaning we're at the start of the string}}
\DoxyCodeLine{1859             found\_plus = \textcolor{keyword}{true};}
\DoxyCodeLine{1860             \}}
\DoxyCodeLine{1861           \}}
\DoxyCodeLine{1862         }
\DoxyCodeLine{1863         std::string::size\_type loc\_minus = token.find\_last\_of(\textcolor{charliteral}{'-\/'});}
\DoxyCodeLine{1864         }
\DoxyCodeLine{1865         \textcolor{keywordflow}{if}(loc\_minus != std::string::npos)}
\DoxyCodeLine{1866           \{}
\DoxyCodeLine{1867           \textcolor{keywordflow}{if}(loc\_minus >= 1)}
\DoxyCodeLine{1868             \{}
\DoxyCodeLine{1869             \textcolor{keyword}{const} \textcolor{keywordtype}{char} prev\_char = token.at(loc\_minus-\/1);}
\DoxyCodeLine{1870             }
\DoxyCodeLine{1871             \textcolor{comment}{// make sure we're not looking at the sign of the exponent}}
\DoxyCodeLine{1872             \textcolor{keywordflow}{if}( (prev\_char != \textcolor{charliteral}{'e'}) \&\& (prev\_char != \textcolor{charliteral}{'E'}) )}
\DoxyCodeLine{1873               \{}
\DoxyCodeLine{1874               found\_minus = \textcolor{keyword}{true};}
\DoxyCodeLine{1875               \}}
\DoxyCodeLine{1876             \textcolor{keywordflow}{else}}
\DoxyCodeLine{1877               \{}
\DoxyCodeLine{1878               \textcolor{comment}{// search again, omitting the exponent}}
\DoxyCodeLine{1879               loc\_minus = token.find\_last\_of(\textcolor{charliteral}{'-\/'}, loc\_minus-\/1);}
\DoxyCodeLine{1880               }
\DoxyCodeLine{1881               \textcolor{keywordflow}{if}(loc\_minus != std::string::npos)  \{ found\_minus = \textcolor{keyword}{true}; \}}
\DoxyCodeLine{1882               \}}
\DoxyCodeLine{1883             \}}
\DoxyCodeLine{1884           \textcolor{keywordflow}{else}}
\DoxyCodeLine{1885             \{}
\DoxyCodeLine{1886             \textcolor{comment}{// loc\_minus == 0, meaning we're at the start of the string}}
\DoxyCodeLine{1887             found\_minus = \textcolor{keyword}{true};}
\DoxyCodeLine{1888             \}}
\DoxyCodeLine{1889           \}}
\DoxyCodeLine{1890         }
\DoxyCodeLine{1891         \textcolor{keywordflow}{if}(found\_plus \&\& found\_minus)}
\DoxyCodeLine{1892           \{}
\DoxyCodeLine{1893           \textcolor{keywordflow}{if}( (loc\_i > loc\_plus) \&\& (loc\_i > loc\_minus) )}
\DoxyCodeLine{1894             \{}
\DoxyCodeLine{1895             \textcolor{comment}{// choose the sign closest to the "{}i"{} to be the separator between the real and imaginary part}}
\DoxyCodeLine{1896             loc\_x = ( (loc\_i -\/ loc\_plus) < (loc\_i -\/ loc\_minus) ) ? loc\_plus : loc\_minus;}
\DoxyCodeLine{1897             found\_x = \textcolor{keyword}{true};}
\DoxyCodeLine{1898             \}}
\DoxyCodeLine{1899           \}}
\DoxyCodeLine{1900         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(found\_plus )  \{ loc\_x = loc\_plus;  found\_x = \textcolor{keyword}{true}; \}}
\DoxyCodeLine{1901         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(found\_minus)  \{ loc\_x = loc\_minus; found\_x = \textcolor{keyword}{true}; \}}
\DoxyCodeLine{1902         }
\DoxyCodeLine{1903         \textcolor{keywordflow}{if}(found\_x)}
\DoxyCodeLine{1904           \{}
\DoxyCodeLine{1905           \textcolor{keywordflow}{if}( loc\_x    > 0           ) \{ str\_real = token.substr(0,loc\_x);                     \} \textcolor{keywordflow}{else} \{ str\_real.clear(); \}}
\DoxyCodeLine{1906           \textcolor{keywordflow}{if}((loc\_x+1) < token.size()) \{ str\_imag = token.substr(loc\_x, token.size()-\/loc\_x-\/1); \} \textcolor{keywordflow}{else} \{ str\_imag.clear(); \}}
\DoxyCodeLine{1907           \}}
\DoxyCodeLine{1908         \textcolor{keywordflow}{else}}
\DoxyCodeLine{1909           \{}
\DoxyCodeLine{1910           str\_real.clear();}
\DoxyCodeLine{1911           str\_imag.clear();}
\DoxyCodeLine{1912           \}}
\DoxyCodeLine{1913         \}}
\DoxyCodeLine{1914       }
\DoxyCodeLine{1915       T val\_real = T(0);}
\DoxyCodeLine{1916       T val\_imag = T(0);}
\DoxyCodeLine{1917       }
\DoxyCodeLine{1918       diskio::convert\_token(val\_real, str\_real);}
\DoxyCodeLine{1919       diskio::convert\_token(val\_imag, str\_imag);}
\DoxyCodeLine{1920       }
\DoxyCodeLine{1921       x.at(row,col) = std::complex<T>(val\_real, val\_imag);}
\DoxyCodeLine{1922       }
\DoxyCodeLine{1923       ++col;}
\DoxyCodeLine{1924       \}}
\DoxyCodeLine{1925     }
\DoxyCodeLine{1926     ++row;}
\DoxyCodeLine{1927     \}}
\DoxyCodeLine{1928   }
\DoxyCodeLine{1929   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1930   \}}
\DoxyCodeLine{1931 }
\DoxyCodeLine{1932 }
\DoxyCodeLine{1933 }
\DoxyCodeLine{1934 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{1935 \textcolor{keyword}{inline}}
\DoxyCodeLine{1936 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{1937 diskio::load\_coord\_ascii(\mbox{\hyperlink{classMat}{Mat<eT>}}\& x, \textcolor{keyword}{const} std::string\& \mbox{\hyperlink{structname}{name}}, std::string\& err\_msg)}
\DoxyCodeLine{1938   \{}
\DoxyCodeLine{1939   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1940   }
\DoxyCodeLine{1941   std::fstream f;}
\DoxyCodeLine{1942   f.open(\mbox{\hyperlink{structname}{name}}.c\_str(), std::fstream::in);}
\DoxyCodeLine{1943   }
\DoxyCodeLine{1944   \textcolor{keywordtype}{bool} load\_okay = f.is\_open();}
\DoxyCodeLine{1945   }
\DoxyCodeLine{1946   \textcolor{keywordflow}{if}(load\_okay == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1947   }
\DoxyCodeLine{1948   \textcolor{keywordflow}{if}(load\_okay)}
\DoxyCodeLine{1949     \{}
\DoxyCodeLine{1950     load\_okay = diskio::load\_coord\_ascii(x, f, err\_msg);}
\DoxyCodeLine{1951     \}}
\DoxyCodeLine{1952   }
\DoxyCodeLine{1953   f.close();}
\DoxyCodeLine{1954   }
\DoxyCodeLine{1955   \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{1956   \}}
\DoxyCodeLine{1957 }
\DoxyCodeLine{1958 }
\DoxyCodeLine{1959 }
\DoxyCodeLine{1961 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{1962 \textcolor{keyword}{inline}}
\DoxyCodeLine{1963 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{1964 diskio::load\_coord\_ascii(\mbox{\hyperlink{classMat}{Mat<eT>}}\& x, std::istream\& f, std::string\& err\_msg)}
\DoxyCodeLine{1965   \{}
\DoxyCodeLine{1966   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{1967   }
\DoxyCodeLine{1968   \textcolor{keywordflow}{if}(f.good() == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1969   }
\DoxyCodeLine{1970   f.clear();}
\DoxyCodeLine{1971   \textcolor{keyword}{const} std::fstream::pos\_type pos1 = f.tellg();}
\DoxyCodeLine{1972   }
\DoxyCodeLine{1973   \textcolor{comment}{// work out the size}}
\DoxyCodeLine{1974   }
\DoxyCodeLine{1975   uword f\_n\_rows = 0;}
\DoxyCodeLine{1976   uword f\_n\_cols = 0;}
\DoxyCodeLine{1977   }
\DoxyCodeLine{1978   \textcolor{keywordtype}{bool} size\_found = \textcolor{keyword}{false};}
\DoxyCodeLine{1979   }
\DoxyCodeLine{1980   std::string       line\_string;}
\DoxyCodeLine{1981   std::stringstream line\_stream;}
\DoxyCodeLine{1982   }
\DoxyCodeLine{1983   std::string token;}
\DoxyCodeLine{1984   }
\DoxyCodeLine{1985   \textcolor{keywordflow}{while}(f.good())}
\DoxyCodeLine{1986     \{}
\DoxyCodeLine{1987     std::getline(f, line\_string);}
\DoxyCodeLine{1988     }
\DoxyCodeLine{1989     \textcolor{keywordflow}{if}(line\_string.size() == 0)  \{ \textcolor{keywordflow}{break}; \}}
\DoxyCodeLine{1990     }
\DoxyCodeLine{1991     line\_stream.clear();}
\DoxyCodeLine{1992     line\_stream.str(line\_string);}
\DoxyCodeLine{1993     }
\DoxyCodeLine{1994     uword line\_row = 0;}
\DoxyCodeLine{1995     uword line\_col = 0;}
\DoxyCodeLine{1996     }
\DoxyCodeLine{1997     \textcolor{comment}{// a valid line in co-\/ord format has at least 2 entries}}
\DoxyCodeLine{1998     }
\DoxyCodeLine{1999     line\_stream >> line\_row;}
\DoxyCodeLine{2000     }
\DoxyCodeLine{2001     \textcolor{keywordflow}{if}(line\_stream.good() == \textcolor{keyword}{false})  \{ err\_msg = \textcolor{stringliteral}{"{}incorrect format"{}}; \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2002     }
\DoxyCodeLine{2003     line\_stream >> line\_col;}
\DoxyCodeLine{2004     }
\DoxyCodeLine{2005     size\_found = \textcolor{keyword}{true};}
\DoxyCodeLine{2006     }
\DoxyCodeLine{2007     \textcolor{keywordflow}{if}(f\_n\_rows < line\_row)  \{ f\_n\_rows = line\_row; \}}
\DoxyCodeLine{2008     \textcolor{keywordflow}{if}(f\_n\_cols < line\_col)  \{ f\_n\_cols = line\_col; \}}
\DoxyCodeLine{2009     \}}
\DoxyCodeLine{2010   }
\DoxyCodeLine{2011   \textcolor{comment}{// take into account that indices start at 0}}
\DoxyCodeLine{2012   \textcolor{keywordflow}{if}(size\_found)  \{ ++f\_n\_rows;  ++f\_n\_cols; \}}
\DoxyCodeLine{2013   }
\DoxyCodeLine{2014   f.clear();}
\DoxyCodeLine{2015   f.seekg(pos1);}
\DoxyCodeLine{2016   }
\DoxyCodeLine{2017   \textcolor{keywordflow}{try}}
\DoxyCodeLine{2018     \{}
\DoxyCodeLine{2019     \mbox{\hyperlink{classMat}{Mat<eT>}} tmp(f\_n\_rows, f\_n\_cols, \mbox{\hyperlink{structarma__zeros__indicator}{arma\_zeros\_indicator}}());}
\DoxyCodeLine{2020     }
\DoxyCodeLine{2021     \textcolor{keywordflow}{while}(f.good())}
\DoxyCodeLine{2022       \{}
\DoxyCodeLine{2023       std::getline(f, line\_string);}
\DoxyCodeLine{2024       }
\DoxyCodeLine{2025       \textcolor{keywordflow}{if}(line\_string.size() == 0)  \{ \textcolor{keywordflow}{break}; \}}
\DoxyCodeLine{2026       }
\DoxyCodeLine{2027       line\_stream.clear();}
\DoxyCodeLine{2028       line\_stream.str(line\_string);}
\DoxyCodeLine{2029       }
\DoxyCodeLine{2030       uword line\_row = 0;}
\DoxyCodeLine{2031       uword line\_col = 0;}
\DoxyCodeLine{2032       }
\DoxyCodeLine{2033       line\_stream >> line\_row;}
\DoxyCodeLine{2034       line\_stream >> line\_col;}
\DoxyCodeLine{2035       }
\DoxyCodeLine{2036       eT val = eT(0);}
\DoxyCodeLine{2037       }
\DoxyCodeLine{2038       line\_stream >> token;}
\DoxyCodeLine{2039       }
\DoxyCodeLine{2040       \textcolor{keywordflow}{if}(line\_stream.fail() == \textcolor{keyword}{false})}
\DoxyCodeLine{2041         \{}
\DoxyCodeLine{2042         diskio::convert\_token( val, token );}
\DoxyCodeLine{2043         \}}
\DoxyCodeLine{2044       }
\DoxyCodeLine{2045       \textcolor{keywordflow}{if}(val != eT(0))  \{ tmp(line\_row,line\_col) = val; \}}
\DoxyCodeLine{2046       \}}
\DoxyCodeLine{2047     }
\DoxyCodeLine{2048     x.steal\_mem(tmp);}
\DoxyCodeLine{2049     \}}
\DoxyCodeLine{2050   \textcolor{keywordflow}{catch}(...)}
\DoxyCodeLine{2051     \{}
\DoxyCodeLine{2052     err\_msg = \textcolor{stringliteral}{"{}not enough memory"{}};}
\DoxyCodeLine{2053     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2054     \}}
\DoxyCodeLine{2055   }
\DoxyCodeLine{2056   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2057   \}}
\DoxyCodeLine{2058 }
\DoxyCodeLine{2059 }
\DoxyCodeLine{2060 }
\DoxyCodeLine{2061 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2062 \textcolor{keyword}{inline}}
\DoxyCodeLine{2063 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2064 diskio::load\_coord\_ascii(\mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& x, std::istream\& f, std::string\& err\_msg)}
\DoxyCodeLine{2065   \{}
\DoxyCodeLine{2066   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2067   }
\DoxyCodeLine{2068   \textcolor{keywordflow}{if}(f.good() == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2069   }
\DoxyCodeLine{2070   f.clear();}
\DoxyCodeLine{2071   \textcolor{keyword}{const} std::fstream::pos\_type pos1 = f.tellg();}
\DoxyCodeLine{2072   }
\DoxyCodeLine{2073   \textcolor{comment}{// work out the size}}
\DoxyCodeLine{2074   }
\DoxyCodeLine{2075   uword f\_n\_rows = 0;}
\DoxyCodeLine{2076   uword f\_n\_cols = 0;}
\DoxyCodeLine{2077   }
\DoxyCodeLine{2078   \textcolor{keywordtype}{bool} size\_found = \textcolor{keyword}{false};}
\DoxyCodeLine{2079   }
\DoxyCodeLine{2080   std::string       line\_string;}
\DoxyCodeLine{2081   std::stringstream line\_stream;}
\DoxyCodeLine{2082   }
\DoxyCodeLine{2083   std::string token\_real;}
\DoxyCodeLine{2084   std::string token\_imag;}
\DoxyCodeLine{2085   }
\DoxyCodeLine{2086   \textcolor{keywordflow}{while}(f.good())}
\DoxyCodeLine{2087     \{}
\DoxyCodeLine{2088     std::getline(f, line\_string);}
\DoxyCodeLine{2089     }
\DoxyCodeLine{2090     \textcolor{keywordflow}{if}(line\_string.size() == 0)  \{ \textcolor{keywordflow}{break}; \}}
\DoxyCodeLine{2091     }
\DoxyCodeLine{2092     line\_stream.clear();}
\DoxyCodeLine{2093     line\_stream.str(line\_string);}
\DoxyCodeLine{2094     }
\DoxyCodeLine{2095     uword line\_row = 0;}
\DoxyCodeLine{2096     uword line\_col = 0;}
\DoxyCodeLine{2097     }
\DoxyCodeLine{2098     \textcolor{comment}{// a valid line in co-\/ord format has at least 2 entries}}
\DoxyCodeLine{2099     }
\DoxyCodeLine{2100     line\_stream >> line\_row;}
\DoxyCodeLine{2101     }
\DoxyCodeLine{2102     \textcolor{keywordflow}{if}(line\_stream.good() == \textcolor{keyword}{false})  \{ err\_msg = \textcolor{stringliteral}{"{}incorrect format"{}}; \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2103     }
\DoxyCodeLine{2104     line\_stream >> line\_col;}
\DoxyCodeLine{2105     }
\DoxyCodeLine{2106     size\_found = \textcolor{keyword}{true};}
\DoxyCodeLine{2107     }
\DoxyCodeLine{2108     \textcolor{keywordflow}{if}(f\_n\_rows < line\_row)  f\_n\_rows = line\_row;}
\DoxyCodeLine{2109     \textcolor{keywordflow}{if}(f\_n\_cols < line\_col)  f\_n\_cols = line\_col;}
\DoxyCodeLine{2110     \}}
\DoxyCodeLine{2111   }
\DoxyCodeLine{2112   \textcolor{comment}{// take into account that indices start at 0}}
\DoxyCodeLine{2113   \textcolor{keywordflow}{if}(size\_found)  \{ ++f\_n\_rows;  ++f\_n\_cols; \}}
\DoxyCodeLine{2114   }
\DoxyCodeLine{2115   f.clear();}
\DoxyCodeLine{2116   f.seekg(pos1);}
\DoxyCodeLine{2117   }
\DoxyCodeLine{2118   \textcolor{keywordflow}{try}}
\DoxyCodeLine{2119     \{}
\DoxyCodeLine{2120     \mbox{\hyperlink{classMat}{Mat< std::complex<T>}} > tmp(f\_n\_rows, f\_n\_cols, \mbox{\hyperlink{structarma__zeros__indicator}{arma\_zeros\_indicator}}());}
\DoxyCodeLine{2121     }
\DoxyCodeLine{2122     \textcolor{keywordflow}{while}(f.good())}
\DoxyCodeLine{2123       \{}
\DoxyCodeLine{2124       std::getline(f, line\_string);}
\DoxyCodeLine{2125       }
\DoxyCodeLine{2126       \textcolor{keywordflow}{if}(line\_string.size() == 0)  \{ \textcolor{keywordflow}{break}; \}}
\DoxyCodeLine{2127       }
\DoxyCodeLine{2128       line\_stream.clear();}
\DoxyCodeLine{2129       line\_stream.str(line\_string);}
\DoxyCodeLine{2130       }
\DoxyCodeLine{2131       uword line\_row = 0;}
\DoxyCodeLine{2132       uword line\_col = 0;}
\DoxyCodeLine{2133       }
\DoxyCodeLine{2134       line\_stream >> line\_row;}
\DoxyCodeLine{2135       line\_stream >> line\_col;}
\DoxyCodeLine{2136       }
\DoxyCodeLine{2137       T val\_real = T(0);}
\DoxyCodeLine{2138       T val\_imag = T(0);}
\DoxyCodeLine{2139       }
\DoxyCodeLine{2140       line\_stream >> token\_real;}
\DoxyCodeLine{2141       }
\DoxyCodeLine{2142       \textcolor{keywordflow}{if}(line\_stream.fail() == \textcolor{keyword}{false})}
\DoxyCodeLine{2143         \{}
\DoxyCodeLine{2144         diskio::convert\_token( val\_real, token\_real );}
\DoxyCodeLine{2145         \}}
\DoxyCodeLine{2146       }
\DoxyCodeLine{2147       }
\DoxyCodeLine{2148       line\_stream >> token\_imag;}
\DoxyCodeLine{2149       }
\DoxyCodeLine{2150       \textcolor{keywordflow}{if}(line\_stream.fail() == \textcolor{keyword}{false})}
\DoxyCodeLine{2151         \{}
\DoxyCodeLine{2152         diskio::convert\_token( val\_imag, token\_imag );}
\DoxyCodeLine{2153         \}}
\DoxyCodeLine{2154       }
\DoxyCodeLine{2155       \textcolor{keywordflow}{if}( (val\_real != T(0)) || (val\_imag != T(0)) )}
\DoxyCodeLine{2156         \{}
\DoxyCodeLine{2157         tmp(line\_row,line\_col) = std::complex<T>(val\_real, val\_imag);}
\DoxyCodeLine{2158         \}}
\DoxyCodeLine{2159       \}}
\DoxyCodeLine{2160     }
\DoxyCodeLine{2161     x.steal\_mem(tmp);}
\DoxyCodeLine{2162     \}}
\DoxyCodeLine{2163   \textcolor{keywordflow}{catch}(...)}
\DoxyCodeLine{2164     \{}
\DoxyCodeLine{2165     err\_msg = \textcolor{stringliteral}{"{}not enough memory"{}};}
\DoxyCodeLine{2166     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2167     \}}
\DoxyCodeLine{2168   }
\DoxyCodeLine{2169   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2170   \}}
\DoxyCodeLine{2171 }
\DoxyCodeLine{2172 }
\DoxyCodeLine{2173 }
\DoxyCodeLine{2176 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{2177 \textcolor{keyword}{inline}}
\DoxyCodeLine{2178 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2179 \mbox{\hyperlink{group__diskio_ga7d310b89b83e6327a818215bb3124aa0}{diskio::load\_arma\_binary}}(\mbox{\hyperlink{classMat}{Mat<eT>}}\& x, \textcolor{keyword}{const} std::string\& \mbox{\hyperlink{structname}{name}}, std::string\& err\_msg)}
\DoxyCodeLine{2180   \{}
\DoxyCodeLine{2181   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2182   }
\DoxyCodeLine{2183   std::ifstream f;}
\DoxyCodeLine{2184   f.open(\mbox{\hyperlink{structname}{name}}.c\_str(), std::fstream::binary);}
\DoxyCodeLine{2185   }
\DoxyCodeLine{2186   \textcolor{keywordtype}{bool} load\_okay = f.is\_open();}
\DoxyCodeLine{2187   }
\DoxyCodeLine{2188   \textcolor{keywordflow}{if}(load\_okay)}
\DoxyCodeLine{2189     \{}
\DoxyCodeLine{2190     load\_okay = \mbox{\hyperlink{group__diskio_ga7d310b89b83e6327a818215bb3124aa0}{diskio::load\_arma\_binary}}(x, f, err\_msg);}
\DoxyCodeLine{2191     f.close();}
\DoxyCodeLine{2192     \}}
\DoxyCodeLine{2193   }
\DoxyCodeLine{2194   \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{2195   \}}
\DoxyCodeLine{2196 }
\DoxyCodeLine{2197 }
\DoxyCodeLine{2198 }
\DoxyCodeLine{2199 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{2200 \textcolor{keyword}{inline}}
\DoxyCodeLine{2201 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2202 \mbox{\hyperlink{group__diskio_ga7d310b89b83e6327a818215bb3124aa0}{diskio::load\_arma\_binary}}(\mbox{\hyperlink{classMat}{Mat<eT>}}\& x, std::istream\& f, std::string\& err\_msg)}
\DoxyCodeLine{2203   \{}
\DoxyCodeLine{2204   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2205   }
\DoxyCodeLine{2206   std::streampos pos = f.tellg();}
\DoxyCodeLine{2207   }
\DoxyCodeLine{2208   \textcolor{keywordtype}{bool} load\_okay = \textcolor{keyword}{true};}
\DoxyCodeLine{2209   }
\DoxyCodeLine{2210   std::string f\_header;}
\DoxyCodeLine{2211   uword       f\_n\_rows;}
\DoxyCodeLine{2212   uword       f\_n\_cols;}
\DoxyCodeLine{2213   }
\DoxyCodeLine{2214   f >> f\_header;}
\DoxyCodeLine{2215   f >> f\_n\_rows;}
\DoxyCodeLine{2216   f >> f\_n\_cols;}
\DoxyCodeLine{2217   }
\DoxyCodeLine{2218   \textcolor{keywordflow}{if}(f\_header == \mbox{\hyperlink{group__diskio_ga143c823196ccbd640cf831526cd4933e}{diskio::gen\_bin\_header}}(x))}
\DoxyCodeLine{2219     \{}
\DoxyCodeLine{2220     \textcolor{comment}{//f.seekg(1, ios::cur);  // NOTE: this may not be portable, as on a Windows machine a newline could be two characters}}
\DoxyCodeLine{2221     f.get();}
\DoxyCodeLine{2222     }
\DoxyCodeLine{2223     \textcolor{keywordflow}{try} \{ x.set\_size(f\_n\_rows,f\_n\_cols); \} \textcolor{keywordflow}{catch}(...) \{ err\_msg = \textcolor{stringliteral}{"{}not enough memory"{}}; \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2224     }
\DoxyCodeLine{2225     f.read( \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char} *\textcolor{keyword}{>}(x.memptr()), std::streamsize(x.n\_elem*\textcolor{keyword}{sizeof}(eT)) );}
\DoxyCodeLine{2226     }
\DoxyCodeLine{2227     load\_okay = f.good();}
\DoxyCodeLine{2228     \}}
\DoxyCodeLine{2229   \textcolor{keywordflow}{else}}
\DoxyCodeLine{2230     \{}
\DoxyCodeLine{2231     load\_okay = \textcolor{keyword}{false};}
\DoxyCodeLine{2232     err\_msg = \textcolor{stringliteral}{"{}incorrect header"{}};}
\DoxyCodeLine{2233     \}}
\DoxyCodeLine{2234   }
\DoxyCodeLine{2235   }
\DoxyCodeLine{2236   \textcolor{comment}{// allow automatic conversion of u32/s32 matrices into u64/s64 matrices}}
\DoxyCodeLine{2237   }
\DoxyCodeLine{2238   \textcolor{keywordflow}{if}(load\_okay == \textcolor{keyword}{false})}
\DoxyCodeLine{2239     \{}
\DoxyCodeLine{2240     \textcolor{keywordflow}{if}( (\textcolor{keyword}{sizeof}(eT) == 8) \&\& \mbox{\hyperlink{structis__same__type}{is\_same\_type<uword,eT>::yes}} )}
\DoxyCodeLine{2241       \{}
\DoxyCodeLine{2242       \mbox{\hyperlink{classMat}{Mat<u32>}}    tmp;}
\DoxyCodeLine{2243       std::string junk;}
\DoxyCodeLine{2244       }
\DoxyCodeLine{2245       f.\mbox{\hyperlink{group__Mat_ga3dbb05713ff59d9e4dc6e9381f84ff03}{clear}}();}
\DoxyCodeLine{2246       f.seekg(pos);}
\DoxyCodeLine{2247       }
\DoxyCodeLine{2248       load\_okay = \mbox{\hyperlink{group__diskio_ga7d310b89b83e6327a818215bb3124aa0}{diskio::load\_arma\_binary}}(tmp, f, junk);}
\DoxyCodeLine{2249       }
\DoxyCodeLine{2250       \textcolor{keywordflow}{if}(load\_okay)  \{ x = \mbox{\hyperlink{classconv__to}{conv\_to< Mat<eT>}} >::from(tmp); \}}
\DoxyCodeLine{2251       \}}
\DoxyCodeLine{2252     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2253     \textcolor{keywordflow}{if}( (\textcolor{keyword}{sizeof}(eT) == 8) \&\& \mbox{\hyperlink{structis__same__type}{is\_same\_type<sword,eT>::yes}} )}
\DoxyCodeLine{2254       \{}
\DoxyCodeLine{2255       \mbox{\hyperlink{classMat}{Mat<s32>}}    tmp;}
\DoxyCodeLine{2256       std::string junk;}
\DoxyCodeLine{2257       }
\DoxyCodeLine{2258       f.\mbox{\hyperlink{group__Mat_ga3dbb05713ff59d9e4dc6e9381f84ff03}{clear}}();}
\DoxyCodeLine{2259       f.seekg(pos);}
\DoxyCodeLine{2260       }
\DoxyCodeLine{2261       load\_okay = \mbox{\hyperlink{group__diskio_ga7d310b89b83e6327a818215bb3124aa0}{diskio::load\_arma\_binary}}(tmp, f, junk);}
\DoxyCodeLine{2262       }
\DoxyCodeLine{2263       \textcolor{keywordflow}{if}(load\_okay)  \{ x = \mbox{\hyperlink{classconv__to}{conv\_to< Mat<eT>}} >::from(tmp); \}}
\DoxyCodeLine{2264       \}}
\DoxyCodeLine{2265     \}}
\DoxyCodeLine{2266   }
\DoxyCodeLine{2267   \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{2268   \}}
\DoxyCodeLine{2269 }
\DoxyCodeLine{2270 }
\DoxyCodeLine{2271 }
\DoxyCodeLine{2272 \textcolor{keyword}{inline}}
\DoxyCodeLine{2273 \textcolor{keywordtype}{void}}
\DoxyCodeLine{2274 diskio::pnm\_skip\_comments(std::istream\& f)}
\DoxyCodeLine{2275   \{}
\DoxyCodeLine{2276   \textcolor{keywordflow}{while}( isspace(f.peek()) )}
\DoxyCodeLine{2277     \{}
\DoxyCodeLine{2278     \textcolor{keywordflow}{while}( isspace(f.peek()) )  \{ f.get(); \}}
\DoxyCodeLine{2279     }
\DoxyCodeLine{2280     \textcolor{keywordflow}{if}(f.peek() == \textcolor{charliteral}{'\#'})}
\DoxyCodeLine{2281       \{}
\DoxyCodeLine{2282       \textcolor{keywordflow}{while}( (f.peek() != \textcolor{charliteral}{'\(\backslash\)r'}) \&\& (f.peek() != \textcolor{charliteral}{'\(\backslash\)n'}) )  \{ f.get(); \}}
\DoxyCodeLine{2283       \}}
\DoxyCodeLine{2284     \}}
\DoxyCodeLine{2285   \}}
\DoxyCodeLine{2286 }
\DoxyCodeLine{2287 }
\DoxyCodeLine{2288 }
\DoxyCodeLine{2290 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{2291 \textcolor{keyword}{inline}}
\DoxyCodeLine{2292 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2293 \mbox{\hyperlink{group__diskio_gad0e116f9a542174fc520dc163a82fe84}{diskio::load\_pgm\_binary}}(\mbox{\hyperlink{classMat}{Mat<eT>}}\& x, \textcolor{keyword}{const} std::string\& \mbox{\hyperlink{structname}{name}}, std::string\& err\_msg)}
\DoxyCodeLine{2294   \{}
\DoxyCodeLine{2295   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2296   }
\DoxyCodeLine{2297   std::fstream f;}
\DoxyCodeLine{2298   f.open(\mbox{\hyperlink{structname}{name}}.c\_str(), std::fstream::in | std::fstream::binary);}
\DoxyCodeLine{2299   }
\DoxyCodeLine{2300   \textcolor{keywordtype}{bool} load\_okay = f.is\_open();}
\DoxyCodeLine{2301   }
\DoxyCodeLine{2302   \textcolor{keywordflow}{if}(load\_okay)}
\DoxyCodeLine{2303     \{}
\DoxyCodeLine{2304     load\_okay = \mbox{\hyperlink{group__diskio_gad0e116f9a542174fc520dc163a82fe84}{diskio::load\_pgm\_binary}}(x, f, err\_msg);}
\DoxyCodeLine{2305     f.close();}
\DoxyCodeLine{2306     \}}
\DoxyCodeLine{2307   }
\DoxyCodeLine{2308   \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{2309   \}}
\DoxyCodeLine{2310 }
\DoxyCodeLine{2311 }
\DoxyCodeLine{2312 }
\DoxyCodeLine{2314 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{2315 \textcolor{keyword}{inline}}
\DoxyCodeLine{2316 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2317 \mbox{\hyperlink{group__diskio_gad0e116f9a542174fc520dc163a82fe84}{diskio::load\_pgm\_binary}}(\mbox{\hyperlink{classMat}{Mat<eT>}}\& x, std::istream\& f, std::string\& err\_msg)}
\DoxyCodeLine{2318   \{}
\DoxyCodeLine{2319   \textcolor{keywordtype}{bool} load\_okay = \textcolor{keyword}{true};}
\DoxyCodeLine{2320   }
\DoxyCodeLine{2321   std::string f\_header;}
\DoxyCodeLine{2322   }
\DoxyCodeLine{2323   f >> f\_header;}
\DoxyCodeLine{2324   }
\DoxyCodeLine{2325   \textcolor{keywordflow}{if}(f\_header == \textcolor{stringliteral}{"{}P5"{}})}
\DoxyCodeLine{2326     \{}
\DoxyCodeLine{2327     uword f\_n\_rows = 0;}
\DoxyCodeLine{2328     uword f\_n\_cols = 0;}
\DoxyCodeLine{2329     \textcolor{keywordtype}{int} f\_maxval = 0;}
\DoxyCodeLine{2330     }
\DoxyCodeLine{2331     diskio::pnm\_skip\_comments(f);}
\DoxyCodeLine{2332     }
\DoxyCodeLine{2333     f >> f\_n\_cols;}
\DoxyCodeLine{2334     diskio::pnm\_skip\_comments(f);}
\DoxyCodeLine{2335     }
\DoxyCodeLine{2336     f >> f\_n\_rows;}
\DoxyCodeLine{2337     diskio::pnm\_skip\_comments(f);}
\DoxyCodeLine{2338     }
\DoxyCodeLine{2339     f >> f\_maxval;}
\DoxyCodeLine{2340     f.get();}
\DoxyCodeLine{2341     }
\DoxyCodeLine{2342     \textcolor{keywordflow}{if}( (f\_maxval > 0) \&\& (f\_maxval <= 65535) )}
\DoxyCodeLine{2343       \{}
\DoxyCodeLine{2344       \textcolor{keywordflow}{try} \{ x.set\_size(f\_n\_rows,f\_n\_cols); \} \textcolor{keywordflow}{catch}(...) \{ err\_msg = \textcolor{stringliteral}{"{}not enough memory"{}}; \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2345       }
\DoxyCodeLine{2346       \textcolor{keywordflow}{if}(f\_maxval <= 255)}
\DoxyCodeLine{2347         \{}
\DoxyCodeLine{2348         \textcolor{keyword}{const} uword n\_elem = f\_n\_cols*f\_n\_rows;}
\DoxyCodeLine{2349         \mbox{\hyperlink{classpodarray}{podarray<u8>}} tmp(n\_elem);}
\DoxyCodeLine{2350         }
\DoxyCodeLine{2351         f.read( \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(tmp.memptr()), std::streamsize(n\_elem) );}
\DoxyCodeLine{2352         }
\DoxyCodeLine{2353         uword i = 0;}
\DoxyCodeLine{2354         }
\DoxyCodeLine{2355         \textcolor{comment}{//cout << "{}f\_n\_cols = "{} << f\_n\_cols << endl;}}
\DoxyCodeLine{2356         \textcolor{comment}{//cout << "{}f\_n\_rows = "{} << f\_n\_rows << endl;}}
\DoxyCodeLine{2357         }
\DoxyCodeLine{2358         \textcolor{keywordflow}{for}(uword row=0; row < f\_n\_rows; ++row)}
\DoxyCodeLine{2359         \textcolor{keywordflow}{for}(uword col=0; col < f\_n\_cols; ++col)}
\DoxyCodeLine{2360           \{}
\DoxyCodeLine{2361           x.at(row,col) = eT(tmp[i]);}
\DoxyCodeLine{2362           ++i;}
\DoxyCodeLine{2363           \}}
\DoxyCodeLine{2364         \}}
\DoxyCodeLine{2365       \textcolor{keywordflow}{else}}
\DoxyCodeLine{2366         \{}
\DoxyCodeLine{2367         \textcolor{keyword}{const} uword n\_elem = f\_n\_cols*f\_n\_rows;}
\DoxyCodeLine{2368         \mbox{\hyperlink{classpodarray}{podarray<u16>}} tmp(n\_elem);}
\DoxyCodeLine{2369         }
\DoxyCodeLine{2370         f.read( \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char} *\textcolor{keyword}{>}(tmp.memptr()), std::streamsize(n\_elem*2) );}
\DoxyCodeLine{2371         }
\DoxyCodeLine{2372         uword i = 0;}
\DoxyCodeLine{2373         }
\DoxyCodeLine{2374         \textcolor{keywordflow}{for}(uword row=0; row < f\_n\_rows; ++row)}
\DoxyCodeLine{2375         \textcolor{keywordflow}{for}(uword col=0; col < f\_n\_cols; ++col)}
\DoxyCodeLine{2376           \{}
\DoxyCodeLine{2377           x.at(row,col) = eT(tmp[i]);}
\DoxyCodeLine{2378           ++i;}
\DoxyCodeLine{2379           \}}
\DoxyCodeLine{2380         \}}
\DoxyCodeLine{2381       \}}
\DoxyCodeLine{2382     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2383       \{}
\DoxyCodeLine{2384       load\_okay = \textcolor{keyword}{false};}
\DoxyCodeLine{2385       err\_msg = \textcolor{stringliteral}{"{}functionality unimplemented"{}};}
\DoxyCodeLine{2386       \}}
\DoxyCodeLine{2387     }
\DoxyCodeLine{2388     \textcolor{keywordflow}{if}(f.good() == \textcolor{keyword}{false})  \{ load\_okay = \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2389     \}}
\DoxyCodeLine{2390   \textcolor{keywordflow}{else}}
\DoxyCodeLine{2391     \{}
\DoxyCodeLine{2392     load\_okay = \textcolor{keyword}{false};}
\DoxyCodeLine{2393     err\_msg = \textcolor{stringliteral}{"{}unsupported header"{}};}
\DoxyCodeLine{2394     \}}
\DoxyCodeLine{2395   }
\DoxyCodeLine{2396   \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{2397   \}}
\DoxyCodeLine{2398 }
\DoxyCodeLine{2399 }
\DoxyCodeLine{2400 }
\DoxyCodeLine{2402 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2403 \textcolor{keyword}{inline}}
\DoxyCodeLine{2404 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2405 \mbox{\hyperlink{group__diskio_gad0e116f9a542174fc520dc163a82fe84}{diskio::load\_pgm\_binary}}(\mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& x, \textcolor{keyword}{const} std::string\& \mbox{\hyperlink{structname}{name}}, std::string\& err\_msg)}
\DoxyCodeLine{2406   \{}
\DoxyCodeLine{2407   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2408   }
\DoxyCodeLine{2409   \mbox{\hyperlink{classMat}{uchar\_mat}} tmp;}
\DoxyCodeLine{2410   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} load\_okay = \mbox{\hyperlink{group__diskio_gad0e116f9a542174fc520dc163a82fe84}{diskio::load\_pgm\_binary}}(tmp, \mbox{\hyperlink{structname}{name}}, err\_msg);}
\DoxyCodeLine{2411   }
\DoxyCodeLine{2412   x = \mbox{\hyperlink{classconv__to}{conv\_to< Mat< std::complex<T>}} > >::from(tmp);}
\DoxyCodeLine{2413   }
\DoxyCodeLine{2414   \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{2415   \}}
\DoxyCodeLine{2416 }
\DoxyCodeLine{2417 }
\DoxyCodeLine{2418 }
\DoxyCodeLine{2420 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2421 \textcolor{keyword}{inline}}
\DoxyCodeLine{2422 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2423 \mbox{\hyperlink{group__diskio_gad0e116f9a542174fc520dc163a82fe84}{diskio::load\_pgm\_binary}}(\mbox{\hyperlink{classMat}{Mat}}< std::complex<T> >\& x, std::istream\& is, std::string\& err\_msg)}
\DoxyCodeLine{2424   \{}
\DoxyCodeLine{2425   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2426   }
\DoxyCodeLine{2427   \mbox{\hyperlink{classMat}{uchar\_mat}} tmp;}
\DoxyCodeLine{2428   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} load\_okay = \mbox{\hyperlink{group__diskio_gad0e116f9a542174fc520dc163a82fe84}{diskio::load\_pgm\_binary}}(tmp, is, err\_msg);}
\DoxyCodeLine{2429   }
\DoxyCodeLine{2430   x = \mbox{\hyperlink{classconv__to}{conv\_to< Mat< std::complex<T>}} > >::from(tmp);}
\DoxyCodeLine{2431   }
\DoxyCodeLine{2432   \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{2433   \}}
\DoxyCodeLine{2434 }
\DoxyCodeLine{2435 }
\DoxyCodeLine{2436 }
\DoxyCodeLine{2438 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{2439 \textcolor{keyword}{inline}}
\DoxyCodeLine{2440 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2441 \mbox{\hyperlink{group__diskio_ga44d57eace6517b322f38e379e2126627}{diskio::load\_hdf5\_binary}}(\mbox{\hyperlink{classMat}{Mat<eT>}}\& x, \textcolor{keyword}{const} \mbox{\hyperlink{structhdf5__name}{hdf5\_name}}\& spec, std::string\& err\_msg)}
\DoxyCodeLine{2442   \{}
\DoxyCodeLine{2443   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2444   }
\DoxyCodeLine{2445 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_HDF5)}}
\DoxyCodeLine{2446     \{}
\DoxyCodeLine{2447     hdf5\_misc::hdf5\_suspend\_printing\_errors hdf5\_print\_suspender;}
\DoxyCodeLine{2448     }
\DoxyCodeLine{2449     \textcolor{keywordtype}{bool} load\_okay = \textcolor{keyword}{false};}
\DoxyCodeLine{2450     }
\DoxyCodeLine{2451     hid\_t fid = arma\_H5Fopen(spec.filename.c\_str(), H5F\_ACC\_RDONLY, H5P\_DEFAULT);}
\DoxyCodeLine{2452     }
\DoxyCodeLine{2453     \textcolor{keywordflow}{if}(fid >= 0)}
\DoxyCodeLine{2454       \{}
\DoxyCodeLine{2455       \textcolor{comment}{// MATLAB HDF5 dataset names are user-\/specified;}}
\DoxyCodeLine{2456       \textcolor{comment}{// Octave tends to store the datasets in a group, with the actual dataset being referred to as "{}value"{}.}}
\DoxyCodeLine{2457       \textcolor{comment}{// If the user hasn't specified a dataset, we will search for "{}dataset"{} and "{}value"{},}}
\DoxyCodeLine{2458       \textcolor{comment}{// and if those are not found we will take the first dataset we do find.}}
\DoxyCodeLine{2459       }
\DoxyCodeLine{2460       std::vector<std::string> searchNames;}
\DoxyCodeLine{2461       }
\DoxyCodeLine{2462       \textcolor{keyword}{const} \textcolor{keywordtype}{bool} exact = (spec.dsname.empty() == \textcolor{keyword}{false});}
\DoxyCodeLine{2463       }
\DoxyCodeLine{2464       \textcolor{keywordflow}{if}(exact)}
\DoxyCodeLine{2465         \{}
\DoxyCodeLine{2466         searchNames.push\_back(spec.dsname);}
\DoxyCodeLine{2467         \}}
\DoxyCodeLine{2468       \textcolor{keywordflow}{else}}
\DoxyCodeLine{2469         \{}
\DoxyCodeLine{2470         searchNames.push\_back(\textcolor{stringliteral}{"{}dataset"{}});}
\DoxyCodeLine{2471         searchNames.push\_back(\textcolor{stringliteral}{"{}value"{}}  );}
\DoxyCodeLine{2472         \}}
\DoxyCodeLine{2473       }
\DoxyCodeLine{2474       hid\_t dataset = hdf5\_misc::search\_hdf5\_file(searchNames, fid, 2, exact);}
\DoxyCodeLine{2475       }
\DoxyCodeLine{2476       \textcolor{keywordflow}{if}(dataset >= 0)}
\DoxyCodeLine{2477         \{}
\DoxyCodeLine{2478         hid\_t filespace = arma\_H5Dget\_space(dataset);}
\DoxyCodeLine{2479         }
\DoxyCodeLine{2480         \textcolor{comment}{// This must be <= 2 due to our search rules.}}
\DoxyCodeLine{2481         \textcolor{keyword}{const} \textcolor{keywordtype}{int} ndims = arma\_H5Sget\_simple\_extent\_ndims(filespace);}
\DoxyCodeLine{2482         }
\DoxyCodeLine{2483         hsize\_t dims[2];}
\DoxyCodeLine{2484         \textcolor{keyword}{const} herr\_t query\_status = arma\_H5Sget\_simple\_extent\_dims(filespace, dims, NULL);}
\DoxyCodeLine{2485         }
\DoxyCodeLine{2486         \textcolor{comment}{// arma\_check(query\_status < 0, "{}Mat::load(): cannot get size of HDF5 dataset"{});}}
\DoxyCodeLine{2487         \textcolor{keywordflow}{if}(query\_status < 0)}
\DoxyCodeLine{2488           \{}
\DoxyCodeLine{2489           err\_msg = \textcolor{stringliteral}{"{}cannot get size of HDF5 dataset"{}};}
\DoxyCodeLine{2490           }
\DoxyCodeLine{2491           arma\_H5Sclose(filespace);}
\DoxyCodeLine{2492           arma\_H5Dclose(dataset);}
\DoxyCodeLine{2493           arma\_H5Fclose(fid);}
\DoxyCodeLine{2494           }
\DoxyCodeLine{2495           \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2496           \}}
\DoxyCodeLine{2497         }
\DoxyCodeLine{2498         \textcolor{keywordflow}{if}(ndims == 1) \{ dims[1] = 1; \}  \textcolor{comment}{// Vector case; fake second dimension (one column).}}
\DoxyCodeLine{2499         }
\DoxyCodeLine{2500         \textcolor{keywordflow}{try} \{ x.set\_size(dims[1], dims[0]); \} \textcolor{keywordflow}{catch}(...) \{ err\_msg = \textcolor{stringliteral}{"{}not enough memory"{}}; \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2501         }
\DoxyCodeLine{2502         \textcolor{comment}{// Now we have to see what type is stored to figure out how to load it.}}
\DoxyCodeLine{2503         hid\_t datatype = arma\_H5Dget\_type(dataset);}
\DoxyCodeLine{2504         hid\_t mat\_type = hdf5\_misc::get\_hdf5\_type<eT>();}
\DoxyCodeLine{2505         }
\DoxyCodeLine{2506         \textcolor{comment}{// If these are the same type, it is simple.}}
\DoxyCodeLine{2507         \textcolor{keywordflow}{if}(arma\_H5Tequal(datatype, mat\_type) > 0)}
\DoxyCodeLine{2508           \{}
\DoxyCodeLine{2509           \textcolor{comment}{// Load directly; H5S\_ALL used so that we load the entire dataset.}}
\DoxyCodeLine{2510           hid\_t read\_status = arma\_H5Dread(dataset, datatype, H5S\_ALL, H5S\_ALL, H5P\_DEFAULT, void\_ptr(x.memptr()));}
\DoxyCodeLine{2511           }
\DoxyCodeLine{2512           \textcolor{keywordflow}{if}(read\_status >= 0) \{ load\_okay = \textcolor{keyword}{true}; \}}
\DoxyCodeLine{2513           \}}
\DoxyCodeLine{2514         \textcolor{keywordflow}{else}}
\DoxyCodeLine{2515           \{}
\DoxyCodeLine{2516           \textcolor{comment}{// Load into another array and convert its type accordingly.}}
\DoxyCodeLine{2517           hid\_t read\_status = hdf5\_misc::load\_and\_convert\_hdf5(x.memptr(), dataset, datatype, x.n\_elem);}
\DoxyCodeLine{2518           }
\DoxyCodeLine{2519           \textcolor{keywordflow}{if}(read\_status >= 0) \{ load\_okay = \textcolor{keyword}{true}; \}}
\DoxyCodeLine{2520           \}}
\DoxyCodeLine{2521         }
\DoxyCodeLine{2522         \textcolor{comment}{// Now clean up.}}
\DoxyCodeLine{2523         arma\_H5Tclose(datatype);}
\DoxyCodeLine{2524         arma\_H5Tclose(mat\_type);}
\DoxyCodeLine{2525         arma\_H5Sclose(filespace);}
\DoxyCodeLine{2526         \}}
\DoxyCodeLine{2527       }
\DoxyCodeLine{2528       arma\_H5Dclose(dataset);}
\DoxyCodeLine{2529       }
\DoxyCodeLine{2530       arma\_H5Fclose(fid);}
\DoxyCodeLine{2531       }
\DoxyCodeLine{2532       \textcolor{keywordflow}{if}(load\_okay == \textcolor{keyword}{false})}
\DoxyCodeLine{2533         \{}
\DoxyCodeLine{2534         err\_msg = \textcolor{stringliteral}{"{}unsupported or missing HDF5 data"{}};}
\DoxyCodeLine{2535         \}}
\DoxyCodeLine{2536       \}}
\DoxyCodeLine{2537     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2538       \{}
\DoxyCodeLine{2539       err\_msg = \textcolor{stringliteral}{"{}cannot open"{}};}
\DoxyCodeLine{2540       \}}
\DoxyCodeLine{2541     }
\DoxyCodeLine{2542     \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{2543     \}}
\DoxyCodeLine{2544 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{2545     \{}
\DoxyCodeLine{2546     arma\_ignore(x);}
\DoxyCodeLine{2547     arma\_ignore(spec);}
\DoxyCodeLine{2548     arma\_ignore(err\_msg);}
\DoxyCodeLine{2549     }
\DoxyCodeLine{2550     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}Mat::load(): use of HDF5 must be enabled"{}});}
\DoxyCodeLine{2551     }
\DoxyCodeLine{2552     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2553     \}}
\DoxyCodeLine{2554 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{2555   \}}
\DoxyCodeLine{2556 }
\DoxyCodeLine{2557 }
\DoxyCodeLine{2558 }
\DoxyCodeLine{2560 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{2561 \textcolor{keyword}{inline}}
\DoxyCodeLine{2562 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2563 \mbox{\hyperlink{group__diskio_ga3a08df975abb1db75bd484e541d4841b}{diskio::load\_auto\_detect}}(\mbox{\hyperlink{classMat}{Mat<eT>}}\& x, \textcolor{keyword}{const} std::string\& \mbox{\hyperlink{structname}{name}}, std::string\& err\_msg)}
\DoxyCodeLine{2564   \{}
\DoxyCodeLine{2565   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2566   }
\DoxyCodeLine{2567 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_HDF5)}}
\DoxyCodeLine{2568     \textcolor{comment}{// We're currently using the C bindings for the HDF5 library, which don't support C++ streams}}
\DoxyCodeLine{2569     \textcolor{keywordflow}{if}( arma\_H5Fis\_hdf5(\mbox{\hyperlink{structname}{name}}.c\_str()) ) \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{group__diskio_ga44d57eace6517b322f38e379e2126627}{load\_hdf5\_binary}}(x, \mbox{\hyperlink{structname}{name}}, err\_msg); \}}
\DoxyCodeLine{2570 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{2571   }
\DoxyCodeLine{2572   std::fstream f;}
\DoxyCodeLine{2573   f.open(\mbox{\hyperlink{structname}{name}}.c\_str(), std::fstream::in | std::fstream::binary);}
\DoxyCodeLine{2574   }
\DoxyCodeLine{2575   \textcolor{keywordtype}{bool} load\_okay = f.is\_open();}
\DoxyCodeLine{2576   }
\DoxyCodeLine{2577   \textcolor{keywordflow}{if}(load\_okay)}
\DoxyCodeLine{2578     \{}
\DoxyCodeLine{2579     load\_okay = \mbox{\hyperlink{group__diskio_ga3a08df975abb1db75bd484e541d4841b}{diskio::load\_auto\_detect}}(x, f, err\_msg);}
\DoxyCodeLine{2580     f.close();}
\DoxyCodeLine{2581     \}}
\DoxyCodeLine{2582   }
\DoxyCodeLine{2583   \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{2584   \}}
\DoxyCodeLine{2585 }
\DoxyCodeLine{2586 }
\DoxyCodeLine{2587 }
\DoxyCodeLine{2589 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{2590 \textcolor{keyword}{inline}}
\DoxyCodeLine{2591 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2592 \mbox{\hyperlink{group__diskio_ga3a08df975abb1db75bd484e541d4841b}{diskio::load\_auto\_detect}}(\mbox{\hyperlink{classMat}{Mat<eT>}}\& x, std::istream\& f, std::string\& err\_msg)}
\DoxyCodeLine{2593   \{}
\DoxyCodeLine{2594   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2595   }
\DoxyCodeLine{2596   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_MAT\_TXT\_str = \textcolor{stringliteral}{"{}ARMA\_MAT\_TXT"{}};}
\DoxyCodeLine{2597   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_MAT\_BIN\_str = \textcolor{stringliteral}{"{}ARMA\_MAT\_BIN"{}};}
\DoxyCodeLine{2598   \textcolor{keyword}{const} \textcolor{keywordtype}{char}*           P5\_str = \textcolor{stringliteral}{"{}P5"{}};}
\DoxyCodeLine{2599   }
\DoxyCodeLine{2600   \textcolor{keyword}{const} uword ARMA\_MAT\_TXT\_len = uword(12);}
\DoxyCodeLine{2601   \textcolor{keyword}{const} uword ARMA\_MAT\_BIN\_len = uword(12);}
\DoxyCodeLine{2602   \textcolor{keyword}{const} uword           P5\_len = uword(2);}
\DoxyCodeLine{2603   }
\DoxyCodeLine{2604   \mbox{\hyperlink{classpodarray}{podarray<char>}} header(ARMA\_MAT\_TXT\_len + 1);}
\DoxyCodeLine{2605   }
\DoxyCodeLine{2606   \textcolor{keywordtype}{char}* header\_mem = header.memptr();}
\DoxyCodeLine{2607   }
\DoxyCodeLine{2608   std::streampos pos = f.tellg();}
\DoxyCodeLine{2609     }
\DoxyCodeLine{2610   f.read( header\_mem, std::streamsize(ARMA\_MAT\_TXT\_len) );}
\DoxyCodeLine{2611   f.clear();}
\DoxyCodeLine{2612   f.seekg(pos);}
\DoxyCodeLine{2613   }
\DoxyCodeLine{2614   header\_mem[ARMA\_MAT\_TXT\_len] = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{2615   }
\DoxyCodeLine{2616   \textcolor{keywordflow}{if}( std::strncmp(ARMA\_MAT\_TXT\_str, header\_mem, \textcolor{keywordtype}{size\_t}(ARMA\_MAT\_TXT\_len)) == 0 )}
\DoxyCodeLine{2617     \{}
\DoxyCodeLine{2618     \textcolor{keywordflow}{return} \mbox{\hyperlink{group__diskio_ga84c9da5c70180743ecc7918230a06d98}{load\_arma\_ascii}}(x, f, err\_msg);}
\DoxyCodeLine{2619     \}}
\DoxyCodeLine{2620   \textcolor{keywordflow}{else}}
\DoxyCodeLine{2621   \textcolor{keywordflow}{if}( std::strncmp(ARMA\_MAT\_BIN\_str, header\_mem, \textcolor{keywordtype}{size\_t}(ARMA\_MAT\_BIN\_len)) == 0 )}
\DoxyCodeLine{2622     \{}
\DoxyCodeLine{2623     \textcolor{keywordflow}{return} \mbox{\hyperlink{group__diskio_ga7d310b89b83e6327a818215bb3124aa0}{load\_arma\_binary}}(x, f, err\_msg);}
\DoxyCodeLine{2624     \}}
\DoxyCodeLine{2625   \textcolor{keywordflow}{else}}
\DoxyCodeLine{2626   \textcolor{keywordflow}{if}( std::strncmp(P5\_str, header\_mem, \textcolor{keywordtype}{size\_t}(P5\_len)) == 0 )}
\DoxyCodeLine{2627     \{}
\DoxyCodeLine{2628     \textcolor{keywordflow}{return} \mbox{\hyperlink{group__diskio_gad0e116f9a542174fc520dc163a82fe84}{load\_pgm\_binary}}(x, f, err\_msg);}
\DoxyCodeLine{2629     \}}
\DoxyCodeLine{2630   \textcolor{keywordflow}{else}}
\DoxyCodeLine{2631     \{}
\DoxyCodeLine{2632     \textcolor{keyword}{const} \mbox{\hyperlink{group__diskio_ga0de594dadb1bc493ecc618520a2d260e}{file\_type}} ft = guess\_file\_type\_internal(f);}
\DoxyCodeLine{2633     }
\DoxyCodeLine{2634     \textcolor{keywordflow}{switch}(ft)}
\DoxyCodeLine{2635       \{}
\DoxyCodeLine{2636       \textcolor{keywordflow}{case} \mbox{\hyperlink{group__diskio_gga0de594dadb1bc493ecc618520a2d260eab4d2490e1c12932d1332e7ce8af72736}{csv\_ascii}}:}
\DoxyCodeLine{2637         \textcolor{keywordflow}{return} \mbox{\hyperlink{group__diskio_gae8a45a3f816b0b5b1e699d3d9f309491}{load\_csv\_ascii}}(x, f, err\_msg);}
\DoxyCodeLine{2638         \textcolor{keywordflow}{break};}
\DoxyCodeLine{2639       }
\DoxyCodeLine{2640       \textcolor{keywordflow}{case} \mbox{\hyperlink{group__diskio_gga0de594dadb1bc493ecc618520a2d260eac7c03701d8a6949bd83abea1ecce583d}{raw\_binary}}:}
\DoxyCodeLine{2641         \textcolor{keywordflow}{return} \mbox{\hyperlink{group__diskio_ga758d71eceff8f867d38619aa52ddf40b}{load\_raw\_binary}}(x, f, err\_msg);}
\DoxyCodeLine{2642         \textcolor{keywordflow}{break};}
\DoxyCodeLine{2643         }
\DoxyCodeLine{2644       \textcolor{keywordflow}{case} \mbox{\hyperlink{group__diskio_gga0de594dadb1bc493ecc618520a2d260ea7963e321f4e9acbc17ee7bb89759c726}{raw\_ascii}}:}
\DoxyCodeLine{2645         \textcolor{keywordflow}{return} \mbox{\hyperlink{group__diskio_gab4a891389f7af45143d69e1e13e02fde}{load\_raw\_ascii}}(x, f, err\_msg);}
\DoxyCodeLine{2646         \textcolor{keywordflow}{break};}
\DoxyCodeLine{2647       }
\DoxyCodeLine{2648       \textcolor{keywordflow}{default}:}
\DoxyCodeLine{2649         err\_msg = \textcolor{stringliteral}{"{}unknown data"{}};}
\DoxyCodeLine{2650         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2651       \}}
\DoxyCodeLine{2652     \}}
\DoxyCodeLine{2653   }
\DoxyCodeLine{2654   \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2655   \}}
\DoxyCodeLine{2656 }
\DoxyCodeLine{2657 }
\DoxyCodeLine{2658 }
\DoxyCodeLine{2659 \textcolor{comment}{//}}
\DoxyCodeLine{2660 \textcolor{comment}{// sparse matrices}}
\DoxyCodeLine{2661 \textcolor{comment}{//}}
\DoxyCodeLine{2662 }
\DoxyCodeLine{2663 }
\DoxyCodeLine{2664 }
\DoxyCodeLine{2666 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{2667 \textcolor{keyword}{inline}}
\DoxyCodeLine{2668 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2669 \mbox{\hyperlink{group__diskio_gab2874c9ce3947ee2bda6176591bdc26b}{diskio::save\_csv\_ascii}}(\textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& x, \textcolor{keyword}{const} std::string\& final\_name, \textcolor{keyword}{const} \mbox{\hyperlink{classfield}{field<std::string>}}\& header, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} with\_header)}
\DoxyCodeLine{2670   \{}
\DoxyCodeLine{2671   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2672   }
\DoxyCodeLine{2673   \textcolor{keyword}{const} std::string tmp\_name = \mbox{\hyperlink{group__diskio_gad32fa08afe53746650c31071f88eacab}{diskio::gen\_tmp\_name}}(final\_name);}
\DoxyCodeLine{2674   }
\DoxyCodeLine{2675   std::ofstream f(tmp\_name.c\_str());}
\DoxyCodeLine{2676   }
\DoxyCodeLine{2677   \textcolor{keywordtype}{bool} save\_okay = f.is\_open();}
\DoxyCodeLine{2678   }
\DoxyCodeLine{2679   \textcolor{keywordflow}{if}(save\_okay == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2680   }
\DoxyCodeLine{2681   \textcolor{keywordflow}{if}(with\_header)}
\DoxyCodeLine{2682     \{}
\DoxyCodeLine{2683     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}diskio::save\_csv\_ascii(): writing header"{}});}
\DoxyCodeLine{2684     }
\DoxyCodeLine{2685     \textcolor{keywordflow}{for}(uword i=0; i < header.\mbox{\hyperlink{classfield_ab81d4115f84d73a4118dedf0194b3e3c}{n\_elem}}; ++i)}
\DoxyCodeLine{2686       \{}
\DoxyCodeLine{2687       f << header(i);}
\DoxyCodeLine{2688       }
\DoxyCodeLine{2689       \textcolor{keywordflow}{if}(i != (header.n\_elem-\/1))  \{ f.put(\textcolor{charliteral}{','}); \}}
\DoxyCodeLine{2690       \}}
\DoxyCodeLine{2691     }
\DoxyCodeLine{2692     f.put(\textcolor{charliteral}{'\(\backslash\)n'});}
\DoxyCodeLine{2693     }
\DoxyCodeLine{2694     save\_okay = f.good();}
\DoxyCodeLine{2695     \}}
\DoxyCodeLine{2696   }
\DoxyCodeLine{2697   \textcolor{keywordflow}{if}(save\_okay)  \{ save\_okay = \mbox{\hyperlink{group__diskio_gab2874c9ce3947ee2bda6176591bdc26b}{diskio::save\_csv\_ascii}}(x, f); \}}
\DoxyCodeLine{2698   }
\DoxyCodeLine{2699   f.flush();}
\DoxyCodeLine{2700   f.close();}
\DoxyCodeLine{2701   }
\DoxyCodeLine{2702   \textcolor{keywordflow}{if}(save\_okay)  \{ save\_okay = \mbox{\hyperlink{group__diskio_gafbccd611e1fec1b6044f81460415d8d3}{diskio::safe\_rename}}(tmp\_name, final\_name); \}}
\DoxyCodeLine{2703   }
\DoxyCodeLine{2704   \textcolor{keywordflow}{return} save\_okay;}
\DoxyCodeLine{2705   \}}
\DoxyCodeLine{2706 }
\DoxyCodeLine{2707 }
\DoxyCodeLine{2708 }
\DoxyCodeLine{2710 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{2711 \textcolor{keyword}{inline}}
\DoxyCodeLine{2712 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2713 \mbox{\hyperlink{group__diskio_gab2874c9ce3947ee2bda6176591bdc26b}{diskio::save\_csv\_ascii}}(\textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& x, std::ostream\& f)}
\DoxyCodeLine{2714   \{}
\DoxyCodeLine{2715   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2716   }
\DoxyCodeLine{2717   \textcolor{keyword}{const} \mbox{\hyperlink{classarma__ostream__state}{arma\_ostream\_state}} stream\_state(f);}
\DoxyCodeLine{2718   }
\DoxyCodeLine{2719   diskio::prepare\_stream<eT>(f);}
\DoxyCodeLine{2720   }
\DoxyCodeLine{2721   x.sync();}
\DoxyCodeLine{2722   }
\DoxyCodeLine{2723   uword x\_n\_rows = x.n\_rows;}
\DoxyCodeLine{2724   uword x\_n\_cols = x.n\_cols;}
\DoxyCodeLine{2725   }
\DoxyCodeLine{2726   \textcolor{keywordflow}{for}(uword row=0; row < x\_n\_rows; ++row)}
\DoxyCodeLine{2727     \{}
\DoxyCodeLine{2728     \textcolor{keywordflow}{for}(uword col=0; col < x\_n\_cols; ++col)}
\DoxyCodeLine{2729       \{}
\DoxyCodeLine{2730       \textcolor{keyword}{const} eT val = x.at(row,col);}
\DoxyCodeLine{2731       }
\DoxyCodeLine{2732       \textcolor{keywordflow}{if}(val != eT(0))  \{ arma\_ostream::raw\_print\_elem(f, val); \}}
\DoxyCodeLine{2733       }
\DoxyCodeLine{2734       \textcolor{keywordflow}{if}( col < (x\_n\_cols-\/1) )  \{ f.put(\textcolor{charliteral}{','}); \}}
\DoxyCodeLine{2735       \}}
\DoxyCodeLine{2736     }
\DoxyCodeLine{2737     f.put(\textcolor{charliteral}{'\(\backslash\)n'});}
\DoxyCodeLine{2738     \}}
\DoxyCodeLine{2739   }
\DoxyCodeLine{2740   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} save\_okay = f.good();}
\DoxyCodeLine{2741   }
\DoxyCodeLine{2742   stream\_state.restore(f);}
\DoxyCodeLine{2743   }
\DoxyCodeLine{2744   \textcolor{keywordflow}{return} save\_okay;}
\DoxyCodeLine{2745   \}}
\DoxyCodeLine{2746 }
\DoxyCodeLine{2747 }
\DoxyCodeLine{2748 }
\DoxyCodeLine{2750 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2751 \textcolor{keyword}{inline}}
\DoxyCodeLine{2752 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2753 \mbox{\hyperlink{group__diskio_gab2874c9ce3947ee2bda6176591bdc26b}{diskio::save\_csv\_ascii}}(\textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat}}< std::complex<T> >\& x, std::ostream\& f)}
\DoxyCodeLine{2754   \{}
\DoxyCodeLine{2755   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2756   }
\DoxyCodeLine{2757   arma\_ignore(x);}
\DoxyCodeLine{2758   arma\_ignore(f);}
\DoxyCodeLine{2759   }
\DoxyCodeLine{2760   arma\_debug\_warn\_level(1, \textcolor{stringliteral}{"{}saving complex sparse matrices as csv\_ascii not yet implemented"{}});}
\DoxyCodeLine{2761   }
\DoxyCodeLine{2762   \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2763   \}}
\DoxyCodeLine{2764 }
\DoxyCodeLine{2765 }
\DoxyCodeLine{2766 }
\DoxyCodeLine{2768 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{2769 \textcolor{keyword}{inline}}
\DoxyCodeLine{2770 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2771 diskio::save\_coord\_ascii(\textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& x, \textcolor{keyword}{const} std::string\& final\_name)}
\DoxyCodeLine{2772   \{}
\DoxyCodeLine{2773   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2774   }
\DoxyCodeLine{2775   \textcolor{keyword}{const} std::string tmp\_name = \mbox{\hyperlink{group__diskio_gad32fa08afe53746650c31071f88eacab}{diskio::gen\_tmp\_name}}(final\_name);}
\DoxyCodeLine{2776   }
\DoxyCodeLine{2777   std::ofstream f(tmp\_name.c\_str());}
\DoxyCodeLine{2778   }
\DoxyCodeLine{2779   \textcolor{keywordtype}{bool} save\_okay = f.is\_open();}
\DoxyCodeLine{2780   }
\DoxyCodeLine{2781   \textcolor{keywordflow}{if}(save\_okay)}
\DoxyCodeLine{2782     \{}
\DoxyCodeLine{2783     save\_okay = diskio::save\_coord\_ascii(x, f);}
\DoxyCodeLine{2784     }
\DoxyCodeLine{2785     f.flush();}
\DoxyCodeLine{2786     f.close();}
\DoxyCodeLine{2787     }
\DoxyCodeLine{2788     \textcolor{keywordflow}{if}(save\_okay)  \{ save\_okay = \mbox{\hyperlink{group__diskio_gafbccd611e1fec1b6044f81460415d8d3}{diskio::safe\_rename}}(tmp\_name, final\_name); \}}
\DoxyCodeLine{2789     \}}
\DoxyCodeLine{2790   }
\DoxyCodeLine{2791   \textcolor{keywordflow}{return} save\_okay;}
\DoxyCodeLine{2792   \}}
\DoxyCodeLine{2793 }
\DoxyCodeLine{2794 }
\DoxyCodeLine{2795 }
\DoxyCodeLine{2797 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{2798 \textcolor{keyword}{inline}}
\DoxyCodeLine{2799 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2800 diskio::save\_coord\_ascii(\textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& x, std::ostream\& f)}
\DoxyCodeLine{2801   \{}
\DoxyCodeLine{2802   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2803   }
\DoxyCodeLine{2804   \textcolor{keyword}{const} \mbox{\hyperlink{classarma__ostream__state}{arma\_ostream\_state}} stream\_state(f);}
\DoxyCodeLine{2805   }
\DoxyCodeLine{2806   diskio::prepare\_stream<eT>(f);}
\DoxyCodeLine{2807   }
\DoxyCodeLine{2808   \textcolor{keyword}{typename} \mbox{\hyperlink{classSpMat_1_1const__iterator}{SpMat<eT>::const\_iterator}} iter     = x.begin();}
\DoxyCodeLine{2809   \textcolor{keyword}{typename} \mbox{\hyperlink{classSpMat_1_1const__iterator}{SpMat<eT>::const\_iterator}} iter\_end = x.end();}
\DoxyCodeLine{2810   }
\DoxyCodeLine{2811   \textcolor{keywordflow}{for}(; iter != iter\_end; ++iter)}
\DoxyCodeLine{2812     \{}
\DoxyCodeLine{2813     \textcolor{keyword}{const} eT val = (*iter);}
\DoxyCodeLine{2814     }
\DoxyCodeLine{2815     f << iter.row() << \textcolor{charliteral}{' '} << iter.col() << \textcolor{charliteral}{' '} << val << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{2816     \}}
\DoxyCodeLine{2817   }
\DoxyCodeLine{2818   }
\DoxyCodeLine{2819   \textcolor{comment}{// make sure it's possible to figure out the matrix size later}}
\DoxyCodeLine{2820   \textcolor{keywordflow}{if}( (x.n\_rows > 0) \&\& (x.n\_cols > 0) )}
\DoxyCodeLine{2821     \{}
\DoxyCodeLine{2822     \textcolor{keyword}{const} uword max\_row = (x.n\_rows > 0) ? x.n\_rows-\/1 : 0;}
\DoxyCodeLine{2823     \textcolor{keyword}{const} uword max\_col = (x.n\_cols > 0) ? x.n\_cols-\/1 : 0;}
\DoxyCodeLine{2824     }
\DoxyCodeLine{2825     \textcolor{keywordflow}{if}( x.at(max\_row, max\_col) == eT(0) )}
\DoxyCodeLine{2826       \{}
\DoxyCodeLine{2827       f << max\_row << \textcolor{charliteral}{' '} << max\_col << \textcolor{stringliteral}{"{} 0\(\backslash\)n"{}};}
\DoxyCodeLine{2828       \}}
\DoxyCodeLine{2829     \}}
\DoxyCodeLine{2830   }
\DoxyCodeLine{2831   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} save\_okay = f.good();}
\DoxyCodeLine{2832   }
\DoxyCodeLine{2833   stream\_state.restore(f);}
\DoxyCodeLine{2834   }
\DoxyCodeLine{2835   \textcolor{keywordflow}{return} save\_okay;}
\DoxyCodeLine{2836   \}}
\DoxyCodeLine{2837 }
\DoxyCodeLine{2838 }
\DoxyCodeLine{2839 }
\DoxyCodeLine{2841 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2842 \textcolor{keyword}{inline}}
\DoxyCodeLine{2843 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2844 diskio::save\_coord\_ascii(\textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat}}< std::complex<T> >\& x, std::ostream\& f)}
\DoxyCodeLine{2845   \{}
\DoxyCodeLine{2846   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2847   }
\DoxyCodeLine{2848   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<T> eT;}
\DoxyCodeLine{2849   }
\DoxyCodeLine{2850   \textcolor{keyword}{const} \mbox{\hyperlink{classarma__ostream__state}{arma\_ostream\_state}} stream\_state(f);}
\DoxyCodeLine{2851   }
\DoxyCodeLine{2852   diskio::prepare\_stream<eT>(f);}
\DoxyCodeLine{2853   }
\DoxyCodeLine{2854   \textcolor{keyword}{typename} \mbox{\hyperlink{classSpMat_1_1const__iterator}{SpMat<eT>::const\_iterator}} iter     = x.begin();}
\DoxyCodeLine{2855   \textcolor{keyword}{typename} \mbox{\hyperlink{classSpMat_1_1const__iterator}{SpMat<eT>::const\_iterator}} iter\_end = x.end();}
\DoxyCodeLine{2856   }
\DoxyCodeLine{2857   \textcolor{keywordflow}{for}(; iter != iter\_end; ++iter)}
\DoxyCodeLine{2858     \{}
\DoxyCodeLine{2859     \textcolor{keyword}{const} eT val = (*iter);}
\DoxyCodeLine{2860     }
\DoxyCodeLine{2861     f << iter.row() << \textcolor{charliteral}{' '} << iter.col() << \textcolor{charliteral}{' '} << val.real() << \textcolor{charliteral}{' '} << val.imag() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{2862     \}}
\DoxyCodeLine{2863   }
\DoxyCodeLine{2864   \textcolor{comment}{// make sure it's possible to figure out the matrix size later}}
\DoxyCodeLine{2865   \textcolor{keywordflow}{if}( (x.n\_rows > 0) \&\& (x.n\_cols > 0) )}
\DoxyCodeLine{2866     \{}
\DoxyCodeLine{2867     \textcolor{keyword}{const} uword max\_row = (x.n\_rows > 0) ? x.n\_rows-\/1 : 0;}
\DoxyCodeLine{2868     \textcolor{keyword}{const} uword max\_col = (x.n\_cols > 0) ? x.n\_cols-\/1 : 0;}
\DoxyCodeLine{2869     }
\DoxyCodeLine{2870     \textcolor{keywordflow}{if}( x.at(max\_row, max\_col) == eT(0) )}
\DoxyCodeLine{2871       \{}
\DoxyCodeLine{2872       f << max\_row << \textcolor{charliteral}{' '} << max\_col << \textcolor{stringliteral}{"{} 0 0\(\backslash\)n"{}};}
\DoxyCodeLine{2873       \}}
\DoxyCodeLine{2874     \}}
\DoxyCodeLine{2875   }
\DoxyCodeLine{2876   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} save\_okay = f.good();}
\DoxyCodeLine{2877   }
\DoxyCodeLine{2878   stream\_state.restore(f);}
\DoxyCodeLine{2879   }
\DoxyCodeLine{2880   \textcolor{keywordflow}{return} save\_okay;}
\DoxyCodeLine{2881   \}}
\DoxyCodeLine{2882 }
\DoxyCodeLine{2883 }
\DoxyCodeLine{2884 }
\DoxyCodeLine{2887 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{2888 \textcolor{keyword}{inline}}
\DoxyCodeLine{2889 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2890 \mbox{\hyperlink{group__diskio_ga831707949f1f222d23e15603832e079b}{diskio::save\_arma\_binary}}(\textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& x, \textcolor{keyword}{const} std::string\& final\_name)}
\DoxyCodeLine{2891   \{}
\DoxyCodeLine{2892   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2893   }
\DoxyCodeLine{2894   \textcolor{keyword}{const} std::string tmp\_name = \mbox{\hyperlink{group__diskio_gad32fa08afe53746650c31071f88eacab}{diskio::gen\_tmp\_name}}(final\_name);}
\DoxyCodeLine{2895   }
\DoxyCodeLine{2896   std::ofstream f(tmp\_name.c\_str(), std::fstream::binary);}
\DoxyCodeLine{2897   }
\DoxyCodeLine{2898   \textcolor{keywordtype}{bool} save\_okay = f.is\_open();}
\DoxyCodeLine{2899   }
\DoxyCodeLine{2900   \textcolor{keywordflow}{if}(save\_okay)}
\DoxyCodeLine{2901     \{}
\DoxyCodeLine{2902     save\_okay = \mbox{\hyperlink{group__diskio_ga831707949f1f222d23e15603832e079b}{diskio::save\_arma\_binary}}(x, f);}
\DoxyCodeLine{2903     }
\DoxyCodeLine{2904     f.flush();}
\DoxyCodeLine{2905     f.close();}
\DoxyCodeLine{2906     }
\DoxyCodeLine{2907     \textcolor{keywordflow}{if}(save\_okay)  \{ save\_okay = \mbox{\hyperlink{group__diskio_gafbccd611e1fec1b6044f81460415d8d3}{diskio::safe\_rename}}(tmp\_name, final\_name); \}}
\DoxyCodeLine{2908     \}}
\DoxyCodeLine{2909   }
\DoxyCodeLine{2910   \textcolor{keywordflow}{return} save\_okay;}
\DoxyCodeLine{2911   \}}
\DoxyCodeLine{2912 }
\DoxyCodeLine{2913 }
\DoxyCodeLine{2914 }
\DoxyCodeLine{2917 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{2918 \textcolor{keyword}{inline}}
\DoxyCodeLine{2919 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2920 \mbox{\hyperlink{group__diskio_ga831707949f1f222d23e15603832e079b}{diskio::save\_arma\_binary}}(\textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& x, std::ostream\& f)}
\DoxyCodeLine{2921   \{}
\DoxyCodeLine{2922   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2923   }
\DoxyCodeLine{2924   f << \mbox{\hyperlink{group__diskio_ga143c823196ccbd640cf831526cd4933e}{diskio::gen\_bin\_header}}(x) << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{2925   f << x.n\_rows << \textcolor{charliteral}{' '} << x.n\_cols << \textcolor{charliteral}{' '} << x.n\_nonzero << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{2926   }
\DoxyCodeLine{2927   f.write( \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(x.values),      std::streamsize(x.n\_nonzero*\textcolor{keyword}{sizeof}(eT))     );}
\DoxyCodeLine{2928   f.write( \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(x.row\_indices), std::streamsize(x.n\_nonzero*\textcolor{keyword}{sizeof}(uword))  );}
\DoxyCodeLine{2929   f.write( \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(x.col\_ptrs),    std::streamsize((x.n\_cols+1)*\textcolor{keyword}{sizeof}(uword)) );}
\DoxyCodeLine{2930   }
\DoxyCodeLine{2931   \textcolor{keywordflow}{return} f.good();}
\DoxyCodeLine{2932   \}}
\DoxyCodeLine{2933 }
\DoxyCodeLine{2934 }
\DoxyCodeLine{2935 }
\DoxyCodeLine{2936 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{2937 \textcolor{keyword}{inline}}
\DoxyCodeLine{2938 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{2939 \mbox{\hyperlink{group__diskio_gae8a45a3f816b0b5b1e699d3d9f309491}{diskio::load\_csv\_ascii}}(\mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& x, \textcolor{keyword}{const} std::string\& \mbox{\hyperlink{structname}{name}}, std::string\& err\_msg, \mbox{\hyperlink{classfield}{field<std::string>}}\& header, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} with\_header)}
\DoxyCodeLine{2940   \{}
\DoxyCodeLine{2941   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{2942   }
\DoxyCodeLine{2943   std::fstream f;}
\DoxyCodeLine{2944   f.open(\mbox{\hyperlink{structname}{name}}.c\_str(), std::fstream::in);}
\DoxyCodeLine{2945   }
\DoxyCodeLine{2946   \textcolor{keywordtype}{bool} load\_okay = f.is\_open();}
\DoxyCodeLine{2947   }
\DoxyCodeLine{2948   \textcolor{keywordflow}{if}(load\_okay == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2949   }
\DoxyCodeLine{2950   \textcolor{keywordflow}{if}(with\_header)}
\DoxyCodeLine{2951     \{}
\DoxyCodeLine{2952     arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}diskio::load\_csv\_ascii(): reading header"{}});}
\DoxyCodeLine{2953     }
\DoxyCodeLine{2954     std::string              header\_line;}
\DoxyCodeLine{2955     std::stringstream        header\_stream;}
\DoxyCodeLine{2956     std::vector<std::string> header\_tokens;}
\DoxyCodeLine{2957     }
\DoxyCodeLine{2958     std::getline(f, header\_line);}
\DoxyCodeLine{2959     }
\DoxyCodeLine{2960     load\_okay = f.good();}
\DoxyCodeLine{2961     }
\DoxyCodeLine{2962     \textcolor{keywordflow}{if}(load\_okay)}
\DoxyCodeLine{2963       \{}
\DoxyCodeLine{2964       std::string token;}
\DoxyCodeLine{2965       }
\DoxyCodeLine{2966       header\_stream.clear();}
\DoxyCodeLine{2967       header\_stream.str(header\_line);}
\DoxyCodeLine{2968       }
\DoxyCodeLine{2969       uword header\_n\_tokens = 0;}
\DoxyCodeLine{2970       }
\DoxyCodeLine{2971       \textcolor{keywordflow}{while}(header\_stream.good())}
\DoxyCodeLine{2972         \{}
\DoxyCodeLine{2973         std::getline(header\_stream, token, \textcolor{charliteral}{','});}
\DoxyCodeLine{2974         ++header\_n\_tokens;}
\DoxyCodeLine{2975         header\_tokens.push\_back(token);}
\DoxyCodeLine{2976         \}}
\DoxyCodeLine{2977       }
\DoxyCodeLine{2978       \textcolor{keywordflow}{if}(header\_n\_tokens == uword(0))}
\DoxyCodeLine{2979         \{}
\DoxyCodeLine{2980         header.\mbox{\hyperlink{group__field_gac9dc9ea2b0eb588746b147e2e25d48db}{reset}}();}
\DoxyCodeLine{2981         \}}
\DoxyCodeLine{2982       \textcolor{keywordflow}{else}}
\DoxyCodeLine{2983         \{}
\DoxyCodeLine{2984         header.\mbox{\hyperlink{group__field_ga0d8cc9b33d72bd17c62f4492f0459ec8}{set\_size}}(1,header\_n\_tokens);}
\DoxyCodeLine{2985         }
\DoxyCodeLine{2986         \textcolor{keywordflow}{for}(uword i=0; i < header\_n\_tokens; ++i)  \{ header.\mbox{\hyperlink{group__field_gad86418c0a65bb58844812b995560cffe}{at}}(i) = header\_tokens[i]; \}}
\DoxyCodeLine{2987         \}}
\DoxyCodeLine{2988       \}}
\DoxyCodeLine{2989     \}}
\DoxyCodeLine{2990   }
\DoxyCodeLine{2991   \textcolor{keywordflow}{if}(load\_okay)}
\DoxyCodeLine{2992     \{}
\DoxyCodeLine{2993     load\_okay = \mbox{\hyperlink{group__diskio_gae8a45a3f816b0b5b1e699d3d9f309491}{diskio::load\_csv\_ascii}}(x, f, err\_msg);}
\DoxyCodeLine{2994     \}}
\DoxyCodeLine{2995   }
\DoxyCodeLine{2996   f.close();}
\DoxyCodeLine{2997   }
\DoxyCodeLine{2998   \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{2999   \}}
\DoxyCodeLine{3000 }
\DoxyCodeLine{3001 }
\DoxyCodeLine{3002 }
\DoxyCodeLine{3003 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{3004 \textcolor{keyword}{inline}}
\DoxyCodeLine{3005 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{3006 \mbox{\hyperlink{group__diskio_gae8a45a3f816b0b5b1e699d3d9f309491}{diskio::load\_csv\_ascii}}(\mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& x, std::istream\& f, std::string\& err\_msg)}
\DoxyCodeLine{3007   \{}
\DoxyCodeLine{3008   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{3009   }
\DoxyCodeLine{3010   \textcolor{comment}{// TODO: replace with more efficient implementation}}
\DoxyCodeLine{3011   }
\DoxyCodeLine{3012   \textcolor{keywordflow}{if}(f.good() == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{3013   }
\DoxyCodeLine{3014   f.clear();}
\DoxyCodeLine{3015   \textcolor{keyword}{const} std::fstream::pos\_type pos1 = f.tellg();}
\DoxyCodeLine{3016   }
\DoxyCodeLine{3017   \textcolor{comment}{//}}
\DoxyCodeLine{3018   \textcolor{comment}{// work out the size}}
\DoxyCodeLine{3019   }
\DoxyCodeLine{3020   uword f\_n\_rows = 0;}
\DoxyCodeLine{3021   uword f\_n\_cols = 0;}
\DoxyCodeLine{3022   }
\DoxyCodeLine{3023   std::string       line\_string;}
\DoxyCodeLine{3024   std::stringstream line\_stream;}
\DoxyCodeLine{3025   }
\DoxyCodeLine{3026   std::string token;}
\DoxyCodeLine{3027   }
\DoxyCodeLine{3028   \textcolor{keywordflow}{while}(f.good())}
\DoxyCodeLine{3029     \{}
\DoxyCodeLine{3030     std::getline(f, line\_string);}
\DoxyCodeLine{3031     }
\DoxyCodeLine{3032     \textcolor{keywordflow}{if}(line\_string.size() == 0)  \{ \textcolor{keywordflow}{break}; \}}
\DoxyCodeLine{3033     }
\DoxyCodeLine{3034     line\_stream.clear();}
\DoxyCodeLine{3035     line\_stream.str(line\_string);}
\DoxyCodeLine{3036     }
\DoxyCodeLine{3037     uword line\_n\_cols = 0;}
\DoxyCodeLine{3038     }
\DoxyCodeLine{3039     \textcolor{keywordflow}{while}(line\_stream.good())}
\DoxyCodeLine{3040       \{}
\DoxyCodeLine{3041       std::getline(line\_stream, token, \textcolor{charliteral}{','});}
\DoxyCodeLine{3042       ++line\_n\_cols;}
\DoxyCodeLine{3043       \}}
\DoxyCodeLine{3044     }
\DoxyCodeLine{3045     \textcolor{keywordflow}{if}(f\_n\_cols < line\_n\_cols)  \{ f\_n\_cols = line\_n\_cols; \}}
\DoxyCodeLine{3046     }
\DoxyCodeLine{3047     ++f\_n\_rows;}
\DoxyCodeLine{3048     \}}
\DoxyCodeLine{3049   }
\DoxyCodeLine{3050   f.clear();}
\DoxyCodeLine{3051   f.seekg(pos1);}
\DoxyCodeLine{3052   }
\DoxyCodeLine{3053   \textcolor{keywordflow}{try}}
\DoxyCodeLine{3054     \{}
\DoxyCodeLine{3055     \mbox{\hyperlink{classMapMat}{MapMat<eT>}} tmp(f\_n\_rows, f\_n\_cols);}
\DoxyCodeLine{3056     }
\DoxyCodeLine{3057     uword row = 0;}
\DoxyCodeLine{3058     }
\DoxyCodeLine{3059     \textcolor{keywordflow}{while}(f.good())}
\DoxyCodeLine{3060       \{}
\DoxyCodeLine{3061       std::getline(f, line\_string);}
\DoxyCodeLine{3062       }
\DoxyCodeLine{3063       \textcolor{keywordflow}{if}(line\_string.size() == 0)  \{ \textcolor{keywordflow}{break}; \}}
\DoxyCodeLine{3064       }
\DoxyCodeLine{3065       line\_stream.clear();}
\DoxyCodeLine{3066       line\_stream.str(line\_string);}
\DoxyCodeLine{3067       }
\DoxyCodeLine{3068       uword col = 0;}
\DoxyCodeLine{3069       }
\DoxyCodeLine{3070       \textcolor{keywordflow}{while}(line\_stream.good())}
\DoxyCodeLine{3071         \{}
\DoxyCodeLine{3072         std::getline(line\_stream, token, \textcolor{charliteral}{','});}
\DoxyCodeLine{3073         }
\DoxyCodeLine{3074         eT val = eT(0);}
\DoxyCodeLine{3075         }
\DoxyCodeLine{3076         diskio::convert\_token( val, token );}
\DoxyCodeLine{3077         }
\DoxyCodeLine{3078         \textcolor{keywordflow}{if}(val != eT(0))  \{ tmp(row,col) = val; \}}
\DoxyCodeLine{3079         }
\DoxyCodeLine{3080         ++col;}
\DoxyCodeLine{3081         \}}
\DoxyCodeLine{3082       }
\DoxyCodeLine{3083       ++row;}
\DoxyCodeLine{3084       \}}
\DoxyCodeLine{3085     }
\DoxyCodeLine{3086     x = tmp;}
\DoxyCodeLine{3087     \}}
\DoxyCodeLine{3088   \textcolor{keywordflow}{catch}(...)}
\DoxyCodeLine{3089     \{}
\DoxyCodeLine{3090     err\_msg = \textcolor{stringliteral}{"{}not enough memory"{}};}
\DoxyCodeLine{3091     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3092     \}}
\DoxyCodeLine{3093   }
\DoxyCodeLine{3094   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3095   \}}
\DoxyCodeLine{3096 }
\DoxyCodeLine{3097 }
\DoxyCodeLine{3098 }
\DoxyCodeLine{3099 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3100 \textcolor{keyword}{inline}}
\DoxyCodeLine{3101 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{3102 \mbox{\hyperlink{group__diskio_gae8a45a3f816b0b5b1e699d3d9f309491}{diskio::load\_csv\_ascii}}(\mbox{\hyperlink{classSpMat}{SpMat}}< std::complex<T> >\& x, std::istream\& f, std::string\& err\_msg)}
\DoxyCodeLine{3103   \{}
\DoxyCodeLine{3104   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{3105   }
\DoxyCodeLine{3106   arma\_ignore(x);}
\DoxyCodeLine{3107   arma\_ignore(f);}
\DoxyCodeLine{3108   arma\_ignore(err\_msg);}
\DoxyCodeLine{3109   }
\DoxyCodeLine{3110   arma\_debug\_warn\_level(1, \textcolor{stringliteral}{"{}loading complex sparse matrices as csv\_ascii not yet implemented"{}});}
\DoxyCodeLine{3111   }
\DoxyCodeLine{3112   \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3113   \}}
\DoxyCodeLine{3114 }
\DoxyCodeLine{3115 }
\DoxyCodeLine{3116 }
\DoxyCodeLine{3117 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{3118 \textcolor{keyword}{inline}}
\DoxyCodeLine{3119 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{3120 diskio::load\_coord\_ascii(\mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& x, \textcolor{keyword}{const} std::string\& \mbox{\hyperlink{structname}{name}}, std::string\& err\_msg)}
\DoxyCodeLine{3121   \{}
\DoxyCodeLine{3122   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{3123   }
\DoxyCodeLine{3124   std::fstream f;}
\DoxyCodeLine{3125   f.open(\mbox{\hyperlink{structname}{name}}.c\_str(), std::fstream::in | std::fstream::binary);}
\DoxyCodeLine{3126   }
\DoxyCodeLine{3127   \textcolor{keywordtype}{bool} load\_okay = f.is\_open();}
\DoxyCodeLine{3128   }
\DoxyCodeLine{3129   \textcolor{keywordflow}{if}(load\_okay)}
\DoxyCodeLine{3130     \{}
\DoxyCodeLine{3131     load\_okay = diskio::load\_coord\_ascii(x, f, err\_msg);}
\DoxyCodeLine{3132     f.close();}
\DoxyCodeLine{3133     \}}
\DoxyCodeLine{3134   }
\DoxyCodeLine{3135   \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{3136   \}}
\DoxyCodeLine{3137 }
\DoxyCodeLine{3138 }
\DoxyCodeLine{3139 }
\DoxyCodeLine{3140 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{3141 \textcolor{keyword}{inline}}
\DoxyCodeLine{3142 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{3143 diskio::load\_coord\_ascii(\mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& x, std::istream\& f, std::string\& err\_msg)}
\DoxyCodeLine{3144   \{}
\DoxyCodeLine{3145   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{3146   }
\DoxyCodeLine{3147   \textcolor{keywordflow}{if}(f.good() == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{3148   }
\DoxyCodeLine{3149   f.clear();}
\DoxyCodeLine{3150   \textcolor{keyword}{const} std::fstream::pos\_type pos1 = f.tellg();}
\DoxyCodeLine{3151   }
\DoxyCodeLine{3152   \textcolor{comment}{// work out the size}}
\DoxyCodeLine{3153   }
\DoxyCodeLine{3154   uword f\_n\_rows = 0;}
\DoxyCodeLine{3155   uword f\_n\_cols = 0;}
\DoxyCodeLine{3156   }
\DoxyCodeLine{3157   \textcolor{keywordtype}{bool} size\_found = \textcolor{keyword}{false};}
\DoxyCodeLine{3158   }
\DoxyCodeLine{3159   std::string       line\_string;}
\DoxyCodeLine{3160   std::stringstream line\_stream;}
\DoxyCodeLine{3161   }
\DoxyCodeLine{3162   std::string token;}
\DoxyCodeLine{3163   }
\DoxyCodeLine{3164   \textcolor{keywordflow}{while}(f.good())}
\DoxyCodeLine{3165     \{}
\DoxyCodeLine{3166     std::getline(f, line\_string);}
\DoxyCodeLine{3167     }
\DoxyCodeLine{3168     \textcolor{keywordflow}{if}(line\_string.size() == 0)  \{ \textcolor{keywordflow}{break}; \}}
\DoxyCodeLine{3169     }
\DoxyCodeLine{3170     line\_stream.clear();}
\DoxyCodeLine{3171     line\_stream.str(line\_string);}
\DoxyCodeLine{3172     }
\DoxyCodeLine{3173     uword line\_row = 0;}
\DoxyCodeLine{3174     uword line\_col = 0;}
\DoxyCodeLine{3175     }
\DoxyCodeLine{3176     \textcolor{comment}{// a valid line in co-\/ord format has at least 2 entries}}
\DoxyCodeLine{3177     }
\DoxyCodeLine{3178     line\_stream >> line\_row;}
\DoxyCodeLine{3179     }
\DoxyCodeLine{3180     \textcolor{keywordflow}{if}(line\_stream.good() == \textcolor{keyword}{false})  \{ err\_msg = \textcolor{stringliteral}{"{}incorrect format"{}}; \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{3181     }
\DoxyCodeLine{3182     line\_stream >> line\_col;}
\DoxyCodeLine{3183     }
\DoxyCodeLine{3184     size\_found = \textcolor{keyword}{true};}
\DoxyCodeLine{3185     }
\DoxyCodeLine{3186     \textcolor{keywordflow}{if}(f\_n\_rows < line\_row)  \{ f\_n\_rows = line\_row; \}}
\DoxyCodeLine{3187     \textcolor{keywordflow}{if}(f\_n\_cols < line\_col)  \{ f\_n\_cols = line\_col; \}}
\DoxyCodeLine{3188     \}}
\DoxyCodeLine{3189   }
\DoxyCodeLine{3190   \textcolor{comment}{// take into account that indices start at 0}}
\DoxyCodeLine{3191   \textcolor{keywordflow}{if}(size\_found)  \{ ++f\_n\_rows;  ++f\_n\_cols; \}}
\DoxyCodeLine{3192   }
\DoxyCodeLine{3193   f.clear();}
\DoxyCodeLine{3194   f.seekg(pos1);}
\DoxyCodeLine{3195   }
\DoxyCodeLine{3196   \textcolor{keywordflow}{try}}
\DoxyCodeLine{3197     \{}
\DoxyCodeLine{3198     \mbox{\hyperlink{classMapMat}{MapMat<eT>}} tmp(f\_n\_rows, f\_n\_cols);}
\DoxyCodeLine{3199     }
\DoxyCodeLine{3200     \textcolor{keywordflow}{while}(f.good())}
\DoxyCodeLine{3201       \{}
\DoxyCodeLine{3202       std::getline(f, line\_string);}
\DoxyCodeLine{3203       }
\DoxyCodeLine{3204       \textcolor{keywordflow}{if}(line\_string.size() == 0)  \{ \textcolor{keywordflow}{break}; \}}
\DoxyCodeLine{3205       }
\DoxyCodeLine{3206       line\_stream.clear();}
\DoxyCodeLine{3207       line\_stream.str(line\_string);}
\DoxyCodeLine{3208       }
\DoxyCodeLine{3209       uword line\_row = 0;}
\DoxyCodeLine{3210       uword line\_col = 0;}
\DoxyCodeLine{3211       }
\DoxyCodeLine{3212       line\_stream >> line\_row;}
\DoxyCodeLine{3213       line\_stream >> line\_col;}
\DoxyCodeLine{3214       }
\DoxyCodeLine{3215       eT val = eT(0);}
\DoxyCodeLine{3216       }
\DoxyCodeLine{3217       line\_stream >> token;}
\DoxyCodeLine{3218       }
\DoxyCodeLine{3219       \textcolor{keywordflow}{if}(line\_stream.fail() == \textcolor{keyword}{false})}
\DoxyCodeLine{3220         \{}
\DoxyCodeLine{3221         diskio::convert\_token( val, token );}
\DoxyCodeLine{3222         \}}
\DoxyCodeLine{3223       }
\DoxyCodeLine{3224       \textcolor{keywordflow}{if}(val != eT(0))  \{ tmp(line\_row,line\_col) = val; \}}
\DoxyCodeLine{3225       \}}
\DoxyCodeLine{3226     }
\DoxyCodeLine{3227     x = tmp;}
\DoxyCodeLine{3228     \}}
\DoxyCodeLine{3229   \textcolor{keywordflow}{catch}(...)}
\DoxyCodeLine{3230     \{}
\DoxyCodeLine{3231     err\_msg = \textcolor{stringliteral}{"{}not enough memory"{}};}
\DoxyCodeLine{3232     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3233     \}}
\DoxyCodeLine{3234   }
\DoxyCodeLine{3235   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3236   \}}
\DoxyCodeLine{3237 }
\DoxyCodeLine{3238 }
\DoxyCodeLine{3239 }
\DoxyCodeLine{3240 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3241 \textcolor{keyword}{inline}}
\DoxyCodeLine{3242 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{3243 diskio::load\_coord\_ascii(\mbox{\hyperlink{classSpMat}{SpMat}}< std::complex<T> >\& x, std::istream\& f, std::string\& err\_msg)}
\DoxyCodeLine{3244   \{}
\DoxyCodeLine{3245   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{3246   }
\DoxyCodeLine{3247   \textcolor{keywordflow}{if}(f.good() == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{3248   }
\DoxyCodeLine{3249   f.clear();}
\DoxyCodeLine{3250   \textcolor{keyword}{const} std::fstream::pos\_type pos1 = f.tellg();}
\DoxyCodeLine{3251   }
\DoxyCodeLine{3252   \textcolor{comment}{// work out the size}}
\DoxyCodeLine{3253   }
\DoxyCodeLine{3254   uword f\_n\_rows = 0;}
\DoxyCodeLine{3255   uword f\_n\_cols = 0;}
\DoxyCodeLine{3256   }
\DoxyCodeLine{3257   \textcolor{keywordtype}{bool} size\_found = \textcolor{keyword}{false};}
\DoxyCodeLine{3258   }
\DoxyCodeLine{3259   std::string       line\_string;}
\DoxyCodeLine{3260   std::stringstream line\_stream;}
\DoxyCodeLine{3261   }
\DoxyCodeLine{3262   std::string token\_real;}
\DoxyCodeLine{3263   std::string token\_imag;}
\DoxyCodeLine{3264   }
\DoxyCodeLine{3265   \textcolor{keywordflow}{while}(f.good())}
\DoxyCodeLine{3266     \{}
\DoxyCodeLine{3267     std::getline(f, line\_string);}
\DoxyCodeLine{3268     }
\DoxyCodeLine{3269     \textcolor{keywordflow}{if}(line\_string.size() == 0)  \{ \textcolor{keywordflow}{break}; \}}
\DoxyCodeLine{3270     }
\DoxyCodeLine{3271     line\_stream.clear();}
\DoxyCodeLine{3272     line\_stream.str(line\_string);}
\DoxyCodeLine{3273     }
\DoxyCodeLine{3274     uword line\_row = 0;}
\DoxyCodeLine{3275     uword line\_col = 0;}
\DoxyCodeLine{3276     }
\DoxyCodeLine{3277     \textcolor{comment}{// a valid line in co-\/ord format has at least 2 entries}}
\DoxyCodeLine{3278     }
\DoxyCodeLine{3279     line\_stream >> line\_row;}
\DoxyCodeLine{3280     }
\DoxyCodeLine{3281     \textcolor{keywordflow}{if}(line\_stream.good() == \textcolor{keyword}{false})  \{ err\_msg = \textcolor{stringliteral}{"{}incorrect format"{}}; \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{3282     }
\DoxyCodeLine{3283     line\_stream >> line\_col;}
\DoxyCodeLine{3284     }
\DoxyCodeLine{3285     size\_found = \textcolor{keyword}{true};}
\DoxyCodeLine{3286     }
\DoxyCodeLine{3287     \textcolor{keywordflow}{if}(f\_n\_rows < line\_row)  f\_n\_rows = line\_row;}
\DoxyCodeLine{3288     \textcolor{keywordflow}{if}(f\_n\_cols < line\_col)  f\_n\_cols = line\_col;}
\DoxyCodeLine{3289     \}}
\DoxyCodeLine{3290   }
\DoxyCodeLine{3291   \textcolor{comment}{// take into account that indices start at 0}}
\DoxyCodeLine{3292   \textcolor{keywordflow}{if}(size\_found)  \{ ++f\_n\_rows;  ++f\_n\_cols; \}}
\DoxyCodeLine{3293   }
\DoxyCodeLine{3294   f.clear();}
\DoxyCodeLine{3295   f.seekg(pos1);}
\DoxyCodeLine{3296   }
\DoxyCodeLine{3297   \textcolor{keywordflow}{try}}
\DoxyCodeLine{3298     \{}
\DoxyCodeLine{3299     \mbox{\hyperlink{classMapMat}{MapMat< std::complex<T>}} > tmp(f\_n\_rows, f\_n\_cols);}
\DoxyCodeLine{3300     }
\DoxyCodeLine{3301     \textcolor{keywordflow}{while}(f.good())}
\DoxyCodeLine{3302       \{}
\DoxyCodeLine{3303       std::getline(f, line\_string);}
\DoxyCodeLine{3304       }
\DoxyCodeLine{3305       \textcolor{keywordflow}{if}(line\_string.size() == 0)  \{ \textcolor{keywordflow}{break}; \}}
\DoxyCodeLine{3306       }
\DoxyCodeLine{3307       line\_stream.clear();}
\DoxyCodeLine{3308       line\_stream.str(line\_string);}
\DoxyCodeLine{3309       }
\DoxyCodeLine{3310       uword line\_row = 0;}
\DoxyCodeLine{3311       uword line\_col = 0;}
\DoxyCodeLine{3312       }
\DoxyCodeLine{3313       line\_stream >> line\_row;}
\DoxyCodeLine{3314       line\_stream >> line\_col;}
\DoxyCodeLine{3315       }
\DoxyCodeLine{3316       T val\_real = T(0);}
\DoxyCodeLine{3317       T val\_imag = T(0);}
\DoxyCodeLine{3318       }
\DoxyCodeLine{3319       line\_stream >> token\_real;}
\DoxyCodeLine{3320       }
\DoxyCodeLine{3321       \textcolor{keywordflow}{if}(line\_stream.fail() == \textcolor{keyword}{false})}
\DoxyCodeLine{3322         \{}
\DoxyCodeLine{3323         diskio::convert\_token( val\_real, token\_real );}
\DoxyCodeLine{3324         \}}
\DoxyCodeLine{3325       }
\DoxyCodeLine{3326       }
\DoxyCodeLine{3327       line\_stream >> token\_imag;}
\DoxyCodeLine{3328       }
\DoxyCodeLine{3329       \textcolor{keywordflow}{if}(line\_stream.fail() == \textcolor{keyword}{false})}
\DoxyCodeLine{3330         \{}
\DoxyCodeLine{3331         diskio::convert\_token( val\_imag, token\_imag );}
\DoxyCodeLine{3332         \}}
\DoxyCodeLine{3333       }
\DoxyCodeLine{3334       \textcolor{keywordflow}{if}( (val\_real != T(0)) || (val\_imag != T(0)) )}
\DoxyCodeLine{3335         \{}
\DoxyCodeLine{3336         tmp(line\_row,line\_col) = std::complex<T>(val\_real, val\_imag);}
\DoxyCodeLine{3337         \}}
\DoxyCodeLine{3338       \}}
\DoxyCodeLine{3339     }
\DoxyCodeLine{3340     x = tmp;}
\DoxyCodeLine{3341     \}}
\DoxyCodeLine{3342   \textcolor{keywordflow}{catch}(...)}
\DoxyCodeLine{3343     \{}
\DoxyCodeLine{3344     err\_msg = \textcolor{stringliteral}{"{}not enough memory"{}};}
\DoxyCodeLine{3345     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3346     \}}
\DoxyCodeLine{3347   }
\DoxyCodeLine{3348   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3349   \}}
\DoxyCodeLine{3350 }
\DoxyCodeLine{3351 }
\DoxyCodeLine{3352 }
\DoxyCodeLine{3355 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{3356 \textcolor{keyword}{inline}}
\DoxyCodeLine{3357 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{3358 \mbox{\hyperlink{group__diskio_ga7d310b89b83e6327a818215bb3124aa0}{diskio::load\_arma\_binary}}(\mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& x, \textcolor{keyword}{const} std::string\& \mbox{\hyperlink{structname}{name}}, std::string\& err\_msg)}
\DoxyCodeLine{3359   \{}
\DoxyCodeLine{3360   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{3361   }
\DoxyCodeLine{3362   std::ifstream f;}
\DoxyCodeLine{3363   f.open(\mbox{\hyperlink{structname}{name}}.c\_str(), std::fstream::binary);}
\DoxyCodeLine{3364   }
\DoxyCodeLine{3365   \textcolor{keywordtype}{bool} load\_okay = f.is\_open();}
\DoxyCodeLine{3366   }
\DoxyCodeLine{3367   \textcolor{keywordflow}{if}(load\_okay)}
\DoxyCodeLine{3368     \{}
\DoxyCodeLine{3369     load\_okay = \mbox{\hyperlink{group__diskio_ga7d310b89b83e6327a818215bb3124aa0}{diskio::load\_arma\_binary}}(x, f, err\_msg);}
\DoxyCodeLine{3370     f.close();}
\DoxyCodeLine{3371     \}}
\DoxyCodeLine{3372   }
\DoxyCodeLine{3373   \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{3374   \}}
\DoxyCodeLine{3375 }
\DoxyCodeLine{3376 }
\DoxyCodeLine{3377 }
\DoxyCodeLine{3378 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{3379 \textcolor{keyword}{inline}}
\DoxyCodeLine{3380 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{3381 \mbox{\hyperlink{group__diskio_ga7d310b89b83e6327a818215bb3124aa0}{diskio::load\_arma\_binary}}(\mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& x, std::istream\& f, std::string\& err\_msg)}
\DoxyCodeLine{3382   \{}
\DoxyCodeLine{3383   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{3384   }
\DoxyCodeLine{3385   \textcolor{keywordtype}{bool} load\_okay = \textcolor{keyword}{true};}
\DoxyCodeLine{3386   }
\DoxyCodeLine{3387   std::string f\_header;}
\DoxyCodeLine{3388   }
\DoxyCodeLine{3389   f >> f\_header;}
\DoxyCodeLine{3390   }
\DoxyCodeLine{3391   \textcolor{keywordflow}{if}(f\_header == \mbox{\hyperlink{group__diskio_ga143c823196ccbd640cf831526cd4933e}{diskio::gen\_bin\_header}}(x))}
\DoxyCodeLine{3392     \{}
\DoxyCodeLine{3393     uword f\_n\_rows;}
\DoxyCodeLine{3394     uword f\_n\_cols;}
\DoxyCodeLine{3395     uword f\_n\_nz;}
\DoxyCodeLine{3396     }
\DoxyCodeLine{3397     f >> f\_n\_rows;}
\DoxyCodeLine{3398     f >> f\_n\_cols;}
\DoxyCodeLine{3399     f >> f\_n\_nz;}
\DoxyCodeLine{3400     }
\DoxyCodeLine{3401     \textcolor{comment}{//f.seekg(1, ios::cur);  // NOTE: this may not be portable, as on a Windows machine a newline could be two characters}}
\DoxyCodeLine{3402     f.get();}
\DoxyCodeLine{3403     }
\DoxyCodeLine{3404     \textcolor{keywordflow}{try} \{ x.reserve(f\_n\_rows, f\_n\_cols, f\_n\_nz); \} \textcolor{keywordflow}{catch}(...) \{ err\_msg = \textcolor{stringliteral}{"{}not enough memory"{}}; \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{3405     }
\DoxyCodeLine{3406     f.read( \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(access::rwp(x.values)),      std::streamsize(x.n\_nonzero*\textcolor{keyword}{sizeof}(eT))     );}
\DoxyCodeLine{3407     }
\DoxyCodeLine{3408     std::streampos pos = f.tellg();}
\DoxyCodeLine{3409     }
\DoxyCodeLine{3410     f.read( \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(access::rwp(x.row\_indices)), std::streamsize(x.n\_nonzero*\textcolor{keyword}{sizeof}(uword))  );}
\DoxyCodeLine{3411     f.read( \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(access::rwp(x.col\_ptrs)),    std::streamsize((x.n\_cols+1)*\textcolor{keyword}{sizeof}(uword)) );}
\DoxyCodeLine{3412     }
\DoxyCodeLine{3413     \textcolor{keywordtype}{bool} check1 = \textcolor{keyword}{true};  \textcolor{keywordflow}{for}(uword i=0; i < x.n\_nonzero; ++i)  \{ \textcolor{keywordflow}{if}(x.values[i] == eT(0))  \{ check1 = \textcolor{keyword}{false}; \textcolor{keywordflow}{break}; \} \}}
\DoxyCodeLine{3414     \textcolor{keywordtype}{bool} check2 = \textcolor{keyword}{true};  \textcolor{keywordflow}{for}(uword i=0; i < x.n\_cols;    ++i)  \{ \textcolor{keywordflow}{if}(x.col\_ptrs[i+1] < x.col\_ptrs[i])  \{ check2 = \textcolor{keyword}{false}; \textcolor{keywordflow}{break}; \} \}}
\DoxyCodeLine{3415     \textcolor{keywordtype}{bool} check3 = (x.col\_ptrs[x.n\_cols] == x.n\_nonzero);}
\DoxyCodeLine{3416     }
\DoxyCodeLine{3417     \textcolor{keywordflow}{if}((check1 == \textcolor{keyword}{true}) \&\& ((check2 == \textcolor{keyword}{false}) || (check3 == \textcolor{keyword}{false})))}
\DoxyCodeLine{3418       \{}
\DoxyCodeLine{3419       \textcolor{keywordflow}{if}(\textcolor{keyword}{sizeof}(uword) == 8)}
\DoxyCodeLine{3420         \{}
\DoxyCodeLine{3421         arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}detected inconsistent data while loading; re-\/reading integer parts as u32"{}});}
\DoxyCodeLine{3422         }
\DoxyCodeLine{3423         \textcolor{comment}{// inconstency could be due to a different uword size used during saving,}}
\DoxyCodeLine{3424         \textcolor{comment}{// so try loading the row\_indices and col\_ptrs under the assumption of 32 bit unsigned integers}}
\DoxyCodeLine{3425         }
\DoxyCodeLine{3426         f.clear();}
\DoxyCodeLine{3427         f.seekg(pos);}
\DoxyCodeLine{3428         }
\DoxyCodeLine{3429         \mbox{\hyperlink{classpodarray}{podarray<u32>}} tmp\_a(x.n\_nonzero );  tmp\_a.zeros();}
\DoxyCodeLine{3430         \mbox{\hyperlink{classpodarray}{podarray<u32>}} tmp\_b(x.n\_cols + 1);  tmp\_b.zeros();}
\DoxyCodeLine{3431         }
\DoxyCodeLine{3432         f.read( \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(tmp\_a.memptr()), std::streamsize( x.n\_nonzero   * \textcolor{keyword}{sizeof}(u32)) );}
\DoxyCodeLine{3433         f.read( \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(tmp\_b.memptr()), std::streamsize((x.n\_cols + 1) * \textcolor{keyword}{sizeof}(u32)) );}
\DoxyCodeLine{3434         }
\DoxyCodeLine{3435         check2 = \textcolor{keyword}{true};  \textcolor{keywordflow}{for}(uword i=0; i < x.n\_cols; ++i)  \{ \textcolor{keywordflow}{if}(tmp\_b[i+1] < tmp\_b[i])  \{ check2 = \textcolor{keyword}{false}; \textcolor{keywordflow}{break}; \} \}}
\DoxyCodeLine{3436         check3 = (tmp\_b[x.n\_cols] == x.n\_nonzero);}
\DoxyCodeLine{3437         }
\DoxyCodeLine{3438         load\_okay = f.good();}
\DoxyCodeLine{3439         }
\DoxyCodeLine{3440         \textcolor{keywordflow}{if}( load\_okay \&\& (check2 == \textcolor{keyword}{true}) \&\& (check3 == \textcolor{keyword}{true}) )}
\DoxyCodeLine{3441           \{}
\DoxyCodeLine{3442           arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}reading integer parts as u32 succeeded"{}});}
\DoxyCodeLine{3443           }
\DoxyCodeLine{3444           arrayops::convert(access::rwp(x.row\_indices), tmp\_a.memptr(), x.n\_nonzero );}
\DoxyCodeLine{3445           arrayops::convert(access::rwp(x.col\_ptrs),    tmp\_b.memptr(), x.n\_cols + 1);}
\DoxyCodeLine{3446           \}}
\DoxyCodeLine{3447         \textcolor{keywordflow}{else}}
\DoxyCodeLine{3448           \{}
\DoxyCodeLine{3449           arma\_extra\_debug\_print(\textcolor{stringliteral}{"{}reading integer parts as u32 failed"{}});}
\DoxyCodeLine{3450           \}}
\DoxyCodeLine{3451         \}}
\DoxyCodeLine{3452       \}}
\DoxyCodeLine{3453     }
\DoxyCodeLine{3454     \textcolor{keywordflow}{if}((check1 == \textcolor{keyword}{false}) || (check2 == \textcolor{keyword}{false}) || (check3 == \textcolor{keyword}{false}))}
\DoxyCodeLine{3455       \{}
\DoxyCodeLine{3456       load\_okay = \textcolor{keyword}{false};}
\DoxyCodeLine{3457       err\_msg = \textcolor{stringliteral}{"{}inconsistent data"{}};}
\DoxyCodeLine{3458       \}}
\DoxyCodeLine{3459     \textcolor{keywordflow}{else}}
\DoxyCodeLine{3460       \{}
\DoxyCodeLine{3461       load\_okay = f.good();}
\DoxyCodeLine{3462       \}}
\DoxyCodeLine{3463     \}}
\DoxyCodeLine{3464   \textcolor{keywordflow}{else}}
\DoxyCodeLine{3465     \{}
\DoxyCodeLine{3466     load\_okay = \textcolor{keyword}{false};}
\DoxyCodeLine{3467     err\_msg = \textcolor{stringliteral}{"{}incorrect header"{}};}
\DoxyCodeLine{3468     \}}
\DoxyCodeLine{3469   }
\DoxyCodeLine{3470   \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{3471   \}}
\DoxyCodeLine{3472 }
\DoxyCodeLine{3473 }
\DoxyCodeLine{3474 }
\DoxyCodeLine{3475 \textcolor{comment}{// cubes}}
\DoxyCodeLine{3476 }
\DoxyCodeLine{3477 }
\DoxyCodeLine{3478 }
\DoxyCodeLine{3480 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{3481 \textcolor{keyword}{inline}}
\DoxyCodeLine{3482 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{3483 \mbox{\hyperlink{group__diskio_ga0e3f9c9fad9eefa6ef90ebab6516d684}{diskio::save\_raw\_ascii}}(\textcolor{keyword}{const} \mbox{\hyperlink{classCube}{Cube<eT>}}\& x, \textcolor{keyword}{const} std::string\& final\_name)}
\DoxyCodeLine{3484   \{}
\DoxyCodeLine{3485   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{3486   }
\DoxyCodeLine{3487   \textcolor{keyword}{const} std::string tmp\_name = \mbox{\hyperlink{group__diskio_gad32fa08afe53746650c31071f88eacab}{diskio::gen\_tmp\_name}}(final\_name);}
\DoxyCodeLine{3488   }
\DoxyCodeLine{3489   std::fstream f(tmp\_name.c\_str(), std::fstream::out);}
\DoxyCodeLine{3490   }
\DoxyCodeLine{3491   \textcolor{keywordtype}{bool} save\_okay = f.is\_open();}
\DoxyCodeLine{3492   }
\DoxyCodeLine{3493   \textcolor{keywordflow}{if}(save\_okay)}
\DoxyCodeLine{3494     \{}
\DoxyCodeLine{3495     save\_okay = \mbox{\hyperlink{group__diskio_ga0e3f9c9fad9eefa6ef90ebab6516d684}{save\_raw\_ascii}}(x, f);}
\DoxyCodeLine{3496     }
\DoxyCodeLine{3497     f.flush();}
\DoxyCodeLine{3498     f.close();}
\DoxyCodeLine{3499     }
\DoxyCodeLine{3500     \textcolor{keywordflow}{if}(save\_okay)  \{ save\_okay = \mbox{\hyperlink{group__diskio_gafbccd611e1fec1b6044f81460415d8d3}{diskio::safe\_rename}}(tmp\_name, final\_name); \}}
\DoxyCodeLine{3501     \}}
\DoxyCodeLine{3502   }
\DoxyCodeLine{3503   \textcolor{keywordflow}{return} save\_okay;}
\DoxyCodeLine{3504   \}}
\DoxyCodeLine{3505 }
\DoxyCodeLine{3506 }
\DoxyCodeLine{3507 }
\DoxyCodeLine{3509 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{3510 \textcolor{keyword}{inline}}
\DoxyCodeLine{3511 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{3512 \mbox{\hyperlink{group__diskio_ga0e3f9c9fad9eefa6ef90ebab6516d684}{diskio::save\_raw\_ascii}}(\textcolor{keyword}{const} \mbox{\hyperlink{classCube}{Cube<eT>}}\& x, std::ostream\& f)}
\DoxyCodeLine{3513   \{}
\DoxyCodeLine{3514   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{3515   }
\DoxyCodeLine{3516   \textcolor{keyword}{const} \mbox{\hyperlink{classarma__ostream__state}{arma\_ostream\_state}} stream\_state(f);}
\DoxyCodeLine{3517   }
\DoxyCodeLine{3518   \textcolor{keyword}{const} std::streamsize cell\_width = diskio::prepare\_stream<eT>(f);}
\DoxyCodeLine{3519   }
\DoxyCodeLine{3520   \textcolor{keywordflow}{for}(uword \mbox{\hyperlink{classslice}{slice}}=0; \mbox{\hyperlink{classslice}{slice}} < x.n\_slices; ++\mbox{\hyperlink{classslice}{slice}})}
\DoxyCodeLine{3521     \{}
\DoxyCodeLine{3522     \textcolor{keywordflow}{for}(uword row=0; row < x.n\_rows; ++row)}
\DoxyCodeLine{3523       \{}
\DoxyCodeLine{3524       \textcolor{keywordflow}{for}(uword col=0; col < x.n\_cols; ++col)}
\DoxyCodeLine{3525         \{}
\DoxyCodeLine{3526         f.put(\textcolor{charliteral}{' '});}
\DoxyCodeLine{3527         }
\DoxyCodeLine{3528         \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__real}{is\_real<eT>::value}})  \{ f.width(cell\_width); \}}
\DoxyCodeLine{3529         }
\DoxyCodeLine{3530         arma\_ostream::raw\_print\_elem(f, x.at(row,col,\mbox{\hyperlink{classslice}{slice}}));}
\DoxyCodeLine{3531         \}}
\DoxyCodeLine{3532         }
\DoxyCodeLine{3533       f.put(\textcolor{charliteral}{'\(\backslash\)n'});}
\DoxyCodeLine{3534       \}}
\DoxyCodeLine{3535     \}}
\DoxyCodeLine{3536   }
\DoxyCodeLine{3537   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} save\_okay = f.good();}
\DoxyCodeLine{3538   }
\DoxyCodeLine{3539   stream\_state.restore(f);}
\DoxyCodeLine{3540   }
\DoxyCodeLine{3541   \textcolor{keywordflow}{return} save\_okay;}
\DoxyCodeLine{3542   \}}
\DoxyCodeLine{3543 }
\DoxyCodeLine{3544 }
\DoxyCodeLine{3545 }
\DoxyCodeLine{3547 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{3548 \textcolor{keyword}{inline}}
\DoxyCodeLine{3549 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{3550 \mbox{\hyperlink{group__diskio_ga20b30004864f1e5dc31d8afb38377fdd}{diskio::save\_raw\_binary}}(\textcolor{keyword}{const} \mbox{\hyperlink{classCube}{Cube<eT>}}\& x, \textcolor{keyword}{const} std::string\& final\_name)}
\DoxyCodeLine{3551   \{}
\DoxyCodeLine{3552   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{3553   }
\DoxyCodeLine{3554   \textcolor{keyword}{const} std::string tmp\_name = \mbox{\hyperlink{group__diskio_gad32fa08afe53746650c31071f88eacab}{diskio::gen\_tmp\_name}}(final\_name);}
\DoxyCodeLine{3555   }
\DoxyCodeLine{3556   std::ofstream f(tmp\_name.c\_str(), std::fstream::binary);}
\DoxyCodeLine{3557   }
\DoxyCodeLine{3558   \textcolor{keywordtype}{bool} save\_okay = f.is\_open();}
\DoxyCodeLine{3559   }
\DoxyCodeLine{3560   \textcolor{keywordflow}{if}(save\_okay)}
\DoxyCodeLine{3561     \{}
\DoxyCodeLine{3562     save\_okay = \mbox{\hyperlink{group__diskio_ga20b30004864f1e5dc31d8afb38377fdd}{diskio::save\_raw\_binary}}(x, f);}
\DoxyCodeLine{3563     }
\DoxyCodeLine{3564     f.flush();}
\DoxyCodeLine{3565     f.close();}
\DoxyCodeLine{3566     }
\DoxyCodeLine{3567     \textcolor{keywordflow}{if}(save\_okay)  \{ save\_okay = \mbox{\hyperlink{group__diskio_gafbccd611e1fec1b6044f81460415d8d3}{diskio::safe\_rename}}(tmp\_name, final\_name); \}}
\DoxyCodeLine{3568     \}}
\DoxyCodeLine{3569   }
\DoxyCodeLine{3570   \textcolor{keywordflow}{return} save\_okay;}
\DoxyCodeLine{3571   \}}
\DoxyCodeLine{3572 }
\DoxyCodeLine{3573 }
\DoxyCodeLine{3574 }
\DoxyCodeLine{3575 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{3576 \textcolor{keyword}{inline}}
\DoxyCodeLine{3577 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{3578 \mbox{\hyperlink{group__diskio_ga20b30004864f1e5dc31d8afb38377fdd}{diskio::save\_raw\_binary}}(\textcolor{keyword}{const} \mbox{\hyperlink{classCube}{Cube<eT>}}\& x, std::ostream\& f)}
\DoxyCodeLine{3579   \{}
\DoxyCodeLine{3580   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{3581   }
\DoxyCodeLine{3582   f.write( \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(x.mem), std::streamsize(x.n\_elem*\textcolor{keyword}{sizeof}(eT)) );}
\DoxyCodeLine{3583   }
\DoxyCodeLine{3584   \textcolor{keywordflow}{return} f.good();}
\DoxyCodeLine{3585   \}}
\DoxyCodeLine{3586 }
\DoxyCodeLine{3587 }
\DoxyCodeLine{3588 }
\DoxyCodeLine{3591 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{3592 \textcolor{keyword}{inline}}
\DoxyCodeLine{3593 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{3594 \mbox{\hyperlink{group__diskio_ga159785ddd277a6ce0589c9b7621e1387}{diskio::save\_arma\_ascii}}(\textcolor{keyword}{const} \mbox{\hyperlink{classCube}{Cube<eT>}}\& x, \textcolor{keyword}{const} std::string\& final\_name)}
\DoxyCodeLine{3595   \{}
\DoxyCodeLine{3596   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{3597   }
\DoxyCodeLine{3598   \textcolor{keyword}{const} std::string tmp\_name = \mbox{\hyperlink{group__diskio_gad32fa08afe53746650c31071f88eacab}{diskio::gen\_tmp\_name}}(final\_name);}
\DoxyCodeLine{3599   }
\DoxyCodeLine{3600   std::ofstream f(tmp\_name.c\_str());}
\DoxyCodeLine{3601   }
\DoxyCodeLine{3602   \textcolor{keywordtype}{bool} save\_okay = f.is\_open();}
\DoxyCodeLine{3603   }
\DoxyCodeLine{3604   \textcolor{keywordflow}{if}(save\_okay)}
\DoxyCodeLine{3605     \{}
\DoxyCodeLine{3606     save\_okay = \mbox{\hyperlink{group__diskio_ga159785ddd277a6ce0589c9b7621e1387}{diskio::save\_arma\_ascii}}(x, f);}
\DoxyCodeLine{3607     }
\DoxyCodeLine{3608     f.flush();}
\DoxyCodeLine{3609     f.close();}
\DoxyCodeLine{3610     }
\DoxyCodeLine{3611     \textcolor{keywordflow}{if}(save\_okay)  \{ save\_okay = \mbox{\hyperlink{group__diskio_gafbccd611e1fec1b6044f81460415d8d3}{diskio::safe\_rename}}(tmp\_name, final\_name); \}}
\DoxyCodeLine{3612     \}}
\DoxyCodeLine{3613   }
\DoxyCodeLine{3614   \textcolor{keywordflow}{return} save\_okay;}
\DoxyCodeLine{3615   \}}
\DoxyCodeLine{3616 }
\DoxyCodeLine{3617 }
\DoxyCodeLine{3618 }
\DoxyCodeLine{3621 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{3622 \textcolor{keyword}{inline}}
\DoxyCodeLine{3623 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{3624 \mbox{\hyperlink{group__diskio_ga159785ddd277a6ce0589c9b7621e1387}{diskio::save\_arma\_ascii}}(\textcolor{keyword}{const} \mbox{\hyperlink{classCube}{Cube<eT>}}\& x, std::ostream\& f)}
\DoxyCodeLine{3625   \{}
\DoxyCodeLine{3626   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{3627   }
\DoxyCodeLine{3628   \textcolor{keyword}{const} \mbox{\hyperlink{classarma__ostream__state}{arma\_ostream\_state}} stream\_state(f);}
\DoxyCodeLine{3629   }
\DoxyCodeLine{3630   f << \mbox{\hyperlink{group__diskio_ga7adb78317f164fa19978566b3bf3f216}{diskio::gen\_txt\_header}}(x) << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{3631   f << x.n\_rows << \textcolor{charliteral}{' '} << x.n\_cols << \textcolor{charliteral}{' '} << x.n\_slices << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{3632   }
\DoxyCodeLine{3633   \textcolor{keyword}{const} std::streamsize cell\_width = diskio::prepare\_stream<eT>(f);}
\DoxyCodeLine{3634   }
\DoxyCodeLine{3635   \textcolor{keywordflow}{for}(uword \mbox{\hyperlink{classslice}{slice}}=0; \mbox{\hyperlink{classslice}{slice}} < x.n\_slices; ++\mbox{\hyperlink{classslice}{slice}})}
\DoxyCodeLine{3636     \{}
\DoxyCodeLine{3637     \textcolor{keywordflow}{for}(uword row=0; row < x.n\_rows; ++row)}
\DoxyCodeLine{3638       \{}
\DoxyCodeLine{3639       \textcolor{keywordflow}{for}(uword col=0; col < x.n\_cols; ++col)}
\DoxyCodeLine{3640         \{}
\DoxyCodeLine{3641         f.put(\textcolor{charliteral}{' '});}
\DoxyCodeLine{3642         }
\DoxyCodeLine{3643         \textcolor{keywordflow}{if}(\mbox{\hyperlink{structis__real}{is\_real<eT>::value}})  \{ f.width(cell\_width); \}}
\DoxyCodeLine{3644         }
\DoxyCodeLine{3645         arma\_ostream::raw\_print\_elem(f, x.at(row,col,\mbox{\hyperlink{classslice}{slice}}));}
\DoxyCodeLine{3646         \}}
\DoxyCodeLine{3647       }
\DoxyCodeLine{3648       f.put(\textcolor{charliteral}{'\(\backslash\)n'});}
\DoxyCodeLine{3649       \}}
\DoxyCodeLine{3650     \}}
\DoxyCodeLine{3651   }
\DoxyCodeLine{3652   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} save\_okay = f.good();}
\DoxyCodeLine{3653   }
\DoxyCodeLine{3654   stream\_state.restore(f);}
\DoxyCodeLine{3655   }
\DoxyCodeLine{3656   \textcolor{keywordflow}{return} save\_okay;}
\DoxyCodeLine{3657   \}}
\DoxyCodeLine{3658 }
\DoxyCodeLine{3659 }
\DoxyCodeLine{3660 }
\DoxyCodeLine{3663 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{3664 \textcolor{keyword}{inline}}
\DoxyCodeLine{3665 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{3666 \mbox{\hyperlink{group__diskio_ga831707949f1f222d23e15603832e079b}{diskio::save\_arma\_binary}}(\textcolor{keyword}{const} \mbox{\hyperlink{classCube}{Cube<eT>}}\& x, \textcolor{keyword}{const} std::string\& final\_name)}
\DoxyCodeLine{3667   \{}
\DoxyCodeLine{3668   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{3669   }
\DoxyCodeLine{3670   \textcolor{keyword}{const} std::string tmp\_name = \mbox{\hyperlink{group__diskio_gad32fa08afe53746650c31071f88eacab}{diskio::gen\_tmp\_name}}(final\_name);}
\DoxyCodeLine{3671   }
\DoxyCodeLine{3672   std::ofstream f(tmp\_name.c\_str(), std::fstream::binary);}
\DoxyCodeLine{3673   }
\DoxyCodeLine{3674   \textcolor{keywordtype}{bool} save\_okay = f.is\_open();}
\DoxyCodeLine{3675   }
\DoxyCodeLine{3676   \textcolor{keywordflow}{if}(save\_okay)}
\DoxyCodeLine{3677     \{}
\DoxyCodeLine{3678     save\_okay = \mbox{\hyperlink{group__diskio_ga831707949f1f222d23e15603832e079b}{diskio::save\_arma\_binary}}(x, f);}
\DoxyCodeLine{3679     }
\DoxyCodeLine{3680     f.flush();}
\DoxyCodeLine{3681     f.close();}
\DoxyCodeLine{3682     }
\DoxyCodeLine{3683     \textcolor{keywordflow}{if}(save\_okay)  \{ save\_okay = \mbox{\hyperlink{group__diskio_gafbccd611e1fec1b6044f81460415d8d3}{diskio::safe\_rename}}(tmp\_name, final\_name); \}}
\DoxyCodeLine{3684     \}}
\DoxyCodeLine{3685   }
\DoxyCodeLine{3686   \textcolor{keywordflow}{return} save\_okay;}
\DoxyCodeLine{3687   \}}
\DoxyCodeLine{3688 }
\DoxyCodeLine{3689 }
\DoxyCodeLine{3690 }
\DoxyCodeLine{3693 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{3694 \textcolor{keyword}{inline}}
\DoxyCodeLine{3695 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{3696 \mbox{\hyperlink{group__diskio_ga831707949f1f222d23e15603832e079b}{diskio::save\_arma\_binary}}(\textcolor{keyword}{const} \mbox{\hyperlink{classCube}{Cube<eT>}}\& x, std::ostream\& f)}
\DoxyCodeLine{3697   \{}
\DoxyCodeLine{3698   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{3699   }
\DoxyCodeLine{3700   f << \mbox{\hyperlink{group__diskio_ga143c823196ccbd640cf831526cd4933e}{diskio::gen\_bin\_header}}(x) << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{3701   f << x.n\_rows << \textcolor{charliteral}{' '} << x.n\_cols << \textcolor{charliteral}{' '} << x.n\_slices << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{3702   }
\DoxyCodeLine{3703   f.write( \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(x.mem), std::streamsize(x.n\_elem*\textcolor{keyword}{sizeof}(eT)) );}
\DoxyCodeLine{3704   }
\DoxyCodeLine{3705   \textcolor{keywordflow}{return} f.good();}
\DoxyCodeLine{3706   \}}
\DoxyCodeLine{3707 }
\DoxyCodeLine{3708 }
\DoxyCodeLine{3709 }
\DoxyCodeLine{3711 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{3712 \textcolor{keyword}{inline}}
\DoxyCodeLine{3713 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{3714 \mbox{\hyperlink{group__diskio_ga03e86aa742db1ee0860e2eee480c0a63}{diskio::save\_hdf5\_binary}}(\textcolor{keyword}{const} \mbox{\hyperlink{classCube}{Cube<eT>}}\& x, \textcolor{keyword}{const} \mbox{\hyperlink{structhdf5__name}{hdf5\_name}}\& spec, std::string\& err\_msg)}
\DoxyCodeLine{3715   \{}
\DoxyCodeLine{3716   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{3717   }
\DoxyCodeLine{3718 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_HDF5)}}
\DoxyCodeLine{3719     \{}
\DoxyCodeLine{3720     hdf5\_misc::hdf5\_suspend\_printing\_errors hdf5\_print\_suspender;}
\DoxyCodeLine{3721     }
\DoxyCodeLine{3722     \textcolor{keywordtype}{bool} save\_okay = \textcolor{keyword}{false};}
\DoxyCodeLine{3723     }
\DoxyCodeLine{3724     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} append  = bool(spec.opts.flags \& hdf5\_opts::flag\_append);}
\DoxyCodeLine{3725     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} replace = bool(spec.opts.flags \& hdf5\_opts::flag\_replace);}
\DoxyCodeLine{3726     }
\DoxyCodeLine{3727     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_existing\_file = ((append || replace) \&\& (arma\_H5Fis\_hdf5(spec.filename.c\_str()) > 0));}
\DoxyCodeLine{3728     }
\DoxyCodeLine{3729     \textcolor{keyword}{const} std::string tmp\_name = (use\_existing\_file) ? std::string() : \mbox{\hyperlink{group__diskio_gad32fa08afe53746650c31071f88eacab}{diskio::gen\_tmp\_name}}(spec.filename);}
\DoxyCodeLine{3730     }
\DoxyCodeLine{3731     \textcolor{comment}{// Set up the file according to HDF5's preferences}}
\DoxyCodeLine{3732     hid\_t file = (use\_existing\_file) ? arma\_H5Fopen(spec.filename.c\_str(), H5F\_ACC\_RDWR, H5P\_DEFAULT) : arma\_H5Fcreate(tmp\_name.c\_str(), H5F\_ACC\_TRUNC, H5P\_DEFAULT, H5P\_DEFAULT);}
\DoxyCodeLine{3733     }
\DoxyCodeLine{3734     \textcolor{keywordflow}{if}(file < 0)  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{3735     }
\DoxyCodeLine{3736     \textcolor{comment}{// We need to create a dataset, datatype, and dataspace}}
\DoxyCodeLine{3737     hsize\_t dims[3];}
\DoxyCodeLine{3738     dims[2] = x.n\_rows;}
\DoxyCodeLine{3739     dims[1] = x.n\_cols;}
\DoxyCodeLine{3740     dims[0] = x.n\_slices;}
\DoxyCodeLine{3741     }
\DoxyCodeLine{3742     hid\_t dataspace = arma\_H5Screate\_simple(3, dims, NULL);   \textcolor{comment}{// treat the cube as a 3d array dataspace}}
\DoxyCodeLine{3743     hid\_t datatype  = hdf5\_misc::get\_hdf5\_type<eT>();}
\DoxyCodeLine{3744     }
\DoxyCodeLine{3745     \textcolor{comment}{// If this returned something invalid, well, it's time to crash.}}
\DoxyCodeLine{3746     \mbox{\hyperlink{group__debug_ga458beb676810b1e43df9f0668359e76f}{arma\_check}}(datatype == -\/1, \textcolor{stringliteral}{"{}Cube::save(): unknown datatype for HDF5"{}});}
\DoxyCodeLine{3747     }
\DoxyCodeLine{3748     \textcolor{comment}{// MATLAB forces the users to specify a name at save time for HDF5;}}
\DoxyCodeLine{3749     \textcolor{comment}{// Octave will use the default of 'dataset' unless otherwise specified.}}
\DoxyCodeLine{3750     \textcolor{comment}{// If the user hasn't specified a dataset name, we will use 'dataset'}}
\DoxyCodeLine{3751     \textcolor{comment}{// We may have to split out the group name from the dataset name.}}
\DoxyCodeLine{3752     std::vector<hid\_t> groups;}
\DoxyCodeLine{3753     std::string full\_name = spec.dsname;}
\DoxyCodeLine{3754     \textcolor{keywordtype}{size\_t} loc;}
\DoxyCodeLine{3755     \textcolor{keywordflow}{while}((loc = full\_name.find(\textcolor{stringliteral}{"{}/"{}})) != std::string::npos)}
\DoxyCodeLine{3756       \{}
\DoxyCodeLine{3757       \textcolor{comment}{// Create another group...}}
\DoxyCodeLine{3758       \textcolor{keywordflow}{if}(loc != 0) \textcolor{comment}{// Ignore the first /, if there is a leading /.}}
\DoxyCodeLine{3759         \{}
\DoxyCodeLine{3760         hid\_t gid = arma\_H5Gcreate((groups.size() == 0) ? file : groups[groups.size() -\/ 1], full\_name.substr(0, loc).c\_str(), H5P\_DEFAULT, H5P\_DEFAULT, H5P\_DEFAULT);}
\DoxyCodeLine{3761         }
\DoxyCodeLine{3762         \textcolor{keywordflow}{if}((gid < 0) \&\& use\_existing\_file)}
\DoxyCodeLine{3763           \{}
\DoxyCodeLine{3764           gid = arma\_H5Gopen((groups.size() == 0) ? file : groups[groups.size() -\/ 1], full\_name.substr(0, loc).c\_str(), H5P\_DEFAULT);}
\DoxyCodeLine{3765           \}}
\DoxyCodeLine{3766         }
\DoxyCodeLine{3767         groups.push\_back(gid);}
\DoxyCodeLine{3768         \}}
\DoxyCodeLine{3769       }
\DoxyCodeLine{3770       full\_name = full\_name.substr(loc + 1);}
\DoxyCodeLine{3771       \}}
\DoxyCodeLine{3772     }
\DoxyCodeLine{3773     \textcolor{keyword}{const} std::string dataset\_name = full\_name.empty() ? std::string(\textcolor{stringliteral}{"{}dataset"{}}) : full\_name;}
\DoxyCodeLine{3774     }
\DoxyCodeLine{3775     \textcolor{keyword}{const} hid\_t last\_group = (groups.size() == 0) ? file : groups[groups.size() -\/ 1];}
\DoxyCodeLine{3776     }
\DoxyCodeLine{3777     \textcolor{keywordflow}{if}(use\_existing\_file \&\& replace)}
\DoxyCodeLine{3778       \{}
\DoxyCodeLine{3779       arma\_H5Ldelete(last\_group, dataset\_name.c\_str(), H5P\_DEFAULT);}
\DoxyCodeLine{3780       \textcolor{comment}{// NOTE: H5Ldelete() in HDF5 v1.8 doesn't reclaim the deleted space; use h5repack to reclaim space: h5repack oldfile.h5 newfile.h5}}
\DoxyCodeLine{3781       \textcolor{comment}{// NOTE: has this behaviour changed in HDF5 1.10 ?}}
\DoxyCodeLine{3782       \textcolor{comment}{// NOTE: https://lists.hdfgroup.org/pipermail/hdf-\/forum\_lists.hdfgroup.org/2017-\/August/010482.html}}
\DoxyCodeLine{3783       \textcolor{comment}{// NOTE: https://lists.hdfgroup.org/pipermail/hdf-\/forum\_lists.hdfgroup.org/2017-\/August/010486.html}}
\DoxyCodeLine{3784       \}}
\DoxyCodeLine{3785     }
\DoxyCodeLine{3786     hid\_t dataset = arma\_H5Dcreate(last\_group, dataset\_name.c\_str(), datatype, dataspace, H5P\_DEFAULT, H5P\_DEFAULT, H5P\_DEFAULT);}
\DoxyCodeLine{3787     }
\DoxyCodeLine{3788     \textcolor{keywordflow}{if}(dataset < 0)}
\DoxyCodeLine{3789       \{}
\DoxyCodeLine{3790       save\_okay = \textcolor{keyword}{false};}
\DoxyCodeLine{3791       }
\DoxyCodeLine{3792       err\_msg = \textcolor{stringliteral}{"{}couldn't create dataset"{}};}
\DoxyCodeLine{3793       \}}
\DoxyCodeLine{3794     \textcolor{keywordflow}{else}}
\DoxyCodeLine{3795       \{}
\DoxyCodeLine{3796       save\_okay = (arma\_H5Dwrite(dataset, datatype, H5S\_ALL, H5S\_ALL, H5P\_DEFAULT, x.mem) >= 0);}
\DoxyCodeLine{3797       }
\DoxyCodeLine{3798       arma\_H5Dclose(dataset);}
\DoxyCodeLine{3799       \}}
\DoxyCodeLine{3800     }
\DoxyCodeLine{3801     arma\_H5Tclose(datatype);}
\DoxyCodeLine{3802     arma\_H5Sclose(dataspace);}
\DoxyCodeLine{3803     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i = 0; i < groups.size(); ++i)  \{ arma\_H5Gclose(groups[i]); \}}
\DoxyCodeLine{3804     arma\_H5Fclose(file);}
\DoxyCodeLine{3805     }
\DoxyCodeLine{3806     \textcolor{keywordflow}{if}((use\_existing\_file == \textcolor{keyword}{false}) \&\& (save\_okay == \textcolor{keyword}{true}))  \{ save\_okay = \mbox{\hyperlink{group__diskio_gafbccd611e1fec1b6044f81460415d8d3}{diskio::safe\_rename}}(tmp\_name, spec.filename); \}}
\DoxyCodeLine{3807     }
\DoxyCodeLine{3808     \textcolor{keywordflow}{return} save\_okay;}
\DoxyCodeLine{3809     \}}
\DoxyCodeLine{3810 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{3811     \{}
\DoxyCodeLine{3812     arma\_ignore(x);}
\DoxyCodeLine{3813     arma\_ignore(spec);}
\DoxyCodeLine{3814     arma\_ignore(err\_msg);}
\DoxyCodeLine{3815     }
\DoxyCodeLine{3816     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}Cube::save(): use of HDF5 must be enabled"{}});}
\DoxyCodeLine{3817     }
\DoxyCodeLine{3818     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3819     \}}
\DoxyCodeLine{3820 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{3821   \}}
\DoxyCodeLine{3822 }
\DoxyCodeLine{3823 }
\DoxyCodeLine{3824 }
\DoxyCodeLine{3827 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{3828 \textcolor{keyword}{inline}}
\DoxyCodeLine{3829 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{3830 \mbox{\hyperlink{group__diskio_gab4a891389f7af45143d69e1e13e02fde}{diskio::load\_raw\_ascii}}(\mbox{\hyperlink{classCube}{Cube<eT>}}\& x, \textcolor{keyword}{const} std::string\& \mbox{\hyperlink{structname}{name}}, std::string\& err\_msg)}
\DoxyCodeLine{3831   \{}
\DoxyCodeLine{3832   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{3833   }
\DoxyCodeLine{3834   \mbox{\hyperlink{classMat}{Mat<eT>}} tmp;}
\DoxyCodeLine{3835   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} load\_okay = \mbox{\hyperlink{group__diskio_gab4a891389f7af45143d69e1e13e02fde}{diskio::load\_raw\_ascii}}(tmp, \mbox{\hyperlink{structname}{name}}, err\_msg);}
\DoxyCodeLine{3836   }
\DoxyCodeLine{3837   \textcolor{keywordflow}{if}(load\_okay)}
\DoxyCodeLine{3838     \{}
\DoxyCodeLine{3839     \textcolor{keywordflow}{if}(tmp.\mbox{\hyperlink{group__Mat_ga3008049216e02308ff665862f451a7ff}{is\_empty}}() == \textcolor{keyword}{false})}
\DoxyCodeLine{3840       \{}
\DoxyCodeLine{3841       \textcolor{keywordflow}{try} \{ x.set\_size(tmp.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}}, tmp.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}}, 1); \} \textcolor{keywordflow}{catch}(...) \{ err\_msg = \textcolor{stringliteral}{"{}not enough memory"{}}; \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{3842       }
\DoxyCodeLine{3843       x.slice(0) = tmp;}
\DoxyCodeLine{3844       \}}
\DoxyCodeLine{3845     \textcolor{keywordflow}{else}}
\DoxyCodeLine{3846       \{}
\DoxyCodeLine{3847       x.reset();}
\DoxyCodeLine{3848       \}}
\DoxyCodeLine{3849     \}}
\DoxyCodeLine{3850   }
\DoxyCodeLine{3851   \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{3852   \}}
\DoxyCodeLine{3853 }
\DoxyCodeLine{3854 }
\DoxyCodeLine{3855 }
\DoxyCodeLine{3858 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{3859 \textcolor{keyword}{inline}}
\DoxyCodeLine{3860 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{3861 \mbox{\hyperlink{group__diskio_gab4a891389f7af45143d69e1e13e02fde}{diskio::load\_raw\_ascii}}(\mbox{\hyperlink{classCube}{Cube<eT>}}\& x, std::istream\& f, std::string\& err\_msg)}
\DoxyCodeLine{3862   \{}
\DoxyCodeLine{3863   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{3864   }
\DoxyCodeLine{3865   \mbox{\hyperlink{classMat}{Mat<eT>}} tmp;}
\DoxyCodeLine{3866   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} load\_okay = \mbox{\hyperlink{group__diskio_gab4a891389f7af45143d69e1e13e02fde}{diskio::load\_raw\_ascii}}(tmp, f, err\_msg);}
\DoxyCodeLine{3867   }
\DoxyCodeLine{3868   \textcolor{keywordflow}{if}(load\_okay)}
\DoxyCodeLine{3869     \{}
\DoxyCodeLine{3870     \textcolor{keywordflow}{if}(tmp.\mbox{\hyperlink{group__Mat_ga3008049216e02308ff665862f451a7ff}{is\_empty}}() == \textcolor{keyword}{false})}
\DoxyCodeLine{3871       \{}
\DoxyCodeLine{3872       \textcolor{keywordflow}{try} \{ x.set\_size(tmp.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}}, tmp.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}}, 1); \} \textcolor{keywordflow}{catch}(...) \{ err\_msg = \textcolor{stringliteral}{"{}not enough memory"{}}; \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{3873       }
\DoxyCodeLine{3874       x.slice(0) = tmp;}
\DoxyCodeLine{3875       \}}
\DoxyCodeLine{3876     \textcolor{keywordflow}{else}}
\DoxyCodeLine{3877       \{}
\DoxyCodeLine{3878       x.reset();}
\DoxyCodeLine{3879       \}}
\DoxyCodeLine{3880     \}}
\DoxyCodeLine{3881   }
\DoxyCodeLine{3882   \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{3883   \}}
\DoxyCodeLine{3884 }
\DoxyCodeLine{3885 }
\DoxyCodeLine{3886 }
\DoxyCodeLine{3889 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{3890 \textcolor{keyword}{inline}}
\DoxyCodeLine{3891 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{3892 \mbox{\hyperlink{group__diskio_ga758d71eceff8f867d38619aa52ddf40b}{diskio::load\_raw\_binary}}(\mbox{\hyperlink{classCube}{Cube<eT>}}\& x, \textcolor{keyword}{const} std::string\& \mbox{\hyperlink{structname}{name}}, std::string\& err\_msg)}
\DoxyCodeLine{3893   \{}
\DoxyCodeLine{3894   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{3895   }
\DoxyCodeLine{3896   std::ifstream f;}
\DoxyCodeLine{3897   f.open(\mbox{\hyperlink{structname}{name}}.c\_str(), std::fstream::binary);}
\DoxyCodeLine{3898   }
\DoxyCodeLine{3899   \textcolor{keywordtype}{bool} load\_okay = f.is\_open();}
\DoxyCodeLine{3900   }
\DoxyCodeLine{3901   \textcolor{keywordflow}{if}(load\_okay)}
\DoxyCodeLine{3902     \{}
\DoxyCodeLine{3903     load\_okay = \mbox{\hyperlink{group__diskio_ga758d71eceff8f867d38619aa52ddf40b}{diskio::load\_raw\_binary}}(x, f, err\_msg);}
\DoxyCodeLine{3904     f.close();}
\DoxyCodeLine{3905     \}}
\DoxyCodeLine{3906   }
\DoxyCodeLine{3907   \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{3908   \}}
\DoxyCodeLine{3909 }
\DoxyCodeLine{3910 }
\DoxyCodeLine{3911 }
\DoxyCodeLine{3912 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{3913 \textcolor{keyword}{inline}}
\DoxyCodeLine{3914 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{3915 \mbox{\hyperlink{group__diskio_ga758d71eceff8f867d38619aa52ddf40b}{diskio::load\_raw\_binary}}(\mbox{\hyperlink{classCube}{Cube<eT>}}\& x, std::istream\& f, std::string\& err\_msg)}
\DoxyCodeLine{3916   \{}
\DoxyCodeLine{3917   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{3918   }
\DoxyCodeLine{3919   f.clear();}
\DoxyCodeLine{3920   \textcolor{keyword}{const} std::streampos pos1 = f.tellg();}
\DoxyCodeLine{3921   }
\DoxyCodeLine{3922   f.clear();}
\DoxyCodeLine{3923   f.seekg(0, ios::end);}
\DoxyCodeLine{3924   }
\DoxyCodeLine{3925   f.clear();}
\DoxyCodeLine{3926   \textcolor{keyword}{const} std::streampos pos2 = f.tellg();}
\DoxyCodeLine{3927   }
\DoxyCodeLine{3928   \textcolor{keyword}{const} uword N = ( (pos1 >= 0) \&\& (pos2 >= 0) ) ? uword(pos2 -\/ pos1) : 0;}
\DoxyCodeLine{3929   }
\DoxyCodeLine{3930   f.clear();}
\DoxyCodeLine{3931   \textcolor{comment}{//f.seekg(0, ios::beg);}}
\DoxyCodeLine{3932   f.seekg(pos1);}
\DoxyCodeLine{3933   }
\DoxyCodeLine{3934   \textcolor{keywordflow}{try} \{ x.set\_size(N / uword(\textcolor{keyword}{sizeof}(eT)), 1, 1); \} \textcolor{keywordflow}{catch}(...) \{ err\_msg = \textcolor{stringliteral}{"{}not enough memory"{}}; \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{3935   }
\DoxyCodeLine{3936   f.clear();}
\DoxyCodeLine{3937   f.read( \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char} *\textcolor{keyword}{>}(x.memptr()), std::streamsize(x.n\_elem * uword(\textcolor{keyword}{sizeof}(eT))) );}
\DoxyCodeLine{3938   }
\DoxyCodeLine{3939   \textcolor{keywordflow}{return} f.good();}
\DoxyCodeLine{3940   \}}
\DoxyCodeLine{3941 }
\DoxyCodeLine{3942 }
\DoxyCodeLine{3943 }
\DoxyCodeLine{3946 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{3947 \textcolor{keyword}{inline}}
\DoxyCodeLine{3948 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{3949 \mbox{\hyperlink{group__diskio_ga84c9da5c70180743ecc7918230a06d98}{diskio::load\_arma\_ascii}}(\mbox{\hyperlink{classCube}{Cube<eT>}}\& x, \textcolor{keyword}{const} std::string\& \mbox{\hyperlink{structname}{name}}, std::string\& err\_msg)}
\DoxyCodeLine{3950   \{}
\DoxyCodeLine{3951   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{3952   }
\DoxyCodeLine{3953   std::ifstream f(\mbox{\hyperlink{structname}{name}}.c\_str());}
\DoxyCodeLine{3954   }
\DoxyCodeLine{3955   \textcolor{keywordtype}{bool} load\_okay = f.is\_open();}
\DoxyCodeLine{3956   }
\DoxyCodeLine{3957   \textcolor{keywordflow}{if}(load\_okay)}
\DoxyCodeLine{3958     \{}
\DoxyCodeLine{3959     load\_okay = \mbox{\hyperlink{group__diskio_ga84c9da5c70180743ecc7918230a06d98}{diskio::load\_arma\_ascii}}(x, f, err\_msg);}
\DoxyCodeLine{3960     f.close();}
\DoxyCodeLine{3961     \}}
\DoxyCodeLine{3962   }
\DoxyCodeLine{3963   \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{3964   \}}
\DoxyCodeLine{3965   }
\DoxyCodeLine{3966 }
\DoxyCodeLine{3967 }
\DoxyCodeLine{3970 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{3971 \textcolor{keyword}{inline}}
\DoxyCodeLine{3972 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{3973 \mbox{\hyperlink{group__diskio_ga84c9da5c70180743ecc7918230a06d98}{diskio::load\_arma\_ascii}}(\mbox{\hyperlink{classCube}{Cube<eT>}}\& x, std::istream\& f, std::string\& err\_msg)}
\DoxyCodeLine{3974   \{}
\DoxyCodeLine{3975   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{3976   }
\DoxyCodeLine{3977   std::streampos pos = f.tellg();}
\DoxyCodeLine{3978   }
\DoxyCodeLine{3979   \textcolor{keywordtype}{bool} load\_okay = \textcolor{keyword}{true};}
\DoxyCodeLine{3980   }
\DoxyCodeLine{3981   std::string f\_header;}
\DoxyCodeLine{3982   uword       f\_n\_rows;}
\DoxyCodeLine{3983   uword       f\_n\_cols;}
\DoxyCodeLine{3984   uword       f\_n\_slices;}
\DoxyCodeLine{3985   }
\DoxyCodeLine{3986   f >> f\_header;}
\DoxyCodeLine{3987   f >> f\_n\_rows;}
\DoxyCodeLine{3988   f >> f\_n\_cols;}
\DoxyCodeLine{3989   f >> f\_n\_slices;}
\DoxyCodeLine{3990   }
\DoxyCodeLine{3991   \textcolor{keywordflow}{if}(f\_header == \mbox{\hyperlink{group__diskio_ga7adb78317f164fa19978566b3bf3f216}{diskio::gen\_txt\_header}}(x))}
\DoxyCodeLine{3992     \{}
\DoxyCodeLine{3993     \textcolor{keywordflow}{try} \{ x.set\_size(f\_n\_rows, f\_n\_cols, f\_n\_slices); \} \textcolor{keywordflow}{catch}(...) \{ err\_msg = \textcolor{stringliteral}{"{}not enough memory"{}}; \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{3994 }
\DoxyCodeLine{3995     \textcolor{keywordflow}{for}(uword \mbox{\hyperlink{classslice}{slice}} = 0; \mbox{\hyperlink{classslice}{slice}} < x.n\_slices; ++\mbox{\hyperlink{classslice}{slice}})}
\DoxyCodeLine{3996     \textcolor{keywordflow}{for}(uword   row = 0;   row < x.n\_rows;   ++row  )}
\DoxyCodeLine{3997     \textcolor{keywordflow}{for}(uword   col = 0;   col < x.n\_cols;   ++col  )}
\DoxyCodeLine{3998       \{}
\DoxyCodeLine{3999       f >> x.at(row,col,\mbox{\hyperlink{classslice}{slice}});}
\DoxyCodeLine{4000       \}}
\DoxyCodeLine{4001     }
\DoxyCodeLine{4002     load\_okay = f.good();}
\DoxyCodeLine{4003     \}}
\DoxyCodeLine{4004   \textcolor{keywordflow}{else}}
\DoxyCodeLine{4005     \{}
\DoxyCodeLine{4006     load\_okay = \textcolor{keyword}{false};}
\DoxyCodeLine{4007     err\_msg = \textcolor{stringliteral}{"{}incorrect header"{}};}
\DoxyCodeLine{4008     \}}
\DoxyCodeLine{4009   }
\DoxyCodeLine{4010   }
\DoxyCodeLine{4011   \textcolor{comment}{// allow automatic conversion of u32/s32 cubes into u64/s64 cubes}}
\DoxyCodeLine{4012   }
\DoxyCodeLine{4013   \textcolor{keywordflow}{if}(load\_okay == \textcolor{keyword}{false})}
\DoxyCodeLine{4014     \{}
\DoxyCodeLine{4015     \textcolor{keywordflow}{if}( (\textcolor{keyword}{sizeof}(eT) == 8) \&\& \mbox{\hyperlink{structis__same__type}{is\_same\_type<uword,eT>::yes}} )}
\DoxyCodeLine{4016       \{}
\DoxyCodeLine{4017       \mbox{\hyperlink{classCube}{Cube<u32>}}   tmp;}
\DoxyCodeLine{4018       std::string junk;}
\DoxyCodeLine{4019       }
\DoxyCodeLine{4020       f.\mbox{\hyperlink{group__Mat_ga3dbb05713ff59d9e4dc6e9381f84ff03}{clear}}();}
\DoxyCodeLine{4021       f.seekg(pos);}
\DoxyCodeLine{4022       }
\DoxyCodeLine{4023       load\_okay = \mbox{\hyperlink{group__diskio_ga84c9da5c70180743ecc7918230a06d98}{diskio::load\_arma\_ascii}}(tmp, f, junk);}
\DoxyCodeLine{4024       }
\DoxyCodeLine{4025       \textcolor{keywordflow}{if}(load\_okay)  \{ x = \mbox{\hyperlink{classconv__to}{conv\_to< Cube<eT>}} >::from(tmp); \}}
\DoxyCodeLine{4026       \}}
\DoxyCodeLine{4027     \textcolor{keywordflow}{else}}
\DoxyCodeLine{4028     \textcolor{keywordflow}{if}( (\textcolor{keyword}{sizeof}(eT) == 8) \&\& \mbox{\hyperlink{structis__same__type}{is\_same\_type<sword,eT>::yes}} )}
\DoxyCodeLine{4029       \{}
\DoxyCodeLine{4030       \mbox{\hyperlink{classCube}{Cube<s32>}}   tmp;}
\DoxyCodeLine{4031       std::string junk;}
\DoxyCodeLine{4032       }
\DoxyCodeLine{4033       f.\mbox{\hyperlink{group__Mat_ga3dbb05713ff59d9e4dc6e9381f84ff03}{clear}}();}
\DoxyCodeLine{4034       f.seekg(pos);}
\DoxyCodeLine{4035       }
\DoxyCodeLine{4036       load\_okay = \mbox{\hyperlink{group__diskio_ga84c9da5c70180743ecc7918230a06d98}{diskio::load\_arma\_ascii}}(tmp, f, junk);}
\DoxyCodeLine{4037       }
\DoxyCodeLine{4038       \textcolor{keywordflow}{if}(load\_okay)  \{ x = \mbox{\hyperlink{classconv__to}{conv\_to< Cube<eT>}} >::from(tmp); \}}
\DoxyCodeLine{4039       \}}
\DoxyCodeLine{4040     \}}
\DoxyCodeLine{4041   }
\DoxyCodeLine{4042   \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{4043   \}}
\DoxyCodeLine{4044 }
\DoxyCodeLine{4045 }
\DoxyCodeLine{4046 }
\DoxyCodeLine{4049 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{4050 \textcolor{keyword}{inline}}
\DoxyCodeLine{4051 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{4052 \mbox{\hyperlink{group__diskio_ga7d310b89b83e6327a818215bb3124aa0}{diskio::load\_arma\_binary}}(\mbox{\hyperlink{classCube}{Cube<eT>}}\& x, \textcolor{keyword}{const} std::string\& \mbox{\hyperlink{structname}{name}}, std::string\& err\_msg)}
\DoxyCodeLine{4053   \{}
\DoxyCodeLine{4054   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{4055   }
\DoxyCodeLine{4056   std::ifstream f;}
\DoxyCodeLine{4057   f.open(\mbox{\hyperlink{structname}{name}}.c\_str(), std::fstream::binary);}
\DoxyCodeLine{4058   }
\DoxyCodeLine{4059   \textcolor{keywordtype}{bool} load\_okay = f.is\_open();}
\DoxyCodeLine{4060   }
\DoxyCodeLine{4061   \textcolor{keywordflow}{if}(load\_okay)}
\DoxyCodeLine{4062     \{}
\DoxyCodeLine{4063     load\_okay = \mbox{\hyperlink{group__diskio_ga7d310b89b83e6327a818215bb3124aa0}{diskio::load\_arma\_binary}}(x, f, err\_msg);}
\DoxyCodeLine{4064     f.close();}
\DoxyCodeLine{4065     \}}
\DoxyCodeLine{4066   }
\DoxyCodeLine{4067   \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{4068   \}}
\DoxyCodeLine{4069 }
\DoxyCodeLine{4070 }
\DoxyCodeLine{4071 }
\DoxyCodeLine{4072 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{4073 \textcolor{keyword}{inline}}
\DoxyCodeLine{4074 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{4075 \mbox{\hyperlink{group__diskio_ga7d310b89b83e6327a818215bb3124aa0}{diskio::load\_arma\_binary}}(\mbox{\hyperlink{classCube}{Cube<eT>}}\& x, std::istream\& f, std::string\& err\_msg)}
\DoxyCodeLine{4076   \{}
\DoxyCodeLine{4077   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{4078   }
\DoxyCodeLine{4079   std::streampos pos = f.tellg();}
\DoxyCodeLine{4080     }
\DoxyCodeLine{4081   \textcolor{keywordtype}{bool} load\_okay = \textcolor{keyword}{true};}
\DoxyCodeLine{4082   }
\DoxyCodeLine{4083   std::string f\_header;}
\DoxyCodeLine{4084   uword       f\_n\_rows;}
\DoxyCodeLine{4085   uword       f\_n\_cols;}
\DoxyCodeLine{4086   uword       f\_n\_slices;}
\DoxyCodeLine{4087   }
\DoxyCodeLine{4088   f >> f\_header;}
\DoxyCodeLine{4089   f >> f\_n\_rows;}
\DoxyCodeLine{4090   f >> f\_n\_cols;}
\DoxyCodeLine{4091   f >> f\_n\_slices;}
\DoxyCodeLine{4092   }
\DoxyCodeLine{4093   \textcolor{keywordflow}{if}(f\_header == \mbox{\hyperlink{group__diskio_ga143c823196ccbd640cf831526cd4933e}{diskio::gen\_bin\_header}}(x))}
\DoxyCodeLine{4094     \{}
\DoxyCodeLine{4095     \textcolor{comment}{//f.seekg(1, ios::cur);  // NOTE: this may not be portable, as on a Windows machine a newline could be two characters}}
\DoxyCodeLine{4096     f.get();}
\DoxyCodeLine{4097     }
\DoxyCodeLine{4098     \textcolor{keywordflow}{try} \{ x.set\_size(f\_n\_rows, f\_n\_cols, f\_n\_slices); \} \textcolor{keywordflow}{catch}(...) \{ err\_msg = \textcolor{stringliteral}{"{}not enough memory"{}}; \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{4099     }
\DoxyCodeLine{4100     f.read( \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char} *\textcolor{keyword}{>}(x.memptr()), std::streamsize(x.n\_elem*\textcolor{keyword}{sizeof}(eT)) );}
\DoxyCodeLine{4101     }
\DoxyCodeLine{4102     load\_okay = f.good();}
\DoxyCodeLine{4103     \}}
\DoxyCodeLine{4104   \textcolor{keywordflow}{else}}
\DoxyCodeLine{4105     \{}
\DoxyCodeLine{4106     load\_okay = \textcolor{keyword}{false};}
\DoxyCodeLine{4107     err\_msg = \textcolor{stringliteral}{"{}incorrect header"{}};}
\DoxyCodeLine{4108     \}}
\DoxyCodeLine{4109   }
\DoxyCodeLine{4110   }
\DoxyCodeLine{4111   \textcolor{comment}{// allow automatic conversion of u32/s32 cubes into u64/s64 cubes}}
\DoxyCodeLine{4112   }
\DoxyCodeLine{4113   \textcolor{keywordflow}{if}(load\_okay == \textcolor{keyword}{false})}
\DoxyCodeLine{4114     \{}
\DoxyCodeLine{4115     \textcolor{keywordflow}{if}( (\textcolor{keyword}{sizeof}(eT) == 8) \&\& \mbox{\hyperlink{structis__same__type}{is\_same\_type<uword,eT>::yes}} )}
\DoxyCodeLine{4116       \{}
\DoxyCodeLine{4117       \mbox{\hyperlink{classCube}{Cube<u32>}}   tmp;}
\DoxyCodeLine{4118       std::string junk;}
\DoxyCodeLine{4119       }
\DoxyCodeLine{4120       f.\mbox{\hyperlink{group__Mat_ga3dbb05713ff59d9e4dc6e9381f84ff03}{clear}}();}
\DoxyCodeLine{4121       f.seekg(pos);}
\DoxyCodeLine{4122       }
\DoxyCodeLine{4123       load\_okay = \mbox{\hyperlink{group__diskio_ga7d310b89b83e6327a818215bb3124aa0}{diskio::load\_arma\_binary}}(tmp, f, junk);}
\DoxyCodeLine{4124       }
\DoxyCodeLine{4125       \textcolor{keywordflow}{if}(load\_okay)  \{ x = \mbox{\hyperlink{classconv__to}{conv\_to< Cube<eT>}} >::from(tmp); \}}
\DoxyCodeLine{4126       \}}
\DoxyCodeLine{4127     \textcolor{keywordflow}{else}}
\DoxyCodeLine{4128     \textcolor{keywordflow}{if}( (\textcolor{keyword}{sizeof}(eT) == 8) \&\& \mbox{\hyperlink{structis__same__type}{is\_same\_type<sword,eT>::yes}} )}
\DoxyCodeLine{4129       \{}
\DoxyCodeLine{4130       \mbox{\hyperlink{classCube}{Cube<s32>}}   tmp;}
\DoxyCodeLine{4131       std::string junk;}
\DoxyCodeLine{4132       }
\DoxyCodeLine{4133       f.\mbox{\hyperlink{group__Cube_ga711b4f9e03c78ea34b759a8c5a4f8226}{clear}}();}
\DoxyCodeLine{4134       f.seekg(pos);}
\DoxyCodeLine{4135       }
\DoxyCodeLine{4136       load\_okay = \mbox{\hyperlink{group__diskio_ga7d310b89b83e6327a818215bb3124aa0}{diskio::load\_arma\_binary}}(tmp, f, junk);}
\DoxyCodeLine{4137       }
\DoxyCodeLine{4138       \textcolor{keywordflow}{if}(load\_okay)  \{ x = \mbox{\hyperlink{classconv__to}{conv\_to< Cube<eT>}} >::from(tmp); \}}
\DoxyCodeLine{4139       \}}
\DoxyCodeLine{4140     \}}
\DoxyCodeLine{4141   }
\DoxyCodeLine{4142   \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{4143   \}}
\DoxyCodeLine{4144 }
\DoxyCodeLine{4145 }
\DoxyCodeLine{4146 }
\DoxyCodeLine{4148 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{4149 \textcolor{keyword}{inline}}
\DoxyCodeLine{4150 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{4151 \mbox{\hyperlink{group__diskio_ga44d57eace6517b322f38e379e2126627}{diskio::load\_hdf5\_binary}}(\mbox{\hyperlink{classCube}{Cube<eT>}}\& x, \textcolor{keyword}{const} \mbox{\hyperlink{structhdf5__name}{hdf5\_name}}\& spec, std::string\& err\_msg)}
\DoxyCodeLine{4152   \{}
\DoxyCodeLine{4153   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{4154   }
\DoxyCodeLine{4155 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_HDF5)}}
\DoxyCodeLine{4156     \{}
\DoxyCodeLine{4157     hdf5\_misc::hdf5\_suspend\_printing\_errors hdf5\_print\_suspender;}
\DoxyCodeLine{4158     }
\DoxyCodeLine{4159     \textcolor{keywordtype}{bool} load\_okay = \textcolor{keyword}{false};}
\DoxyCodeLine{4160     }
\DoxyCodeLine{4161     hid\_t fid = arma\_H5Fopen(spec.filename.c\_str(), H5F\_ACC\_RDONLY, H5P\_DEFAULT);}
\DoxyCodeLine{4162     }
\DoxyCodeLine{4163     \textcolor{keywordflow}{if}(fid >= 0)}
\DoxyCodeLine{4164       \{}
\DoxyCodeLine{4165       \textcolor{comment}{// MATLAB HDF5 dataset names are user-\/specified;}}
\DoxyCodeLine{4166       \textcolor{comment}{// Octave tends to store the datasets in a group, with the actual dataset being referred to as "{}value"{}.}}
\DoxyCodeLine{4167       \textcolor{comment}{// If the user hasn't specified a dataset, we will search for "{}dataset"{} and "{}value"{},}}
\DoxyCodeLine{4168       \textcolor{comment}{// and if those are not found we will take the first dataset we do find.}}
\DoxyCodeLine{4169       }
\DoxyCodeLine{4170       std::vector<std::string> searchNames;}
\DoxyCodeLine{4171       }
\DoxyCodeLine{4172       \textcolor{keyword}{const} \textcolor{keywordtype}{bool} exact = (spec.dsname.empty() == \textcolor{keyword}{false});}
\DoxyCodeLine{4173       }
\DoxyCodeLine{4174       \textcolor{keywordflow}{if}(exact)}
\DoxyCodeLine{4175         \{}
\DoxyCodeLine{4176         searchNames.push\_back(spec.dsname);}
\DoxyCodeLine{4177         \}}
\DoxyCodeLine{4178       \textcolor{keywordflow}{else}}
\DoxyCodeLine{4179         \{}
\DoxyCodeLine{4180         searchNames.push\_back(\textcolor{stringliteral}{"{}dataset"{}});}
\DoxyCodeLine{4181         searchNames.push\_back(\textcolor{stringliteral}{"{}value"{}}  );}
\DoxyCodeLine{4182         \}}
\DoxyCodeLine{4183       }
\DoxyCodeLine{4184       hid\_t dataset = hdf5\_misc::search\_hdf5\_file(searchNames, fid, 3, exact);}
\DoxyCodeLine{4185       }
\DoxyCodeLine{4186       \textcolor{keywordflow}{if}(dataset >= 0)}
\DoxyCodeLine{4187         \{}
\DoxyCodeLine{4188         hid\_t filespace = arma\_H5Dget\_space(dataset);}
\DoxyCodeLine{4189         }
\DoxyCodeLine{4190         \textcolor{comment}{// This must be <= 3 due to our search rules.}}
\DoxyCodeLine{4191         \textcolor{keyword}{const} \textcolor{keywordtype}{int} ndims = arma\_H5Sget\_simple\_extent\_ndims(filespace);}
\DoxyCodeLine{4192         }
\DoxyCodeLine{4193         hsize\_t dims[3];}
\DoxyCodeLine{4194         \textcolor{keyword}{const} herr\_t query\_status = arma\_H5Sget\_simple\_extent\_dims(filespace, dims, NULL);}
\DoxyCodeLine{4195         }
\DoxyCodeLine{4196         \textcolor{comment}{// arma\_check(query\_status < 0, "{}Cube::load(): cannot get size of HDF5 dataset"{});}}
\DoxyCodeLine{4197         \textcolor{keywordflow}{if}(query\_status < 0)}
\DoxyCodeLine{4198           \{}
\DoxyCodeLine{4199           err\_msg = \textcolor{stringliteral}{"{}cannot get size of HDF5 dataset"{}};}
\DoxyCodeLine{4200           }
\DoxyCodeLine{4201           arma\_H5Sclose(filespace);}
\DoxyCodeLine{4202           arma\_H5Dclose(dataset);}
\DoxyCodeLine{4203           arma\_H5Fclose(fid);}
\DoxyCodeLine{4204           }
\DoxyCodeLine{4205           \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{4206           \}}
\DoxyCodeLine{4207         }
\DoxyCodeLine{4208         \textcolor{keywordflow}{if}(ndims == 1) \{ dims[1] = 1; dims[2] = 1; \}  \textcolor{comment}{// Vector case; one row/colum, several slices}}
\DoxyCodeLine{4209         \textcolor{keywordflow}{if}(ndims == 2) \{              dims[2] = 1; \}  \textcolor{comment}{// Matrix case; one column, several rows/slices}}
\DoxyCodeLine{4210         }
\DoxyCodeLine{4211         \textcolor{keywordflow}{try} \{ x.set\_size(dims[2], dims[1], dims[0]); \} \textcolor{keywordflow}{catch}(...) \{ err\_msg = \textcolor{stringliteral}{"{}not enough memory"{}}; \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{4212         }
\DoxyCodeLine{4213         \textcolor{comment}{// Now we have to see what type is stored to figure out how to load it.}}
\DoxyCodeLine{4214         hid\_t datatype = arma\_H5Dget\_type(dataset);}
\DoxyCodeLine{4215         hid\_t mat\_type = hdf5\_misc::get\_hdf5\_type<eT>();}
\DoxyCodeLine{4216         }
\DoxyCodeLine{4217         \textcolor{comment}{// If these are the same type, it is simple.}}
\DoxyCodeLine{4218         \textcolor{keywordflow}{if}(arma\_H5Tequal(datatype, mat\_type) > 0)}
\DoxyCodeLine{4219           \{}
\DoxyCodeLine{4220           \textcolor{comment}{// Load directly; H5S\_ALL used so that we load the entire dataset.}}
\DoxyCodeLine{4221           hid\_t read\_status = arma\_H5Dread(dataset, datatype, H5S\_ALL, H5S\_ALL, H5P\_DEFAULT, void\_ptr(x.memptr()));}
\DoxyCodeLine{4222           }
\DoxyCodeLine{4223           \textcolor{keywordflow}{if}(read\_status >= 0) \{ load\_okay = \textcolor{keyword}{true}; \}}
\DoxyCodeLine{4224           \}}
\DoxyCodeLine{4225         \textcolor{keywordflow}{else}}
\DoxyCodeLine{4226           \{}
\DoxyCodeLine{4227           \textcolor{comment}{// Load into another array and convert its type accordingly.}}
\DoxyCodeLine{4228           hid\_t read\_status = hdf5\_misc::load\_and\_convert\_hdf5(x.memptr(), dataset, datatype, x.n\_elem);}
\DoxyCodeLine{4229           }
\DoxyCodeLine{4230           \textcolor{keywordflow}{if}(read\_status >= 0) \{ load\_okay = \textcolor{keyword}{true}; \}}
\DoxyCodeLine{4231           \}}
\DoxyCodeLine{4232         }
\DoxyCodeLine{4233         \textcolor{comment}{// Now clean up.}}
\DoxyCodeLine{4234         arma\_H5Tclose(datatype);}
\DoxyCodeLine{4235         arma\_H5Tclose(mat\_type);}
\DoxyCodeLine{4236         arma\_H5Sclose(filespace);}
\DoxyCodeLine{4237         \}}
\DoxyCodeLine{4238       }
\DoxyCodeLine{4239       arma\_H5Dclose(dataset);}
\DoxyCodeLine{4240       }
\DoxyCodeLine{4241       arma\_H5Fclose(fid);}
\DoxyCodeLine{4242       }
\DoxyCodeLine{4243       \textcolor{keywordflow}{if}(load\_okay == \textcolor{keyword}{false})}
\DoxyCodeLine{4244         \{}
\DoxyCodeLine{4245         err\_msg = \textcolor{stringliteral}{"{}unsupported or missing HDF5 data"{}};}
\DoxyCodeLine{4246         \}}
\DoxyCodeLine{4247       \}}
\DoxyCodeLine{4248     \textcolor{keywordflow}{else}}
\DoxyCodeLine{4249       \{}
\DoxyCodeLine{4250       err\_msg = \textcolor{stringliteral}{"{}cannot open"{}};}
\DoxyCodeLine{4251       \}}
\DoxyCodeLine{4252     }
\DoxyCodeLine{4253     \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{4254     \}}
\DoxyCodeLine{4255 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{4256     \{}
\DoxyCodeLine{4257     arma\_ignore(x);}
\DoxyCodeLine{4258     arma\_ignore(spec);}
\DoxyCodeLine{4259     arma\_ignore(err\_msg);}
\DoxyCodeLine{4260     }
\DoxyCodeLine{4261     arma\_stop\_logic\_error(\textcolor{stringliteral}{"{}Cube::load(): use of HDF5 must be enabled"{}});}
\DoxyCodeLine{4262     }
\DoxyCodeLine{4263     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{4264     \}}
\DoxyCodeLine{4265 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{4266   \}}
\DoxyCodeLine{4267 }
\DoxyCodeLine{4268 }
\DoxyCodeLine{4269 }
\DoxyCodeLine{4271 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{4272 \textcolor{keyword}{inline}}
\DoxyCodeLine{4273 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{4274 \mbox{\hyperlink{group__diskio_ga3a08df975abb1db75bd484e541d4841b}{diskio::load\_auto\_detect}}(\mbox{\hyperlink{classCube}{Cube<eT>}}\& x, \textcolor{keyword}{const} std::string\& \mbox{\hyperlink{structname}{name}}, std::string\& err\_msg)}
\DoxyCodeLine{4275   \{}
\DoxyCodeLine{4276   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{4277   }
\DoxyCodeLine{4278 \textcolor{preprocessor}{  \#if defined(ARMA\_USE\_HDF5)}}
\DoxyCodeLine{4279     \textcolor{comment}{// We're currently using the C bindings for the HDF5 library, which don't support C++ streams}}
\DoxyCodeLine{4280     \textcolor{keywordflow}{if}( arma\_H5Fis\_hdf5(\mbox{\hyperlink{structname}{name}}.c\_str()) ) \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{group__diskio_ga44d57eace6517b322f38e379e2126627}{load\_hdf5\_binary}}(x, \mbox{\hyperlink{structname}{name}}, err\_msg); \}}
\DoxyCodeLine{4281 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{4282   }
\DoxyCodeLine{4283   std::fstream f;}
\DoxyCodeLine{4284   f.open(\mbox{\hyperlink{structname}{name}}.c\_str(), std::fstream::in | std::fstream::binary);}
\DoxyCodeLine{4285   }
\DoxyCodeLine{4286   \textcolor{keywordtype}{bool} load\_okay = f.is\_open();}
\DoxyCodeLine{4287   }
\DoxyCodeLine{4288   \textcolor{keywordflow}{if}(load\_okay)}
\DoxyCodeLine{4289     \{}
\DoxyCodeLine{4290     load\_okay = \mbox{\hyperlink{group__diskio_ga3a08df975abb1db75bd484e541d4841b}{diskio::load\_auto\_detect}}(x, f, err\_msg);}
\DoxyCodeLine{4291     f.close();}
\DoxyCodeLine{4292     \}}
\DoxyCodeLine{4293   }
\DoxyCodeLine{4294   \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{4295   \}}
\DoxyCodeLine{4296 }
\DoxyCodeLine{4297 }
\DoxyCodeLine{4298 }
\DoxyCodeLine{4300 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{4301 \textcolor{keyword}{inline}}
\DoxyCodeLine{4302 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{4303 \mbox{\hyperlink{group__diskio_ga3a08df975abb1db75bd484e541d4841b}{diskio::load\_auto\_detect}}(\mbox{\hyperlink{classCube}{Cube<eT>}}\& x, std::istream\& f, std::string\& err\_msg)}
\DoxyCodeLine{4304   \{}
\DoxyCodeLine{4305   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{4306   }
\DoxyCodeLine{4307   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_CUB\_TXT\_str = \textcolor{stringliteral}{"{}ARMA\_CUB\_TXT"{}};}
\DoxyCodeLine{4308   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ARMA\_CUB\_BIN\_str = \textcolor{stringliteral}{"{}ARMA\_CUB\_BIN"{}};}
\DoxyCodeLine{4309   \textcolor{keyword}{const} \textcolor{keywordtype}{char}*           P6\_str = \textcolor{stringliteral}{"{}P6"{}};}
\DoxyCodeLine{4310   }
\DoxyCodeLine{4311   \textcolor{keyword}{const} uword ARMA\_CUB\_TXT\_len = uword(12);}
\DoxyCodeLine{4312   \textcolor{keyword}{const} uword ARMA\_CUB\_BIN\_len = uword(12);}
\DoxyCodeLine{4313   \textcolor{keyword}{const} uword           P6\_len = uword(2);}
\DoxyCodeLine{4314   }
\DoxyCodeLine{4315   \mbox{\hyperlink{classpodarray}{podarray<char>}} header(ARMA\_CUB\_TXT\_len + 1);}
\DoxyCodeLine{4316   }
\DoxyCodeLine{4317   \textcolor{keywordtype}{char}* header\_mem = header.memptr();}
\DoxyCodeLine{4318   }
\DoxyCodeLine{4319   std::streampos pos = f.tellg();}
\DoxyCodeLine{4320   }
\DoxyCodeLine{4321   f.read( header\_mem, std::streamsize(ARMA\_CUB\_TXT\_len) );}
\DoxyCodeLine{4322   f.clear();}
\DoxyCodeLine{4323   f.seekg(pos);}
\DoxyCodeLine{4324   }
\DoxyCodeLine{4325   header\_mem[ARMA\_CUB\_TXT\_len] = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{4326   }
\DoxyCodeLine{4327   \textcolor{keywordflow}{if}( std::strncmp(ARMA\_CUB\_TXT\_str, header\_mem, \textcolor{keywordtype}{size\_t}(ARMA\_CUB\_TXT\_len)) == 0 )}
\DoxyCodeLine{4328     \{}
\DoxyCodeLine{4329     \textcolor{keywordflow}{return} \mbox{\hyperlink{group__diskio_ga84c9da5c70180743ecc7918230a06d98}{load\_arma\_ascii}}(x, f, err\_msg);}
\DoxyCodeLine{4330     \}}
\DoxyCodeLine{4331   \textcolor{keywordflow}{else}}
\DoxyCodeLine{4332   \textcolor{keywordflow}{if}( std::strncmp(ARMA\_CUB\_BIN\_str, header\_mem, \textcolor{keywordtype}{size\_t}(ARMA\_CUB\_BIN\_len)) == 0 )}
\DoxyCodeLine{4333     \{}
\DoxyCodeLine{4334     \textcolor{keywordflow}{return} \mbox{\hyperlink{group__diskio_ga7d310b89b83e6327a818215bb3124aa0}{load\_arma\_binary}}(x, f, err\_msg);}
\DoxyCodeLine{4335     \}}
\DoxyCodeLine{4336   \textcolor{keywordflow}{else}}
\DoxyCodeLine{4337   \textcolor{keywordflow}{if}( std::strncmp(P6\_str, header\_mem, \textcolor{keywordtype}{size\_t}(P6\_len)) == 0 )}
\DoxyCodeLine{4338     \{}
\DoxyCodeLine{4339     \textcolor{keywordflow}{return} load\_ppm\_binary(x, f, err\_msg);}
\DoxyCodeLine{4340     \}}
\DoxyCodeLine{4341   \textcolor{keywordflow}{else}}
\DoxyCodeLine{4342     \{}
\DoxyCodeLine{4343     \textcolor{keyword}{const} \mbox{\hyperlink{group__diskio_ga0de594dadb1bc493ecc618520a2d260e}{file\_type}} ft = guess\_file\_type\_internal(f);}
\DoxyCodeLine{4344     }
\DoxyCodeLine{4345     \textcolor{keywordflow}{switch}(ft)}
\DoxyCodeLine{4346       \{}
\DoxyCodeLine{4347       \textcolor{comment}{// case csv\_ascii:}}
\DoxyCodeLine{4348       \textcolor{comment}{//   return load\_csv\_ascii(x, f, err\_msg);}}
\DoxyCodeLine{4349       \textcolor{comment}{//   break;}}
\DoxyCodeLine{4350       }
\DoxyCodeLine{4351       \textcolor{keywordflow}{case} \mbox{\hyperlink{group__diskio_gga0de594dadb1bc493ecc618520a2d260eac7c03701d8a6949bd83abea1ecce583d}{raw\_binary}}:}
\DoxyCodeLine{4352         \textcolor{keywordflow}{return} \mbox{\hyperlink{group__diskio_ga758d71eceff8f867d38619aa52ddf40b}{load\_raw\_binary}}(x, f, err\_msg);}
\DoxyCodeLine{4353         \textcolor{keywordflow}{break};}
\DoxyCodeLine{4354         }
\DoxyCodeLine{4355       \textcolor{keywordflow}{case} \mbox{\hyperlink{group__diskio_gga0de594dadb1bc493ecc618520a2d260ea7963e321f4e9acbc17ee7bb89759c726}{raw\_ascii}}:}
\DoxyCodeLine{4356         \textcolor{keywordflow}{return} \mbox{\hyperlink{group__diskio_gab4a891389f7af45143d69e1e13e02fde}{load\_raw\_ascii}}(x, f, err\_msg);}
\DoxyCodeLine{4357         \textcolor{keywordflow}{break};}
\DoxyCodeLine{4358         }
\DoxyCodeLine{4359       \textcolor{keywordflow}{default}:}
\DoxyCodeLine{4360         err\_msg = \textcolor{stringliteral}{"{}unknown data"{}};}
\DoxyCodeLine{4361         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{4362       \}}
\DoxyCodeLine{4363     \}}
\DoxyCodeLine{4364   }
\DoxyCodeLine{4365   \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{4366   \}}
\DoxyCodeLine{4367 }
\DoxyCodeLine{4368 }
\DoxyCodeLine{4369 }
\DoxyCodeLine{4370 }
\DoxyCodeLine{4371 }
\DoxyCodeLine{4372 \textcolor{comment}{// fields}}
\DoxyCodeLine{4373 }
\DoxyCodeLine{4374 }
\DoxyCodeLine{4375 }
\DoxyCodeLine{4376 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{4377 \textcolor{keyword}{inline}}
\DoxyCodeLine{4378 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{4379 \mbox{\hyperlink{group__diskio_ga831707949f1f222d23e15603832e079b}{diskio::save\_arma\_binary}}(\textcolor{keyword}{const} \mbox{\hyperlink{classfield}{field<T1>}}\& x, \textcolor{keyword}{const} std::string\& final\_name)}
\DoxyCodeLine{4380   \{}
\DoxyCodeLine{4381   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{4382   }
\DoxyCodeLine{4383   \textcolor{keyword}{const} std::string tmp\_name = \mbox{\hyperlink{group__diskio_gad32fa08afe53746650c31071f88eacab}{diskio::gen\_tmp\_name}}(final\_name);}
\DoxyCodeLine{4384   }
\DoxyCodeLine{4385   std::ofstream f( tmp\_name.c\_str(), std::fstream::binary );}
\DoxyCodeLine{4386   }
\DoxyCodeLine{4387   \textcolor{keywordtype}{bool} save\_okay = f.is\_open();}
\DoxyCodeLine{4388   }
\DoxyCodeLine{4389   \textcolor{keywordflow}{if}(save\_okay)}
\DoxyCodeLine{4390     \{}
\DoxyCodeLine{4391     save\_okay = \mbox{\hyperlink{group__diskio_ga831707949f1f222d23e15603832e079b}{diskio::save\_arma\_binary}}(x, f);}
\DoxyCodeLine{4392     }
\DoxyCodeLine{4393     f.flush();}
\DoxyCodeLine{4394     f.close();}
\DoxyCodeLine{4395     }
\DoxyCodeLine{4396     \textcolor{keywordflow}{if}(save\_okay)  \{ save\_okay = \mbox{\hyperlink{group__diskio_gafbccd611e1fec1b6044f81460415d8d3}{diskio::safe\_rename}}(tmp\_name, final\_name); \}}
\DoxyCodeLine{4397     \}}
\DoxyCodeLine{4398   }
\DoxyCodeLine{4399   \textcolor{keywordflow}{return} save\_okay;}
\DoxyCodeLine{4400   \}}
\DoxyCodeLine{4401 }
\DoxyCodeLine{4402 }
\DoxyCodeLine{4403 }
\DoxyCodeLine{4404 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{4405 \textcolor{keyword}{inline}}
\DoxyCodeLine{4406 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{4407 \mbox{\hyperlink{group__diskio_ga831707949f1f222d23e15603832e079b}{diskio::save\_arma\_binary}}(\textcolor{keyword}{const} \mbox{\hyperlink{classfield}{field<T1>}}\& x, std::ostream\& f)}
\DoxyCodeLine{4408   \{}
\DoxyCodeLine{4409   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{4410   }
\DoxyCodeLine{4411   arma\_type\_check(( (\mbox{\hyperlink{structis__Mat}{is\_Mat<T1>::value}} == \textcolor{keyword}{false}) \&\& (\mbox{\hyperlink{structis__Cube}{is\_Cube<T1>::value}} == \textcolor{keyword}{false}) ));}
\DoxyCodeLine{4412   }
\DoxyCodeLine{4413   \textcolor{keywordflow}{if}(x.n\_slices <= 1)}
\DoxyCodeLine{4414     \{}
\DoxyCodeLine{4415     f << \textcolor{stringliteral}{"{}ARMA\_FLD\_BIN"{}} << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{4416     f << x.n\_rows       << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{4417     f << x.n\_cols       << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{4418     \}}
\DoxyCodeLine{4419   \textcolor{keywordflow}{else}}
\DoxyCodeLine{4420     \{}
\DoxyCodeLine{4421     f << \textcolor{stringliteral}{"{}ARMA\_FL3\_BIN"{}} << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{4422     f << x.n\_rows       << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{4423     f << x.n\_cols       << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{4424     f << x.n\_slices     << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{4425     \}}
\DoxyCodeLine{4426   }
\DoxyCodeLine{4427   \textcolor{keywordtype}{bool} save\_okay = \textcolor{keyword}{true};}
\DoxyCodeLine{4428   }
\DoxyCodeLine{4429   \textcolor{keywordflow}{for}(uword i=0; i<x.n\_elem; ++i)}
\DoxyCodeLine{4430     \{}
\DoxyCodeLine{4431     save\_okay = \mbox{\hyperlink{group__diskio_ga831707949f1f222d23e15603832e079b}{diskio::save\_arma\_binary}}(x[i], f);}
\DoxyCodeLine{4432     }
\DoxyCodeLine{4433     \textcolor{keywordflow}{if}(save\_okay == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{break}; \}}
\DoxyCodeLine{4434     \}}
\DoxyCodeLine{4435   }
\DoxyCodeLine{4436   \textcolor{keywordflow}{return} save\_okay;}
\DoxyCodeLine{4437   \}}
\DoxyCodeLine{4438 }
\DoxyCodeLine{4439 }
\DoxyCodeLine{4440 }
\DoxyCodeLine{4441 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{4442 \textcolor{keyword}{inline}}
\DoxyCodeLine{4443 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{4444 \mbox{\hyperlink{group__diskio_ga7d310b89b83e6327a818215bb3124aa0}{diskio::load\_arma\_binary}}(\mbox{\hyperlink{classfield}{field<T1>}}\& x, \textcolor{keyword}{const} std::string\& \mbox{\hyperlink{structname}{name}}, std::string\& err\_msg)}
\DoxyCodeLine{4445   \{}
\DoxyCodeLine{4446   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{4447   }
\DoxyCodeLine{4448   std::ifstream f( \mbox{\hyperlink{structname}{name}}.c\_str(), std::fstream::binary );}
\DoxyCodeLine{4449   }
\DoxyCodeLine{4450   \textcolor{keywordtype}{bool} load\_okay = f.is\_open();}
\DoxyCodeLine{4451   }
\DoxyCodeLine{4452   \textcolor{keywordflow}{if}(load\_okay)}
\DoxyCodeLine{4453     \{}
\DoxyCodeLine{4454     load\_okay = \mbox{\hyperlink{group__diskio_ga7d310b89b83e6327a818215bb3124aa0}{diskio::load\_arma\_binary}}(x, f, err\_msg);}
\DoxyCodeLine{4455     f.close();}
\DoxyCodeLine{4456     \}}
\DoxyCodeLine{4457   }
\DoxyCodeLine{4458   \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{4459   \}}
\DoxyCodeLine{4460 }
\DoxyCodeLine{4461 }
\DoxyCodeLine{4462 }
\DoxyCodeLine{4463 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{4464 \textcolor{keyword}{inline}}
\DoxyCodeLine{4465 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{4466 \mbox{\hyperlink{group__diskio_ga7d310b89b83e6327a818215bb3124aa0}{diskio::load\_arma\_binary}}(\mbox{\hyperlink{classfield}{field<T1>}}\& x, std::istream\& f, std::string\& err\_msg)}
\DoxyCodeLine{4467   \{}
\DoxyCodeLine{4468   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{4469   }
\DoxyCodeLine{4470   arma\_type\_check(( (\mbox{\hyperlink{structis__Mat}{is\_Mat<T1>::value}} == \textcolor{keyword}{false}) \&\& (\mbox{\hyperlink{structis__Cube}{is\_Cube<T1>::value}} == \textcolor{keyword}{false}) ));}
\DoxyCodeLine{4471   }
\DoxyCodeLine{4472   \textcolor{keywordtype}{bool} load\_okay = \textcolor{keyword}{true};}
\DoxyCodeLine{4473   }
\DoxyCodeLine{4474   std::string f\_type;}
\DoxyCodeLine{4475   f >> f\_type;}
\DoxyCodeLine{4476   }
\DoxyCodeLine{4477   \textcolor{keywordflow}{if}(f\_type == \textcolor{stringliteral}{"{}ARMA\_FLD\_BIN"{}})}
\DoxyCodeLine{4478     \{}
\DoxyCodeLine{4479     uword f\_n\_rows;}
\DoxyCodeLine{4480     uword f\_n\_cols;}
\DoxyCodeLine{4481     }
\DoxyCodeLine{4482     f >> f\_n\_rows;}
\DoxyCodeLine{4483     f >> f\_n\_cols;}
\DoxyCodeLine{4484     }
\DoxyCodeLine{4485     \textcolor{keywordflow}{try} \{ x.set\_size(f\_n\_rows, f\_n\_cols); \} \textcolor{keywordflow}{catch}(...) \{ err\_msg = \textcolor{stringliteral}{"{}not enough memory"{}}; \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{4486     }
\DoxyCodeLine{4487     f.get();}
\DoxyCodeLine{4488     }
\DoxyCodeLine{4489     \textcolor{keywordflow}{for}(uword i=0; i<x.n\_elem; ++i)}
\DoxyCodeLine{4490       \{}
\DoxyCodeLine{4491       load\_okay = \mbox{\hyperlink{group__diskio_ga7d310b89b83e6327a818215bb3124aa0}{diskio::load\_arma\_binary}}(x[i], f, err\_msg);}
\DoxyCodeLine{4492       }
\DoxyCodeLine{4493       \textcolor{keywordflow}{if}(load\_okay == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{break}; \}}
\DoxyCodeLine{4494       \}}
\DoxyCodeLine{4495     \}}
\DoxyCodeLine{4496   \textcolor{keywordflow}{else}}
\DoxyCodeLine{4497   \textcolor{keywordflow}{if}(f\_type == \textcolor{stringliteral}{"{}ARMA\_FL3\_BIN"{}})}
\DoxyCodeLine{4498     \{}
\DoxyCodeLine{4499     uword f\_n\_rows;}
\DoxyCodeLine{4500     uword f\_n\_cols;}
\DoxyCodeLine{4501     uword f\_n\_slices;}
\DoxyCodeLine{4502     }
\DoxyCodeLine{4503     f >> f\_n\_rows;}
\DoxyCodeLine{4504     f >> f\_n\_cols;}
\DoxyCodeLine{4505     f >> f\_n\_slices;}
\DoxyCodeLine{4506     }
\DoxyCodeLine{4507     \textcolor{keywordflow}{try} \{ x.set\_size(f\_n\_rows, f\_n\_cols, f\_n\_slices); \} \textcolor{keywordflow}{catch}(...) \{ err\_msg = \textcolor{stringliteral}{"{}not enough memory"{}}; \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{4508     }
\DoxyCodeLine{4509     f.get();}
\DoxyCodeLine{4510     }
\DoxyCodeLine{4511     \textcolor{keywordflow}{for}(uword i=0; i<x.n\_elem; ++i)}
\DoxyCodeLine{4512       \{}
\DoxyCodeLine{4513       load\_okay = \mbox{\hyperlink{group__diskio_ga7d310b89b83e6327a818215bb3124aa0}{diskio::load\_arma\_binary}}(x[i], f, err\_msg);}
\DoxyCodeLine{4514       }
\DoxyCodeLine{4515       \textcolor{keywordflow}{if}(load\_okay == \textcolor{keyword}{false})  \{ \textcolor{keywordflow}{break}; \}}
\DoxyCodeLine{4516       \}}
\DoxyCodeLine{4517     \}}
\DoxyCodeLine{4518   \textcolor{keywordflow}{else}}
\DoxyCodeLine{4519     \{}
\DoxyCodeLine{4520     load\_okay = \textcolor{keyword}{false};}
\DoxyCodeLine{4521     err\_msg = \textcolor{stringliteral}{"{}unsupported field type"{}};}
\DoxyCodeLine{4522     \}}
\DoxyCodeLine{4523   }
\DoxyCodeLine{4524   \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{4525   \}}
\DoxyCodeLine{4526 }
\DoxyCodeLine{4527 }
\DoxyCodeLine{4528 }
\DoxyCodeLine{4529 \textcolor{keyword}{inline}}
\DoxyCodeLine{4530 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{4531 diskio::save\_std\_string(\textcolor{keyword}{const} \mbox{\hyperlink{classfield}{field<std::string>}}\& x, \textcolor{keyword}{const} std::string\& final\_name)}
\DoxyCodeLine{4532   \{}
\DoxyCodeLine{4533   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{4534   }
\DoxyCodeLine{4535   \textcolor{keyword}{const} std::string tmp\_name = \mbox{\hyperlink{group__diskio_gad32fa08afe53746650c31071f88eacab}{diskio::gen\_tmp\_name}}(final\_name);}
\DoxyCodeLine{4536   }
\DoxyCodeLine{4537   std::ofstream f( tmp\_name.c\_str(), std::fstream::binary );}
\DoxyCodeLine{4538   }
\DoxyCodeLine{4539   \textcolor{keywordtype}{bool} save\_okay = f.is\_open();}
\DoxyCodeLine{4540   }
\DoxyCodeLine{4541   \textcolor{keywordflow}{if}(save\_okay)}
\DoxyCodeLine{4542     \{}
\DoxyCodeLine{4543     save\_okay = diskio::save\_std\_string(x, f);}
\DoxyCodeLine{4544     }
\DoxyCodeLine{4545     f.flush();}
\DoxyCodeLine{4546     f.close();}
\DoxyCodeLine{4547     }
\DoxyCodeLine{4548     \textcolor{keywordflow}{if}(save\_okay)  \{ save\_okay = \mbox{\hyperlink{group__diskio_gafbccd611e1fec1b6044f81460415d8d3}{diskio::safe\_rename}}(tmp\_name, final\_name); \}}
\DoxyCodeLine{4549     \}}
\DoxyCodeLine{4550   }
\DoxyCodeLine{4551   \textcolor{keywordflow}{return} save\_okay;}
\DoxyCodeLine{4552   \}}
\DoxyCodeLine{4553 }
\DoxyCodeLine{4554 }
\DoxyCodeLine{4555 }
\DoxyCodeLine{4556 \textcolor{keyword}{inline}}
\DoxyCodeLine{4557 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{4558 diskio::save\_std\_string(\textcolor{keyword}{const} \mbox{\hyperlink{classfield}{field<std::string>}}\& x, std::ostream\& f)}
\DoxyCodeLine{4559   \{}
\DoxyCodeLine{4560   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{4561   }
\DoxyCodeLine{4562   \textcolor{keywordflow}{for}(uword row=0; row<x.n\_rows; ++row)}
\DoxyCodeLine{4563   \textcolor{keywordflow}{for}(uword col=0; col<x.n\_cols; ++col)}
\DoxyCodeLine{4564     \{}
\DoxyCodeLine{4565     f << x.at(row,col);}
\DoxyCodeLine{4566     }
\DoxyCodeLine{4567     \textcolor{keywordflow}{if}(col < x.n\_cols-\/1)}
\DoxyCodeLine{4568       \{}
\DoxyCodeLine{4569       f << \textcolor{charliteral}{' '};}
\DoxyCodeLine{4570       \}}
\DoxyCodeLine{4571     \textcolor{keywordflow}{else}}
\DoxyCodeLine{4572       \{}
\DoxyCodeLine{4573       f << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{4574       \}}
\DoxyCodeLine{4575     \}}
\DoxyCodeLine{4576   }
\DoxyCodeLine{4577   \textcolor{keywordflow}{return} f.good();}
\DoxyCodeLine{4578   \}}
\DoxyCodeLine{4579 }
\DoxyCodeLine{4580 }
\DoxyCodeLine{4581 }
\DoxyCodeLine{4582 \textcolor{keyword}{inline}}
\DoxyCodeLine{4583 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{4584 diskio::load\_std\_string(\mbox{\hyperlink{classfield}{field<std::string>}}\& x, \textcolor{keyword}{const} std::string\& \mbox{\hyperlink{structname}{name}}, std::string\& err\_msg)}
\DoxyCodeLine{4585   \{}
\DoxyCodeLine{4586   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{4587   }
\DoxyCodeLine{4588   std::ifstream f( \mbox{\hyperlink{structname}{name}}.c\_str() );}
\DoxyCodeLine{4589   }
\DoxyCodeLine{4590   \textcolor{keywordtype}{bool} load\_okay = f.is\_open();}
\DoxyCodeLine{4591   }
\DoxyCodeLine{4592   \textcolor{keywordflow}{if}(load\_okay)}
\DoxyCodeLine{4593     \{}
\DoxyCodeLine{4594     load\_okay = diskio::load\_std\_string(x, f, err\_msg);}
\DoxyCodeLine{4595     f.close();}
\DoxyCodeLine{4596     \}}
\DoxyCodeLine{4597   }
\DoxyCodeLine{4598   \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{4599   \}}
\DoxyCodeLine{4600 }
\DoxyCodeLine{4601 }
\DoxyCodeLine{4602 }
\DoxyCodeLine{4603 \textcolor{keyword}{inline}}
\DoxyCodeLine{4604 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{4605 diskio::load\_std\_string(\mbox{\hyperlink{classfield}{field<std::string>}}\& x, std::istream\& f, std::string\& err\_msg)}
\DoxyCodeLine{4606   \{}
\DoxyCodeLine{4607   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{4608   }
\DoxyCodeLine{4609   \textcolor{keywordtype}{bool} load\_okay = \textcolor{keyword}{true};}
\DoxyCodeLine{4610   }
\DoxyCodeLine{4611   \textcolor{comment}{//}}
\DoxyCodeLine{4612   \textcolor{comment}{// work out the size}}
\DoxyCodeLine{4613   }
\DoxyCodeLine{4614   uword f\_n\_rows = 0;}
\DoxyCodeLine{4615   uword f\_n\_cols = 0;}
\DoxyCodeLine{4616   }
\DoxyCodeLine{4617   \textcolor{keywordtype}{bool} f\_n\_cols\_found = \textcolor{keyword}{false};}
\DoxyCodeLine{4618   }
\DoxyCodeLine{4619   std::string line\_string;}
\DoxyCodeLine{4620   std::string token;}
\DoxyCodeLine{4621   }
\DoxyCodeLine{4622   \textcolor{keywordflow}{while}( f.good() \&\& load\_okay )}
\DoxyCodeLine{4623     \{}
\DoxyCodeLine{4624     std::getline(f, line\_string);}
\DoxyCodeLine{4625     }
\DoxyCodeLine{4626     \textcolor{keywordflow}{if}(line\_string.size() == 0)  \{ \textcolor{keywordflow}{break}; \}}
\DoxyCodeLine{4627     }
\DoxyCodeLine{4628     std::stringstream line\_stream(line\_string);}
\DoxyCodeLine{4629     }
\DoxyCodeLine{4630     uword line\_n\_cols = 0;}
\DoxyCodeLine{4631     }
\DoxyCodeLine{4632     \textcolor{keywordflow}{while}(line\_stream >> token)  \{ line\_n\_cols++; \}}
\DoxyCodeLine{4633     }
\DoxyCodeLine{4634     \textcolor{keywordflow}{if}(f\_n\_cols\_found == \textcolor{keyword}{false})}
\DoxyCodeLine{4635       \{}
\DoxyCodeLine{4636       f\_n\_cols = line\_n\_cols;}
\DoxyCodeLine{4637       f\_n\_cols\_found = \textcolor{keyword}{true};}
\DoxyCodeLine{4638       \}}
\DoxyCodeLine{4639     \textcolor{keywordflow}{else}}
\DoxyCodeLine{4640       \{}
\DoxyCodeLine{4641       \textcolor{keywordflow}{if}(line\_n\_cols != f\_n\_cols)}
\DoxyCodeLine{4642         \{}
\DoxyCodeLine{4643         load\_okay = \textcolor{keyword}{false};}
\DoxyCodeLine{4644         err\_msg = \textcolor{stringliteral}{"{}inconsistent number of columns"{}};}
\DoxyCodeLine{4645         \}}
\DoxyCodeLine{4646       \}}
\DoxyCodeLine{4647     }
\DoxyCodeLine{4648     ++f\_n\_rows;}
\DoxyCodeLine{4649     \}}
\DoxyCodeLine{4650     }
\DoxyCodeLine{4651   \textcolor{keywordflow}{if}(load\_okay)}
\DoxyCodeLine{4652     \{}
\DoxyCodeLine{4653     f.clear();}
\DoxyCodeLine{4654     f.seekg(0, ios::beg);}
\DoxyCodeLine{4655     \textcolor{comment}{//f.seekg(start);}}
\DoxyCodeLine{4656     }
\DoxyCodeLine{4657     \textcolor{keywordflow}{try} \{ x.set\_size(f\_n\_rows, f\_n\_cols); \} \textcolor{keywordflow}{catch}(...) \{ err\_msg = \textcolor{stringliteral}{"{}not enough memory"{}}; \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{4658     }
\DoxyCodeLine{4659     \textcolor{keywordflow}{for}(uword row=0; row < x.n\_rows; ++row)}
\DoxyCodeLine{4660     \textcolor{keywordflow}{for}(uword col=0; col < x.n\_cols; ++col)}
\DoxyCodeLine{4661       \{}
\DoxyCodeLine{4662       f >> x.at(row,col);}
\DoxyCodeLine{4663       \}}
\DoxyCodeLine{4664     \}}
\DoxyCodeLine{4665   }
\DoxyCodeLine{4666   \textcolor{keywordflow}{if}(f.good() == \textcolor{keyword}{false})  \{ load\_okay = \textcolor{keyword}{false}; \}}
\DoxyCodeLine{4667   }
\DoxyCodeLine{4668   \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{4669   \}}
\DoxyCodeLine{4670 }
\DoxyCodeLine{4671 }
\DoxyCodeLine{4672 }
\DoxyCodeLine{4674 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{4675 \textcolor{keyword}{inline}}
\DoxyCodeLine{4676 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{4677 \mbox{\hyperlink{group__diskio_ga3a08df975abb1db75bd484e541d4841b}{diskio::load\_auto\_detect}}(\mbox{\hyperlink{classfield}{field<T1>}}\& x, \textcolor{keyword}{const} std::string\& \mbox{\hyperlink{structname}{name}}, std::string\& err\_msg)}
\DoxyCodeLine{4678   \{}
\DoxyCodeLine{4679   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{4680   }
\DoxyCodeLine{4681   std::fstream f;}
\DoxyCodeLine{4682   f.open(\mbox{\hyperlink{structname}{name}}.c\_str(), std::fstream::in | std::fstream::binary);}
\DoxyCodeLine{4683   }
\DoxyCodeLine{4684   \textcolor{keywordtype}{bool} load\_okay = f.is\_open();}
\DoxyCodeLine{4685   }
\DoxyCodeLine{4686   \textcolor{keywordflow}{if}(load\_okay)}
\DoxyCodeLine{4687     \{}
\DoxyCodeLine{4688     load\_okay = \mbox{\hyperlink{group__diskio_ga3a08df975abb1db75bd484e541d4841b}{diskio::load\_auto\_detect}}(x, f, err\_msg);}
\DoxyCodeLine{4689     f.close();}
\DoxyCodeLine{4690     \}}
\DoxyCodeLine{4691   }
\DoxyCodeLine{4692   \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{4693   \}}
\DoxyCodeLine{4694 }
\DoxyCodeLine{4695 }
\DoxyCodeLine{4696 }
\DoxyCodeLine{4698 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{4699 \textcolor{keyword}{inline}}
\DoxyCodeLine{4700 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{4701 \mbox{\hyperlink{group__diskio_ga3a08df975abb1db75bd484e541d4841b}{diskio::load\_auto\_detect}}(\mbox{\hyperlink{classfield}{field<T1>}}\& x, std::istream\& f, std::string\& err\_msg)}
\DoxyCodeLine{4702   \{}
\DoxyCodeLine{4703   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{4704   }
\DoxyCodeLine{4705   arma\_type\_check(( \mbox{\hyperlink{structis__Mat}{is\_Mat<T1>::value}} == \textcolor{keyword}{false} ));}
\DoxyCodeLine{4706   }
\DoxyCodeLine{4707   \textcolor{keyword}{static} \textcolor{keyword}{const} std::string ARMA\_FLD\_BIN = \textcolor{stringliteral}{"{}ARMA\_FLD\_BIN"{}};}
\DoxyCodeLine{4708   \textcolor{keyword}{static} \textcolor{keyword}{const} std::string ARMA\_FL3\_BIN = \textcolor{stringliteral}{"{}ARMA\_FL3\_BIN"{}};}
\DoxyCodeLine{4709   \textcolor{keyword}{static} \textcolor{keyword}{const} std::string           P6 = \textcolor{stringliteral}{"{}P6"{}};}
\DoxyCodeLine{4710   }
\DoxyCodeLine{4711   \mbox{\hyperlink{classpodarray}{podarray<char>}} raw\_header(uword(ARMA\_FLD\_BIN.length()) + 1);}
\DoxyCodeLine{4712   }
\DoxyCodeLine{4713   std::streampos pos = f.tellg();}
\DoxyCodeLine{4714   }
\DoxyCodeLine{4715   f.read( raw\_header.memptr(), std::streamsize(ARMA\_FLD\_BIN.length()) );}
\DoxyCodeLine{4716   }
\DoxyCodeLine{4717   f.clear();}
\DoxyCodeLine{4718   f.seekg(pos);}
\DoxyCodeLine{4719   }
\DoxyCodeLine{4720   raw\_header[uword(ARMA\_FLD\_BIN.length())] = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{4721   }
\DoxyCodeLine{4722   \textcolor{keyword}{const} std::string header = raw\_header.\mbox{\hyperlink{classpodarray_a3235dffb0bca72b5aa2f6f7d2c696601}{mem}};}
\DoxyCodeLine{4723   }
\DoxyCodeLine{4724   \textcolor{keywordflow}{if}(ARMA\_FLD\_BIN == header.substr(0, ARMA\_FLD\_BIN.length()))}
\DoxyCodeLine{4725     \{}
\DoxyCodeLine{4726     \textcolor{keywordflow}{return} \mbox{\hyperlink{group__diskio_ga7d310b89b83e6327a818215bb3124aa0}{load\_arma\_binary}}(x, f, err\_msg);}
\DoxyCodeLine{4727     \}}
\DoxyCodeLine{4728   \textcolor{keywordflow}{else}}
\DoxyCodeLine{4729   \textcolor{keywordflow}{if}(ARMA\_FL3\_BIN == header.substr(0, ARMA\_FL3\_BIN.length()))}
\DoxyCodeLine{4730     \{}
\DoxyCodeLine{4731     \textcolor{keywordflow}{return} \mbox{\hyperlink{group__diskio_ga7d310b89b83e6327a818215bb3124aa0}{load\_arma\_binary}}(x, f, err\_msg);}
\DoxyCodeLine{4732     \}}
\DoxyCodeLine{4733   \textcolor{keywordflow}{else}}
\DoxyCodeLine{4734   \textcolor{keywordflow}{if}(P6 == header.substr(0, P6.length()))}
\DoxyCodeLine{4735     \{}
\DoxyCodeLine{4736     \textcolor{keywordflow}{return} load\_ppm\_binary(x, f, err\_msg);}
\DoxyCodeLine{4737     \}}
\DoxyCodeLine{4738   \textcolor{keywordflow}{else}}
\DoxyCodeLine{4739     \{}
\DoxyCodeLine{4740     err\_msg = \textcolor{stringliteral}{"{}unsupported header"{}};}
\DoxyCodeLine{4741     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{4742     \}}
\DoxyCodeLine{4743   \}}
\DoxyCodeLine{4744 }
\DoxyCodeLine{4745 }
\DoxyCodeLine{4746 }
\DoxyCodeLine{4747 \textcolor{comment}{//}}
\DoxyCodeLine{4748 \textcolor{comment}{// handling of PPM images by cubes}}
\DoxyCodeLine{4749 }
\DoxyCodeLine{4750 }
\DoxyCodeLine{4751 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{4752 \textcolor{keyword}{inline}}
\DoxyCodeLine{4753 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{4754 diskio::load\_ppm\_binary(\mbox{\hyperlink{classCube}{Cube<eT>}}\& x, \textcolor{keyword}{const} std::string\& \mbox{\hyperlink{structname}{name}}, std::string\& err\_msg)}
\DoxyCodeLine{4755   \{}
\DoxyCodeLine{4756   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{4757   }
\DoxyCodeLine{4758   std::fstream f;}
\DoxyCodeLine{4759   f.open(\mbox{\hyperlink{structname}{name}}.c\_str(), std::fstream::in | std::fstream::binary);}
\DoxyCodeLine{4760   }
\DoxyCodeLine{4761   \textcolor{keywordtype}{bool} load\_okay = f.is\_open();}
\DoxyCodeLine{4762   }
\DoxyCodeLine{4763   \textcolor{keywordflow}{if}(load\_okay)}
\DoxyCodeLine{4764     \{}
\DoxyCodeLine{4765     load\_okay = diskio::load\_ppm\_binary(x, f, err\_msg);}
\DoxyCodeLine{4766     f.close();}
\DoxyCodeLine{4767     \}}
\DoxyCodeLine{4768   }
\DoxyCodeLine{4769   \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{4770   \}}
\DoxyCodeLine{4771 }
\DoxyCodeLine{4772 }
\DoxyCodeLine{4773 }
\DoxyCodeLine{4774 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{4775 \textcolor{keyword}{inline}}
\DoxyCodeLine{4776 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{4777 diskio::load\_ppm\_binary(\mbox{\hyperlink{classCube}{Cube<eT>}}\& x, std::istream\& f, std::string\& err\_msg)}
\DoxyCodeLine{4778   \{}
\DoxyCodeLine{4779   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{4780   }
\DoxyCodeLine{4781   \textcolor{keywordtype}{bool} load\_okay = \textcolor{keyword}{true};}
\DoxyCodeLine{4782   }
\DoxyCodeLine{4783   std::string f\_header;}
\DoxyCodeLine{4784   }
\DoxyCodeLine{4785   f >> f\_header;}
\DoxyCodeLine{4786   }
\DoxyCodeLine{4787   \textcolor{keywordflow}{if}(f\_header == \textcolor{stringliteral}{"{}P6"{}})}
\DoxyCodeLine{4788     \{}
\DoxyCodeLine{4789     uword f\_n\_rows = 0;}
\DoxyCodeLine{4790     uword f\_n\_cols = 0;}
\DoxyCodeLine{4791     \textcolor{keywordtype}{int} f\_maxval = 0;}
\DoxyCodeLine{4792     }
\DoxyCodeLine{4793     diskio::pnm\_skip\_comments(f);}
\DoxyCodeLine{4794     }
\DoxyCodeLine{4795     f >> f\_n\_cols;}
\DoxyCodeLine{4796     diskio::pnm\_skip\_comments(f);}
\DoxyCodeLine{4797     }
\DoxyCodeLine{4798     f >> f\_n\_rows;}
\DoxyCodeLine{4799     diskio::pnm\_skip\_comments(f);}
\DoxyCodeLine{4800     }
\DoxyCodeLine{4801     f >> f\_maxval;}
\DoxyCodeLine{4802     f.get();}
\DoxyCodeLine{4803     }
\DoxyCodeLine{4804     \textcolor{keywordflow}{if}( (f\_maxval > 0) \&\& (f\_maxval <= 65535) )}
\DoxyCodeLine{4805       \{}
\DoxyCodeLine{4806       \textcolor{keywordflow}{try} \{ x.set\_size(f\_n\_rows, f\_n\_cols, 3); \} \textcolor{keywordflow}{catch}(...) \{ err\_msg = \textcolor{stringliteral}{"{}not enough memory"{}}; \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{4807       }
\DoxyCodeLine{4808       \textcolor{keywordflow}{if}(f\_maxval <= 255)}
\DoxyCodeLine{4809         \{}
\DoxyCodeLine{4810         \textcolor{keyword}{const} uword n\_elem = 3*f\_n\_cols*f\_n\_rows;}
\DoxyCodeLine{4811         \mbox{\hyperlink{classpodarray}{podarray<u8>}} tmp(n\_elem);}
\DoxyCodeLine{4812         }
\DoxyCodeLine{4813         f.read( \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(tmp.\mbox{\hyperlink{group__Cube_ga5b00237224a8e3bfb05728de7c962f85}{memptr}}()), std::streamsize(n\_elem) );}
\DoxyCodeLine{4814         }
\DoxyCodeLine{4815         uword i = 0;}
\DoxyCodeLine{4816         }
\DoxyCodeLine{4817         \textcolor{comment}{//cout << "{}f\_n\_cols = "{} << f\_n\_cols << endl;}}
\DoxyCodeLine{4818         \textcolor{comment}{//cout << "{}f\_n\_rows = "{} << f\_n\_rows << endl;}}
\DoxyCodeLine{4819         }
\DoxyCodeLine{4820         \textcolor{keywordflow}{for}(uword row=0; row < f\_n\_rows; ++row)}
\DoxyCodeLine{4821         \textcolor{keywordflow}{for}(uword col=0; col < f\_n\_cols; ++col)}
\DoxyCodeLine{4822           \{}
\DoxyCodeLine{4823           x.at(row,col,0) = eT(tmp[i+0]);}
\DoxyCodeLine{4824           x.at(row,col,1) = eT(tmp[i+1]);}
\DoxyCodeLine{4825           x.at(row,col,2) = eT(tmp[i+2]);}
\DoxyCodeLine{4826           i+=3;}
\DoxyCodeLine{4827           \}}
\DoxyCodeLine{4828         \}}
\DoxyCodeLine{4829       \textcolor{keywordflow}{else}}
\DoxyCodeLine{4830         \{}
\DoxyCodeLine{4831         \textcolor{keyword}{const} uword n\_elem = 3*f\_n\_cols*f\_n\_rows;}
\DoxyCodeLine{4832         \mbox{\hyperlink{classpodarray}{podarray<u16>}} tmp(n\_elem);}
\DoxyCodeLine{4833         }
\DoxyCodeLine{4834         f.read( \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char} *\textcolor{keyword}{>}(tmp.\mbox{\hyperlink{group__Cube_ga5b00237224a8e3bfb05728de7c962f85}{memptr}}()), std::streamsize(2*n\_elem) );}
\DoxyCodeLine{4835         }
\DoxyCodeLine{4836         uword i = 0;}
\DoxyCodeLine{4837         }
\DoxyCodeLine{4838         \textcolor{keywordflow}{for}(uword row=0; row < f\_n\_rows; ++row)}
\DoxyCodeLine{4839         \textcolor{keywordflow}{for}(uword col=0; col < f\_n\_cols; ++col)}
\DoxyCodeLine{4840           \{}
\DoxyCodeLine{4841           x.at(row,col,0) = eT(tmp[i+0]);}
\DoxyCodeLine{4842           x.at(row,col,1) = eT(tmp[i+1]);}
\DoxyCodeLine{4843           x.at(row,col,2) = eT(tmp[i+2]);}
\DoxyCodeLine{4844           i+=3;}
\DoxyCodeLine{4845           \}}
\DoxyCodeLine{4846         \}}
\DoxyCodeLine{4847       \}}
\DoxyCodeLine{4848     \textcolor{keywordflow}{else}}
\DoxyCodeLine{4849       \{}
\DoxyCodeLine{4850       load\_okay = \textcolor{keyword}{false};}
\DoxyCodeLine{4851       err\_msg = \textcolor{stringliteral}{"{}functionality unimplemented"{}};}
\DoxyCodeLine{4852       \}}
\DoxyCodeLine{4853     }
\DoxyCodeLine{4854     \textcolor{keywordflow}{if}(f.good() == \textcolor{keyword}{false})  \{ load\_okay = \textcolor{keyword}{false}; \}}
\DoxyCodeLine{4855     \}}
\DoxyCodeLine{4856   \textcolor{keywordflow}{else}}
\DoxyCodeLine{4857     \{}
\DoxyCodeLine{4858     load\_okay = \textcolor{keyword}{false};}
\DoxyCodeLine{4859     err\_msg = \textcolor{stringliteral}{"{}unsupported header"{}};}
\DoxyCodeLine{4860     \}}
\DoxyCodeLine{4861   }
\DoxyCodeLine{4862   \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{4863   \}}
\DoxyCodeLine{4864 }
\DoxyCodeLine{4865 }
\DoxyCodeLine{4866 }
\DoxyCodeLine{4867 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{4868 \textcolor{keyword}{inline}}
\DoxyCodeLine{4869 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{4870 diskio::save\_ppm\_binary(\textcolor{keyword}{const} \mbox{\hyperlink{classCube}{Cube<eT>}}\& x, \textcolor{keyword}{const} std::string\& final\_name)}
\DoxyCodeLine{4871   \{}
\DoxyCodeLine{4872   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{4873   }
\DoxyCodeLine{4874   \textcolor{keyword}{const} std::string tmp\_name = \mbox{\hyperlink{group__diskio_gad32fa08afe53746650c31071f88eacab}{diskio::gen\_tmp\_name}}(final\_name);}
\DoxyCodeLine{4875   }
\DoxyCodeLine{4876   std::ofstream f( tmp\_name.c\_str(), std::fstream::binary );}
\DoxyCodeLine{4877   }
\DoxyCodeLine{4878   \textcolor{keywordtype}{bool} save\_okay = f.is\_open();}
\DoxyCodeLine{4879   }
\DoxyCodeLine{4880   \textcolor{keywordflow}{if}(save\_okay)}
\DoxyCodeLine{4881     \{}
\DoxyCodeLine{4882     save\_okay = diskio::save\_ppm\_binary(x, f);}
\DoxyCodeLine{4883     }
\DoxyCodeLine{4884     f.flush();}
\DoxyCodeLine{4885     f.close();}
\DoxyCodeLine{4886     }
\DoxyCodeLine{4887     \textcolor{keywordflow}{if}(save\_okay)  \{ save\_okay = \mbox{\hyperlink{group__diskio_gafbccd611e1fec1b6044f81460415d8d3}{diskio::safe\_rename}}(tmp\_name, final\_name); \}}
\DoxyCodeLine{4888     \}}
\DoxyCodeLine{4889   }
\DoxyCodeLine{4890   \textcolor{keywordflow}{return} save\_okay;}
\DoxyCodeLine{4891   \}}
\DoxyCodeLine{4892 }
\DoxyCodeLine{4893 }
\DoxyCodeLine{4894 }
\DoxyCodeLine{4895 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{4896 \textcolor{keyword}{inline}}
\DoxyCodeLine{4897 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{4898 diskio::save\_ppm\_binary(\textcolor{keyword}{const} \mbox{\hyperlink{classCube}{Cube<eT>}}\& x, std::ostream\& f)}
\DoxyCodeLine{4899   \{}
\DoxyCodeLine{4900   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{4901   }
\DoxyCodeLine{4902   arma\_debug\_check( (x.n\_slices != 3), \textcolor{stringliteral}{"{}diskio::save\_ppm\_binary(): given cube must have exactly 3 slices"{}} );}
\DoxyCodeLine{4903   }
\DoxyCodeLine{4904   \textcolor{keyword}{const} uword n\_elem = 3 * x.n\_rows * x.n\_cols;}
\DoxyCodeLine{4905   \mbox{\hyperlink{classpodarray}{podarray<u8>}} tmp(n\_elem);}
\DoxyCodeLine{4906   }
\DoxyCodeLine{4907   uword i = 0;}
\DoxyCodeLine{4908   \textcolor{keywordflow}{for}(uword row=0; row < x.n\_rows; ++row)}
\DoxyCodeLine{4909     \{}
\DoxyCodeLine{4910     \textcolor{keywordflow}{for}(uword col=0; col < x.n\_cols; ++col)}
\DoxyCodeLine{4911       \{}
\DoxyCodeLine{4912       tmp[i+0] = u8( \mbox{\hyperlink{classaccess_a9687cee4d2be0fe591998d6f5c6d0849}{access::tmp\_real}}( x.at(row,col,0) ) );}
\DoxyCodeLine{4913       tmp[i+1] = u8( \mbox{\hyperlink{classaccess_a9687cee4d2be0fe591998d6f5c6d0849}{access::tmp\_real}}( x.at(row,col,1) ) );}
\DoxyCodeLine{4914       tmp[i+2] = u8( \mbox{\hyperlink{classaccess_a9687cee4d2be0fe591998d6f5c6d0849}{access::tmp\_real}}( x.at(row,col,2) ) );}
\DoxyCodeLine{4915       }
\DoxyCodeLine{4916       i+=3;}
\DoxyCodeLine{4917       \}}
\DoxyCodeLine{4918     \}}
\DoxyCodeLine{4919   }
\DoxyCodeLine{4920   f << \textcolor{stringliteral}{"{}P6"{}} << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{4921   f << x.n\_cols << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{4922   f << x.n\_rows << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{4923   f << 255 << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{4924   }
\DoxyCodeLine{4925   f.write( \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(tmp.\mbox{\hyperlink{classCube_a5d762740f29569b8493d2d6372dc908d}{mem}}), std::streamsize(n\_elem) );}
\DoxyCodeLine{4926   }
\DoxyCodeLine{4927   \textcolor{keywordflow}{return} f.good();}
\DoxyCodeLine{4928   \}}
\DoxyCodeLine{4929 }
\DoxyCodeLine{4930 }
\DoxyCodeLine{4931 }
\DoxyCodeLine{4932 \textcolor{comment}{//}}
\DoxyCodeLine{4933 \textcolor{comment}{// handling of PPM images by fields}}
\DoxyCodeLine{4934 }
\DoxyCodeLine{4935 }
\DoxyCodeLine{4936 }
\DoxyCodeLine{4937 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{4938 \textcolor{keyword}{inline}}
\DoxyCodeLine{4939 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{4940 diskio::load\_ppm\_binary(\mbox{\hyperlink{classfield}{field<T1>}}\& x, \textcolor{keyword}{const} std::string\& \mbox{\hyperlink{structname}{name}}, std::string\& err\_msg)}
\DoxyCodeLine{4941   \{}
\DoxyCodeLine{4942   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{4943   }
\DoxyCodeLine{4944   std::fstream f;}
\DoxyCodeLine{4945   f.open(\mbox{\hyperlink{structname}{name}}.c\_str(), std::fstream::in | std::fstream::binary);}
\DoxyCodeLine{4946   }
\DoxyCodeLine{4947   \textcolor{keywordtype}{bool} load\_okay = f.is\_open();}
\DoxyCodeLine{4948   }
\DoxyCodeLine{4949   \textcolor{keywordflow}{if}(load\_okay)}
\DoxyCodeLine{4950     \{}
\DoxyCodeLine{4951     load\_okay = diskio::load\_ppm\_binary(x, f, err\_msg);}
\DoxyCodeLine{4952     f.close();}
\DoxyCodeLine{4953     \}}
\DoxyCodeLine{4954   }
\DoxyCodeLine{4955   \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{4956   \}}
\DoxyCodeLine{4957 }
\DoxyCodeLine{4958 }
\DoxyCodeLine{4959 }
\DoxyCodeLine{4960 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{4961 \textcolor{keyword}{inline}}
\DoxyCodeLine{4962 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{4963 diskio::load\_ppm\_binary(\mbox{\hyperlink{classfield}{field<T1>}}\& x, std::istream\& f, std::string\& err\_msg)}
\DoxyCodeLine{4964   \{}
\DoxyCodeLine{4965   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{4966   }
\DoxyCodeLine{4967   arma\_type\_check(( \mbox{\hyperlink{structis__Mat}{is\_Mat<T1>::value}} == \textcolor{keyword}{false} ));}
\DoxyCodeLine{4968   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{4969   }
\DoxyCodeLine{4970   \textcolor{keywordtype}{bool} load\_okay = \textcolor{keyword}{true};}
\DoxyCodeLine{4971   }
\DoxyCodeLine{4972   std::string f\_header;}
\DoxyCodeLine{4973   }
\DoxyCodeLine{4974   f >> f\_header;}
\DoxyCodeLine{4975   }
\DoxyCodeLine{4976   \textcolor{keywordflow}{if}(f\_header == \textcolor{stringliteral}{"{}P6"{}})}
\DoxyCodeLine{4977     \{}
\DoxyCodeLine{4978     uword f\_n\_rows = 0;}
\DoxyCodeLine{4979     uword f\_n\_cols = 0;}
\DoxyCodeLine{4980     \textcolor{keywordtype}{int} f\_maxval = 0;}
\DoxyCodeLine{4981     }
\DoxyCodeLine{4982     diskio::pnm\_skip\_comments(f);}
\DoxyCodeLine{4983     }
\DoxyCodeLine{4984     f >> f\_n\_cols;}
\DoxyCodeLine{4985     diskio::pnm\_skip\_comments(f);}
\DoxyCodeLine{4986     }
\DoxyCodeLine{4987     f >> f\_n\_rows;}
\DoxyCodeLine{4988     diskio::pnm\_skip\_comments(f);}
\DoxyCodeLine{4989     }
\DoxyCodeLine{4990     f >> f\_maxval;}
\DoxyCodeLine{4991     f.get();}
\DoxyCodeLine{4992     }
\DoxyCodeLine{4993     \textcolor{keywordflow}{if}( (f\_maxval > 0) \&\& (f\_maxval <= 65535) )}
\DoxyCodeLine{4994       \{}
\DoxyCodeLine{4995       x.set\_size(3);}
\DoxyCodeLine{4996       \mbox{\hyperlink{classMat}{Mat<eT>}}\& R = x(0);}
\DoxyCodeLine{4997       \mbox{\hyperlink{classMat}{Mat<eT>}}\& G = x(1);}
\DoxyCodeLine{4998       \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structB}{B}} = x(2);}
\DoxyCodeLine{4999       }
\DoxyCodeLine{5000       \textcolor{keywordflow}{try} \{ R.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(f\_n\_rows,f\_n\_cols); \} \textcolor{keywordflow}{catch}(...) \{ err\_msg = \textcolor{stringliteral}{"{}not enough memory"{}}; \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{5001       \textcolor{keywordflow}{try} \{ G.\mbox{\hyperlink{group__Mat_ga750c2d7d0bd0cf7b88e17a24db252438}{set\_size}}(f\_n\_rows,f\_n\_cols); \} \textcolor{keywordflow}{catch}(...) \{ err\_msg = \textcolor{stringliteral}{"{}not enough memory"{}}; \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{5002       \textcolor{keywordflow}{try} \{ \mbox{\hyperlink{structB}{B}}.set\_size(f\_n\_rows,f\_n\_cols); \} \textcolor{keywordflow}{catch}(...) \{ err\_msg = \textcolor{stringliteral}{"{}not enough memory"{}}; \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{5003       }
\DoxyCodeLine{5004       \textcolor{keywordflow}{if}(f\_maxval <= 255)}
\DoxyCodeLine{5005         \{}
\DoxyCodeLine{5006         \textcolor{keyword}{const} uword n\_elem = 3*f\_n\_cols*f\_n\_rows;}
\DoxyCodeLine{5007         \mbox{\hyperlink{classpodarray}{podarray<u8>}} tmp(n\_elem);}
\DoxyCodeLine{5008         }
\DoxyCodeLine{5009         f.read( \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(tmp.\mbox{\hyperlink{group__Cube_ga5b00237224a8e3bfb05728de7c962f85}{memptr}}()), std::streamsize(n\_elem) );}
\DoxyCodeLine{5010         }
\DoxyCodeLine{5011         uword i = 0;}
\DoxyCodeLine{5012         }
\DoxyCodeLine{5013         \textcolor{comment}{//cout << "{}f\_n\_cols = "{} << f\_n\_cols << endl;}}
\DoxyCodeLine{5014         \textcolor{comment}{//cout << "{}f\_n\_rows = "{} << f\_n\_rows << endl;}}
\DoxyCodeLine{5015         }
\DoxyCodeLine{5016         }
\DoxyCodeLine{5017         \textcolor{keywordflow}{for}(uword row=0; row < f\_n\_rows; ++row)}
\DoxyCodeLine{5018           \{}
\DoxyCodeLine{5019           \textcolor{keywordflow}{for}(uword col=0; col < f\_n\_cols; ++col)}
\DoxyCodeLine{5020             \{}
\DoxyCodeLine{5021             R.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(row,col) = eT(tmp[i+0]);}
\DoxyCodeLine{5022             G.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(row,col) = eT(tmp[i+1]);}
\DoxyCodeLine{5023             \mbox{\hyperlink{structB}{B}}.at(row,col) = eT(tmp[i+2]);}
\DoxyCodeLine{5024             i+=3;}
\DoxyCodeLine{5025             \}}
\DoxyCodeLine{5026           }
\DoxyCodeLine{5027           \}}
\DoxyCodeLine{5028         \}}
\DoxyCodeLine{5029       \textcolor{keywordflow}{else}}
\DoxyCodeLine{5030         \{}
\DoxyCodeLine{5031         \textcolor{keyword}{const} uword n\_elem = 3*f\_n\_cols*f\_n\_rows;}
\DoxyCodeLine{5032         \mbox{\hyperlink{classpodarray}{podarray<u16>}} tmp(n\_elem);}
\DoxyCodeLine{5033         }
\DoxyCodeLine{5034         f.read( \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char} *\textcolor{keyword}{>}(tmp.\mbox{\hyperlink{group__Cube_ga5b00237224a8e3bfb05728de7c962f85}{memptr}}()), std::streamsize(2*n\_elem) );}
\DoxyCodeLine{5035         }
\DoxyCodeLine{5036         uword i = 0;}
\DoxyCodeLine{5037         }
\DoxyCodeLine{5038         \textcolor{keywordflow}{for}(uword row=0; row < f\_n\_rows; ++row)}
\DoxyCodeLine{5039         \textcolor{keywordflow}{for}(uword col=0; col < f\_n\_cols; ++col)}
\DoxyCodeLine{5040           \{}
\DoxyCodeLine{5041           R.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(row,col) = eT(tmp[i+0]);}
\DoxyCodeLine{5042           G.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(row,col) = eT(tmp[i+1]);}
\DoxyCodeLine{5043           \mbox{\hyperlink{structB}{B}}.at(row,col) = eT(tmp[i+2]);}
\DoxyCodeLine{5044           i+=3;}
\DoxyCodeLine{5045           \}}
\DoxyCodeLine{5046         \}}
\DoxyCodeLine{5047       \}}
\DoxyCodeLine{5048     \textcolor{keywordflow}{else}}
\DoxyCodeLine{5049       \{}
\DoxyCodeLine{5050       load\_okay = \textcolor{keyword}{false};}
\DoxyCodeLine{5051       err\_msg = \textcolor{stringliteral}{"{}functionality unimplemented"{}};}
\DoxyCodeLine{5052       \}}
\DoxyCodeLine{5053     }
\DoxyCodeLine{5054     \textcolor{keywordflow}{if}(f.good() == \textcolor{keyword}{false})  \{ load\_okay = \textcolor{keyword}{false}; \}}
\DoxyCodeLine{5055     \}}
\DoxyCodeLine{5056   \textcolor{keywordflow}{else}}
\DoxyCodeLine{5057     \{}
\DoxyCodeLine{5058     load\_okay = \textcolor{keyword}{false};}
\DoxyCodeLine{5059     err\_msg = \textcolor{stringliteral}{"{}unsupported header"{}};}
\DoxyCodeLine{5060     \}}
\DoxyCodeLine{5061   }
\DoxyCodeLine{5062   \textcolor{keywordflow}{return} load\_okay;}
\DoxyCodeLine{5063   \}}
\DoxyCodeLine{5064 }
\DoxyCodeLine{5065 }
\DoxyCodeLine{5066 }
\DoxyCodeLine{5067 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{5068 \textcolor{keyword}{inline}}
\DoxyCodeLine{5069 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{5070 diskio::save\_ppm\_binary(\textcolor{keyword}{const} \mbox{\hyperlink{classfield}{field<T1>}}\& x, \textcolor{keyword}{const} std::string\& final\_name)}
\DoxyCodeLine{5071   \{}
\DoxyCodeLine{5072   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{5073   }
\DoxyCodeLine{5074   \textcolor{keyword}{const} std::string tmp\_name = \mbox{\hyperlink{group__diskio_gad32fa08afe53746650c31071f88eacab}{diskio::gen\_tmp\_name}}(final\_name);}
\DoxyCodeLine{5075   std::ofstream f( tmp\_name.c\_str(), std::fstream::binary );}
\DoxyCodeLine{5076   }
\DoxyCodeLine{5077   \textcolor{keywordtype}{bool} save\_okay = f.is\_open();}
\DoxyCodeLine{5078   }
\DoxyCodeLine{5079   \textcolor{keywordflow}{if}(save\_okay)}
\DoxyCodeLine{5080     \{}
\DoxyCodeLine{5081     save\_okay = diskio::save\_ppm\_binary(x, f);}
\DoxyCodeLine{5082     }
\DoxyCodeLine{5083     f.flush();}
\DoxyCodeLine{5084     f.close();}
\DoxyCodeLine{5085     }
\DoxyCodeLine{5086     \textcolor{keywordflow}{if}(save\_okay)  \{ save\_okay = \mbox{\hyperlink{group__diskio_gafbccd611e1fec1b6044f81460415d8d3}{diskio::safe\_rename}}(tmp\_name, final\_name); \}}
\DoxyCodeLine{5087     \}}
\DoxyCodeLine{5088   }
\DoxyCodeLine{5089   \textcolor{keywordflow}{return} save\_okay;}
\DoxyCodeLine{5090   \}}
\DoxyCodeLine{5091 }
\DoxyCodeLine{5092 }
\DoxyCodeLine{5093 }
\DoxyCodeLine{5094 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1>}
\DoxyCodeLine{5095 \textcolor{keyword}{inline}}
\DoxyCodeLine{5096 \textcolor{keywordtype}{bool}}
\DoxyCodeLine{5097 diskio::save\_ppm\_binary(\textcolor{keyword}{const} \mbox{\hyperlink{classfield}{field<T1>}}\& x, std::ostream\& f)}
\DoxyCodeLine{5098   \{}
\DoxyCodeLine{5099   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{5100   }
\DoxyCodeLine{5101   arma\_type\_check(( \mbox{\hyperlink{structis__Mat}{is\_Mat<T1>::value}} == \textcolor{keyword}{false} ));}
\DoxyCodeLine{5102   }
\DoxyCodeLine{5103   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T1::elem\_type eT;}
\DoxyCodeLine{5104   }
\DoxyCodeLine{5105   arma\_debug\_check( (x.n\_elem != 3), \textcolor{stringliteral}{"{}diskio::save\_ppm\_binary(): given field must have exactly 3 matrices of equal size"{}} );}
\DoxyCodeLine{5106   }
\DoxyCodeLine{5107   \textcolor{keywordtype}{bool} \mbox{\hyperlink{structsame__size}{same\_size}} = \textcolor{keyword}{true};}
\DoxyCodeLine{5108   \textcolor{keywordflow}{for}(uword i=1; i<3; ++i)}
\DoxyCodeLine{5109     \{}
\DoxyCodeLine{5110     \textcolor{keywordflow}{if}( (x(0).n\_rows != x(i).n\_rows) || (x(0).n\_cols != x(i).n\_cols) )}
\DoxyCodeLine{5111       \{}
\DoxyCodeLine{5112       \mbox{\hyperlink{structsame__size}{same\_size}} = \textcolor{keyword}{false};}
\DoxyCodeLine{5113       \textcolor{keywordflow}{break};}
\DoxyCodeLine{5114       \}}
\DoxyCodeLine{5115     \}}
\DoxyCodeLine{5116   }
\DoxyCodeLine{5117   arma\_debug\_check( (\mbox{\hyperlink{structsame__size}{same\_size}} != \textcolor{keyword}{true}), \textcolor{stringliteral}{"{}diskio::save\_ppm\_binary(): given field must have exactly 3 matrices of equal size"{}} );}
\DoxyCodeLine{5118   }
\DoxyCodeLine{5119   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& R = x(0);}
\DoxyCodeLine{5120   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& G = x(1);}
\DoxyCodeLine{5121   \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structB}{B}} = x(2);}
\DoxyCodeLine{5122   }
\DoxyCodeLine{5123   f << \textcolor{stringliteral}{"{}P6"{}} << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{5124   f << R.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}} << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{5125   f << R.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}} << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{5126   f << 255 << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{5127 }
\DoxyCodeLine{5128   \textcolor{keyword}{const} uword n\_elem = 3 * R.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}} * R.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}};}
\DoxyCodeLine{5129   \mbox{\hyperlink{classpodarray}{podarray<u8>}} tmp(n\_elem);}
\DoxyCodeLine{5130 }
\DoxyCodeLine{5131   uword i = 0;}
\DoxyCodeLine{5132   \textcolor{keywordflow}{for}(uword row=0; row < R.\mbox{\hyperlink{classMat_a751755caeae1d831a1c27049740e7360}{n\_rows}}; ++row)}
\DoxyCodeLine{5133   \textcolor{keywordflow}{for}(uword col=0; col < R.\mbox{\hyperlink{classMat_ae4f28b81d1d7ace8ae86d0787f2fd367}{n\_cols}}; ++col)}
\DoxyCodeLine{5134     \{}
\DoxyCodeLine{5135     tmp[i+0] = u8( \mbox{\hyperlink{classaccess_a9687cee4d2be0fe591998d6f5c6d0849}{access::tmp\_real}}( R.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(row,col) ) );}
\DoxyCodeLine{5136     tmp[i+1] = u8( \mbox{\hyperlink{classaccess_a9687cee4d2be0fe591998d6f5c6d0849}{access::tmp\_real}}( G.\mbox{\hyperlink{group__Mat_ga62c874c45807d7853afd231ae9f512d7}{at}}(row,col) ) );}
\DoxyCodeLine{5137     tmp[i+2] = u8( \mbox{\hyperlink{classaccess_a9687cee4d2be0fe591998d6f5c6d0849}{access::tmp\_real}}( \mbox{\hyperlink{structB}{B}}.at(row,col) ) );}
\DoxyCodeLine{5138     }
\DoxyCodeLine{5139     i+=3;}
\DoxyCodeLine{5140     \}}
\DoxyCodeLine{5141   }
\DoxyCodeLine{5142   f.write( \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(tmp.\mbox{\hyperlink{classCube_a5d762740f29569b8493d2d6372dc908d}{mem}}), std::streamsize(n\_elem) );}
\DoxyCodeLine{5143   }
\DoxyCodeLine{5144   \textcolor{keywordflow}{return} f.good();}
\DoxyCodeLine{5145   \}}
\DoxyCodeLine{5146 }
\DoxyCodeLine{5147 }
\DoxyCodeLine{5148 }
\DoxyCodeLine{5150 }

\end{DoxyCode}
