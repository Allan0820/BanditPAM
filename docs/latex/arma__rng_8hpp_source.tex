\hypertarget{arma__rng_8hpp_source}{}\doxysection{arma\+\_\+rng.\+hpp}
\label{arma__rng_8hpp_source}\index{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/arma\_rng.hpp@{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/arma\_rng.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008-\/2016 Conrad Sanderson (http://conradsanderson.id.au)}}
\DoxyCodeLine{2 \textcolor{comment}{// Copyright 2008-\/2016 National ICT Australia (NICTA)}}
\DoxyCodeLine{3 \textcolor{comment}{// }}
\DoxyCodeLine{4 \textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{5 \textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{6 \textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{7 \textcolor{comment}{// http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{8 \textcolor{comment}{// }}
\DoxyCodeLine{9 \textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{10 \textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{11 \textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{12 \textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{13 \textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{14 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{19 }
\DoxyCodeLine{20 }
\DoxyCodeLine{21 \textcolor{preprocessor}{\#if defined(ARMA\_RNG\_ALT)}}
\DoxyCodeLine{22 \textcolor{preprocessor}{  \#undef ARMA\_USE\_EXTERN\_RNG}}
\DoxyCodeLine{23 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{24 }
\DoxyCodeLine{25 }
\DoxyCodeLine{26 \textcolor{comment}{// NOTE: mt19937\_64\_instance\_warmup is used as a workaround}}
\DoxyCodeLine{27 \textcolor{comment}{// NOTE: for thread\_local issue on macOS 11 and/or AppleClang 12.0}}
\DoxyCodeLine{28 \textcolor{comment}{// NOTE: see https://gitlab.com/conradsnicta/armadillo-\/code/-\//issues/173}}
\DoxyCodeLine{29 \textcolor{comment}{// NOTE: if this workaround causes problems, please report it and }}
\DoxyCodeLine{30 \textcolor{comment}{// NOTE: disable the workaround by uncommenting the code block below:}}
\DoxyCodeLine{31 }
\DoxyCodeLine{32 \textcolor{comment}{// \#if defined(\_\_APPLE\_\_) || defined(\_\_apple\_build\_version\_\_)}}
\DoxyCodeLine{33 \textcolor{comment}{//   \#if !defined(ARMA\_DONT\_DISABLE\_EXTERN\_RNG)}}
\DoxyCodeLine{34 \textcolor{comment}{//     \#undef ARMA\_USE\_EXTERN\_RNG}}
\DoxyCodeLine{35 \textcolor{comment}{//   \#endif}}
\DoxyCodeLine{36 \textcolor{comment}{// \#endif}}
\DoxyCodeLine{37 }
\DoxyCodeLine{38 }
\DoxyCodeLine{39 \textcolor{comment}{// NOTE: workaround for another thread\_local issue on macOS}}
\DoxyCodeLine{40 \textcolor{comment}{// NOTE: where GCC (not Clang) may not have support for thread\_local}}
\DoxyCodeLine{41 }
\DoxyCodeLine{42 \textcolor{preprocessor}{\#if (defined(\_\_APPLE\_\_) \&\& defined(\_\_GNUG\_\_) \&\& !defined(\_\_clang\_\_))}}
\DoxyCodeLine{43 \textcolor{preprocessor}{  \#if !defined(ARMA\_DONT\_DISABLE\_EXTERN\_RNG)}}
\DoxyCodeLine{44 \textcolor{preprocessor}{    \#undef ARMA\_USE\_EXTERN\_RNG}}
\DoxyCodeLine{45 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{46 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{47 }
\DoxyCodeLine{48 }
\DoxyCodeLine{49 }
\DoxyCodeLine{50 \textcolor{preprocessor}{\#if defined(ARMA\_USE\_EXTERN\_RNG)}}
\DoxyCodeLine{51   \textcolor{keyword}{extern} \textcolor{keyword}{thread\_local} std::mt19937\_64 mt19937\_64\_instance;}
\DoxyCodeLine{52   }
\DoxyCodeLine{53 \textcolor{preprocessor}{  \#if defined(\_\_APPLE\_\_) || defined(\_\_apple\_build\_version\_\_)}}
\DoxyCodeLine{54     \textcolor{keyword}{namespace}}
\DoxyCodeLine{55       \{}
\DoxyCodeLine{56       \textcolor{keyword}{struct }mt19937\_64\_instance\_warmup}
\DoxyCodeLine{57         \{}
\DoxyCodeLine{58         \textcolor{keyword}{inline} mt19937\_64\_instance\_warmup()}
\DoxyCodeLine{59           \{}
\DoxyCodeLine{60           \textcolor{keyword}{typename} std::mt19937\_64::result\_type junk = mt19937\_64\_instance();}
\DoxyCodeLine{61           arma\_ignore(junk);}
\DoxyCodeLine{62           \}}
\DoxyCodeLine{63         \};}
\DoxyCodeLine{64       }
\DoxyCodeLine{65       \textcolor{keyword}{static} mt19937\_64\_instance\_warmup mt19937\_64\_instance\_warmup\_run;}
\DoxyCodeLine{66       \}}
\DoxyCodeLine{67 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{68 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{69 }
\DoxyCodeLine{70 }
\DoxyCodeLine{71 }
\DoxyCodeLine{72 \textcolor{keyword}{class }\mbox{\hyperlink{classarma__rng}{arma\_rng}}}
\DoxyCodeLine{73   \{}
\DoxyCodeLine{74   \textcolor{keyword}{public}:}
\DoxyCodeLine{75   }
\DoxyCodeLine{76 \textcolor{preprocessor}{  \#if   defined(ARMA\_RNG\_ALT)}}
\DoxyCodeLine{77     \textcolor{keyword}{typedef} arma\_rng\_alt::seed\_type      seed\_type;}
\DoxyCodeLine{78 \textcolor{preprocessor}{  \#elif defined(ARMA\_USE\_EXTERN\_RNG)}}
\DoxyCodeLine{79     \textcolor{keyword}{typedef} std::mt19937\_64::result\_type seed\_type;}
\DoxyCodeLine{80 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{81     \textcolor{keyword}{typedef} arma\_rng\_cxx98::seed\_type    seed\_type;}
\DoxyCodeLine{82 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{83   }
\DoxyCodeLine{84 \textcolor{preprocessor}{  \#if   defined(ARMA\_RNG\_ALT)}}
\DoxyCodeLine{85     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} rng\_method = 2;}
\DoxyCodeLine{86 \textcolor{preprocessor}{  \#elif defined(ARMA\_USE\_EXTERN\_RNG)}}
\DoxyCodeLine{87     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} rng\_method = 1;}
\DoxyCodeLine{88 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{89     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} rng\_method = 0;}
\DoxyCodeLine{90 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{91   }
\DoxyCodeLine{92   \textcolor{keyword}{inline} \textcolor{keyword}{static} \textcolor{keywordtype}{void} set\_seed(\textcolor{keyword}{const} seed\_type val);}
\DoxyCodeLine{93   \textcolor{keyword}{inline} \textcolor{keyword}{static} \textcolor{keywordtype}{void} set\_seed\_random();}
\DoxyCodeLine{94   }
\DoxyCodeLine{95   \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT> \textcolor{keyword}{struct }\mbox{\hyperlink{structarma__rng_1_1randi}{randi}};}
\DoxyCodeLine{96   \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT> \textcolor{keyword}{struct }\mbox{\hyperlink{structarma__rng_1_1randu}{randu}};}
\DoxyCodeLine{97   \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT> \textcolor{keyword}{struct }\mbox{\hyperlink{structarma__rng_1_1randn}{randn}};}
\DoxyCodeLine{98   \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT> \textcolor{keyword}{struct }\mbox{\hyperlink{structarma__rng_1_1randg}{randg}};}
\DoxyCodeLine{99   \};}
\DoxyCodeLine{100 }
\DoxyCodeLine{101 }
\DoxyCodeLine{102 }
\DoxyCodeLine{103 \textcolor{keyword}{inline}}
\DoxyCodeLine{104 \textcolor{keywordtype}{void}}
\DoxyCodeLine{105 arma\_rng::set\_seed(\textcolor{keyword}{const} arma\_rng::seed\_type val)}
\DoxyCodeLine{106   \{}
\DoxyCodeLine{107 \textcolor{preprocessor}{  \#if   defined(ARMA\_RNG\_ALT)}}
\DoxyCodeLine{108     \{}
\DoxyCodeLine{109     arma\_rng\_alt::set\_seed(val);}
\DoxyCodeLine{110     \}}
\DoxyCodeLine{111 \textcolor{preprocessor}{  \#elif defined(ARMA\_USE\_EXTERN\_RNG)}}
\DoxyCodeLine{112     \{}
\DoxyCodeLine{113     mt19937\_64\_instance.seed(val);}
\DoxyCodeLine{114     \}}
\DoxyCodeLine{115 \textcolor{preprocessor}{  \#else}}
\DoxyCodeLine{116     \{}
\DoxyCodeLine{117     arma\_rng\_cxx98::set\_seed(val);}
\DoxyCodeLine{118     \}}
\DoxyCodeLine{119 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{120   \}}
\DoxyCodeLine{121 }
\DoxyCodeLine{122 }
\DoxyCodeLine{123 }
\DoxyCodeLine{124 arma\_cold}
\DoxyCodeLine{125 \textcolor{keyword}{inline}}
\DoxyCodeLine{126 \textcolor{keywordtype}{void}}
\DoxyCodeLine{127 arma\_rng::set\_seed\_random()}
\DoxyCodeLine{128   \{}
\DoxyCodeLine{129   seed\_type seed1 = seed\_type(0);}
\DoxyCodeLine{130   seed\_type seed2 = seed\_type(0);}
\DoxyCodeLine{131   seed\_type seed3 = seed\_type(0);}
\DoxyCodeLine{132   seed\_type seed4 = seed\_type(0);}
\DoxyCodeLine{133   }
\DoxyCodeLine{134   \textcolor{keywordtype}{bool} have\_seed = \textcolor{keyword}{false};}
\DoxyCodeLine{135   }
\DoxyCodeLine{136   \textcolor{keywordflow}{try}}
\DoxyCodeLine{137     \{}
\DoxyCodeLine{138     std::random\_device rd;}
\DoxyCodeLine{139     }
\DoxyCodeLine{140     \textcolor{keywordflow}{if}(rd.entropy() > \textcolor{keywordtype}{double}(0))  \{ seed1 = \textcolor{keyword}{static\_cast<}seed\_type\textcolor{keyword}{>}( rd() ); \}}
\DoxyCodeLine{141     }
\DoxyCodeLine{142     \textcolor{keywordflow}{if}(seed1 != seed\_type(0))  \{ have\_seed = \textcolor{keyword}{true}; \}}
\DoxyCodeLine{143     \}}
\DoxyCodeLine{144   \textcolor{keywordflow}{catch}(...) \{\}}
\DoxyCodeLine{145   }
\DoxyCodeLine{146   }
\DoxyCodeLine{147   \textcolor{keywordflow}{if}(have\_seed == \textcolor{keyword}{false})}
\DoxyCodeLine{148     \{}
\DoxyCodeLine{149     \textcolor{keywordflow}{try}}
\DoxyCodeLine{150       \{}
\DoxyCodeLine{151       \textcolor{keyword}{union}}
\DoxyCodeLine{152         \{}
\DoxyCodeLine{153         seed\_type     a;}
\DoxyCodeLine{154         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} b[\textcolor{keyword}{sizeof}(seed\_type)];}
\DoxyCodeLine{155         \} tmp;}
\DoxyCodeLine{156       }
\DoxyCodeLine{157       tmp.a = seed\_type(0);}
\DoxyCodeLine{158       }
\DoxyCodeLine{159       std::ifstream f(\textcolor{stringliteral}{"{}/dev/urandom"{}}, std::ifstream::binary);}
\DoxyCodeLine{160       }
\DoxyCodeLine{161       \textcolor{keywordflow}{if}(f.good())  \{ f.read((\textcolor{keywordtype}{char}*)(\&(tmp.b[0])), \textcolor{keyword}{sizeof}(seed\_type)); \}}
\DoxyCodeLine{162       }
\DoxyCodeLine{163       \textcolor{keywordflow}{if}(f.good())}
\DoxyCodeLine{164         \{}
\DoxyCodeLine{165         seed2 = tmp.a;}
\DoxyCodeLine{166         }
\DoxyCodeLine{167         \textcolor{keywordflow}{if}(seed2 != seed\_type(0))  \{ have\_seed = \textcolor{keyword}{true}; \}}
\DoxyCodeLine{168         \}}
\DoxyCodeLine{169       \}}
\DoxyCodeLine{170     \textcolor{keywordflow}{catch}(...) \{\}}
\DoxyCodeLine{171     \}}
\DoxyCodeLine{172   }
\DoxyCodeLine{173   }
\DoxyCodeLine{174   \textcolor{keywordflow}{if}(have\_seed == \textcolor{keyword}{false})}
\DoxyCodeLine{175     \{}
\DoxyCodeLine{176     \textcolor{comment}{// get better-\/than-\/nothing seeds in case reading /dev/urandom failed }}
\DoxyCodeLine{177     }
\DoxyCodeLine{178     \textcolor{keyword}{const} std::chrono::system\_clock::time\_point tp\_now = std::chrono::system\_clock::now();}
\DoxyCodeLine{179     }
\DoxyCodeLine{180     \textcolor{keyword}{auto} since\_epoch\_usec = std::chrono::duration\_cast<std::chrono::microseconds>(tp\_now.time\_since\_epoch()).count();}
\DoxyCodeLine{181     }
\DoxyCodeLine{182     seed3 = \textcolor{keyword}{static\_cast<}seed\_type\textcolor{keyword}{>}( since\_epoch\_usec \& 0xFFFF );}
\DoxyCodeLine{183     }
\DoxyCodeLine{184     \textcolor{keyword}{union}}
\DoxyCodeLine{185       \{}
\DoxyCodeLine{186       uword*        a;}
\DoxyCodeLine{187       \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} b[\textcolor{keyword}{sizeof}(uword*)];}
\DoxyCodeLine{188       \} tmp;}
\DoxyCodeLine{189     }
\DoxyCodeLine{190     tmp.a = (uword*)malloc(\textcolor{keyword}{sizeof}(uword));}
\DoxyCodeLine{191     }
\DoxyCodeLine{192     \textcolor{keywordflow}{if}(tmp.a != \textcolor{keyword}{nullptr})}
\DoxyCodeLine{193       \{}
\DoxyCodeLine{194       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i=0; i<\textcolor{keyword}{sizeof}(uword*); ++i)  \{ seed4 += seed\_type(tmp.b[i]); \}}
\DoxyCodeLine{195       }
\DoxyCodeLine{196       free(tmp.a);}
\DoxyCodeLine{197       \}}
\DoxyCodeLine{198     \}}
\DoxyCodeLine{199   }
\DoxyCodeLine{200   arma\_rng::set\_seed( seed1 + seed2 + seed3 + seed4 );}
\DoxyCodeLine{201   \}}
\DoxyCodeLine{202 }
\DoxyCodeLine{203 }
\DoxyCodeLine{204 }
\DoxyCodeLine{205 \textcolor{comment}{//}}
\DoxyCodeLine{206 }
\DoxyCodeLine{207 }
\DoxyCodeLine{208 }
\DoxyCodeLine{209 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{210 \textcolor{keyword}{struct }\mbox{\hyperlink{structarma__rng_1_1randi}{arma\_rng::randi}}}
\DoxyCodeLine{211   \{}
\DoxyCodeLine{212   \textcolor{keyword}{inline}}
\DoxyCodeLine{213   \textcolor{keyword}{operator} eT ()}
\DoxyCodeLine{214     \{}
\DoxyCodeLine{215 \textcolor{preprocessor}{    \#if   defined(ARMA\_RNG\_ALT)}}
\DoxyCodeLine{216       \{}
\DoxyCodeLine{217       \textcolor{keywordflow}{return} eT( arma\_rng\_alt::randi\_val() );}
\DoxyCodeLine{218       \}}
\DoxyCodeLine{219 \textcolor{preprocessor}{    \#elif defined(ARMA\_USE\_EXTERN\_RNG)}}
\DoxyCodeLine{220       \{}
\DoxyCodeLine{221       \textcolor{keyword}{constexpr} \textcolor{keywordtype}{double} scale = double(\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::numeric\_limits<int>::max}}()) / double(\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::mt19937\_64::max}}());}
\DoxyCodeLine{222       }
\DoxyCodeLine{223       \textcolor{keywordflow}{return} eT( \textcolor{keywordtype}{double}(mt19937\_64\_instance()) * scale );}
\DoxyCodeLine{224       \}}
\DoxyCodeLine{225 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{226       \{}
\DoxyCodeLine{227       \textcolor{keywordflow}{return} eT( arma\_rng\_cxx98::randi\_val() );}
\DoxyCodeLine{228       \}}
\DoxyCodeLine{229 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{230     \}}
\DoxyCodeLine{231   }
\DoxyCodeLine{232   }
\DoxyCodeLine{233   \textcolor{keyword}{inline}}
\DoxyCodeLine{234   \textcolor{keyword}{static}}
\DoxyCodeLine{235   \textcolor{keywordtype}{int}}
\DoxyCodeLine{236   max\_val()}
\DoxyCodeLine{237     \{}
\DoxyCodeLine{238 \textcolor{preprocessor}{    \#if   defined(ARMA\_RNG\_ALT)}}
\DoxyCodeLine{239       \{}
\DoxyCodeLine{240       \textcolor{keywordflow}{return} arma\_rng\_alt::randi\_max\_val();}
\DoxyCodeLine{241       \}}
\DoxyCodeLine{242 \textcolor{preprocessor}{    \#elif defined(ARMA\_USE\_EXTERN\_RNG)}}
\DoxyCodeLine{243       \{}
\DoxyCodeLine{244       \textcolor{keywordflow}{return} \mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::numeric\_limits<int>::max}}();}
\DoxyCodeLine{245       \}}
\DoxyCodeLine{246 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{247       \{}
\DoxyCodeLine{248       \textcolor{keywordflow}{return} arma\_rng\_cxx98::randi\_max\_val();}
\DoxyCodeLine{249       \}}
\DoxyCodeLine{250 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{251     \}}
\DoxyCodeLine{252   }
\DoxyCodeLine{253   }
\DoxyCodeLine{254   \textcolor{keyword}{inline}}
\DoxyCodeLine{255   \textcolor{keyword}{static}}
\DoxyCodeLine{256   \textcolor{keywordtype}{void}}
\DoxyCodeLine{257   fill(eT* mem, \textcolor{keyword}{const} uword N, \textcolor{keyword}{const} \textcolor{keywordtype}{int} a, \textcolor{keyword}{const} \textcolor{keywordtype}{int} b)}
\DoxyCodeLine{258     \{}
\DoxyCodeLine{259 \textcolor{preprocessor}{    \#if   defined(ARMA\_RNG\_ALT)}}
\DoxyCodeLine{260       \{}
\DoxyCodeLine{261       arma\_rng\_alt::randi\_fill(mem, N, a, b);}
\DoxyCodeLine{262       \}}
\DoxyCodeLine{263 \textcolor{preprocessor}{    \#elif defined(ARMA\_USE\_EXTERN\_RNG)}}
\DoxyCodeLine{264       \{}
\DoxyCodeLine{265       std::uniform\_int\_distribution<int> local\_i\_distr(a, b);}
\DoxyCodeLine{266       }
\DoxyCodeLine{267       \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)  \{ mem[i] = eT(local\_i\_distr(mt19937\_64\_instance)); \}}
\DoxyCodeLine{268       \}}
\DoxyCodeLine{269 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{270       \{}
\DoxyCodeLine{271       \textcolor{keywordflow}{if}(N == uword(1))  \{ arma\_rng\_cxx98::randi\_fill(mem, uword(1), a, b); \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{272       }
\DoxyCodeLine{273       \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::mt19937\_64::result\_type local\_seed\_type;}
\DoxyCodeLine{274       }
\DoxyCodeLine{275       std::mt19937\_64                    local\_engine;}
\DoxyCodeLine{276       std::uniform\_int\_distribution<int> local\_i\_distr(a, b);}
\DoxyCodeLine{277       }
\DoxyCodeLine{278       local\_engine.seed( local\_seed\_type(std::rand()) );}
\DoxyCodeLine{279       }
\DoxyCodeLine{280       \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)  \{ mem[i] = eT(local\_i\_distr(local\_engine)); \}}
\DoxyCodeLine{281       \}}
\DoxyCodeLine{282 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{283     \}}
\DoxyCodeLine{284   \};}
\DoxyCodeLine{285 }
\DoxyCodeLine{286 }
\DoxyCodeLine{287 }
\DoxyCodeLine{288 \textcolor{comment}{//}}
\DoxyCodeLine{289 }
\DoxyCodeLine{290 }
\DoxyCodeLine{291 }
\DoxyCodeLine{292 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{293 \textcolor{keyword}{struct }\mbox{\hyperlink{structarma__rng_1_1randu}{arma\_rng::randu}}}
\DoxyCodeLine{294   \{}
\DoxyCodeLine{295   \textcolor{keyword}{inline}}
\DoxyCodeLine{296   \textcolor{keyword}{operator} eT ()}
\DoxyCodeLine{297     \{}
\DoxyCodeLine{298 \textcolor{preprocessor}{    \#if   defined(ARMA\_RNG\_ALT)}}
\DoxyCodeLine{299       \{}
\DoxyCodeLine{300       \textcolor{keywordflow}{return} eT( arma\_rng\_alt::randu\_val() );}
\DoxyCodeLine{301       \}}
\DoxyCodeLine{302 \textcolor{preprocessor}{    \#elif defined(ARMA\_USE\_EXTERN\_RNG)}}
\DoxyCodeLine{303       \{}
\DoxyCodeLine{304       \textcolor{keyword}{constexpr} \textcolor{keywordtype}{double} scale = double(1.0) / double(\mbox{\hyperlink{group__fn__max_gaf2317ac99c92ae7a239291d01a615893}{std::mt19937\_64::max}}());}
\DoxyCodeLine{305       }
\DoxyCodeLine{306       \textcolor{keywordflow}{return} eT( \textcolor{keywordtype}{double}(mt19937\_64\_instance()) * scale );}
\DoxyCodeLine{307       \}}
\DoxyCodeLine{308 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{309       \{}
\DoxyCodeLine{310       \textcolor{keywordflow}{return} eT( arma\_rng\_cxx98::randu\_val() );}
\DoxyCodeLine{311       \}}
\DoxyCodeLine{312 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{313     \}}
\DoxyCodeLine{314   }
\DoxyCodeLine{315   }
\DoxyCodeLine{316   \textcolor{keyword}{inline}}
\DoxyCodeLine{317   \textcolor{keyword}{static}}
\DoxyCodeLine{318   \textcolor{keywordtype}{void}}
\DoxyCodeLine{319   fill(eT* mem, \textcolor{keyword}{const} uword N)}
\DoxyCodeLine{320     \{}
\DoxyCodeLine{321 \textcolor{preprocessor}{    \#if defined(ARMA\_RNG\_ALT)}}
\DoxyCodeLine{322       \{}
\DoxyCodeLine{323       \textcolor{keywordflow}{for}(uword i=0; i < N; ++i)  \{ mem[i] = eT( arma\_rng\_alt::randu\_val() ); \}}
\DoxyCodeLine{324       \}}
\DoxyCodeLine{325 \textcolor{preprocessor}{    \#elif defined(ARMA\_USE\_EXTERN\_RNG)}}
\DoxyCodeLine{326       \{}
\DoxyCodeLine{327       std::uniform\_real\_distribution<double> local\_u\_distr;}
\DoxyCodeLine{328       }
\DoxyCodeLine{329       \textcolor{keywordflow}{for}(uword i=0; i < N; ++i)  \{ mem[i] = eT( local\_u\_distr(mt19937\_64\_instance) ); \}}
\DoxyCodeLine{330       \}}
\DoxyCodeLine{331 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{332       \{}
\DoxyCodeLine{333       \textcolor{keywordflow}{if}(N == uword(1))  \{ mem[0] = eT( arma\_rng\_cxx98::randu\_val() ); \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{334       }
\DoxyCodeLine{335       \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::mt19937\_64::result\_type local\_seed\_type;}
\DoxyCodeLine{336       }
\DoxyCodeLine{337       std::mt19937\_64                        local\_engine;}
\DoxyCodeLine{338       std::uniform\_real\_distribution<double> local\_u\_distr;}
\DoxyCodeLine{339       }
\DoxyCodeLine{340       local\_engine.seed( local\_seed\_type(std::rand()) );}
\DoxyCodeLine{341       }
\DoxyCodeLine{342       \textcolor{keywordflow}{for}(uword i=0; i < N; ++i)  \{ mem[i] = eT( local\_u\_distr(local\_engine) ); \}}
\DoxyCodeLine{343       \}}
\DoxyCodeLine{344 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{345     \}}
\DoxyCodeLine{346   \};}
\DoxyCodeLine{347 }
\DoxyCodeLine{348 }
\DoxyCodeLine{349 }
\DoxyCodeLine{350 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{351 \textcolor{keyword}{struct }\mbox{\hyperlink{structarma__rng_1_1randu}{arma\_rng::randu}}< std::complex<T> >}
\DoxyCodeLine{352   \{}
\DoxyCodeLine{353   arma\_inline}
\DoxyCodeLine{354   \textcolor{keyword}{operator} std::complex<T> ()}
\DoxyCodeLine{355     \{}
\DoxyCodeLine{356 \textcolor{preprocessor}{    \#if defined(ARMA\_RNG\_ALT)}}
\DoxyCodeLine{357       \{}
\DoxyCodeLine{358       \textcolor{keyword}{const} T a = T( arma\_rng\_alt::randu\_val() );}
\DoxyCodeLine{359       \textcolor{keyword}{const} T b = T( arma\_rng\_alt::randu\_val() );}
\DoxyCodeLine{360       }
\DoxyCodeLine{361       \textcolor{keywordflow}{return} std::complex<T>(a, b);}
\DoxyCodeLine{362       \}}
\DoxyCodeLine{363 \textcolor{preprocessor}{    \#elif defined(ARMA\_USE\_EXTERN\_RNG)}}
\DoxyCodeLine{364       \{}
\DoxyCodeLine{365       std::uniform\_real\_distribution<double> local\_u\_distr;}
\DoxyCodeLine{366       }
\DoxyCodeLine{367       \textcolor{keyword}{const} T a = T( local\_u\_distr(mt19937\_64\_instance) );}
\DoxyCodeLine{368       \textcolor{keyword}{const} T b = T( local\_u\_distr(mt19937\_64\_instance) );}
\DoxyCodeLine{369       }
\DoxyCodeLine{370       \textcolor{keywordflow}{return} std::complex<T>(a, b);}
\DoxyCodeLine{371       \}}
\DoxyCodeLine{372 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{373       \{}
\DoxyCodeLine{374       \textcolor{keyword}{const} T a = T( arma\_rng\_cxx98::randu\_val() );}
\DoxyCodeLine{375       \textcolor{keyword}{const} T b = T( arma\_rng\_cxx98::randu\_val() );}
\DoxyCodeLine{376       }
\DoxyCodeLine{377       \textcolor{keywordflow}{return} std::complex<T>(a, b);}
\DoxyCodeLine{378       \}}
\DoxyCodeLine{379 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{380     \}}
\DoxyCodeLine{381   }
\DoxyCodeLine{382   }
\DoxyCodeLine{383   \textcolor{keyword}{inline}}
\DoxyCodeLine{384   \textcolor{keyword}{static}}
\DoxyCodeLine{385   \textcolor{keywordtype}{void}}
\DoxyCodeLine{386   fill(std::complex<T>* mem, \textcolor{keyword}{const} uword N)}
\DoxyCodeLine{387     \{}
\DoxyCodeLine{388 \textcolor{preprocessor}{    \#if defined(ARMA\_RNG\_ALT)}}
\DoxyCodeLine{389       \{}
\DoxyCodeLine{390       \textcolor{keywordflow}{for}(uword i=0; i < N; ++i)}
\DoxyCodeLine{391         \{}
\DoxyCodeLine{392         \textcolor{keyword}{const} T a = T( arma\_rng\_alt::randu\_val() );}
\DoxyCodeLine{393         \textcolor{keyword}{const} T b = T( arma\_rng\_alt::randu\_val() );}
\DoxyCodeLine{394         }
\DoxyCodeLine{395         mem[i] = std::complex<T>(a, b);}
\DoxyCodeLine{396         \}}
\DoxyCodeLine{397       \}}
\DoxyCodeLine{398 \textcolor{preprocessor}{    \#elif defined(ARMA\_USE\_EXTERN\_RNG)}}
\DoxyCodeLine{399       \{}
\DoxyCodeLine{400       std::uniform\_real\_distribution<double> local\_u\_distr;}
\DoxyCodeLine{401       }
\DoxyCodeLine{402       \textcolor{keywordflow}{for}(uword i=0; i < N; ++i)}
\DoxyCodeLine{403         \{}
\DoxyCodeLine{404         \textcolor{keyword}{const} T a = T( local\_u\_distr(mt19937\_64\_instance) );}
\DoxyCodeLine{405         \textcolor{keyword}{const} T b = T( local\_u\_distr(mt19937\_64\_instance) );}
\DoxyCodeLine{406         }
\DoxyCodeLine{407         mem[i] = std::complex<T>(a, b);}
\DoxyCodeLine{408         \}}
\DoxyCodeLine{409       \}}
\DoxyCodeLine{410 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{411       \{}
\DoxyCodeLine{412       \textcolor{keywordflow}{if}(N == uword(1))}
\DoxyCodeLine{413         \{}
\DoxyCodeLine{414         \textcolor{keyword}{const} T a = T( arma\_rng\_cxx98::randu\_val() );}
\DoxyCodeLine{415         \textcolor{keyword}{const} T b = T( arma\_rng\_cxx98::randu\_val() );}
\DoxyCodeLine{416         }
\DoxyCodeLine{417         mem[0] = std::complex<T>(a, b);}
\DoxyCodeLine{418         }
\DoxyCodeLine{419         \textcolor{keywordflow}{return};}
\DoxyCodeLine{420         \}}
\DoxyCodeLine{421       }
\DoxyCodeLine{422       \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::mt19937\_64::result\_type local\_seed\_type;}
\DoxyCodeLine{423       }
\DoxyCodeLine{424       std::mt19937\_64                        local\_engine;}
\DoxyCodeLine{425       std::uniform\_real\_distribution<double> local\_u\_distr;}
\DoxyCodeLine{426       }
\DoxyCodeLine{427       local\_engine.seed( local\_seed\_type(std::rand()) );}
\DoxyCodeLine{428       }
\DoxyCodeLine{429       \textcolor{keywordflow}{for}(uword i=0; i < N; ++i)}
\DoxyCodeLine{430         \{}
\DoxyCodeLine{431         \textcolor{keyword}{const} T a = T( local\_u\_distr(local\_engine) );}
\DoxyCodeLine{432         \textcolor{keyword}{const} T b = T( local\_u\_distr(local\_engine) );}
\DoxyCodeLine{433         }
\DoxyCodeLine{434         mem[i] = std::complex<T>(a, b);}
\DoxyCodeLine{435         \}}
\DoxyCodeLine{436       \}}
\DoxyCodeLine{437 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{438     \}}
\DoxyCodeLine{439   \};}
\DoxyCodeLine{440 }
\DoxyCodeLine{441 }
\DoxyCodeLine{442 }
\DoxyCodeLine{443 \textcolor{comment}{//}}
\DoxyCodeLine{444 }
\DoxyCodeLine{445 }
\DoxyCodeLine{446 }
\DoxyCodeLine{447 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{448 \textcolor{keyword}{struct }\mbox{\hyperlink{structarma__rng_1_1randn}{arma\_rng::randn}}}
\DoxyCodeLine{449   \{}
\DoxyCodeLine{450   \textcolor{keyword}{inline}}
\DoxyCodeLine{451   \textcolor{keyword}{operator} eT ()\textcolor{keyword}{ const}}
\DoxyCodeLine{452 \textcolor{keyword}{    }\{}
\DoxyCodeLine{453 \textcolor{preprocessor}{    \#if   defined(ARMA\_RNG\_ALT)}}
\DoxyCodeLine{454       \{}
\DoxyCodeLine{455       \textcolor{keywordflow}{return} eT( arma\_rng\_alt::randn\_val() );}
\DoxyCodeLine{456       \}}
\DoxyCodeLine{457 \textcolor{preprocessor}{    \#elif defined(ARMA\_USE\_EXTERN\_RNG)}}
\DoxyCodeLine{458       \{}
\DoxyCodeLine{459       std::normal\_distribution<double> local\_n\_distr;}
\DoxyCodeLine{460       }
\DoxyCodeLine{461       \textcolor{keywordflow}{return} eT( local\_n\_distr(mt19937\_64\_instance) );}
\DoxyCodeLine{462       \}}
\DoxyCodeLine{463 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{464       \{}
\DoxyCodeLine{465       \textcolor{keywordflow}{return} eT( arma\_rng\_cxx98::randn\_val() );}
\DoxyCodeLine{466       \}}
\DoxyCodeLine{467 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{468     \}}
\DoxyCodeLine{469   }
\DoxyCodeLine{470   }
\DoxyCodeLine{471   \textcolor{keyword}{inline}}
\DoxyCodeLine{472   \textcolor{keyword}{static}}
\DoxyCodeLine{473   \textcolor{keywordtype}{void}}
\DoxyCodeLine{474   dual\_val(eT\& out1, eT\& out2)}
\DoxyCodeLine{475     \{}
\DoxyCodeLine{476 \textcolor{preprocessor}{    \#if   defined(ARMA\_RNG\_ALT)}}
\DoxyCodeLine{477       \{}
\DoxyCodeLine{478       arma\_rng\_alt::randn\_dual\_val(out1, out2);}
\DoxyCodeLine{479       \}}
\DoxyCodeLine{480 \textcolor{preprocessor}{    \#elif defined(ARMA\_USE\_EXTERN\_RNG)}}
\DoxyCodeLine{481       \{}
\DoxyCodeLine{482       std::normal\_distribution<double> local\_n\_distr;}
\DoxyCodeLine{483       }
\DoxyCodeLine{484       out1 = eT( local\_n\_distr(mt19937\_64\_instance) );}
\DoxyCodeLine{485       out2 = eT( local\_n\_distr(mt19937\_64\_instance) );}
\DoxyCodeLine{486       \}}
\DoxyCodeLine{487 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{488       \{}
\DoxyCodeLine{489       arma\_rng\_cxx98::randn\_dual\_val(out1, out2);}
\DoxyCodeLine{490       \}}
\DoxyCodeLine{491 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{492     \}}
\DoxyCodeLine{493   }
\DoxyCodeLine{494   }
\DoxyCodeLine{495   \textcolor{keyword}{inline}}
\DoxyCodeLine{496   \textcolor{keyword}{static}}
\DoxyCodeLine{497   \textcolor{keywordtype}{void}}
\DoxyCodeLine{498   fill\_simple(eT* mem, \textcolor{keyword}{const} uword N)}
\DoxyCodeLine{499     \{}
\DoxyCodeLine{500 \textcolor{preprocessor}{    \#if defined(ARMA\_RNG\_ALT)}}
\DoxyCodeLine{501       \{}
\DoxyCodeLine{502       \textcolor{comment}{// NOTE: old method to avoid regressions in user code that assumes specific sequence}}
\DoxyCodeLine{503       }
\DoxyCodeLine{504       uword i, j;}
\DoxyCodeLine{505       }
\DoxyCodeLine{506       \textcolor{keywordflow}{for}(i=0, j=1; j < N; i+=2, j+=2)  \{ arma\_rng\_alt::randn\_dual\_val( mem[i], mem[j] ); \}}
\DoxyCodeLine{507       }
\DoxyCodeLine{508       \textcolor{keywordflow}{if}(i < N)  \{ mem[i] = eT( arma\_rng\_alt::randn\_val() ); \}}
\DoxyCodeLine{509       \}}
\DoxyCodeLine{510 \textcolor{preprocessor}{    \#elif defined(ARMA\_USE\_EXTERN\_RNG)}}
\DoxyCodeLine{511       \{}
\DoxyCodeLine{512       std::normal\_distribution<double> local\_n\_distr;}
\DoxyCodeLine{513       }
\DoxyCodeLine{514       \textcolor{keywordflow}{for}(uword i=0; i < N; ++i)  \{ mem[i] = eT( local\_n\_distr(mt19937\_64\_instance) ); \}}
\DoxyCodeLine{515       \}}
\DoxyCodeLine{516 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{517       \{}
\DoxyCodeLine{518       \textcolor{keywordflow}{if}(N == uword(1))  \{ mem[0] = eT( arma\_rng\_cxx98::randn\_val() ); \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{519       }
\DoxyCodeLine{520       \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::mt19937\_64::result\_type local\_seed\_type;}
\DoxyCodeLine{521       }
\DoxyCodeLine{522       std::mt19937\_64                  local\_engine;}
\DoxyCodeLine{523       std::normal\_distribution<double> local\_n\_distr;}
\DoxyCodeLine{524       }
\DoxyCodeLine{525       local\_engine.seed( local\_seed\_type(std::rand()) );}
\DoxyCodeLine{526       }
\DoxyCodeLine{527       \textcolor{keywordflow}{for}(uword i=0; i < N; ++i)  \{ mem[i] = eT( local\_n\_distr(local\_engine) ); \}}
\DoxyCodeLine{528       \}}
\DoxyCodeLine{529 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{530     \}}
\DoxyCodeLine{531   }
\DoxyCodeLine{532   }
\DoxyCodeLine{533   \textcolor{keyword}{inline}}
\DoxyCodeLine{534   \textcolor{keyword}{static}}
\DoxyCodeLine{535   \textcolor{keywordtype}{void}}
\DoxyCodeLine{536   fill(eT* mem, \textcolor{keyword}{const} uword N)}
\DoxyCodeLine{537     \{}
\DoxyCodeLine{538 \textcolor{preprocessor}{    \#if defined(ARMA\_USE\_OPENMP)}}
\DoxyCodeLine{539       \{}
\DoxyCodeLine{540       \textcolor{keywordflow}{if}((N < 1024) || omp\_in\_parallel())  \{ \mbox{\hyperlink{structarma__rng_1_1randn}{arma\_rng::randn<eT>::fill\_simple}}(mem, N); \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{541       }
\DoxyCodeLine{542       \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::mt19937\_64::result\_type local\_seed\_type;}
\DoxyCodeLine{543       }
\DoxyCodeLine{544       \textcolor{keyword}{const} uword n\_threads = uword( mp\_thread\_limit::get() );}
\DoxyCodeLine{545       }
\DoxyCodeLine{546       std::vector< std::mt19937\_64                  > engine(n\_threads);}
\DoxyCodeLine{547       std::vector< std::normal\_distribution<double> >  distr(n\_threads);}
\DoxyCodeLine{548       }
\DoxyCodeLine{549       \textcolor{keywordflow}{for}(uword t=0; t < n\_threads; ++t)}
\DoxyCodeLine{550         \{}
\DoxyCodeLine{551         std::mt19937\_64\& t\_engine = engine[t];}
\DoxyCodeLine{552         }
\DoxyCodeLine{553         t\_engine.seed( local\_seed\_type(t) + local\_seed\_type(\mbox{\hyperlink{structarma__rng_1_1randi}{arma\_rng::randi<local\_seed\_type>}}()) );}
\DoxyCodeLine{554         \}}
\DoxyCodeLine{555       }
\DoxyCodeLine{556       \textcolor{keyword}{const} uword chunk\_size = N / n\_threads;}
\DoxyCodeLine{557       }
\DoxyCodeLine{558 \textcolor{preprocessor}{      \#pragma omp parallel for schedule(static) num\_threads(int(n\_threads))}}
\DoxyCodeLine{559       \textcolor{keywordflow}{for}(uword t=0; t < n\_threads; ++t)}
\DoxyCodeLine{560         \{}
\DoxyCodeLine{561         \textcolor{keyword}{const} uword start = (t+0) * chunk\_size;}
\DoxyCodeLine{562         \textcolor{keyword}{const} uword endp1 = (t+1) * chunk\_size;}
\DoxyCodeLine{563         }
\DoxyCodeLine{564         std::mt19937\_64\&                  t\_engine = engine[t];}
\DoxyCodeLine{565         std::normal\_distribution<double>\& t\_distr  =  distr[t];}
\DoxyCodeLine{566         }
\DoxyCodeLine{567         \textcolor{keywordflow}{for}(uword i=start; i < endp1; ++i)  \{ mem[i] = eT( t\_distr(t\_engine)); \}}
\DoxyCodeLine{568         \}}
\DoxyCodeLine{569       }
\DoxyCodeLine{570       std::mt19937\_64\&                  t0\_engine = engine[0];}
\DoxyCodeLine{571       std::normal\_distribution<double>\& t0\_distr  =  distr[0];}
\DoxyCodeLine{572       }
\DoxyCodeLine{573       \textcolor{keywordflow}{for}(uword i=(n\_threads*chunk\_size); i < N; ++i)  \{ mem[i] = eT( t0\_distr(t0\_engine)); \}}
\DoxyCodeLine{574       \}}
\DoxyCodeLine{575 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{576       \{}
\DoxyCodeLine{577       \mbox{\hyperlink{structarma__rng_1_1randn}{arma\_rng::randn<eT>::fill\_simple}}(mem, N);}
\DoxyCodeLine{578       \}}
\DoxyCodeLine{579 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{580     \}}
\DoxyCodeLine{581   }
\DoxyCodeLine{582   \};}
\DoxyCodeLine{583 }
\DoxyCodeLine{584 }
\DoxyCodeLine{585 }
\DoxyCodeLine{586 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{587 \textcolor{keyword}{struct }\mbox{\hyperlink{structarma__rng_1_1randn}{arma\_rng::randn}}< std::complex<T> >}
\DoxyCodeLine{588   \{}
\DoxyCodeLine{589   \textcolor{keyword}{inline}}
\DoxyCodeLine{590   \textcolor{keyword}{operator} std::complex<T> ()\textcolor{keyword}{ const}}
\DoxyCodeLine{591 \textcolor{keyword}{    }\{}
\DoxyCodeLine{592 \textcolor{preprocessor}{    \#if defined(\_MSC\_VER)}}
\DoxyCodeLine{593       \textcolor{comment}{// attempt at workaround for MSVC bug}}
\DoxyCodeLine{594       \textcolor{comment}{// does MS even test their so-\/called compilers before release?}}
\DoxyCodeLine{595       T a;}
\DoxyCodeLine{596       T b;}
\DoxyCodeLine{597 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{598       T a(0);}
\DoxyCodeLine{599       T b(0);}
\DoxyCodeLine{600 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{601     }
\DoxyCodeLine{602     \mbox{\hyperlink{structarma__rng_1_1randn}{arma\_rng::randn<T>::dual\_val}}(a, b);}
\DoxyCodeLine{603     }
\DoxyCodeLine{604     \textcolor{keywordflow}{return} std::complex<T>(a, b);}
\DoxyCodeLine{605     \}}
\DoxyCodeLine{606   }
\DoxyCodeLine{607   }
\DoxyCodeLine{608   \textcolor{keyword}{inline}}
\DoxyCodeLine{609   \textcolor{keyword}{static}}
\DoxyCodeLine{610   \textcolor{keywordtype}{void}}
\DoxyCodeLine{611   dual\_val(std::complex<T>\& out1, std::complex<T>\& out2)}
\DoxyCodeLine{612     \{}
\DoxyCodeLine{613 \textcolor{preprocessor}{    \#if defined(\_MSC\_VER)}}
\DoxyCodeLine{614       T a;}
\DoxyCodeLine{615       T b;}
\DoxyCodeLine{616 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{617       T a(0);}
\DoxyCodeLine{618       T b(0);}
\DoxyCodeLine{619 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{620     }
\DoxyCodeLine{621     \mbox{\hyperlink{structarma__rng_1_1randn}{arma\_rng::randn<T>::dual\_val}}(a,b);}
\DoxyCodeLine{622     out1 = std::complex<T>(a,b);}
\DoxyCodeLine{623     }
\DoxyCodeLine{624     \mbox{\hyperlink{structarma__rng_1_1randn}{arma\_rng::randn<T>::dual\_val}}(a,b);}
\DoxyCodeLine{625     out2 = std::complex<T>(a,b);}
\DoxyCodeLine{626     \}}
\DoxyCodeLine{627   }
\DoxyCodeLine{628   }
\DoxyCodeLine{629   \textcolor{keyword}{inline}}
\DoxyCodeLine{630   \textcolor{keyword}{static}}
\DoxyCodeLine{631   \textcolor{keywordtype}{void}}
\DoxyCodeLine{632   fill\_simple(std::complex<T>* mem, \textcolor{keyword}{const} uword N)}
\DoxyCodeLine{633     \{}
\DoxyCodeLine{634 \textcolor{preprocessor}{    \#if defined(ARMA\_RNG\_ALT)}}
\DoxyCodeLine{635       \{}
\DoxyCodeLine{636       \textcolor{keywordflow}{for}(uword i=0; i < N; ++i)  \{ mem[i] = std::complex<T>( \mbox{\hyperlink{structarma__rng_1_1randn}{arma\_rng::randn}}< std::complex<T> >() ); \}}
\DoxyCodeLine{637       \}}
\DoxyCodeLine{638 \textcolor{preprocessor}{    \#elif defined(ARMA\_USE\_EXTERN\_RNG)}}
\DoxyCodeLine{639       \{}
\DoxyCodeLine{640       std::normal\_distribution<double> local\_n\_distr;}
\DoxyCodeLine{641       }
\DoxyCodeLine{642       \textcolor{keywordflow}{for}(uword i=0; i < N; ++i)}
\DoxyCodeLine{643         \{}
\DoxyCodeLine{644         \textcolor{keyword}{const} T a = T( local\_n\_distr(mt19937\_64\_instance) );}
\DoxyCodeLine{645         \textcolor{keyword}{const} T b = T( local\_n\_distr(mt19937\_64\_instance) );}
\DoxyCodeLine{646         }
\DoxyCodeLine{647         mem[i] = std::complex<T>(a,b);}
\DoxyCodeLine{648         \}}
\DoxyCodeLine{649       \}}
\DoxyCodeLine{650 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{651       \{}
\DoxyCodeLine{652       \textcolor{keywordflow}{if}(N == uword(1))}
\DoxyCodeLine{653         \{}
\DoxyCodeLine{654         T a = T(0);}
\DoxyCodeLine{655         T b = T(0);}
\DoxyCodeLine{656         }
\DoxyCodeLine{657         arma\_rng\_cxx98::randn\_dual\_val(a,b);}
\DoxyCodeLine{658         }
\DoxyCodeLine{659         mem[0] = std::complex<T>(a,b);}
\DoxyCodeLine{660         }
\DoxyCodeLine{661         \textcolor{keywordflow}{return};}
\DoxyCodeLine{662         \}}
\DoxyCodeLine{663       }
\DoxyCodeLine{664       \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::mt19937\_64::result\_type local\_seed\_type;}
\DoxyCodeLine{665       }
\DoxyCodeLine{666       std::mt19937\_64                  local\_engine;}
\DoxyCodeLine{667       std::normal\_distribution<double> local\_n\_distr;}
\DoxyCodeLine{668       }
\DoxyCodeLine{669       local\_engine.seed( local\_seed\_type(std::rand()) );}
\DoxyCodeLine{670       }
\DoxyCodeLine{671       \textcolor{keywordflow}{for}(uword i=0; i < N; ++i)}
\DoxyCodeLine{672         \{}
\DoxyCodeLine{673         \textcolor{keyword}{const} T a = T( local\_n\_distr(local\_engine) );}
\DoxyCodeLine{674         \textcolor{keyword}{const} T b = T( local\_n\_distr(local\_engine) );}
\DoxyCodeLine{675         }
\DoxyCodeLine{676         mem[i] = std::complex<T>(a,b);}
\DoxyCodeLine{677         \}}
\DoxyCodeLine{678       \}}
\DoxyCodeLine{679 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{680     \}}
\DoxyCodeLine{681   }
\DoxyCodeLine{682   }
\DoxyCodeLine{683   \textcolor{keyword}{inline}}
\DoxyCodeLine{684   \textcolor{keyword}{static}}
\DoxyCodeLine{685   \textcolor{keywordtype}{void}}
\DoxyCodeLine{686   fill(std::complex<T>* mem, \textcolor{keyword}{const} uword N)}
\DoxyCodeLine{687     \{}
\DoxyCodeLine{688 \textcolor{preprocessor}{    \#if defined(ARMA\_USE\_OPENMP)}}
\DoxyCodeLine{689       \{}
\DoxyCodeLine{690       \textcolor{keywordflow}{if}((N < 512) || omp\_in\_parallel())  \{ \mbox{\hyperlink{structarma__rng_1_1randn}{arma\_rng::randn< std::complex<T>}} >::fill\_simple(mem, N); \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{691       }
\DoxyCodeLine{692       \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::mt19937\_64::result\_type local\_seed\_type;}
\DoxyCodeLine{693       }
\DoxyCodeLine{694       \textcolor{keyword}{const} uword n\_threads = uword( mp\_thread\_limit::get() );}
\DoxyCodeLine{695       }
\DoxyCodeLine{696       std::vector< std::mt19937\_64                  > engine(n\_threads);}
\DoxyCodeLine{697       std::vector< std::normal\_distribution<double> >  distr(n\_threads);}
\DoxyCodeLine{698       }
\DoxyCodeLine{699       \textcolor{keywordflow}{for}(uword t=0; t < n\_threads; ++t)}
\DoxyCodeLine{700         \{}
\DoxyCodeLine{701         std::mt19937\_64\& t\_engine = engine[t];}
\DoxyCodeLine{702         }
\DoxyCodeLine{703         t\_engine.seed( local\_seed\_type(t) + local\_seed\_type(\mbox{\hyperlink{structarma__rng_1_1randi}{arma\_rng::randi<local\_seed\_type>}}()) );}
\DoxyCodeLine{704         \}}
\DoxyCodeLine{705       }
\DoxyCodeLine{706       \textcolor{keyword}{const} uword chunk\_size = N / n\_threads;}
\DoxyCodeLine{707       }
\DoxyCodeLine{708 \textcolor{preprocessor}{      \#pragma omp parallel for schedule(static) num\_threads(int(n\_threads))}}
\DoxyCodeLine{709       \textcolor{keywordflow}{for}(uword t=0; t < n\_threads; ++t)}
\DoxyCodeLine{710         \{}
\DoxyCodeLine{711         \textcolor{keyword}{const} uword start = (t+0) * chunk\_size;}
\DoxyCodeLine{712         \textcolor{keyword}{const} uword endp1 = (t+1) * chunk\_size;}
\DoxyCodeLine{713         }
\DoxyCodeLine{714         std::mt19937\_64\&                  t\_engine = engine[t];}
\DoxyCodeLine{715         std::normal\_distribution<double>\& t\_distr  =  distr[t];}
\DoxyCodeLine{716         }
\DoxyCodeLine{717         \textcolor{keywordflow}{for}(uword i=start; i < endp1; ++i)}
\DoxyCodeLine{718           \{}
\DoxyCodeLine{719           \textcolor{keyword}{const} T val1 = T( t\_distr(t\_engine) );}
\DoxyCodeLine{720           \textcolor{keyword}{const} T val2 = T( t\_distr(t\_engine) );}
\DoxyCodeLine{721           }
\DoxyCodeLine{722           mem[i] = std::complex<T>(val1, val2);}
\DoxyCodeLine{723           \}}
\DoxyCodeLine{724         \}}
\DoxyCodeLine{725       }
\DoxyCodeLine{726       std::mt19937\_64\&                  t0\_engine = engine[0];}
\DoxyCodeLine{727       std::normal\_distribution<double>\& t0\_distr  =  distr[0];}
\DoxyCodeLine{728       }
\DoxyCodeLine{729       \textcolor{keywordflow}{for}(uword i=(n\_threads*chunk\_size); i < N; ++i)}
\DoxyCodeLine{730         \{}
\DoxyCodeLine{731         \textcolor{keyword}{const} T val1 = T( t0\_distr(t0\_engine) );}
\DoxyCodeLine{732         \textcolor{keyword}{const} T val2 = T( t0\_distr(t0\_engine) );}
\DoxyCodeLine{733         }
\DoxyCodeLine{734         mem[i] = std::complex<T>(val1, val2);}
\DoxyCodeLine{735         \}}
\DoxyCodeLine{736       \}}
\DoxyCodeLine{737 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{738       \{}
\DoxyCodeLine{739       \mbox{\hyperlink{structarma__rng_1_1randn}{arma\_rng::randn< std::complex<T>}} >::fill\_simple(mem, N);}
\DoxyCodeLine{740       \}}
\DoxyCodeLine{741 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{742     \}}
\DoxyCodeLine{743   \};}
\DoxyCodeLine{744 }
\DoxyCodeLine{745 }
\DoxyCodeLine{746 }
\DoxyCodeLine{747 \textcolor{comment}{//}}
\DoxyCodeLine{748 }
\DoxyCodeLine{749 }
\DoxyCodeLine{750 }
\DoxyCodeLine{751 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{752 \textcolor{keyword}{struct }\mbox{\hyperlink{structarma__rng_1_1randg}{arma\_rng::randg}}}
\DoxyCodeLine{753   \{}
\DoxyCodeLine{754   \textcolor{keyword}{inline}}
\DoxyCodeLine{755   \textcolor{keyword}{static}}
\DoxyCodeLine{756   \textcolor{keywordtype}{void}}
\DoxyCodeLine{757   fill\_simple(eT* mem, \textcolor{keyword}{const} uword N, \textcolor{keyword}{const} \textcolor{keywordtype}{double} a, \textcolor{keyword}{const} \textcolor{keywordtype}{double} b)}
\DoxyCodeLine{758     \{}
\DoxyCodeLine{759 \textcolor{preprocessor}{    \#if defined(ARMA\_USE\_EXTERN\_RNG)}}
\DoxyCodeLine{760       \{}
\DoxyCodeLine{761       std::gamma\_distribution<double> local\_g\_distr(a,b);}
\DoxyCodeLine{762       }
\DoxyCodeLine{763       \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)  \{ mem[i] = eT(local\_g\_distr(mt19937\_64\_instance)); \}}
\DoxyCodeLine{764       \}}
\DoxyCodeLine{765 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{766       \{}
\DoxyCodeLine{767       \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::mt19937\_64::result\_type local\_seed\_type;}
\DoxyCodeLine{768       }
\DoxyCodeLine{769       std::mt19937\_64                 local\_engine;}
\DoxyCodeLine{770       std::gamma\_distribution<double> local\_g\_distr(a,b);}
\DoxyCodeLine{771       }
\DoxyCodeLine{772       local\_engine.seed( local\_seed\_type(\mbox{\hyperlink{structarma__rng_1_1randi}{arma\_rng::randi<local\_seed\_type>}}()) );}
\DoxyCodeLine{773       }
\DoxyCodeLine{774       \textcolor{keywordflow}{for}(uword i=0; i<N; ++i)  \{ mem[i] = eT(local\_g\_distr(local\_engine)); \}}
\DoxyCodeLine{775       \}}
\DoxyCodeLine{776 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{777     \}}
\DoxyCodeLine{778   }
\DoxyCodeLine{779   }
\DoxyCodeLine{780   \textcolor{keyword}{inline}}
\DoxyCodeLine{781   \textcolor{keyword}{static}}
\DoxyCodeLine{782   \textcolor{keywordtype}{void}}
\DoxyCodeLine{783   fill(eT* mem, \textcolor{keyword}{const} uword N, \textcolor{keyword}{const} \textcolor{keywordtype}{double} a, \textcolor{keyword}{const} \textcolor{keywordtype}{double} b)}
\DoxyCodeLine{784     \{}
\DoxyCodeLine{785 \textcolor{preprocessor}{    \#if defined(ARMA\_USE\_OPENMP)}}
\DoxyCodeLine{786       \{}
\DoxyCodeLine{787       \textcolor{keywordflow}{if}((N < 512) || omp\_in\_parallel())  \{ \mbox{\hyperlink{structarma__rng_1_1randg}{arma\_rng::randg<eT>::fill\_simple}}(mem, N, a, b); \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{788       }
\DoxyCodeLine{789       \textcolor{keyword}{typedef} std::mt19937\_64                  motor\_type;}
\DoxyCodeLine{790       \textcolor{keyword}{typedef} std::mt19937\_64::result\_type      ovum\_type;}
\DoxyCodeLine{791       \textcolor{keyword}{typedef} std::gamma\_distribution<double>  distr\_type;}
\DoxyCodeLine{792       }
\DoxyCodeLine{793       \textcolor{keyword}{const} uword n\_threads = uword( mp\_thread\_limit::get() );}
\DoxyCodeLine{794       }
\DoxyCodeLine{795       std::vector<motor\_type> g\_motor(n\_threads);}
\DoxyCodeLine{796       std::vector<distr\_type> g\_distr(n\_threads);}
\DoxyCodeLine{797       }
\DoxyCodeLine{798       \textcolor{keyword}{const} distr\_type g\_distr\_base(a,b);}
\DoxyCodeLine{799       }
\DoxyCodeLine{800       \textcolor{keywordflow}{for}(uword t=0; t < n\_threads; ++t)}
\DoxyCodeLine{801         \{}
\DoxyCodeLine{802         motor\_type\& g\_motor\_t = g\_motor[t];}
\DoxyCodeLine{803         distr\_type\& g\_distr\_t = g\_distr[t];}
\DoxyCodeLine{804         }
\DoxyCodeLine{805         g\_motor\_t.seed( ovum\_type(t) + ovum\_type(\mbox{\hyperlink{structarma__rng_1_1randi}{arma\_rng::randi<ovum\_type>}}()) );}
\DoxyCodeLine{806         }
\DoxyCodeLine{807         g\_distr\_t.param( g\_distr\_base.param() );}
\DoxyCodeLine{808         \}}
\DoxyCodeLine{809       }
\DoxyCodeLine{810       \textcolor{keyword}{const} uword chunk\_size = N / n\_threads;}
\DoxyCodeLine{811       }
\DoxyCodeLine{812 \textcolor{preprocessor}{      \#pragma omp parallel for schedule(static) num\_threads(int(n\_threads))}}
\DoxyCodeLine{813       \textcolor{keywordflow}{for}(uword t=0; t < n\_threads; ++t)}
\DoxyCodeLine{814         \{}
\DoxyCodeLine{815         \textcolor{keyword}{const} uword start = (t+0) * chunk\_size;}
\DoxyCodeLine{816         \textcolor{keyword}{const} uword endp1 = (t+1) * chunk\_size;}
\DoxyCodeLine{817         }
\DoxyCodeLine{818         motor\_type\& g\_motor\_t = g\_motor[t];}
\DoxyCodeLine{819         distr\_type\& g\_distr\_t = g\_distr[t];}
\DoxyCodeLine{820         }
\DoxyCodeLine{821         \textcolor{keywordflow}{for}(uword i=start; i < endp1; ++i)  \{ mem[i] = eT( g\_distr\_t(g\_motor\_t)); \}}
\DoxyCodeLine{822         \}}
\DoxyCodeLine{823       }
\DoxyCodeLine{824       motor\_type\& g\_motor\_0 = g\_motor[0];}
\DoxyCodeLine{825       distr\_type\& g\_distr\_0 = g\_distr[0];}
\DoxyCodeLine{826       }
\DoxyCodeLine{827       \textcolor{keywordflow}{for}(uword i=(n\_threads*chunk\_size); i < N; ++i)  \{ mem[i] = eT( g\_distr\_0(g\_motor\_0)); \}}
\DoxyCodeLine{828       \}}
\DoxyCodeLine{829 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{830       \{}
\DoxyCodeLine{831       \mbox{\hyperlink{structarma__rng_1_1randg}{arma\_rng::randg<eT>::fill\_simple}}(mem, N, a, b);}
\DoxyCodeLine{832       \}}
\DoxyCodeLine{833 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{834     \}}
\DoxyCodeLine{835   }
\DoxyCodeLine{836   \};}
\DoxyCodeLine{837 }
\DoxyCodeLine{838 }
\DoxyCodeLine{839 }

\end{DoxyCode}
