\hypertarget{spglue__merge__meat_8hpp_source}{}\doxysection{spglue\+\_\+merge\+\_\+meat.\+hpp}
\label{spglue__merge__meat_8hpp_source}\index{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/spglue\_merge\_meat.hpp@{/Users/motiwari/Desktop/BanditPAM/headers/carma/extern/armadillo-\/code/include/armadillo\_bits/spglue\_merge\_meat.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008-\/2016 Conrad Sanderson (http://conradsanderson.id.au)}}
\DoxyCodeLine{2 \textcolor{comment}{// Copyright 2008-\/2016 National ICT Australia (NICTA)}}
\DoxyCodeLine{3 \textcolor{comment}{// }}
\DoxyCodeLine{4 \textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{5 \textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{6 \textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{7 \textcolor{comment}{// http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{8 \textcolor{comment}{// }}
\DoxyCodeLine{9 \textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{10 \textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{11 \textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{12 \textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{13 \textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{14 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{19 }
\DoxyCodeLine{20 }
\DoxyCodeLine{21 }
\DoxyCodeLine{22 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{23 arma\_hot}
\DoxyCodeLine{24 \textcolor{keyword}{inline}}
\DoxyCodeLine{25 \textcolor{keywordtype}{void}}
\DoxyCodeLine{26 spglue\_merge::subview\_merge(\mbox{\hyperlink{classSpSubview}{SpSubview<eT>}}\& sv, \textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& \mbox{\hyperlink{structB}{B}})}
\DoxyCodeLine{27   \{}
\DoxyCodeLine{28   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{29   }
\DoxyCodeLine{30   \textcolor{keywordflow}{if}(sv.n\_elem == 0)  \{ \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{31   }
\DoxyCodeLine{32   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structB}{B}}.n\_nonzero == 0)  \{ sv.zeros(); \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{33   }
\DoxyCodeLine{34   \mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& \mbox{\hyperlink{structA}{A}} = \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(sv.m);}
\DoxyCodeLine{35   }
\DoxyCodeLine{36   \textcolor{keyword}{const} uword merge\_n\_nonzero = \mbox{\hyperlink{structA}{A}}.n\_nonzero -\/ sv.n\_nonzero + \mbox{\hyperlink{structB}{B}}.n\_nonzero;}
\DoxyCodeLine{37   }
\DoxyCodeLine{38   \textcolor{keyword}{const} uword sv\_row\_start = sv.aux\_row1;}
\DoxyCodeLine{39   \textcolor{keyword}{const} uword sv\_col\_start = sv.aux\_col1;}
\DoxyCodeLine{40   }
\DoxyCodeLine{41   \textcolor{keyword}{const} uword sv\_row\_end   = sv.aux\_row1 + sv.n\_rows -\/ 1;}
\DoxyCodeLine{42   \textcolor{keyword}{const} uword sv\_col\_end   = sv.aux\_col1 + sv.n\_cols -\/ 1;}
\DoxyCodeLine{43   }
\DoxyCodeLine{44   }
\DoxyCodeLine{45   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.n\_nonzero == sv.n\_nonzero)}
\DoxyCodeLine{46     \{}
\DoxyCodeLine{47     \textcolor{comment}{// A is either all zeros or has all of its elements in the subview}}
\DoxyCodeLine{48     \textcolor{comment}{// so the merge is equivalent to overwrite of A}}
\DoxyCodeLine{49     }
\DoxyCodeLine{50     \mbox{\hyperlink{classSpMat}{SpMat<eT>}} tmp(\mbox{\hyperlink{structarma__reserve__indicator}{arma\_reserve\_indicator}}(), \mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structB}{B}}.n\_nonzero);}
\DoxyCodeLine{51     }
\DoxyCodeLine{52     \textcolor{keyword}{typename} \mbox{\hyperlink{classSpMat_1_1const__iterator}{SpMat<eT>::const\_iterator}} B\_it     = \mbox{\hyperlink{structB}{B}}.begin();}
\DoxyCodeLine{53     \textcolor{keyword}{typename} \mbox{\hyperlink{classSpMat_1_1const__iterator}{SpMat<eT>::const\_iterator}} B\_it\_end = \mbox{\hyperlink{structB}{B}}.end();}
\DoxyCodeLine{54     }
\DoxyCodeLine{55     uword tmp\_count = 0;}
\DoxyCodeLine{56     }
\DoxyCodeLine{57     \textcolor{keywordflow}{for}(; B\_it != B\_it\_end; ++B\_it)}
\DoxyCodeLine{58       \{}
\DoxyCodeLine{59       \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(tmp.values[tmp\_count])      = (*B\_it);}
\DoxyCodeLine{60       \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(tmp.row\_indices[tmp\_count]) = B\_it.row() + sv\_row\_start;}
\DoxyCodeLine{61       \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(tmp.col\_ptrs[B\_it.col() + sv\_col\_start + 1])++;}
\DoxyCodeLine{62       ++tmp\_count;}
\DoxyCodeLine{63       \}}
\DoxyCodeLine{64     }
\DoxyCodeLine{65     \textcolor{keywordflow}{for}(uword i=0; i < tmp.n\_cols; ++i)}
\DoxyCodeLine{66       \{}
\DoxyCodeLine{67       \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(tmp.col\_ptrs[i + 1]) += tmp.col\_ptrs[i];}
\DoxyCodeLine{68       \}}
\DoxyCodeLine{69     }
\DoxyCodeLine{70     \mbox{\hyperlink{structA}{A}}.steal\_mem(tmp);}
\DoxyCodeLine{71     }
\DoxyCodeLine{72     \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(sv.n\_nonzero) = \mbox{\hyperlink{structB}{B}}.n\_nonzero;}
\DoxyCodeLine{73     }
\DoxyCodeLine{74     \textcolor{keywordflow}{return};}
\DoxyCodeLine{75     \}}
\DoxyCodeLine{76   }
\DoxyCodeLine{77   }
\DoxyCodeLine{78   \textcolor{keywordflow}{if}(sv.n\_nonzero > (\mbox{\hyperlink{structA}{A}}.n\_nonzero/2))}
\DoxyCodeLine{79     \{}
\DoxyCodeLine{80     \textcolor{comment}{// A has most of its elements in the subview,}}
\DoxyCodeLine{81     \textcolor{comment}{// so regenerate A with zeros in the subview region}}
\DoxyCodeLine{82     \textcolor{comment}{// in order to increase merging efficiency}}
\DoxyCodeLine{83     }
\DoxyCodeLine{84     sv.zeros();}
\DoxyCodeLine{85     \}}
\DoxyCodeLine{86   }
\DoxyCodeLine{87   }
\DoxyCodeLine{88   \mbox{\hyperlink{classSpMat}{SpMat<eT>}} out(\mbox{\hyperlink{structarma__reserve__indicator}{arma\_reserve\_indicator}}(), \mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_cols, merge\_n\_nonzero);}
\DoxyCodeLine{89   }
\DoxyCodeLine{90   \textcolor{keyword}{typename} \mbox{\hyperlink{classSpMat_1_1const__iterator}{SpMat<eT>::const\_iterator}} x\_it  = \mbox{\hyperlink{structA}{A}}.begin();}
\DoxyCodeLine{91   \textcolor{keyword}{typename} \mbox{\hyperlink{classSpMat_1_1const__iterator}{SpMat<eT>::const\_iterator}} x\_end = \mbox{\hyperlink{structA}{A}}.end();}
\DoxyCodeLine{92   }
\DoxyCodeLine{93   \textcolor{keyword}{typename} \mbox{\hyperlink{classSpMat_1_1const__iterator}{SpMat<eT>::const\_iterator}} y\_it  = \mbox{\hyperlink{structB}{B}}.begin();}
\DoxyCodeLine{94   \textcolor{keyword}{typename} \mbox{\hyperlink{classSpMat_1_1const__iterator}{SpMat<eT>::const\_iterator}} y\_end = \mbox{\hyperlink{structB}{B}}.end();}
\DoxyCodeLine{95   }
\DoxyCodeLine{96   uword count = 0;}
\DoxyCodeLine{97   }
\DoxyCodeLine{98   \textcolor{keywordtype}{bool} x\_it\_valid = (x\_it != x\_end);}
\DoxyCodeLine{99   \textcolor{keywordtype}{bool} y\_it\_valid = (y\_it != y\_end);}
\DoxyCodeLine{100   }
\DoxyCodeLine{101   \textcolor{keywordflow}{while}(x\_it\_valid || y\_it\_valid)}
\DoxyCodeLine{102     \{}
\DoxyCodeLine{103     eT out\_val = eT(0);}
\DoxyCodeLine{104     }
\DoxyCodeLine{105     \textcolor{keyword}{const} uword x\_it\_row = (x\_it\_valid) ? uword(x\_it.row()) : uword(0);}
\DoxyCodeLine{106     \textcolor{keyword}{const} uword x\_it\_col = (x\_it\_valid) ? uword(x\_it.col()) : uword(0);}
\DoxyCodeLine{107     }
\DoxyCodeLine{108     \textcolor{keyword}{const} uword y\_it\_row = (y\_it\_valid) ? uword(sv\_row\_start + y\_it.row()) : uword(0);}
\DoxyCodeLine{109     \textcolor{keyword}{const} uword y\_it\_col = (y\_it\_valid) ? uword(sv\_col\_start + y\_it.col()) : uword(0);}
\DoxyCodeLine{110     }
\DoxyCodeLine{111     \textcolor{keywordtype}{bool} use\_y\_loc = \textcolor{keyword}{false};}
\DoxyCodeLine{112     }
\DoxyCodeLine{113     \textcolor{keywordflow}{if}(x\_it\_valid \&\& y\_it\_valid)}
\DoxyCodeLine{114       \{}
\DoxyCodeLine{115       \textcolor{keywordflow}{if}( (x\_it\_row == y\_it\_row) \&\& (x\_it\_col == y\_it\_col) )}
\DoxyCodeLine{116         \{}
\DoxyCodeLine{117         out\_val = (*y\_it);}
\DoxyCodeLine{118         }
\DoxyCodeLine{119         ++x\_it;}
\DoxyCodeLine{120         ++y\_it;}
\DoxyCodeLine{121         \}}
\DoxyCodeLine{122       \textcolor{keywordflow}{else}}
\DoxyCodeLine{123         \{}
\DoxyCodeLine{124         \textcolor{keywordflow}{if}((x\_it\_col < y\_it\_col) || ((x\_it\_col == y\_it\_col) \&\& (x\_it\_row < y\_it\_row))) \textcolor{comment}{// if y is closer to the end}}
\DoxyCodeLine{125           \{}
\DoxyCodeLine{126           \textcolor{keyword}{const} \textcolor{keywordtype}{bool} x\_inside\_box = ((x\_it\_row >= sv\_row\_start) \&\& (x\_it\_row <= sv\_row\_end)) \&\& ((x\_it\_col >= sv\_col\_start) \&\& (x\_it\_col <= sv\_col\_end));}
\DoxyCodeLine{127           }
\DoxyCodeLine{128           out\_val = (x\_inside\_box) ? eT(0) : (*x\_it);}
\DoxyCodeLine{129           }
\DoxyCodeLine{130           ++x\_it;}
\DoxyCodeLine{131           \}}
\DoxyCodeLine{132         \textcolor{keywordflow}{else}}
\DoxyCodeLine{133           \{}
\DoxyCodeLine{134           out\_val = (*y\_it);}
\DoxyCodeLine{135           }
\DoxyCodeLine{136           ++y\_it;}
\DoxyCodeLine{137           }
\DoxyCodeLine{138           use\_y\_loc = \textcolor{keyword}{true};}
\DoxyCodeLine{139           \}}
\DoxyCodeLine{140         \}}
\DoxyCodeLine{141       \}}
\DoxyCodeLine{142     \textcolor{keywordflow}{else}}
\DoxyCodeLine{143     \textcolor{keywordflow}{if}(x\_it\_valid)}
\DoxyCodeLine{144       \{}
\DoxyCodeLine{145       \textcolor{keyword}{const} \textcolor{keywordtype}{bool} x\_inside\_box = ((x\_it\_row >= sv\_row\_start) \&\& (x\_it\_row <= sv\_row\_end)) \&\& ((x\_it\_col >= sv\_col\_start) \&\& (x\_it\_col <= sv\_col\_end));}
\DoxyCodeLine{146       }
\DoxyCodeLine{147       out\_val = (x\_inside\_box) ? eT(0) : (*x\_it);}
\DoxyCodeLine{148       }
\DoxyCodeLine{149       ++x\_it;}
\DoxyCodeLine{150       \}}
\DoxyCodeLine{151     \textcolor{keywordflow}{else}}
\DoxyCodeLine{152     \textcolor{keywordflow}{if}(y\_it\_valid)}
\DoxyCodeLine{153       \{}
\DoxyCodeLine{154       out\_val = (*y\_it);}
\DoxyCodeLine{155       }
\DoxyCodeLine{156       ++y\_it;}
\DoxyCodeLine{157       }
\DoxyCodeLine{158       use\_y\_loc = \textcolor{keyword}{true};}
\DoxyCodeLine{159       \}}
\DoxyCodeLine{160     }
\DoxyCodeLine{161     \textcolor{keywordflow}{if}(out\_val != eT(0))}
\DoxyCodeLine{162       \{}
\DoxyCodeLine{163       \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(out.values[count]) = out\_val;}
\DoxyCodeLine{164       }
\DoxyCodeLine{165       \textcolor{keyword}{const} uword out\_row = (use\_y\_loc == \textcolor{keyword}{false}) ? x\_it\_row : y\_it\_row;}
\DoxyCodeLine{166       \textcolor{keyword}{const} uword out\_col = (use\_y\_loc == \textcolor{keyword}{false}) ? x\_it\_col : y\_it\_col;}
\DoxyCodeLine{167       }
\DoxyCodeLine{168       \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(out.row\_indices[count]) = out\_row;}
\DoxyCodeLine{169       \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(out.col\_ptrs[out\_col + 1])++;}
\DoxyCodeLine{170       ++count;}
\DoxyCodeLine{171       \}}
\DoxyCodeLine{172     }
\DoxyCodeLine{173     x\_it\_valid = (x\_it != x\_end);}
\DoxyCodeLine{174     y\_it\_valid = (y\_it != y\_end);}
\DoxyCodeLine{175     \}}
\DoxyCodeLine{176   }
\DoxyCodeLine{177   \mbox{\hyperlink{group__debug_ga458beb676810b1e43df9f0668359e76f}{arma\_check}}( (count != merge\_n\_nonzero), \textcolor{stringliteral}{"{}internal error: spglue\_merge::subview\_merge(): count != merge\_n\_nonzero"{}} );}
\DoxyCodeLine{178   }
\DoxyCodeLine{179   \textcolor{keyword}{const} uword out\_n\_cols = out.n\_cols;}
\DoxyCodeLine{180   }
\DoxyCodeLine{181   uword* col\_ptrs = access::rwp(out.col\_ptrs);}
\DoxyCodeLine{182   }
\DoxyCodeLine{183   \textcolor{keywordflow}{for}(uword c = 1; c <= out\_n\_cols; ++c)}
\DoxyCodeLine{184     \{}
\DoxyCodeLine{185     col\_ptrs[c] += col\_ptrs[c -\/ 1];}
\DoxyCodeLine{186     \}}
\DoxyCodeLine{187   }
\DoxyCodeLine{188   \mbox{\hyperlink{structA}{A}}.steal\_mem(out);}
\DoxyCodeLine{189   }
\DoxyCodeLine{190   \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(sv.n\_nonzero) = \mbox{\hyperlink{structB}{B}}.n\_nonzero;}
\DoxyCodeLine{191   \}}
\DoxyCodeLine{192 }
\DoxyCodeLine{193 }
\DoxyCodeLine{194 }
\DoxyCodeLine{195 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{196 arma\_hot}
\DoxyCodeLine{197 \textcolor{keyword}{inline}}
\DoxyCodeLine{198 \textcolor{keywordtype}{void}}
\DoxyCodeLine{199 spglue\_merge::subview\_merge(\mbox{\hyperlink{classSpSubview}{SpSubview<eT>}}\& sv, \textcolor{keyword}{const} \mbox{\hyperlink{classMat}{Mat<eT>}}\& \mbox{\hyperlink{structB}{B}})}
\DoxyCodeLine{200   \{}
\DoxyCodeLine{201   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{202   }
\DoxyCodeLine{203   \textcolor{keywordflow}{if}(sv.n\_elem == 0)  \{ \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{204   }
\DoxyCodeLine{205   \textcolor{keyword}{const} eT*   B\_memptr = \mbox{\hyperlink{structB}{B}}.memptr();}
\DoxyCodeLine{206   \textcolor{keyword}{const} uword B\_n\_elem = \mbox{\hyperlink{structB}{B}}.n\_elem;}
\DoxyCodeLine{207   }
\DoxyCodeLine{208   uword B\_n\_nonzero = 0;}
\DoxyCodeLine{209   }
\DoxyCodeLine{210   \textcolor{keywordflow}{for}(uword i=0; i < B\_n\_elem; ++i)}
\DoxyCodeLine{211     \{}
\DoxyCodeLine{212     B\_n\_nonzero += (B\_memptr[i] != eT(0)) ? uword(1) : uword(0);}
\DoxyCodeLine{213     \}}
\DoxyCodeLine{214   }
\DoxyCodeLine{215   \textcolor{keywordflow}{if}(B\_n\_nonzero == 0)  \{ sv.zeros(); \textcolor{keywordflow}{return}; \}}
\DoxyCodeLine{216   }
\DoxyCodeLine{217   \mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& \mbox{\hyperlink{structA}{A}} = \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(sv.m);}
\DoxyCodeLine{218   }
\DoxyCodeLine{219   \textcolor{keyword}{const} uword merge\_n\_nonzero = \mbox{\hyperlink{structA}{A}}.n\_nonzero -\/ sv.n\_nonzero + B\_n\_nonzero;}
\DoxyCodeLine{220   }
\DoxyCodeLine{221   \textcolor{keyword}{const} uword sv\_row\_start = sv.aux\_row1;}
\DoxyCodeLine{222   \textcolor{keyword}{const} uword sv\_col\_start = sv.aux\_col1;}
\DoxyCodeLine{223   }
\DoxyCodeLine{224   \textcolor{keyword}{const} uword sv\_row\_end   = sv.aux\_row1 + sv.n\_rows -\/ 1;}
\DoxyCodeLine{225   \textcolor{keyword}{const} uword sv\_col\_end   = sv.aux\_col1 + sv.n\_cols -\/ 1;}
\DoxyCodeLine{226   }
\DoxyCodeLine{227   }
\DoxyCodeLine{228   \textcolor{keywordflow}{if}(\mbox{\hyperlink{structA}{A}}.n\_nonzero == sv.n\_nonzero)}
\DoxyCodeLine{229     \{}
\DoxyCodeLine{230     \textcolor{comment}{// A is either all zeros or has all of its elements in the subview}}
\DoxyCodeLine{231     \textcolor{comment}{// so the merge is equivalent to overwrite of A}}
\DoxyCodeLine{232     }
\DoxyCodeLine{233     \mbox{\hyperlink{classSpMat}{SpMat<eT>}} tmp(\mbox{\hyperlink{structarma__reserve__indicator}{arma\_reserve\_indicator}}(), \mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_cols, B\_n\_nonzero);}
\DoxyCodeLine{234     }
\DoxyCodeLine{235     \textcolor{keyword}{typename} \mbox{\hyperlink{classMat_1_1const__row__col__iterator}{Mat<eT>::const\_row\_col\_iterator}} B\_it     = \mbox{\hyperlink{structB}{B}}.begin\_row\_col();}
\DoxyCodeLine{236     \textcolor{keyword}{typename} \mbox{\hyperlink{classMat_1_1const__row__col__iterator}{Mat<eT>::const\_row\_col\_iterator}} B\_it\_end = \mbox{\hyperlink{structB}{B}}.end\_row\_col();}
\DoxyCodeLine{237     }
\DoxyCodeLine{238     uword tmp\_count = 0;}
\DoxyCodeLine{239     }
\DoxyCodeLine{240     \textcolor{keywordflow}{for}(; B\_it != B\_it\_end; ++B\_it)}
\DoxyCodeLine{241       \{}
\DoxyCodeLine{242       \textcolor{keyword}{const} eT val = (*B\_it);}
\DoxyCodeLine{243       }
\DoxyCodeLine{244       \textcolor{keywordflow}{if}(val != eT(0))}
\DoxyCodeLine{245         \{}
\DoxyCodeLine{246         \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(tmp.values[tmp\_count])      = val;}
\DoxyCodeLine{247         \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(tmp.row\_indices[tmp\_count]) = B\_it.row() + sv\_row\_start;}
\DoxyCodeLine{248         \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(tmp.col\_ptrs[B\_it.col() + sv\_col\_start + 1])++;}
\DoxyCodeLine{249         ++tmp\_count;}
\DoxyCodeLine{250         \}}
\DoxyCodeLine{251       \}}
\DoxyCodeLine{252     }
\DoxyCodeLine{253     \textcolor{keywordflow}{for}(uword i=0; i < tmp.n\_cols; ++i)}
\DoxyCodeLine{254       \{}
\DoxyCodeLine{255       \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(tmp.col\_ptrs[i + 1]) += tmp.col\_ptrs[i];}
\DoxyCodeLine{256       \}}
\DoxyCodeLine{257     }
\DoxyCodeLine{258     \mbox{\hyperlink{structA}{A}}.steal\_mem(tmp);}
\DoxyCodeLine{259     }
\DoxyCodeLine{260     \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(sv.n\_nonzero) = B\_n\_nonzero;}
\DoxyCodeLine{261     }
\DoxyCodeLine{262     \textcolor{keywordflow}{return};}
\DoxyCodeLine{263     \}}
\DoxyCodeLine{264   }
\DoxyCodeLine{265   }
\DoxyCodeLine{266   \textcolor{keywordflow}{if}(sv.n\_nonzero > (\mbox{\hyperlink{structA}{A}}.n\_nonzero/2))}
\DoxyCodeLine{267     \{}
\DoxyCodeLine{268     \textcolor{comment}{// A has most of its elements in the subview,}}
\DoxyCodeLine{269     \textcolor{comment}{// so regenerate A with zeros in the subview region}}
\DoxyCodeLine{270     \textcolor{comment}{// in order to increase merging efficiency}}
\DoxyCodeLine{271     }
\DoxyCodeLine{272     sv.zeros();}
\DoxyCodeLine{273     \}}
\DoxyCodeLine{274   }
\DoxyCodeLine{275   }
\DoxyCodeLine{276   \mbox{\hyperlink{classSpMat}{SpMat<eT>}} out(\mbox{\hyperlink{structarma__reserve__indicator}{arma\_reserve\_indicator}}(), \mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_cols, merge\_n\_nonzero);}
\DoxyCodeLine{277   }
\DoxyCodeLine{278   \textcolor{keyword}{typename} \mbox{\hyperlink{classSpMat_1_1const__iterator}{SpMat<eT>::const\_iterator}} x\_it  = \mbox{\hyperlink{structA}{A}}.begin();}
\DoxyCodeLine{279   \textcolor{keyword}{typename} \mbox{\hyperlink{classSpMat_1_1const__iterator}{SpMat<eT>::const\_iterator}} x\_end = \mbox{\hyperlink{structA}{A}}.end();}
\DoxyCodeLine{280   }
\DoxyCodeLine{281   \textcolor{keyword}{typename} \mbox{\hyperlink{classMat_1_1const__row__col__iterator}{Mat<eT>::const\_row\_col\_iterator}} y\_it  = \mbox{\hyperlink{structB}{B}}.begin\_row\_col();}
\DoxyCodeLine{282   \textcolor{keyword}{typename} \mbox{\hyperlink{classMat_1_1const__row__col__iterator}{Mat<eT>::const\_row\_col\_iterator}} y\_end = \mbox{\hyperlink{structB}{B}}.end\_row\_col();}
\DoxyCodeLine{283   }
\DoxyCodeLine{284   uword count = 0;}
\DoxyCodeLine{285   }
\DoxyCodeLine{286   \textcolor{keywordtype}{bool} x\_it\_valid = (x\_it != x\_end);}
\DoxyCodeLine{287   \textcolor{keywordtype}{bool} y\_it\_valid = (y\_it != y\_end);}
\DoxyCodeLine{288     }
\DoxyCodeLine{289   \textcolor{keywordflow}{while}(x\_it\_valid || y\_it\_valid)}
\DoxyCodeLine{290     \{}
\DoxyCodeLine{291     eT out\_val = eT(0);}
\DoxyCodeLine{292     }
\DoxyCodeLine{293     \textcolor{keyword}{const} uword x\_it\_row = (x\_it\_valid) ? uword(x\_it.row()) : uword(0);}
\DoxyCodeLine{294     \textcolor{keyword}{const} uword x\_it\_col = (x\_it\_valid) ? uword(x\_it.col()) : uword(0);}
\DoxyCodeLine{295     }
\DoxyCodeLine{296     \textcolor{keyword}{const} uword y\_it\_row = (y\_it\_valid) ? uword(sv\_row\_start + y\_it.row()) : uword(0);}
\DoxyCodeLine{297     \textcolor{keyword}{const} uword y\_it\_col = (y\_it\_valid) ? uword(sv\_col\_start + y\_it.col()) : uword(0);}
\DoxyCodeLine{298     }
\DoxyCodeLine{299     \textcolor{keywordtype}{bool} use\_y\_loc = \textcolor{keyword}{false};}
\DoxyCodeLine{300     }
\DoxyCodeLine{301     \textcolor{keywordflow}{if}(x\_it\_valid \&\& y\_it\_valid)}
\DoxyCodeLine{302       \{}
\DoxyCodeLine{303       \textcolor{keywordflow}{if}( (x\_it\_row == y\_it\_row) \&\& (x\_it\_col == y\_it\_col) )}
\DoxyCodeLine{304         \{}
\DoxyCodeLine{305         out\_val = (*y\_it);}
\DoxyCodeLine{306         }
\DoxyCodeLine{307         ++x\_it;}
\DoxyCodeLine{308         ++y\_it;}
\DoxyCodeLine{309         \}}
\DoxyCodeLine{310       \textcolor{keywordflow}{else}}
\DoxyCodeLine{311         \{}
\DoxyCodeLine{312         \textcolor{keywordflow}{if}((x\_it\_col < y\_it\_col) || ((x\_it\_col == y\_it\_col) \&\& (x\_it\_row < y\_it\_row))) \textcolor{comment}{// if y is closer to the end}}
\DoxyCodeLine{313           \{}
\DoxyCodeLine{314           \textcolor{keyword}{const} \textcolor{keywordtype}{bool} x\_inside\_box = ((x\_it\_row >= sv\_row\_start) \&\& (x\_it\_row <= sv\_row\_end)) \&\& ((x\_it\_col >= sv\_col\_start) \&\& (x\_it\_col <= sv\_col\_end));}
\DoxyCodeLine{315           }
\DoxyCodeLine{316           out\_val = (x\_inside\_box) ? eT(0) : (*x\_it);}
\DoxyCodeLine{317           }
\DoxyCodeLine{318           ++x\_it;}
\DoxyCodeLine{319           \}}
\DoxyCodeLine{320         \textcolor{keywordflow}{else}}
\DoxyCodeLine{321           \{}
\DoxyCodeLine{322           out\_val = (*y\_it);}
\DoxyCodeLine{323           }
\DoxyCodeLine{324           ++y\_it;}
\DoxyCodeLine{325           }
\DoxyCodeLine{326           use\_y\_loc = \textcolor{keyword}{true};}
\DoxyCodeLine{327           \}}
\DoxyCodeLine{328         \}}
\DoxyCodeLine{329       \}}
\DoxyCodeLine{330     \textcolor{keywordflow}{else}}
\DoxyCodeLine{331     \textcolor{keywordflow}{if}(x\_it\_valid)}
\DoxyCodeLine{332       \{}
\DoxyCodeLine{333       \textcolor{keyword}{const} \textcolor{keywordtype}{bool} x\_inside\_box = ((x\_it\_row >= sv\_row\_start) \&\& (x\_it\_row <= sv\_row\_end)) \&\& ((x\_it\_col >= sv\_col\_start) \&\& (x\_it\_col <= sv\_col\_end));}
\DoxyCodeLine{334       }
\DoxyCodeLine{335       out\_val = (x\_inside\_box) ? eT(0) : (*x\_it);}
\DoxyCodeLine{336       }
\DoxyCodeLine{337       ++x\_it;}
\DoxyCodeLine{338       \}}
\DoxyCodeLine{339     \textcolor{keywordflow}{else}}
\DoxyCodeLine{340     \textcolor{keywordflow}{if}(y\_it\_valid)}
\DoxyCodeLine{341       \{}
\DoxyCodeLine{342       out\_val = (*y\_it);}
\DoxyCodeLine{343       }
\DoxyCodeLine{344       ++y\_it;}
\DoxyCodeLine{345       }
\DoxyCodeLine{346       use\_y\_loc = \textcolor{keyword}{true};}
\DoxyCodeLine{347       \}}
\DoxyCodeLine{348     }
\DoxyCodeLine{349     \textcolor{keywordflow}{if}(out\_val != eT(0))}
\DoxyCodeLine{350       \{}
\DoxyCodeLine{351       \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(out.values[count]) = out\_val;}
\DoxyCodeLine{352       }
\DoxyCodeLine{353       \textcolor{keyword}{const} uword out\_row = (use\_y\_loc == \textcolor{keyword}{false}) ? x\_it\_row : y\_it\_row;}
\DoxyCodeLine{354       \textcolor{keyword}{const} uword out\_col = (use\_y\_loc == \textcolor{keyword}{false}) ? x\_it\_col : y\_it\_col;}
\DoxyCodeLine{355       }
\DoxyCodeLine{356       \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(out.row\_indices[count]) = out\_row;}
\DoxyCodeLine{357       \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(out.col\_ptrs[out\_col + 1])++;}
\DoxyCodeLine{358       ++count;}
\DoxyCodeLine{359       \}}
\DoxyCodeLine{360     }
\DoxyCodeLine{361     x\_it\_valid = (x\_it != x\_end);}
\DoxyCodeLine{362     y\_it\_valid = (y\_it != y\_end);}
\DoxyCodeLine{363     \}}
\DoxyCodeLine{364   }
\DoxyCodeLine{365   \mbox{\hyperlink{group__debug_ga458beb676810b1e43df9f0668359e76f}{arma\_check}}( (count != merge\_n\_nonzero), \textcolor{stringliteral}{"{}internal error: spglue\_merge::subview\_merge(): count != merge\_n\_nonzero"{}} );}
\DoxyCodeLine{366   }
\DoxyCodeLine{367   \textcolor{keyword}{const} uword out\_n\_cols = out.n\_cols;}
\DoxyCodeLine{368   }
\DoxyCodeLine{369   uword* col\_ptrs = access::rwp(out.col\_ptrs);}
\DoxyCodeLine{370   }
\DoxyCodeLine{371   \textcolor{keywordflow}{for}(uword c = 1; c <= out\_n\_cols; ++c)}
\DoxyCodeLine{372     \{}
\DoxyCodeLine{373     col\_ptrs[c] += col\_ptrs[c -\/ 1];}
\DoxyCodeLine{374     \}}
\DoxyCodeLine{375   }
\DoxyCodeLine{376   \mbox{\hyperlink{structA}{A}}.steal\_mem(out);}
\DoxyCodeLine{377   }
\DoxyCodeLine{378   \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(sv.n\_nonzero) = B\_n\_nonzero;}
\DoxyCodeLine{379   \}}
\DoxyCodeLine{380 }
\DoxyCodeLine{381 }
\DoxyCodeLine{382 }
\DoxyCodeLine{383 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{384 arma\_hot}
\DoxyCodeLine{385 \textcolor{keyword}{inline}}
\DoxyCodeLine{386 \textcolor{keywordtype}{void}}
\DoxyCodeLine{387 spglue\_merge::symmat\_merge(\mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& \mbox{\hyperlink{structB}{B}})}
\DoxyCodeLine{388   \{}
\DoxyCodeLine{389   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{390   }
\DoxyCodeLine{391   out.\mbox{\hyperlink{group__SpMat_gac9162550cc7b009108f58ebf931be224}{reserve}}(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_cols, 2*\mbox{\hyperlink{structA}{A}}.n\_nonzero); \textcolor{comment}{// worst case scenario}}
\DoxyCodeLine{392   }
\DoxyCodeLine{393   \textcolor{keyword}{typename} \mbox{\hyperlink{classSpMat_1_1const__iterator}{SpMat<eT>::const\_iterator}} x\_it  = \mbox{\hyperlink{structA}{A}}.begin();}
\DoxyCodeLine{394   \textcolor{keyword}{typename} \mbox{\hyperlink{classSpMat_1_1const__iterator}{SpMat<eT>::const\_iterator}} x\_end = \mbox{\hyperlink{structA}{A}}.end();}
\DoxyCodeLine{395   }
\DoxyCodeLine{396   \textcolor{keyword}{typename} \mbox{\hyperlink{classSpMat_1_1const__iterator}{SpMat<eT>::const\_iterator}} y\_it  = \mbox{\hyperlink{structB}{B}}.begin();}
\DoxyCodeLine{397   \textcolor{keyword}{typename} \mbox{\hyperlink{classSpMat_1_1const__iterator}{SpMat<eT>::const\_iterator}} y\_end = \mbox{\hyperlink{structB}{B}}.end();}
\DoxyCodeLine{398   }
\DoxyCodeLine{399   uword count = 0;}
\DoxyCodeLine{400   }
\DoxyCodeLine{401   \textcolor{keywordflow}{while}( (x\_it != x\_end) || (y\_it != y\_end) )}
\DoxyCodeLine{402     \{}
\DoxyCodeLine{403     eT out\_val;}
\DoxyCodeLine{404     }
\DoxyCodeLine{405     \textcolor{keyword}{const} uword x\_it\_col = x\_it.col();}
\DoxyCodeLine{406     \textcolor{keyword}{const} uword x\_it\_row = x\_it.row();}
\DoxyCodeLine{407     }
\DoxyCodeLine{408     \textcolor{keyword}{const} uword y\_it\_col = y\_it.col();}
\DoxyCodeLine{409     \textcolor{keyword}{const} uword y\_it\_row = y\_it.row();}
\DoxyCodeLine{410     }
\DoxyCodeLine{411     \textcolor{keywordtype}{bool} use\_y\_loc = \textcolor{keyword}{false};}
\DoxyCodeLine{412     }
\DoxyCodeLine{413     \textcolor{keywordflow}{if}(x\_it == y\_it)}
\DoxyCodeLine{414       \{}
\DoxyCodeLine{415       \textcolor{comment}{// this can only happen on the diagonal}}
\DoxyCodeLine{416       }
\DoxyCodeLine{417       out\_val = (*x\_it);}
\DoxyCodeLine{418       }
\DoxyCodeLine{419       ++x\_it;}
\DoxyCodeLine{420       ++y\_it;}
\DoxyCodeLine{421       \}}
\DoxyCodeLine{422     \textcolor{keywordflow}{else}}
\DoxyCodeLine{423       \{}
\DoxyCodeLine{424       \textcolor{keywordflow}{if}((x\_it\_col < y\_it\_col) || ((x\_it\_col == y\_it\_col) \&\& (x\_it\_row < y\_it\_row))) \textcolor{comment}{// if y is closer to the end}}
\DoxyCodeLine{425         \{}
\DoxyCodeLine{426         out\_val = (*x\_it);}
\DoxyCodeLine{427         }
\DoxyCodeLine{428         ++x\_it;}
\DoxyCodeLine{429         \}}
\DoxyCodeLine{430       \textcolor{keywordflow}{else}}
\DoxyCodeLine{431         \{}
\DoxyCodeLine{432         out\_val = (*y\_it);}
\DoxyCodeLine{433         }
\DoxyCodeLine{434         ++y\_it;}
\DoxyCodeLine{435         }
\DoxyCodeLine{436         use\_y\_loc = \textcolor{keyword}{true};}
\DoxyCodeLine{437         \}}
\DoxyCodeLine{438       \}}
\DoxyCodeLine{439     }
\DoxyCodeLine{440     \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(out.values[count]) = out\_val;}
\DoxyCodeLine{441     }
\DoxyCodeLine{442     \textcolor{keyword}{const} uword out\_row = (use\_y\_loc == \textcolor{keyword}{false}) ? x\_it\_row : y\_it\_row;}
\DoxyCodeLine{443     \textcolor{keyword}{const} uword out\_col = (use\_y\_loc == \textcolor{keyword}{false}) ? x\_it\_col : y\_it\_col;}
\DoxyCodeLine{444     }
\DoxyCodeLine{445     \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(out.row\_indices[count]) = out\_row;}
\DoxyCodeLine{446     \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(out.col\_ptrs[out\_col + 1])++;}
\DoxyCodeLine{447     ++count;}
\DoxyCodeLine{448     \}}
\DoxyCodeLine{449   }
\DoxyCodeLine{450   \textcolor{keyword}{const} uword out\_n\_cols = out.\mbox{\hyperlink{classSpMat_a4f01c9d35f90eb836c6be489605052dd}{n\_cols}};}
\DoxyCodeLine{451   }
\DoxyCodeLine{452   uword* col\_ptrs = access::rwp(out.col\_ptrs);}
\DoxyCodeLine{453   }
\DoxyCodeLine{454   \textcolor{comment}{// Fix column pointers to be cumulative.}}
\DoxyCodeLine{455   \textcolor{keywordflow}{for}(uword c = 1; c <= out\_n\_cols; ++c)}
\DoxyCodeLine{456     \{}
\DoxyCodeLine{457     col\_ptrs[c] += col\_ptrs[c -\/ 1];}
\DoxyCodeLine{458     \}}
\DoxyCodeLine{459   }
\DoxyCodeLine{460   \textcolor{comment}{// quick resize without reallocating memory and copying data}}
\DoxyCodeLine{461   \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(         out.\mbox{\hyperlink{classSpMat_a71a87b0de327d5643983dd21f455b984}{n\_nonzero}}) = count;}
\DoxyCodeLine{462   \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(     out.values[count]) = eT(0);}
\DoxyCodeLine{463   \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(out.row\_indices[count]) = uword(0);}
\DoxyCodeLine{464   \}}
\DoxyCodeLine{465 }
\DoxyCodeLine{466 }
\DoxyCodeLine{467 }
\DoxyCodeLine{468 \textcolor{keyword}{template}<\textcolor{keyword}{typename} eT>}
\DoxyCodeLine{469 arma\_hot}
\DoxyCodeLine{470 \textcolor{keyword}{inline}}
\DoxyCodeLine{471 \textcolor{keywordtype}{void}}
\DoxyCodeLine{472 spglue\_merge::diagview\_merge(\mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& out, \textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& \mbox{\hyperlink{structA}{A}}, \textcolor{keyword}{const} \mbox{\hyperlink{classSpMat}{SpMat<eT>}}\& \mbox{\hyperlink{structB}{B}})}
\DoxyCodeLine{473   \{}
\DoxyCodeLine{474   arma\_extra\_debug\_sigprint();}
\DoxyCodeLine{475   }
\DoxyCodeLine{476   \textcolor{comment}{// NOTE: assuming that B has non-\/zero elements only on the main diagonal}}
\DoxyCodeLine{477   }
\DoxyCodeLine{478   out.\mbox{\hyperlink{group__SpMat_gac9162550cc7b009108f58ebf931be224}{reserve}}(\mbox{\hyperlink{structA}{A}}.n\_rows, \mbox{\hyperlink{structA}{A}}.n\_cols, \mbox{\hyperlink{structA}{A}}.n\_nonzero + \mbox{\hyperlink{structB}{B}}.n\_nonzero); \textcolor{comment}{// worst case scenario}}
\DoxyCodeLine{479   }
\DoxyCodeLine{480   \textcolor{keyword}{typename} \mbox{\hyperlink{classSpMat_1_1const__iterator}{SpMat<eT>::const\_iterator}} x\_it  = \mbox{\hyperlink{structA}{A}}.begin();}
\DoxyCodeLine{481   \textcolor{keyword}{typename} \mbox{\hyperlink{classSpMat_1_1const__iterator}{SpMat<eT>::const\_iterator}} x\_end = \mbox{\hyperlink{structA}{A}}.end();}
\DoxyCodeLine{482   }
\DoxyCodeLine{483   \textcolor{keyword}{typename} \mbox{\hyperlink{classSpMat_1_1const__iterator}{SpMat<eT>::const\_iterator}} y\_it  = \mbox{\hyperlink{structB}{B}}.begin();}
\DoxyCodeLine{484   \textcolor{keyword}{typename} \mbox{\hyperlink{classSpMat_1_1const__iterator}{SpMat<eT>::const\_iterator}} y\_end = \mbox{\hyperlink{structB}{B}}.end();}
\DoxyCodeLine{485   }
\DoxyCodeLine{486   uword count = 0;}
\DoxyCodeLine{487   }
\DoxyCodeLine{488   \textcolor{keywordflow}{while}( (x\_it != x\_end) || (y\_it != y\_end) )}
\DoxyCodeLine{489     \{}
\DoxyCodeLine{490     eT out\_val = eT(0);}
\DoxyCodeLine{491     }
\DoxyCodeLine{492     \textcolor{keyword}{const} uword x\_it\_col = x\_it.col();}
\DoxyCodeLine{493     \textcolor{keyword}{const} uword x\_it\_row = x\_it.row();}
\DoxyCodeLine{494     }
\DoxyCodeLine{495     \textcolor{keyword}{const} uword y\_it\_col = y\_it.col();}
\DoxyCodeLine{496     \textcolor{keyword}{const} uword y\_it\_row = y\_it.row();}
\DoxyCodeLine{497     }
\DoxyCodeLine{498     \textcolor{keywordtype}{bool} use\_y\_loc = \textcolor{keyword}{false};}
\DoxyCodeLine{499     }
\DoxyCodeLine{500     \textcolor{keywordflow}{if}(x\_it == y\_it)}
\DoxyCodeLine{501       \{}
\DoxyCodeLine{502       \textcolor{comment}{// this can only happen on the diagonal}}
\DoxyCodeLine{503       }
\DoxyCodeLine{504       out\_val = (*y\_it);}
\DoxyCodeLine{505       }
\DoxyCodeLine{506       ++x\_it;}
\DoxyCodeLine{507       ++y\_it;}
\DoxyCodeLine{508       \}}
\DoxyCodeLine{509     \textcolor{keywordflow}{else}}
\DoxyCodeLine{510       \{}
\DoxyCodeLine{511       \textcolor{keywordflow}{if}((x\_it\_col < y\_it\_col) || ((x\_it\_col == y\_it\_col) \&\& (x\_it\_row < y\_it\_row))) \textcolor{comment}{// if y is closer to the end}}
\DoxyCodeLine{512         \{}
\DoxyCodeLine{513         \textcolor{keywordflow}{if}(x\_it\_col != x\_it\_row)  \{ out\_val = (*x\_it); \}  \textcolor{comment}{// don't take values from the main diagonal of A}}
\DoxyCodeLine{514         }
\DoxyCodeLine{515         ++x\_it;}
\DoxyCodeLine{516         \}}
\DoxyCodeLine{517       \textcolor{keywordflow}{else}}
\DoxyCodeLine{518         \{}
\DoxyCodeLine{519         \textcolor{keywordflow}{if}(y\_it\_col == y\_it\_row)  \{ out\_val = (*y\_it); use\_y\_loc = \textcolor{keyword}{true}; \}  \textcolor{comment}{// take values only from the main diagonal of B}}
\DoxyCodeLine{520         }
\DoxyCodeLine{521         ++y\_it;}
\DoxyCodeLine{522         \}}
\DoxyCodeLine{523       \}}
\DoxyCodeLine{524     }
\DoxyCodeLine{525     \textcolor{keywordflow}{if}(out\_val != eT(0))}
\DoxyCodeLine{526       \{}
\DoxyCodeLine{527       \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(out.values[count]) = out\_val;}
\DoxyCodeLine{528       }
\DoxyCodeLine{529       \textcolor{keyword}{const} uword out\_row = (use\_y\_loc == \textcolor{keyword}{false}) ? x\_it\_row : y\_it\_row;}
\DoxyCodeLine{530       \textcolor{keyword}{const} uword out\_col = (use\_y\_loc == \textcolor{keyword}{false}) ? x\_it\_col : y\_it\_col;}
\DoxyCodeLine{531       }
\DoxyCodeLine{532       \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(out.row\_indices[count]) = out\_row;}
\DoxyCodeLine{533       \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(out.col\_ptrs[out\_col + 1])++;}
\DoxyCodeLine{534       ++count;}
\DoxyCodeLine{535       \}}
\DoxyCodeLine{536     \}}
\DoxyCodeLine{537   }
\DoxyCodeLine{538   \textcolor{keyword}{const} uword out\_n\_cols = out.\mbox{\hyperlink{classSpMat_a4f01c9d35f90eb836c6be489605052dd}{n\_cols}};}
\DoxyCodeLine{539   }
\DoxyCodeLine{540   uword* col\_ptrs = access::rwp(out.col\_ptrs);}
\DoxyCodeLine{541   }
\DoxyCodeLine{542   \textcolor{comment}{// Fix column pointers to be cumulative.}}
\DoxyCodeLine{543   \textcolor{keywordflow}{for}(uword c = 1; c <= out\_n\_cols; ++c)}
\DoxyCodeLine{544     \{}
\DoxyCodeLine{545     col\_ptrs[c] += col\_ptrs[c -\/ 1];}
\DoxyCodeLine{546     \}}
\DoxyCodeLine{547   }
\DoxyCodeLine{548   \textcolor{comment}{// quick resize without reallocating memory and copying data}}
\DoxyCodeLine{549   \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(         out.\mbox{\hyperlink{classSpMat_a71a87b0de327d5643983dd21f455b984}{n\_nonzero}}) = count;}
\DoxyCodeLine{550   \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(     out.values[count]) = eT(0);}
\DoxyCodeLine{551   \mbox{\hyperlink{classaccess_a90cb80857bc3814f3661fe952f7c97c4}{access::rw}}(out.row\_indices[count]) = uword(0);}
\DoxyCodeLine{552   \}}
\DoxyCodeLine{553 }
\DoxyCodeLine{554 }
\DoxyCodeLine{555 }

\end{DoxyCode}
